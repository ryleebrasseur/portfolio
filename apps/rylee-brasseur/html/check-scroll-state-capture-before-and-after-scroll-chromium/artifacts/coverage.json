[
  {
    "url": "",
    "scriptId": "11",
    "source": "(() => {\n      globalThis.__pwInitScripts = globalThis.__pwInitScripts || {};\n      const hasInitScript = globalThis.__pwInitScripts[\"ee175dbc817b42e5a2f2ac003a0c66b7\"];\n      if (hasInitScript)\n        return;\n      globalThis.__pwInitScripts[\"ee175dbc817b42e5a2f2ac003a0c66b7\"] = true;\n      (function builtins(global) {\n  global = global ?? globalThis;\n  if (!global[\"__playwright_builtins__\"]) {\n    const builtins2 = {\n      setTimeout: global.setTimeout?.bind(global),\n      clearTimeout: global.clearTimeout?.bind(global),\n      setInterval: global.setInterval?.bind(global),\n      clearInterval: global.clearInterval?.bind(global),\n      requestAnimationFrame: global.requestAnimationFrame?.bind(global),\n      cancelAnimationFrame: global.cancelAnimationFrame?.bind(global),\n      requestIdleCallback: global.requestIdleCallback?.bind(global),\n      cancelIdleCallback: global.cancelIdleCallback?.bind(global),\n      performance: global.performance,\n      eval: global.eval?.bind(global),\n      Intl: global.Intl,\n      Date: global.Date,\n      Map: global.Map,\n      Set: global.Set\n    };\n    Object.defineProperty(global, \"__playwright_builtins__\", { value: builtins2, configurable: false, enumerable: false, writable: false });\n  }\n  return global[\"__playwright_builtins__\"];\n})()\n    })();",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 1303,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1,
            "endOffset": 1299,
            "count": 1
          },
          {
            "startOffset": 203,
            "endOffset": 210,
            "count": 0
          }
        ]
      },
      {
        "functionName": "builtins",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 295,
            "endOffset": 1290,
            "count": 1
          }
        ]
      }
    ]
  },
  {
    "url": "",
    "scriptId": "12",
    "source": "(() => {\n      globalThis.__pwInitScripts = globalThis.__pwInitScripts || {};\n      const hasInitScript = globalThis.__pwInitScripts[\"a3b8e62b5671e50bb8de18d8a8696ccd\"];\n      if (hasInitScript)\n        return;\n      globalThis.__pwInitScripts[\"a3b8e62b5671e50bb8de18d8a8696ccd\"] = true;\n      (() => {\n      // Capture motion system state\n      ;\n      window.__motionState = {};\n      window.__observerState = {};\n\n      // Override console methods to add metadata\n      const originalLog = console.log;\n      const originalError = console.error;\n      const originalWarn = console.warn;\n      console.log = (...args) => {\n        var _stack$split$;\n        const stack = new Error().stack;\n        const caller = (stack === null || stack === void 0 || (_stack$split$ = stack.split('\\n')[2]) === null || _stack$split$ === void 0 ? void 0 : _stack$split$.trim()) || 'unknown';\n        originalLog('[Runtime Log]', ...args, `\\n  at ${caller}`);\n      };\n      console.error = (...args) => {\n        const stack = new Error().stack;\n        originalError('[Runtime Error]', ...args, `\\n${stack}`);\n      };\n      console.warn = (...args) => {\n        var _stack$split$2;\n        const stack = new Error().stack;\n        originalWarn('[Runtime Warning]', ...args, `\\n  at ${stack === null || stack === void 0 || (_stack$split$2 = stack.split('\\n')[2]) === null || _stack$split$2 === void 0 ? void 0 : _stack$split$2.trim()}`);\n      };\n\n      // Log all events\n      const events = ['scroll', 'click', 'keydown', 'resize', 'visibilitychange'];\n      events.forEach(eventType => {\n        window.addEventListener(eventType, e => {\n          var _e$target;\n          console.log(`[Event: ${eventType}]`, {\n            timestamp: Date.now(),\n            target: (_e$target = e.target) === null || _e$target === void 0 ? void 0 : _e$target.tagName,\n            scrollY: window.scrollY\n          });\n        }, {\n          passive: true,\n          capture: true\n        });\n      });\n    })(undefined)\n    })();",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 2004,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1,
            "endOffset": 2000,
            "count": 1
          },
          {
            "startOffset": 71,
            "endOffset": 76,
            "count": 0
          },
          {
            "startOffset": 203,
            "endOffset": 210,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 295,
            "endOffset": 1982,
            "count": 1
          }
        ]
      },
      {
        "functionName": "console.log",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 610,
            "endOffset": 952,
            "count": 36
          },
          {
            "startOffset": 831,
            "endOffset": 839,
            "count": 0
          },
          {
            "startOffset": 864,
            "endOffset": 876,
            "count": 0
          }
        ]
      },
      {
        "functionName": "console.error",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 976,
            "endOffset": 1104,
            "count": 0
          }
        ]
      },
      {
        "functionName": "console.warn",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1127,
            "endOffset": 1432,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1563,
            "endOffset": 1974,
            "count": 5
          }
        ]
      },
      {
        "functionName": "window.addEventListener.passive",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1621,
            "endOffset": 1902,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5173/",
    "scriptId": "13",
    "source": "\nimport RefreshRuntime from \"/@react-refresh\"\nRefreshRuntime.injectIntoGlobalHook(window)\nwindow.$RefreshReg$ = () => {}\nwindow.$RefreshSig$ = () => (type) => type\nwindow.__vite_plugin_react_preamble_installed__ = true\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 219,
            "count": 1
          }
        ]
      },
      {
        "functionName": "window.$RefreshReg$",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 112,
            "endOffset": 120,
            "count": 0
          }
        ]
      },
      {
        "functionName": "window.$RefreshSig$",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 143,
            "endOffset": 163,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5173/@react-refresh",
    "scriptId": "16",
    "source": "import { injectQuery as __vite__injectQuery } from \"/@vite/client\";const exports = {};\n/**\n * @license React\n * react-refresh-runtime.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\"use strict\";\nif (true) {\n  (function() {\n    \"use strict\";\n    var REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\");\n    var REACT_MEMO_TYPE = Symbol.for(\"react.memo\");\n    var PossiblyWeakMap = typeof WeakMap === \"function\" ? WeakMap : Map;\n    var allFamiliesByID = /* @__PURE__ */ new Map();\n    var allFamiliesByType = new PossiblyWeakMap();\n    var allSignaturesByType = new PossiblyWeakMap();\n    var updatedFamiliesByType = new PossiblyWeakMap();\n    var pendingUpdates = [];\n    var helpersByRendererID = /* @__PURE__ */ new Map();\n    var helpersByRoot = /* @__PURE__ */ new Map();\n    var mountedRoots = /* @__PURE__ */ new Set();\n    var failedRoots = /* @__PURE__ */ new Set();\n    var rootElements = (\n      // $FlowIssue\n      typeof WeakMap === \"function\" ? /* @__PURE__ */ new WeakMap() : null\n    );\n    var isPerformingRefresh = false;\n    function computeFullKey(signature) {\n      if (signature.fullKey !== null) {\n        return signature.fullKey;\n      }\n      var fullKey = signature.ownKey;\n      var hooks;\n      try {\n        hooks = signature.getCustomHooks();\n      } catch (err) {\n        signature.forceReset = true;\n        signature.fullKey = fullKey;\n        return fullKey;\n      }\n      for (var i = 0; i < hooks.length; i++) {\n        var hook = hooks[i];\n        if (typeof hook !== \"function\") {\n          signature.forceReset = true;\n          signature.fullKey = fullKey;\n          return fullKey;\n        }\n        var nestedHookSignature = allSignaturesByType.get(hook);\n        if (nestedHookSignature === void 0) {\n          continue;\n        }\n        var nestedHookKey = computeFullKey(nestedHookSignature);\n        if (nestedHookSignature.forceReset) {\n          signature.forceReset = true;\n        }\n        fullKey += \"\\n---\\n\" + nestedHookKey;\n      }\n      signature.fullKey = fullKey;\n      return fullKey;\n    }\n    function haveEqualSignatures(prevType, nextType) {\n      var prevSignature = allSignaturesByType.get(prevType);\n      var nextSignature = allSignaturesByType.get(nextType);\n      if (prevSignature === void 0 && nextSignature === void 0) {\n        return true;\n      }\n      if (prevSignature === void 0 || nextSignature === void 0) {\n        return false;\n      }\n      if (computeFullKey(prevSignature) !== computeFullKey(nextSignature)) {\n        return false;\n      }\n      if (nextSignature.forceReset) {\n        return false;\n      }\n      return true;\n    }\n    function isReactClass(type) {\n      return type.prototype && type.prototype.isReactComponent;\n    }\n    function canPreserveStateBetween(prevType, nextType) {\n      if (isReactClass(prevType) || isReactClass(nextType)) {\n        return false;\n      }\n      if (haveEqualSignatures(prevType, nextType)) {\n        return true;\n      }\n      return false;\n    }\n    function resolveFamily(type) {\n      return updatedFamiliesByType.get(type);\n    }\n    function cloneMap(map) {\n      var clone = /* @__PURE__ */ new Map();\n      map.forEach(function(value, key) {\n        clone.set(key, value);\n      });\n      return clone;\n    }\n    function cloneSet(set) {\n      var clone = /* @__PURE__ */ new Set();\n      set.forEach(function(value) {\n        clone.add(value);\n      });\n      return clone;\n    }\n    function getProperty(object, property) {\n      try {\n        return object[property];\n      } catch (err) {\n        return void 0;\n      }\n    }\n    function performReactRefresh() {\n      if (pendingUpdates.length === 0) {\n        return null;\n      }\n      if (isPerformingRefresh) {\n        return null;\n      }\n      isPerformingRefresh = true;\n      try {\n        var staleFamilies = /* @__PURE__ */ new Set();\n        var updatedFamilies = /* @__PURE__ */ new Set();\n        var updates = pendingUpdates;\n        pendingUpdates = [];\n        updates.forEach(function(_ref) {\n          var family = _ref[0], nextType = _ref[1];\n          var prevType = family.current;\n          updatedFamiliesByType.set(prevType, family);\n          updatedFamiliesByType.set(nextType, family);\n          family.current = nextType;\n          if (canPreserveStateBetween(prevType, nextType)) {\n            updatedFamilies.add(family);\n          } else {\n            staleFamilies.add(family);\n          }\n        });\n        var update = {\n          updatedFamilies,\n          // Families that will re-render preserving state\n          staleFamilies\n          // Families that will be remounted\n        };\n        helpersByRendererID.forEach(function(helpers) {\n          helpers.setRefreshHandler(resolveFamily);\n        });\n        var didError = false;\n        var firstError = null;\n        var failedRootsSnapshot = cloneSet(failedRoots);\n        var mountedRootsSnapshot = cloneSet(mountedRoots);\n        var helpersByRootSnapshot = cloneMap(helpersByRoot);\n        failedRootsSnapshot.forEach(function(root) {\n          var helpers = helpersByRootSnapshot.get(root);\n          if (helpers === void 0) {\n            throw new Error(\"Could not find helpers for a root. This is a bug in React Refresh.\");\n          }\n          if (!failedRoots.has(root)) {\n          }\n          if (rootElements === null) {\n            return;\n          }\n          if (!rootElements.has(root)) {\n            return;\n          }\n          var element = rootElements.get(root);\n          try {\n            helpers.scheduleRoot(root, element);\n          } catch (err) {\n            if (!didError) {\n              didError = true;\n              firstError = err;\n            }\n          }\n        });\n        mountedRootsSnapshot.forEach(function(root) {\n          var helpers = helpersByRootSnapshot.get(root);\n          if (helpers === void 0) {\n            throw new Error(\"Could not find helpers for a root. This is a bug in React Refresh.\");\n          }\n          if (!mountedRoots.has(root)) {\n          }\n          try {\n            helpers.scheduleRefresh(root, update);\n          } catch (err) {\n            if (!didError) {\n              didError = true;\n              firstError = err;\n            }\n          }\n        });\n        if (didError) {\n          throw firstError;\n        }\n        return update;\n      } finally {\n        isPerformingRefresh = false;\n      }\n    }\n    function register(type, id) {\n      {\n        if (type === null) {\n          return;\n        }\n        if (typeof type !== \"function\" && typeof type !== \"object\") {\n          return;\n        }\n        if (allFamiliesByType.has(type)) {\n          return;\n        }\n        var family = allFamiliesByID.get(id);\n        if (family === void 0) {\n          family = {\n            current: type\n          };\n          allFamiliesByID.set(id, family);\n        } else {\n          pendingUpdates.push([family, type]);\n        }\n        allFamiliesByType.set(type, family);\n        if (typeof type === \"object\" && type !== null) {\n          switch (getProperty(type, \"$$typeof\")) {\n            case REACT_FORWARD_REF_TYPE:\n              register(type.render, id + \"$render\");\n              break;\n            case REACT_MEMO_TYPE:\n              register(type.type, id + \"$type\");\n              break;\n          }\n        }\n      }\n    }\n    function setSignature(type, key) {\n      var forceReset = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;\n      var getCustomHooks = arguments.length > 3 ? arguments[3] : void 0;\n      {\n        if (!allSignaturesByType.has(type)) {\n          allSignaturesByType.set(type, {\n            forceReset,\n            ownKey: key,\n            fullKey: null,\n            getCustomHooks: getCustomHooks || function() {\n              return [];\n            }\n          });\n        }\n        if (typeof type === \"object\" && type !== null) {\n          switch (getProperty(type, \"$$typeof\")) {\n            case REACT_FORWARD_REF_TYPE:\n              setSignature(type.render, key, forceReset, getCustomHooks);\n              break;\n            case REACT_MEMO_TYPE:\n              setSignature(type.type, key, forceReset, getCustomHooks);\n              break;\n          }\n        }\n      }\n    }\n    function collectCustomHooksForSignature(type) {\n      {\n        var signature = allSignaturesByType.get(type);\n        if (signature !== void 0) {\n          computeFullKey(signature);\n        }\n      }\n    }\n    function getFamilyByID(id) {\n      {\n        return allFamiliesByID.get(id);\n      }\n    }\n    function getFamilyByType(type) {\n      {\n        return allFamiliesByType.get(type);\n      }\n    }\n    function findAffectedHostInstances(families) {\n      {\n        var affectedInstances = /* @__PURE__ */ new Set();\n        mountedRoots.forEach(function(root) {\n          var helpers = helpersByRoot.get(root);\n          if (helpers === void 0) {\n            throw new Error(\"Could not find helpers for a root. This is a bug in React Refresh.\");\n          }\n          var instancesForRoot = helpers.findHostInstancesForRefresh(root, families);\n          instancesForRoot.forEach(function(inst) {\n            affectedInstances.add(inst);\n          });\n        });\n        return affectedInstances;\n      }\n    }\n    function injectIntoGlobalHook(globalObject) {\n      {\n        var hook = globalObject.__REACT_DEVTOOLS_GLOBAL_HOOK__;\n        if (hook === void 0) {\n          var nextID = 0;\n          globalObject.__REACT_DEVTOOLS_GLOBAL_HOOK__ = hook = {\n            renderers: /* @__PURE__ */ new Map(),\n            supportsFiber: true,\n            inject: function(injected) {\n              return nextID++;\n            },\n            onScheduleFiberRoot: function(id, root, children) {\n            },\n            onCommitFiberRoot: function(id, root, maybePriorityLevel, didError) {\n            },\n            onCommitFiberUnmount: function() {\n            }\n          };\n        }\n        if (hook.isDisabled) {\n          console[\"warn\"](\"Something has shimmed the React DevTools global hook (__REACT_DEVTOOLS_GLOBAL_HOOK__). Fast Refresh is not compatible with this shim and will be disabled.\");\n          return;\n        }\n        var oldInject = hook.inject;\n        hook.inject = function(injected) {\n          var id = oldInject.apply(this, arguments);\n          if (typeof injected.scheduleRefresh === \"function\" && typeof injected.setRefreshHandler === \"function\") {\n            helpersByRendererID.set(id, injected);\n          }\n          return id;\n        };\n        hook.renderers.forEach(function(injected, id) {\n          if (typeof injected.scheduleRefresh === \"function\" && typeof injected.setRefreshHandler === \"function\") {\n            helpersByRendererID.set(id, injected);\n          }\n        });\n        var oldOnCommitFiberRoot = hook.onCommitFiberRoot;\n        var oldOnScheduleFiberRoot = hook.onScheduleFiberRoot || function() {\n        };\n        hook.onScheduleFiberRoot = function(id, root, children) {\n          if (!isPerformingRefresh) {\n            failedRoots.delete(root);\n            if (rootElements !== null) {\n              rootElements.set(root, children);\n            }\n          }\n          return oldOnScheduleFiberRoot.apply(this, arguments);\n        };\n        hook.onCommitFiberRoot = function(id, root, maybePriorityLevel, didError) {\n          var helpers = helpersByRendererID.get(id);\n          if (helpers !== void 0) {\n            helpersByRoot.set(root, helpers);\n            var current = root.current;\n            var alternate = current.alternate;\n            if (alternate !== null) {\n              var wasMounted = alternate.memoizedState != null && alternate.memoizedState.element != null && mountedRoots.has(root);\n              var isMounted = current.memoizedState != null && current.memoizedState.element != null;\n              if (!wasMounted && isMounted) {\n                mountedRoots.add(root);\n                failedRoots.delete(root);\n              } else if (wasMounted && isMounted)\n                ;\n              else if (wasMounted && !isMounted) {\n                mountedRoots.delete(root);\n                if (didError) {\n                  failedRoots.add(root);\n                } else {\n                  helpersByRoot.delete(root);\n                }\n              } else if (!wasMounted && !isMounted) {\n                if (didError) {\n                  failedRoots.add(root);\n                }\n              }\n            } else {\n              mountedRoots.add(root);\n            }\n          }\n          return oldOnCommitFiberRoot.apply(this, arguments);\n        };\n      }\n    }\n    function hasUnrecoverableErrors() {\n      return false;\n    }\n    function _getMountedRootCount() {\n      {\n        return mountedRoots.size;\n      }\n    }\n    function createSignatureFunctionForTransform() {\n      {\n        var savedType;\n        var hasCustomHooks;\n        var didCollectHooks = false;\n        return function(type, key, forceReset, getCustomHooks) {\n          if (typeof key === \"string\") {\n            if (!savedType) {\n              savedType = type;\n              hasCustomHooks = typeof getCustomHooks === \"function\";\n            }\n            if (type != null && (typeof type === \"function\" || typeof type === \"object\")) {\n              setSignature(type, key, forceReset, getCustomHooks);\n            }\n            return type;\n          } else {\n            if (!didCollectHooks && hasCustomHooks) {\n              didCollectHooks = true;\n              collectCustomHooksForSignature(savedType);\n            }\n          }\n        };\n      }\n    }\n    function isLikelyComponentType(type) {\n      {\n        switch (typeof type) {\n          case \"function\": {\n            if (type.prototype != null) {\n              if (type.prototype.isReactComponent) {\n                return true;\n              }\n              var ownNames = Object.getOwnPropertyNames(type.prototype);\n              if (ownNames.length > 1 || ownNames[0] !== \"constructor\") {\n                return false;\n              }\n              if (type.prototype.__proto__ !== Object.prototype) {\n                return false;\n              }\n            }\n            var name = type.name || type.displayName;\n            return typeof name === \"string\" && /^[A-Z]/.test(name);\n          }\n          case \"object\": {\n            if (type != null) {\n              switch (getProperty(type, \"$$typeof\")) {\n                case REACT_FORWARD_REF_TYPE:\n                case REACT_MEMO_TYPE:\n                  return true;\n                default:\n                  return false;\n              }\n            }\n            return false;\n          }\n          default: {\n            return false;\n          }\n        }\n      }\n    }\n    exports._getMountedRootCount = _getMountedRootCount;\n    exports.collectCustomHooksForSignature = collectCustomHooksForSignature;\n    exports.createSignatureFunctionForTransform = createSignatureFunctionForTransform;\n    exports.findAffectedHostInstances = findAffectedHostInstances;\n    exports.getFamilyByID = getFamilyByID;\n    exports.getFamilyByType = getFamilyByType;\n    exports.hasUnrecoverableErrors = hasUnrecoverableErrors;\n    exports.injectIntoGlobalHook = injectIntoGlobalHook;\n    exports.isLikelyComponentType = isLikelyComponentType;\n    exports.performReactRefresh = performReactRefresh;\n    exports.register = register;\n    exports.setSignature = setSignature;\n  })();\n}\nfunction debounce(fn, delay) {\n  let handle;\n  return () => {\n    clearTimeout(handle);\n    handle = setTimeout(fn, delay);\n  };\n}\nconst enqueueUpdate = debounce(exports.performReactRefresh, 16);\nfunction registerExportsForReactRefresh(filename, moduleExports) {\n  for (const key in moduleExports) {\n    if (key === \"__esModule\")\n      continue;\n    const exportValue = moduleExports[key];\n    if (exports.isLikelyComponentType(exportValue)) {\n      exports.register(exportValue, filename + \" export \" + key);\n    }\n  }\n}\nfunction validateRefreshBoundaryAndEnqueueUpdate(prevExports, nextExports) {\n  if (!predicateOnExport(prevExports, (key) => key in nextExports)) {\n    return \"Could not Fast Refresh (export removed)\";\n  }\n  if (!predicateOnExport(nextExports, (key) => key in prevExports)) {\n    return \"Could not Fast Refresh (new export)\";\n  }\n  let hasExports = false;\n  const allExportsAreComponentsOrUnchanged = predicateOnExport(\n    nextExports,\n    (key, value) => {\n      hasExports = true;\n      if (exports.isLikelyComponentType(value))\n        return true;\n      return prevExports[key] === nextExports[key];\n    }\n  );\n  if (hasExports && allExportsAreComponentsOrUnchanged) {\n    enqueueUpdate();\n  } else {\n    return \"Could not Fast Refresh. Learn more at https://github.com/vitejs/vite-plugin-react/tree/main/packages/plugin-react#consistent-components-exports\";\n  }\n}\nfunction predicateOnExport(moduleExports, predicate) {\n  for (const key in moduleExports) {\n    if (key === \"__esModule\")\n      continue;\n    const desc = Object.getOwnPropertyDescriptor(moduleExports, key);\n    if (desc && desc.get)\n      return false;\n    if (!predicate(key, moduleExports[key]))\n      return false;\n  }\n  return true;\n}\nfunction __hmr_import(module) {\n  return import(\n    /* @vite-ignore */\n    __vite__injectQuery(module, 'import')\n  );\n}\nexports.__hmr_import = __hmr_import;\nexports.registerExportsForReactRefresh = registerExportsForReactRefresh;\nexports.validateRefreshBoundaryAndEnqueueUpdate = validateRefreshBoundaryAndEnqueueUpdate;\nexport default exports;\n\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkByZWFjdC1yZWZyZXNoIl0sInNvdXJjZXNDb250ZW50IjpbIlxuY29uc3QgZXhwb3J0cyA9IHt9XG4vKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiByZWFjdC1yZWZyZXNoLXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgKGZ1bmN0aW9uKCkge1xuJ3VzZSBzdHJpY3QnO1xuXG4vLyBBVFRFTlRJT05cbnZhciBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZm9yd2FyZF9yZWYnKTtcbnZhciBSRUFDVF9NRU1PX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5tZW1vJyk7XG5cbnZhciBQb3NzaWJseVdlYWtNYXAgPSB0eXBlb2YgV2Vha01hcCA9PT0gJ2Z1bmN0aW9uJyA/IFdlYWtNYXAgOiBNYXA7IC8vIFdlIG5ldmVyIHJlbW92ZSB0aGVzZSBhc3NvY2lhdGlvbnMuXG4vLyBJdCdzIE9LIHRvIHJlZmVyZW5jZSBmYW1pbGllcywgYnV0IHVzZSBXZWFrTWFwL1NldCBmb3IgdHlwZXMuXG5cbnZhciBhbGxGYW1pbGllc0J5SUQgPSBuZXcgTWFwKCk7XG52YXIgYWxsRmFtaWxpZXNCeVR5cGUgPSBuZXcgUG9zc2libHlXZWFrTWFwKCk7XG52YXIgYWxsU2lnbmF0dXJlc0J5VHlwZSA9IG5ldyBQb3NzaWJseVdlYWtNYXAoKTsgLy8gVGhpcyBXZWFrTWFwIGlzIHJlYWQgYnkgUmVhY3QsIHNvIHdlIG9ubHkgcHV0IGZhbWlsaWVzXG4vLyB0aGF0IGhhdmUgYWN0dWFsbHkgYmVlbiBlZGl0ZWQgaGVyZS4gVGhpcyBrZWVwcyBjaGVja3MgZmFzdC5cbi8vICRGbG93SXNzdWVcblxudmFyIHVwZGF0ZWRGYW1pbGllc0J5VHlwZSA9IG5ldyBQb3NzaWJseVdlYWtNYXAoKTsgLy8gVGhpcyBpcyBjbGVhcmVkIG9uIGV2ZXJ5IHBlcmZvcm1SZWFjdFJlZnJlc2goKSBjYWxsLlxuLy8gSXQgaXMgYW4gYXJyYXkgb2YgW0ZhbWlseSwgTmV4dFR5cGVdIHR1cGxlcy5cblxudmFyIHBlbmRpbmdVcGRhdGVzID0gW107IC8vIFRoaXMgaXMgaW5qZWN0ZWQgYnkgdGhlIHJlbmRlcmVyIHZpYSBEZXZUb29scyBnbG9iYWwgaG9vay5cblxudmFyIGhlbHBlcnNCeVJlbmRlcmVySUQgPSBuZXcgTWFwKCk7XG52YXIgaGVscGVyc0J5Um9vdCA9IG5ldyBNYXAoKTsgLy8gV2Uga2VlcCB0cmFjayBvZiBtb3VudGVkIHJvb3RzIHNvIHdlIGNhbiBzY2hlZHVsZSB1cGRhdGVzLlxuXG52YXIgbW91bnRlZFJvb3RzID0gbmV3IFNldCgpOyAvLyBJZiBhIHJvb3QgY2FwdHVyZXMgYW4gZXJyb3IsIHdlIHJlbWVtYmVyIGl0IHNvIHdlIGNhbiByZXRyeSBvbiBlZGl0LlxuXG52YXIgZmFpbGVkUm9vdHMgPSBuZXcgU2V0KCk7IC8vIEluIGVudmlyb25tZW50cyB0aGF0IHN1cHBvcnQgV2Vha01hcCwgd2UgYWxzbyByZW1lbWJlciB0aGUgbGFzdCBlbGVtZW50IGZvciBldmVyeSByb290LlxuLy8gSXQgbmVlZHMgdG8gYmUgd2VhayBiZWNhdXNlIHdlIGRvIHRoaXMgZXZlbiBmb3Igcm9vdHMgdGhhdCBmYWlsZWQgdG8gbW91bnQuXG4vLyBJZiB0aGVyZSBpcyBubyBXZWFrTWFwLCB3ZSB3b24ndCBhdHRlbXB0IHRvIGRvIHJldHJ5aW5nLlxuLy8gJEZsb3dJc3N1ZVxuXG52YXIgcm9vdEVsZW1lbnRzID0gLy8gJEZsb3dJc3N1ZVxudHlwZW9mIFdlYWtNYXAgPT09ICdmdW5jdGlvbicgPyBuZXcgV2Vha01hcCgpIDogbnVsbDtcbnZhciBpc1BlcmZvcm1pbmdSZWZyZXNoID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGNvbXB1dGVGdWxsS2V5KHNpZ25hdHVyZSkge1xuICBpZiAoc2lnbmF0dXJlLmZ1bGxLZXkgIT09IG51bGwpIHtcbiAgICByZXR1cm4gc2lnbmF0dXJlLmZ1bGxLZXk7XG4gIH1cblxuICB2YXIgZnVsbEtleSA9IHNpZ25hdHVyZS5vd25LZXk7XG4gIHZhciBob29rcztcblxuICB0cnkge1xuICAgIGhvb2tzID0gc2lnbmF0dXJlLmdldEN1c3RvbUhvb2tzKCk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIC8vIFRoaXMgY2FuIGhhcHBlbiBpbiBhbiBlZGdlIGNhc2UsIGUuZy4gaWYgZXhwcmVzc2lvbiBsaWtlIEZvby51c2VTb21ldGhpbmdcbiAgICAvLyBkZXBlbmRzIG9uIEZvbyB3aGljaCBpcyBsYXppbHkgaW5pdGlhbGl6ZWQgZHVyaW5nIHJlbmRlcmluZy5cbiAgICAvLyBJbiB0aGF0IGNhc2UganVzdCBhc3N1bWUgd2UnbGwgaGF2ZSB0byByZW1vdW50LlxuICAgIHNpZ25hdHVyZS5mb3JjZVJlc2V0ID0gdHJ1ZTtcbiAgICBzaWduYXR1cmUuZnVsbEtleSA9IGZ1bGxLZXk7XG4gICAgcmV0dXJuIGZ1bGxLZXk7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGhvb2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGhvb2sgPSBob29rc1tpXTtcblxuICAgIGlmICh0eXBlb2YgaG9vayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gU29tZXRoaW5nJ3Mgd3JvbmcuIEFzc3VtZSB3ZSBuZWVkIHRvIHJlbW91bnQuXG4gICAgICBzaWduYXR1cmUuZm9yY2VSZXNldCA9IHRydWU7XG4gICAgICBzaWduYXR1cmUuZnVsbEtleSA9IGZ1bGxLZXk7XG4gICAgICByZXR1cm4gZnVsbEtleTtcbiAgICB9XG5cbiAgICB2YXIgbmVzdGVkSG9va1NpZ25hdHVyZSA9IGFsbFNpZ25hdHVyZXNCeVR5cGUuZ2V0KGhvb2spO1xuXG4gICAgaWYgKG5lc3RlZEhvb2tTaWduYXR1cmUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gTm8gc2lnbmF0dXJlIG1lYW5zIEhvb2sgd2Fzbid0IGluIHRoZSBzb3VyY2UgY29kZSwgZS5nLiBpbiBhIGxpYnJhcnkuXG4gICAgICAvLyBXZSdsbCBza2lwIGl0IGJlY2F1c2Ugd2UgY2FuIGFzc3VtZSBpdCB3b24ndCBjaGFuZ2UgZHVyaW5nIHRoaXMgc2Vzc2lvbi5cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHZhciBuZXN0ZWRIb29rS2V5ID0gY29tcHV0ZUZ1bGxLZXkobmVzdGVkSG9va1NpZ25hdHVyZSk7XG5cbiAgICBpZiAobmVzdGVkSG9va1NpZ25hdHVyZS5mb3JjZVJlc2V0KSB7XG4gICAgICBzaWduYXR1cmUuZm9yY2VSZXNldCA9IHRydWU7XG4gICAgfVxuXG4gICAgZnVsbEtleSArPSAnXFxuLS0tXFxuJyArIG5lc3RlZEhvb2tLZXk7XG4gIH1cblxuICBzaWduYXR1cmUuZnVsbEtleSA9IGZ1bGxLZXk7XG4gIHJldHVybiBmdWxsS2V5O1xufVxuXG5mdW5jdGlvbiBoYXZlRXF1YWxTaWduYXR1cmVzKHByZXZUeXBlLCBuZXh0VHlwZSkge1xuICB2YXIgcHJldlNpZ25hdHVyZSA9IGFsbFNpZ25hdHVyZXNCeVR5cGUuZ2V0KHByZXZUeXBlKTtcbiAgdmFyIG5leHRTaWduYXR1cmUgPSBhbGxTaWduYXR1cmVzQnlUeXBlLmdldChuZXh0VHlwZSk7XG5cbiAgaWYgKHByZXZTaWduYXR1cmUgPT09IHVuZGVmaW5lZCAmJiBuZXh0U2lnbmF0dXJlID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChwcmV2U2lnbmF0dXJlID09PSB1bmRlZmluZWQgfHwgbmV4dFNpZ25hdHVyZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKGNvbXB1dGVGdWxsS2V5KHByZXZTaWduYXR1cmUpICE9PSBjb21wdXRlRnVsbEtleShuZXh0U2lnbmF0dXJlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChuZXh0U2lnbmF0dXJlLmZvcmNlUmVzZXQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gaXNSZWFjdENsYXNzKHR5cGUpIHtcbiAgcmV0dXJuIHR5cGUucHJvdG90eXBlICYmIHR5cGUucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQ7XG59XG5cbmZ1bmN0aW9uIGNhblByZXNlcnZlU3RhdGVCZXR3ZWVuKHByZXZUeXBlLCBuZXh0VHlwZSkge1xuICBpZiAoaXNSZWFjdENsYXNzKHByZXZUeXBlKSB8fCBpc1JlYWN0Q2xhc3MobmV4dFR5cGUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKGhhdmVFcXVhbFNpZ25hdHVyZXMocHJldlR5cGUsIG5leHRUeXBlKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiByZXNvbHZlRmFtaWx5KHR5cGUpIHtcbiAgLy8gT25seSBjaGVjayB1cGRhdGVkIHR5cGVzIHRvIGtlZXAgbG9va3VwcyBmYXN0LlxuICByZXR1cm4gdXBkYXRlZEZhbWlsaWVzQnlUeXBlLmdldCh0eXBlKTtcbn0gLy8gSWYgd2UgZGlkbid0IGNhcmUgYWJvdXQgSUUxMSwgd2UgY291bGQgdXNlIG5ldyBNYXAvU2V0KGl0ZXJhYmxlKS5cblxuXG5mdW5jdGlvbiBjbG9uZU1hcChtYXApIHtcbiAgdmFyIGNsb25lID0gbmV3IE1hcCgpO1xuICBtYXAuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgIGNsb25lLnNldChrZXksIHZhbHVlKTtcbiAgfSk7XG4gIHJldHVybiBjbG9uZTtcbn1cblxuZnVuY3Rpb24gY2xvbmVTZXQoc2V0KSB7XG4gIHZhciBjbG9uZSA9IG5ldyBTZXQoKTtcbiAgc2V0LmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgY2xvbmUuYWRkKHZhbHVlKTtcbiAgfSk7XG4gIHJldHVybiBjbG9uZTtcbn0gLy8gVGhpcyBpcyBhIHNhZmV0eSBtZWNoYW5pc20gdG8gcHJvdGVjdCBhZ2FpbnN0IHJvZ3VlIGdldHRlcnMgYW5kIFByb3hpZXMuXG5cblxuZnVuY3Rpb24gZ2V0UHJvcGVydHkob2JqZWN0LCBwcm9wZXJ0eSkge1xuICB0cnkge1xuICAgIHJldHVybiBvYmplY3RbcHJvcGVydHldO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICAvLyBJbnRlbnRpb25hbGx5IGlnbm9yZS5cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG5cbmZ1bmN0aW9uIHBlcmZvcm1SZWFjdFJlZnJlc2goKSB7XG5cbiAgaWYgKHBlbmRpbmdVcGRhdGVzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKGlzUGVyZm9ybWluZ1JlZnJlc2gpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlzUGVyZm9ybWluZ1JlZnJlc2ggPSB0cnVlO1xuXG4gIHRyeSB7XG4gICAgdmFyIHN0YWxlRmFtaWxpZXMgPSBuZXcgU2V0KCk7XG4gICAgdmFyIHVwZGF0ZWRGYW1pbGllcyA9IG5ldyBTZXQoKTtcbiAgICB2YXIgdXBkYXRlcyA9IHBlbmRpbmdVcGRhdGVzO1xuICAgIHBlbmRpbmdVcGRhdGVzID0gW107XG4gICAgdXBkYXRlcy5mb3JFYWNoKGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgICB2YXIgZmFtaWx5ID0gX3JlZlswXSxcbiAgICAgICAgICBuZXh0VHlwZSA9IF9yZWZbMV07XG4gICAgICAvLyBOb3cgdGhhdCB3ZSBnb3QgYSByZWFsIGVkaXQsIHdlIGNhbiBjcmVhdGUgYXNzb2NpYXRpb25zXG4gICAgICAvLyB0aGF0IHdpbGwgYmUgcmVhZCBieSB0aGUgUmVhY3QgcmVjb25jaWxlci5cbiAgICAgIHZhciBwcmV2VHlwZSA9IGZhbWlseS5jdXJyZW50O1xuICAgICAgdXBkYXRlZEZhbWlsaWVzQnlUeXBlLnNldChwcmV2VHlwZSwgZmFtaWx5KTtcbiAgICAgIHVwZGF0ZWRGYW1pbGllc0J5VHlwZS5zZXQobmV4dFR5cGUsIGZhbWlseSk7XG4gICAgICBmYW1pbHkuY3VycmVudCA9IG5leHRUeXBlOyAvLyBEZXRlcm1pbmUgd2hldGhlciB0aGlzIHNob3VsZCBiZSBhIHJlLXJlbmRlciBvciBhIHJlLW1vdW50LlxuXG4gICAgICBpZiAoY2FuUHJlc2VydmVTdGF0ZUJldHdlZW4ocHJldlR5cGUsIG5leHRUeXBlKSkge1xuICAgICAgICB1cGRhdGVkRmFtaWxpZXMuYWRkKGZhbWlseSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGFsZUZhbWlsaWVzLmFkZChmYW1pbHkpO1xuICAgICAgfVxuICAgIH0pOyAvLyBUT0RPOiByZW5hbWUgdGhlc2UgZmllbGRzIHRvIHNvbWV0aGluZyBtb3JlIG1lYW5pbmdmdWwuXG5cbiAgICB2YXIgdXBkYXRlID0ge1xuICAgICAgdXBkYXRlZEZhbWlsaWVzOiB1cGRhdGVkRmFtaWxpZXMsXG4gICAgICAvLyBGYW1pbGllcyB0aGF0IHdpbGwgcmUtcmVuZGVyIHByZXNlcnZpbmcgc3RhdGVcbiAgICAgIHN0YWxlRmFtaWxpZXM6IHN0YWxlRmFtaWxpZXMgLy8gRmFtaWxpZXMgdGhhdCB3aWxsIGJlIHJlbW91bnRlZFxuXG4gICAgfTtcbiAgICBoZWxwZXJzQnlSZW5kZXJlcklELmZvckVhY2goZnVuY3Rpb24gKGhlbHBlcnMpIHtcbiAgICAgIC8vIEV2ZW4gaWYgdGhlcmUgYXJlIG5vIHJvb3RzLCBzZXQgdGhlIGhhbmRsZXIgb24gZmlyc3QgdXBkYXRlLlxuICAgICAgLy8gVGhpcyBlbnN1cmVzIHRoYXQgaWYgKm5ldyogcm9vdHMgYXJlIG1vdW50ZWQsIHRoZXknbGwgdXNlIHRoZSByZXNvbHZlIGhhbmRsZXIuXG4gICAgICBoZWxwZXJzLnNldFJlZnJlc2hIYW5kbGVyKHJlc29sdmVGYW1pbHkpO1xuICAgIH0pO1xuICAgIHZhciBkaWRFcnJvciA9IGZhbHNlO1xuICAgIHZhciBmaXJzdEVycm9yID0gbnVsbDsgLy8gV2Ugc25hcHNob3QgbWFwcyBhbmQgc2V0cyB0aGF0IGFyZSBtdXRhdGVkIGR1cmluZyBjb21taXRzLlxuICAgIC8vIElmIHdlIGRvbid0IGRvIHRoaXMsIHRoZXJlIGlzIGEgcmlzayB0aGV5IHdpbGwgYmUgbXV0YXRlZCB3aGlsZVxuICAgIC8vIHdlIGl0ZXJhdGUgb3ZlciB0aGVtLiBGb3IgZXhhbXBsZSwgdHJ5aW5nIHRvIHJlY292ZXIgYSBmYWlsZWQgcm9vdFxuICAgIC8vIG1heSBjYXVzZSBhbm90aGVyIHJvb3QgdG8gYmUgYWRkZWQgdG8gdGhlIGZhaWxlZCBsaXN0IC0tIGFuIGluZmluaXRlIGxvb3AuXG5cbiAgICB2YXIgZmFpbGVkUm9vdHNTbmFwc2hvdCA9IGNsb25lU2V0KGZhaWxlZFJvb3RzKTtcbiAgICB2YXIgbW91bnRlZFJvb3RzU25hcHNob3QgPSBjbG9uZVNldChtb3VudGVkUm9vdHMpO1xuICAgIHZhciBoZWxwZXJzQnlSb290U25hcHNob3QgPSBjbG9uZU1hcChoZWxwZXJzQnlSb290KTtcbiAgICBmYWlsZWRSb290c1NuYXBzaG90LmZvckVhY2goZnVuY3Rpb24gKHJvb3QpIHtcbiAgICAgIHZhciBoZWxwZXJzID0gaGVscGVyc0J5Um9vdFNuYXBzaG90LmdldChyb290KTtcblxuICAgICAgaWYgKGhlbHBlcnMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBmaW5kIGhlbHBlcnMgZm9yIGEgcm9vdC4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdCBSZWZyZXNoLicpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWZhaWxlZFJvb3RzLmhhcyhyb290KSkgey8vIE5vIGxvbmdlciBmYWlsZWQuXG4gICAgICB9XG5cbiAgICAgIGlmIChyb290RWxlbWVudHMgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXJvb3RFbGVtZW50cy5oYXMocm9vdCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgZWxlbWVudCA9IHJvb3RFbGVtZW50cy5nZXQocm9vdCk7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGhlbHBlcnMuc2NoZWR1bGVSb290KHJvb3QsIGVsZW1lbnQpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGlmICghZGlkRXJyb3IpIHtcbiAgICAgICAgICBkaWRFcnJvciA9IHRydWU7XG4gICAgICAgICAgZmlyc3RFcnJvciA9IGVycjtcbiAgICAgICAgfSAvLyBLZWVwIHRyeWluZyBvdGhlciByb290cy5cblxuICAgICAgfVxuICAgIH0pO1xuICAgIG1vdW50ZWRSb290c1NuYXBzaG90LmZvckVhY2goZnVuY3Rpb24gKHJvb3QpIHtcbiAgICAgIHZhciBoZWxwZXJzID0gaGVscGVyc0J5Um9vdFNuYXBzaG90LmdldChyb290KTtcblxuICAgICAgaWYgKGhlbHBlcnMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBmaW5kIGhlbHBlcnMgZm9yIGEgcm9vdC4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdCBSZWZyZXNoLicpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIW1vdW50ZWRSb290cy5oYXMocm9vdCkpIHsvLyBObyBsb25nZXIgbW91bnRlZC5cbiAgICAgIH1cblxuICAgICAgdHJ5IHtcbiAgICAgICAgaGVscGVycy5zY2hlZHVsZVJlZnJlc2gocm9vdCwgdXBkYXRlKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBpZiAoIWRpZEVycm9yKSB7XG4gICAgICAgICAgZGlkRXJyb3IgPSB0cnVlO1xuICAgICAgICAgIGZpcnN0RXJyb3IgPSBlcnI7XG4gICAgICAgIH0gLy8gS2VlcCB0cnlpbmcgb3RoZXIgcm9vdHMuXG5cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmIChkaWRFcnJvcikge1xuICAgICAgdGhyb3cgZmlyc3RFcnJvcjtcbiAgICB9XG5cbiAgICByZXR1cm4gdXBkYXRlO1xuICB9IGZpbmFsbHkge1xuICAgIGlzUGVyZm9ybWluZ1JlZnJlc2ggPSBmYWxzZTtcbiAgfVxufVxuZnVuY3Rpb24gcmVnaXN0ZXIodHlwZSwgaWQpIHtcbiAge1xuICAgIGlmICh0eXBlID09PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB0eXBlICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB0eXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gVGhpcyBjYW4gaGFwcGVuIGluIGFuIGVkZ2UgY2FzZSwgZS5nLiBpZiB3ZSByZWdpc3RlclxuICAgIC8vIHJldHVybiB2YWx1ZSBvZiBhIEhPQyBidXQgaXQgcmV0dXJucyBhIGNhY2hlZCBjb21wb25lbnQuXG4gICAgLy8gSWdub3JlIGFueXRoaW5nIGJ1dCB0aGUgZmlyc3QgcmVnaXN0cmF0aW9uIGZvciBlYWNoIHR5cGUuXG5cblxuICAgIGlmIChhbGxGYW1pbGllc0J5VHlwZS5oYXModHlwZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIENyZWF0ZSBmYW1pbHkgb3IgcmVtZW1iZXIgdG8gdXBkYXRlIGl0LlxuICAgIC8vIE5vbmUgb2YgdGhpcyBib29ra2VlcGluZyBhZmZlY3RzIHJlY29uY2lsaWF0aW9uXG4gICAgLy8gdW50aWwgdGhlIGZpcnN0IHBlcmZvcm1SZWFjdFJlZnJlc2goKSBjYWxsIGFib3ZlLlxuXG5cbiAgICB2YXIgZmFtaWx5ID0gYWxsRmFtaWxpZXNCeUlELmdldChpZCk7XG5cbiAgICBpZiAoZmFtaWx5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGZhbWlseSA9IHtcbiAgICAgICAgY3VycmVudDogdHlwZVxuICAgICAgfTtcbiAgICAgIGFsbEZhbWlsaWVzQnlJRC5zZXQoaWQsIGZhbWlseSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBlbmRpbmdVcGRhdGVzLnB1c2goW2ZhbWlseSwgdHlwZV0pO1xuICAgIH1cblxuICAgIGFsbEZhbWlsaWVzQnlUeXBlLnNldCh0eXBlLCBmYW1pbHkpOyAvLyBWaXNpdCBpbm5lciB0eXBlcyBiZWNhdXNlIHdlIG1pZ2h0IG5vdCBoYXZlIHJlZ2lzdGVyZWQgdGhlbS5cblxuICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCkge1xuICAgICAgc3dpdGNoIChnZXRQcm9wZXJ0eSh0eXBlLCAnJCR0eXBlb2YnKSkge1xuICAgICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgICAgcmVnaXN0ZXIodHlwZS5yZW5kZXIsIGlkICsgJyRyZW5kZXInKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgICByZWdpc3Rlcih0eXBlLnR5cGUsIGlkICsgJyR0eXBlJyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBzZXRTaWduYXR1cmUodHlwZSwga2V5KSB7XG4gIHZhciBmb3JjZVJlc2V0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBmYWxzZTtcbiAgdmFyIGdldEN1c3RvbUhvb2tzID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgPyBhcmd1bWVudHNbM10gOiB1bmRlZmluZWQ7XG5cbiAge1xuICAgIGlmICghYWxsU2lnbmF0dXJlc0J5VHlwZS5oYXModHlwZSkpIHtcbiAgICAgIGFsbFNpZ25hdHVyZXNCeVR5cGUuc2V0KHR5cGUsIHtcbiAgICAgICAgZm9yY2VSZXNldDogZm9yY2VSZXNldCxcbiAgICAgICAgb3duS2V5OiBrZXksXG4gICAgICAgIGZ1bGxLZXk6IG51bGwsXG4gICAgICAgIGdldEN1c3RvbUhvb2tzOiBnZXRDdXN0b21Ib29rcyB8fCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IC8vIFZpc2l0IGlubmVyIHR5cGVzIGJlY2F1c2Ugd2UgbWlnaHQgbm90IGhhdmUgc2lnbmVkIHRoZW0uXG5cblxuICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCkge1xuICAgICAgc3dpdGNoIChnZXRQcm9wZXJ0eSh0eXBlLCAnJCR0eXBlb2YnKSkge1xuICAgICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgICAgc2V0U2lnbmF0dXJlKHR5cGUucmVuZGVyLCBrZXksIGZvcmNlUmVzZXQsIGdldEN1c3RvbUhvb2tzKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgICBzZXRTaWduYXR1cmUodHlwZS50eXBlLCBrZXksIGZvcmNlUmVzZXQsIGdldEN1c3RvbUhvb2tzKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbn0gLy8gVGhpcyBpcyBsYXppbHkgY2FsbGVkIGR1cmluZyBmaXJzdCByZW5kZXIgZm9yIGEgdHlwZS5cbi8vIEl0IGNhcHR1cmVzIEhvb2sgbGlzdCBhdCB0aGF0IHRpbWUgc28gaW5saW5lIHJlcXVpcmVzIGRvbid0IGJyZWFrIGNvbXBhcmlzb25zLlxuXG5mdW5jdGlvbiBjb2xsZWN0Q3VzdG9tSG9va3NGb3JTaWduYXR1cmUodHlwZSkge1xuICB7XG4gICAgdmFyIHNpZ25hdHVyZSA9IGFsbFNpZ25hdHVyZXNCeVR5cGUuZ2V0KHR5cGUpO1xuXG4gICAgaWYgKHNpZ25hdHVyZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb21wdXRlRnVsbEtleShzaWduYXR1cmUpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZ2V0RmFtaWx5QnlJRChpZCkge1xuICB7XG4gICAgcmV0dXJuIGFsbEZhbWlsaWVzQnlJRC5nZXQoaWQpO1xuICB9XG59XG5mdW5jdGlvbiBnZXRGYW1pbHlCeVR5cGUodHlwZSkge1xuICB7XG4gICAgcmV0dXJuIGFsbEZhbWlsaWVzQnlUeXBlLmdldCh0eXBlKTtcbiAgfVxufVxuZnVuY3Rpb24gZmluZEFmZmVjdGVkSG9zdEluc3RhbmNlcyhmYW1pbGllcykge1xuICB7XG4gICAgdmFyIGFmZmVjdGVkSW5zdGFuY2VzID0gbmV3IFNldCgpO1xuICAgIG1vdW50ZWRSb290cy5mb3JFYWNoKGZ1bmN0aW9uIChyb290KSB7XG4gICAgICB2YXIgaGVscGVycyA9IGhlbHBlcnNCeVJvb3QuZ2V0KHJvb3QpO1xuXG4gICAgICBpZiAoaGVscGVycyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGZpbmQgaGVscGVycyBmb3IgYSByb290LiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0IFJlZnJlc2guJyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBpbnN0YW5jZXNGb3JSb290ID0gaGVscGVycy5maW5kSG9zdEluc3RhbmNlc0ZvclJlZnJlc2gocm9vdCwgZmFtaWxpZXMpO1xuICAgICAgaW5zdGFuY2VzRm9yUm9vdC5mb3JFYWNoKGZ1bmN0aW9uIChpbnN0KSB7XG4gICAgICAgIGFmZmVjdGVkSW5zdGFuY2VzLmFkZChpbnN0KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiBhZmZlY3RlZEluc3RhbmNlcztcbiAgfVxufVxuZnVuY3Rpb24gaW5qZWN0SW50b0dsb2JhbEhvb2soZ2xvYmFsT2JqZWN0KSB7XG4gIHtcbiAgICAvLyBGb3IgUmVhY3QgTmF0aXZlLCB0aGUgZ2xvYmFsIGhvb2sgd2lsbCBiZSBzZXQgdXAgYnkgcmVxdWlyZSgncmVhY3QtZGV2dG9vbHMtY29yZScpLlxuICAgIC8vIFRoYXQgY29kZSB3aWxsIHJ1biBiZWZvcmUgdXMuIFNvIHdlIG5lZWQgdG8gbW9ua2V5cGF0Y2ggZnVuY3Rpb25zIG9uIGV4aXN0aW5nIGhvb2suXG4gICAgLy8gRm9yIFJlYWN0IFdlYiwgdGhlIGdsb2JhbCBob29rIHdpbGwgYmUgc2V0IHVwIGJ5IHRoZSBleHRlbnNpb24uXG4gICAgLy8gVGhpcyB3aWxsIGFsc28gcnVuIGJlZm9yZSB1cy5cbiAgICB2YXIgaG9vayA9IGdsb2JhbE9iamVjdC5fX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX187XG5cbiAgICBpZiAoaG9vayA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBIb3dldmVyLCBpZiB0aGVyZSBpcyBubyBEZXZUb29scyBleHRlbnNpb24sIHdlJ2xsIG5lZWQgdG8gc2V0IHVwIHRoZSBnbG9iYWwgaG9vayBvdXJzZWx2ZXMuXG4gICAgICAvLyBOb3RlIHRoYXQgaW4gdGhpcyBjYXNlIGl0J3MgaW1wb3J0YW50IHRoYXQgcmVuZGVyZXIgY29kZSBydW5zICphZnRlciogdGhpcyBtZXRob2QgY2FsbC5cbiAgICAgIC8vIE90aGVyd2lzZSwgdGhlIHJlbmRlcmVyIHdpbGwgdGhpbmsgdGhhdCB0aGVyZSBpcyBubyBnbG9iYWwgaG9vaywgYW5kIHdvbid0IGRvIHRoZSBpbmplY3Rpb24uXG4gICAgICB2YXIgbmV4dElEID0gMDtcbiAgICAgIGdsb2JhbE9iamVjdC5fX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gPSBob29rID0ge1xuICAgICAgICByZW5kZXJlcnM6IG5ldyBNYXAoKSxcbiAgICAgICAgc3VwcG9ydHNGaWJlcjogdHJ1ZSxcbiAgICAgICAgaW5qZWN0OiBmdW5jdGlvbiAoaW5qZWN0ZWQpIHtcbiAgICAgICAgICByZXR1cm4gbmV4dElEKys7XG4gICAgICAgIH0sXG4gICAgICAgIG9uU2NoZWR1bGVGaWJlclJvb3Q6IGZ1bmN0aW9uIChpZCwgcm9vdCwgY2hpbGRyZW4pIHt9LFxuICAgICAgICBvbkNvbW1pdEZpYmVyUm9vdDogZnVuY3Rpb24gKGlkLCByb290LCBtYXliZVByaW9yaXR5TGV2ZWwsIGRpZEVycm9yKSB7fSxcbiAgICAgICAgb25Db21taXRGaWJlclVubW91bnQ6IGZ1bmN0aW9uICgpIHt9XG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmIChob29rLmlzRGlzYWJsZWQpIHtcbiAgICAgIC8vIFRoaXMgaXNuJ3QgYSByZWFsIHByb3BlcnR5IG9uIHRoZSBob29rLCBidXQgaXQgY2FuIGJlIHNldCB0byBvcHQgb3V0XG4gICAgICAvLyBvZiBEZXZUb29scyBpbnRlZ3JhdGlvbiBhbmQgYXNzb2NpYXRlZCB3YXJuaW5ncyBhbmQgbG9ncy5cbiAgICAgIC8vIFVzaW5nIGNvbnNvbGVbJ3dhcm4nXSB0byBldmFkZSBCYWJlbCBhbmQgRVNMaW50XG4gICAgICBjb25zb2xlWyd3YXJuJ10oJ1NvbWV0aGluZyBoYXMgc2hpbW1lZCB0aGUgUmVhY3QgRGV2VG9vbHMgZ2xvYmFsIGhvb2sgKF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXykuICcgKyAnRmFzdCBSZWZyZXNoIGlzIG5vdCBjb21wYXRpYmxlIHdpdGggdGhpcyBzaGltIGFuZCB3aWxsIGJlIGRpc2FibGVkLicpO1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gSGVyZSwgd2UganVzdCB3YW50IHRvIGdldCBhIHJlZmVyZW5jZSB0byBzY2hlZHVsZVJlZnJlc2guXG5cblxuICAgIHZhciBvbGRJbmplY3QgPSBob29rLmluamVjdDtcblxuICAgIGhvb2suaW5qZWN0ID0gZnVuY3Rpb24gKGluamVjdGVkKSB7XG4gICAgICB2YXIgaWQgPSBvbGRJbmplY3QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgICAgaWYgKHR5cGVvZiBpbmplY3RlZC5zY2hlZHVsZVJlZnJlc2ggPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGluamVjdGVkLnNldFJlZnJlc2hIYW5kbGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIFRoaXMgdmVyc2lvbiBzdXBwb3J0cyBSZWFjdCBSZWZyZXNoLlxuICAgICAgICBoZWxwZXJzQnlSZW5kZXJlcklELnNldChpZCwgaW5qZWN0ZWQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaWQ7XG4gICAgfTsgLy8gRG8gdGhlIHNhbWUgZm9yIGFueSBhbHJlYWR5IGluamVjdGVkIHJvb3RzLlxuICAgIC8vIFRoaXMgaXMgdXNlZnVsIGlmIFJlYWN0RE9NIGhhcyBhbHJlYWR5IGJlZW4gaW5pdGlhbGl6ZWQuXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xNzYyNlxuXG5cbiAgICBob29rLnJlbmRlcmVycy5mb3JFYWNoKGZ1bmN0aW9uIChpbmplY3RlZCwgaWQpIHtcbiAgICAgIGlmICh0eXBlb2YgaW5qZWN0ZWQuc2NoZWR1bGVSZWZyZXNoID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBpbmplY3RlZC5zZXRSZWZyZXNoSGFuZGxlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBUaGlzIHZlcnNpb24gc3VwcG9ydHMgUmVhY3QgUmVmcmVzaC5cbiAgICAgICAgaGVscGVyc0J5UmVuZGVyZXJJRC5zZXQoaWQsIGluamVjdGVkKTtcbiAgICAgIH1cbiAgICB9KTsgLy8gV2UgYWxzbyB3YW50IHRvIHRyYWNrIGN1cnJlbnRseSBtb3VudGVkIHJvb3RzLlxuXG4gICAgdmFyIG9sZE9uQ29tbWl0RmliZXJSb290ID0gaG9vay5vbkNvbW1pdEZpYmVyUm9vdDtcblxuICAgIHZhciBvbGRPblNjaGVkdWxlRmliZXJSb290ID0gaG9vay5vblNjaGVkdWxlRmliZXJSb290IHx8IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgaG9vay5vblNjaGVkdWxlRmliZXJSb290ID0gZnVuY3Rpb24gKGlkLCByb290LCBjaGlsZHJlbikge1xuICAgICAgaWYgKCFpc1BlcmZvcm1pbmdSZWZyZXNoKSB7XG4gICAgICAgIC8vIElmIGl0IHdhcyBpbnRlbnRpb25hbGx5IHNjaGVkdWxlZCwgZG9uJ3QgYXR0ZW1wdCB0byByZXN0b3JlLlxuICAgICAgICAvLyBUaGlzIGluY2x1ZGVzIGludGVudGlvbmFsbHkgc2NoZWR1bGVkIHVubW91bnRzLlxuICAgICAgICBmYWlsZWRSb290cy5kZWxldGUocm9vdCk7XG5cbiAgICAgICAgaWYgKHJvb3RFbGVtZW50cyAhPT0gbnVsbCkge1xuICAgICAgICAgIHJvb3RFbGVtZW50cy5zZXQocm9vdCwgY2hpbGRyZW4pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvbGRPblNjaGVkdWxlRmliZXJSb290LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcblxuICAgIGhvb2sub25Db21taXRGaWJlclJvb3QgPSBmdW5jdGlvbiAoaWQsIHJvb3QsIG1heWJlUHJpb3JpdHlMZXZlbCwgZGlkRXJyb3IpIHtcbiAgICAgIHZhciBoZWxwZXJzID0gaGVscGVyc0J5UmVuZGVyZXJJRC5nZXQoaWQpO1xuXG4gICAgICBpZiAoaGVscGVycyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGhlbHBlcnNCeVJvb3Quc2V0KHJvb3QsIGhlbHBlcnMpO1xuICAgICAgICB2YXIgY3VycmVudCA9IHJvb3QuY3VycmVudDtcbiAgICAgICAgdmFyIGFsdGVybmF0ZSA9IGN1cnJlbnQuYWx0ZXJuYXRlOyAvLyBXZSBuZWVkIHRvIGRldGVybWluZSB3aGV0aGVyIHRoaXMgcm9vdCBoYXMganVzdCAodW4pbW91bnRlZC5cbiAgICAgICAgLy8gVGhpcyBsb2dpYyBpcyBjb3B5LXBhc3RlZCBmcm9tIHNpbWlsYXIgbG9naWMgaW4gdGhlIERldlRvb2xzIGJhY2tlbmQuXG4gICAgICAgIC8vIElmIHRoaXMgYnJlYWtzIHdpdGggc29tZSByZWZhY3RvcmluZywgeW91J2xsIHdhbnQgdG8gdXBkYXRlIERldlRvb2xzIHRvby5cblxuICAgICAgICBpZiAoYWx0ZXJuYXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgdmFyIHdhc01vdW50ZWQgPSBhbHRlcm5hdGUubWVtb2l6ZWRTdGF0ZSAhPSBudWxsICYmIGFsdGVybmF0ZS5tZW1vaXplZFN0YXRlLmVsZW1lbnQgIT0gbnVsbCAmJiBtb3VudGVkUm9vdHMuaGFzKHJvb3QpO1xuICAgICAgICAgIHZhciBpc01vdW50ZWQgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGUgIT0gbnVsbCAmJiBjdXJyZW50Lm1lbW9pemVkU3RhdGUuZWxlbWVudCAhPSBudWxsO1xuXG4gICAgICAgICAgaWYgKCF3YXNNb3VudGVkICYmIGlzTW91bnRlZCkge1xuICAgICAgICAgICAgLy8gTW91bnQgYSBuZXcgcm9vdC5cbiAgICAgICAgICAgIG1vdW50ZWRSb290cy5hZGQocm9vdCk7XG4gICAgICAgICAgICBmYWlsZWRSb290cy5kZWxldGUocm9vdCk7XG4gICAgICAgICAgfSBlbHNlIGlmICh3YXNNb3VudGVkICYmIGlzTW91bnRlZCkgOyBlbHNlIGlmICh3YXNNb3VudGVkICYmICFpc01vdW50ZWQpIHtcbiAgICAgICAgICAgIC8vIFVubW91bnQgYW4gZXhpc3Rpbmcgcm9vdC5cbiAgICAgICAgICAgIG1vdW50ZWRSb290cy5kZWxldGUocm9vdCk7XG5cbiAgICAgICAgICAgIGlmIChkaWRFcnJvcikge1xuICAgICAgICAgICAgICAvLyBXZSdsbCByZW1vdW50IGl0IG9uIGZ1dHVyZSBlZGl0cy5cbiAgICAgICAgICAgICAgZmFpbGVkUm9vdHMuYWRkKHJvb3QpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaGVscGVyc0J5Um9vdC5kZWxldGUocm9vdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmICghd2FzTW91bnRlZCAmJiAhaXNNb3VudGVkKSB7XG4gICAgICAgICAgICBpZiAoZGlkRXJyb3IpIHtcbiAgICAgICAgICAgICAgLy8gV2UnbGwgcmVtb3VudCBpdCBvbiBmdXR1cmUgZWRpdHMuXG4gICAgICAgICAgICAgIGZhaWxlZFJvb3RzLmFkZChyb290KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gTW91bnQgYSBuZXcgcm9vdC5cbiAgICAgICAgICBtb3VudGVkUm9vdHMuYWRkKHJvb3QpO1xuICAgICAgICB9XG4gICAgICB9IC8vIEFsd2F5cyBjYWxsIHRoZSBkZWNvcmF0ZWQgRGV2VG9vbHMgaG9vay5cblxuXG4gICAgICByZXR1cm4gb2xkT25Db21taXRGaWJlclJvb3QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9XG59XG5mdW5jdGlvbiBoYXNVbnJlY292ZXJhYmxlRXJyb3JzKCkge1xuICAvLyBUT0RPOiBkZWxldGUgdGhpcyBhZnRlciByZW1vdmluZyBkZXBlbmRlbmN5IGluIFJOLlxuICByZXR1cm4gZmFsc2U7XG59IC8vIEV4cG9zZWQgZm9yIHRlc3RpbmcuXG5cbmZ1bmN0aW9uIF9nZXRNb3VudGVkUm9vdENvdW50KCkge1xuICB7XG4gICAgcmV0dXJuIG1vdW50ZWRSb290cy5zaXplO1xuICB9XG59IC8vIFRoaXMgaXMgYSB3cmFwcGVyIG92ZXIgbW9yZSBwcmltaXRpdmUgZnVuY3Rpb25zIGZvciBzZXR0aW5nIHNpZ25hdHVyZS5cbi8vIFNpZ25hdHVyZXMgbGV0IHVzIGRlY2lkZSB3aGV0aGVyIHRoZSBIb29rIG9yZGVyIGhhcyBjaGFuZ2VkIG9uIHJlZnJlc2guXG4vL1xuLy8gVGhpcyBmdW5jdGlvbiBpcyBpbnRlbmRlZCB0byBiZSB1c2VkIGFzIGEgdHJhbnNmb3JtIHRhcmdldCwgZS5nLjpcbi8vIHZhciBfcyA9IGNyZWF0ZVNpZ25hdHVyZUZ1bmN0aW9uRm9yVHJhbnNmb3JtKClcbi8vXG4vLyBmdW5jdGlvbiBIZWxsbygpIHtcbi8vICAgY29uc3QgW2Zvbywgc2V0Rm9vXSA9IHVzZVN0YXRlKDApO1xuLy8gICBjb25zdCB2YWx1ZSA9IHVzZUN1c3RvbUhvb2soKTtcbi8vICAgX3MoKTsgLyogQ2FsbCB3aXRob3V0IGFyZ3VtZW50cyB0cmlnZ2VycyBjb2xsZWN0aW5nIHRoZSBjdXN0b20gSG9vayBsaXN0LlxuLy8gICAgICAgICAgKiBUaGlzIGRvZXNuJ3QgaGFwcGVuIGR1cmluZyB0aGUgbW9kdWxlIGV2YWx1YXRpb24gYmVjYXVzZSB3ZVxuLy8gICAgICAgICAgKiBkb24ndCB3YW50IHRvIGNoYW5nZSB0aGUgbW9kdWxlIG9yZGVyIHdpdGggaW5saW5lIHJlcXVpcmVzLlxuLy8gICAgICAgICAgKiBOZXh0IGNhbGxzIGFyZSBub29wcy4gKi9cbi8vICAgcmV0dXJuIDxoMT5IaTwvaDE+O1xuLy8gfVxuLy9cbi8vIC8qIENhbGwgd2l0aCBhcmd1bWVudHMgYXR0YWNoZXMgdGhlIHNpZ25hdHVyZSB0byB0aGUgdHlwZTogKi9cbi8vIF9zKFxuLy8gICBIZWxsbyxcbi8vICAgJ3VzZVN0YXRle1tmb28sIHNldEZvb119KDApJyxcbi8vICAgKCkgPT4gW3VzZUN1c3RvbUhvb2tdLCAvKiBMYXp5IHRvIGF2b2lkIHRyaWdnZXJpbmcgaW5saW5lIHJlcXVpcmVzICovXG4vLyApO1xuXG5mdW5jdGlvbiBjcmVhdGVTaWduYXR1cmVGdW5jdGlvbkZvclRyYW5zZm9ybSgpIHtcbiAge1xuICAgIHZhciBzYXZlZFR5cGU7XG4gICAgdmFyIGhhc0N1c3RvbUhvb2tzO1xuICAgIHZhciBkaWRDb2xsZWN0SG9va3MgPSBmYWxzZTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHR5cGUsIGtleSwgZm9yY2VSZXNldCwgZ2V0Q3VzdG9tSG9va3MpIHtcbiAgICAgIGlmICh0eXBlb2Yga2V5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAvLyBXZSdyZSBpbiB0aGUgaW5pdGlhbCBwaGFzZSB0aGF0IGFzc29jaWF0ZXMgc2lnbmF0dXJlc1xuICAgICAgICAvLyB3aXRoIHRoZSBmdW5jdGlvbnMuIE5vdGUgdGhpcyBtYXkgYmUgY2FsbGVkIG11bHRpcGxlIHRpbWVzXG4gICAgICAgIC8vIGluIEhPQyBjaGFpbnMgbGlrZSBfcyhob2MxKF9zKGhvYzIoX3MoYWN0dWFsRnVuY3Rpb24pKSkpKS5cbiAgICAgICAgaWYgKCFzYXZlZFR5cGUpIHtcbiAgICAgICAgICAvLyBXZSdyZSBpbiB0aGUgaW5uZXJtb3N0IGNhbGwsIHNvIHRoaXMgaXMgdGhlIGFjdHVhbCB0eXBlLlxuICAgICAgICAgIHNhdmVkVHlwZSA9IHR5cGU7XG4gICAgICAgICAgaGFzQ3VzdG9tSG9va3MgPSB0eXBlb2YgZ2V0Q3VzdG9tSG9va3MgPT09ICdmdW5jdGlvbic7XG4gICAgICAgIH0gLy8gU2V0IHRoZSBzaWduYXR1cmUgZm9yIGFsbCB0eXBlcyAoZXZlbiB3cmFwcGVycyEpIGluIGNhc2VcbiAgICAgICAgLy8gdGhleSBoYXZlIG5vIHNpZ25hdHVyZXMgb2YgdGhlaXIgb3duLiBUaGlzIGlzIHRvIHByZXZlbnRcbiAgICAgICAgLy8gcHJvYmxlbXMgbGlrZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzIwNDE3LlxuXG5cbiAgICAgICAgaWYgKHR5cGUgIT0gbnVsbCAmJiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnKSkge1xuICAgICAgICAgIHNldFNpZ25hdHVyZSh0eXBlLCBrZXksIGZvcmNlUmVzZXQsIGdldEN1c3RvbUhvb2tzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gV2UncmUgaW4gdGhlIF9zKCkgY2FsbCB3aXRob3V0IGFyZ3VtZW50cywgd2hpY2ggbWVhbnNcbiAgICAgICAgLy8gdGhpcyBpcyB0aGUgdGltZSB0byBjb2xsZWN0IGN1c3RvbSBIb29rIHNpZ25hdHVyZXMuXG4gICAgICAgIC8vIE9ubHkgZG8gdGhpcyBvbmNlLiBUaGlzIHBhdGggaXMgaG90IGFuZCBydW5zICppbnNpZGUqIGV2ZXJ5IHJlbmRlciFcbiAgICAgICAgaWYgKCFkaWRDb2xsZWN0SG9va3MgJiYgaGFzQ3VzdG9tSG9va3MpIHtcbiAgICAgICAgICBkaWRDb2xsZWN0SG9va3MgPSB0cnVlO1xuICAgICAgICAgIGNvbGxlY3RDdXN0b21Ib29rc0ZvclNpZ25hdHVyZShzYXZlZFR5cGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxufVxuZnVuY3Rpb24gaXNMaWtlbHlDb21wb25lbnRUeXBlKHR5cGUpIHtcbiAge1xuICAgIHN3aXRjaCAodHlwZW9mIHR5cGUpIHtcbiAgICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAgICAge1xuICAgICAgICAgIC8vIEZpcnN0LCBkZWFsIHdpdGggY2xhc3Nlcy5cbiAgICAgICAgICBpZiAodHlwZS5wcm90b3R5cGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHR5cGUucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgLy8gUmVhY3QgY2xhc3MuXG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgb3duTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0eXBlLnByb3RvdHlwZSk7XG5cbiAgICAgICAgICAgIGlmIChvd25OYW1lcy5sZW5ndGggPiAxIHx8IG93bk5hbWVzWzBdICE9PSAnY29uc3RydWN0b3InKSB7XG4gICAgICAgICAgICAgIC8vIFRoaXMgbG9va3MgbGlrZSBhIGNsYXNzLlxuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b1xuXG5cbiAgICAgICAgICAgIGlmICh0eXBlLnByb3RvdHlwZS5fX3Byb3RvX18gIT09IE9iamVjdC5wcm90b3R5cGUpIHtcbiAgICAgICAgICAgICAgLy8gSXQgaGFzIGEgc3VwZXJjbGFzcy5cbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSAvLyBQYXNzIHRocm91Z2guXG4gICAgICAgICAgICAvLyBUaGlzIGxvb2tzIGxpa2UgYSByZWd1bGFyIGZ1bmN0aW9uIHdpdGggZW1wdHkgcHJvdG90eXBlLlxuXG4gICAgICAgICAgfSAvLyBGb3IgcGxhaW4gZnVuY3Rpb25zIGFuZCBhcnJvd3MsIHVzZSBuYW1lIGFzIGEgaGV1cmlzdGljLlxuXG5cbiAgICAgICAgICB2YXIgbmFtZSA9IHR5cGUubmFtZSB8fCB0eXBlLmRpc3BsYXlOYW1lO1xuICAgICAgICAgIHJldHVybiB0eXBlb2YgbmFtZSA9PT0gJ3N0cmluZycgJiYgL15bQS1aXS8udGVzdChuYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICB7XG4gICAgICAgICAgaWYgKHR5cGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgc3dpdGNoIChnZXRQcm9wZXJ0eSh0eXBlLCAnJCR0eXBlb2YnKSkge1xuICAgICAgICAgICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICAgICAgICAgIC8vIERlZmluaXRlbHkgUmVhY3QgY29tcG9uZW50cy5cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnRzLl9nZXRNb3VudGVkUm9vdENvdW50ID0gX2dldE1vdW50ZWRSb290Q291bnQ7XG5leHBvcnRzLmNvbGxlY3RDdXN0b21Ib29rc0ZvclNpZ25hdHVyZSA9IGNvbGxlY3RDdXN0b21Ib29rc0ZvclNpZ25hdHVyZTtcbmV4cG9ydHMuY3JlYXRlU2lnbmF0dXJlRnVuY3Rpb25Gb3JUcmFuc2Zvcm0gPSBjcmVhdGVTaWduYXR1cmVGdW5jdGlvbkZvclRyYW5zZm9ybTtcbmV4cG9ydHMuZmluZEFmZmVjdGVkSG9zdEluc3RhbmNlcyA9IGZpbmRBZmZlY3RlZEhvc3RJbnN0YW5jZXM7XG5leHBvcnRzLmdldEZhbWlseUJ5SUQgPSBnZXRGYW1pbHlCeUlEO1xuZXhwb3J0cy5nZXRGYW1pbHlCeVR5cGUgPSBnZXRGYW1pbHlCeVR5cGU7XG5leHBvcnRzLmhhc1VucmVjb3ZlcmFibGVFcnJvcnMgPSBoYXNVbnJlY292ZXJhYmxlRXJyb3JzO1xuZXhwb3J0cy5pbmplY3RJbnRvR2xvYmFsSG9vayA9IGluamVjdEludG9HbG9iYWxIb29rO1xuZXhwb3J0cy5pc0xpa2VseUNvbXBvbmVudFR5cGUgPSBpc0xpa2VseUNvbXBvbmVudFR5cGU7XG5leHBvcnRzLnBlcmZvcm1SZWFjdFJlZnJlc2ggPSBwZXJmb3JtUmVhY3RSZWZyZXNoO1xuZXhwb3J0cy5yZWdpc3RlciA9IHJlZ2lzdGVyO1xuZXhwb3J0cy5zZXRTaWduYXR1cmUgPSBzZXRTaWduYXR1cmU7XG4gIH0pKCk7XG59XG5cbmZ1bmN0aW9uIGRlYm91bmNlKGZuLCBkZWxheSkge1xuICBsZXQgaGFuZGxlXG4gIHJldHVybiAoKSA9PiB7XG4gICAgY2xlYXJUaW1lb3V0KGhhbmRsZSlcbiAgICBoYW5kbGUgPSBzZXRUaW1lb3V0KGZuLCBkZWxheSlcbiAgfVxufVxuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bmRlZiAqL1xuY29uc3QgZW5xdWV1ZVVwZGF0ZSA9IGRlYm91bmNlKGV4cG9ydHMucGVyZm9ybVJlYWN0UmVmcmVzaCwgMTYpXG5cbi8vIFRha2VuIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL3BtbW13aC9yZWFjdC1yZWZyZXNoLXdlYnBhY2stcGx1Z2luL2Jsb2IvbWFpbi9saWIvcnVudGltZS9SZWZyZXNoVXRpbHMuanMjTDE0MVxuLy8gVGhpcyBhbGxvd3MgdG8gcmVzaXN0ZXIgY29tcG9uZW50cyBub3QgZGV0ZWN0ZWQgYnkgU1dDIGxpa2Ugc3R5bGVkIGNvbXBvbmVudFxuZnVuY3Rpb24gcmVnaXN0ZXJFeHBvcnRzRm9yUmVhY3RSZWZyZXNoKGZpbGVuYW1lLCBtb2R1bGVFeHBvcnRzKSB7XG4gIGZvciAoY29uc3Qga2V5IGluIG1vZHVsZUV4cG9ydHMpIHtcbiAgICBpZiAoa2V5ID09PSAnX19lc01vZHVsZScpIGNvbnRpbnVlXG4gICAgY29uc3QgZXhwb3J0VmFsdWUgPSBtb2R1bGVFeHBvcnRzW2tleV1cbiAgICBpZiAoZXhwb3J0cy5pc0xpa2VseUNvbXBvbmVudFR5cGUoZXhwb3J0VmFsdWUpKSB7XG4gICAgICAvLyAnZXhwb3J0JyBpcyByZXF1aXJlZCB0byBhdm9pZCBrZXkgY29sbGlzaW9uIHdoZW4gcmVuYW1lZCBleHBvcnRzIHRoYXRcbiAgICAgIC8vIHNoYWRvdyBhIGxvY2FsIGNvbXBvbmVudCBuYW1lOiBodHRwczovL2dpdGh1Yi5jb20vdml0ZWpzL3ZpdGUtcGx1Z2luLXJlYWN0L2lzc3Vlcy8xMTZcbiAgICAgIC8vIFRoZSByZWdpc3RlciBmdW5jdGlvbiBoYXMgYW4gaWRlbnRpdHkgY2hlY2sgdG8gbm90IHJlZ2lzdGVyIHR3aWNlIHRoZSBzYW1lIGNvbXBvbmVudCxcbiAgICAgIC8vIHNvIHRoaXMgaXMgc2FmZSB0byBub3QgdXNlZCB0aGUgc2FtZSBrZXkgaGVyZS5cbiAgICAgIGV4cG9ydHMucmVnaXN0ZXIoZXhwb3J0VmFsdWUsIGZpbGVuYW1lICsgJyBleHBvcnQgJyArIGtleSlcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVSZWZyZXNoQm91bmRhcnlBbmRFbnF1ZXVlVXBkYXRlKHByZXZFeHBvcnRzLCBuZXh0RXhwb3J0cykge1xuICBpZiAoIXByZWRpY2F0ZU9uRXhwb3J0KHByZXZFeHBvcnRzLCAoa2V5KSA9PiBrZXkgaW4gbmV4dEV4cG9ydHMpKSB7XG4gICAgcmV0dXJuICdDb3VsZCBub3QgRmFzdCBSZWZyZXNoIChleHBvcnQgcmVtb3ZlZCknXG4gIH1cbiAgaWYgKCFwcmVkaWNhdGVPbkV4cG9ydChuZXh0RXhwb3J0cywgKGtleSkgPT4ga2V5IGluIHByZXZFeHBvcnRzKSkge1xuICAgIHJldHVybiAnQ291bGQgbm90IEZhc3QgUmVmcmVzaCAobmV3IGV4cG9ydCknXG4gIH1cblxuICBsZXQgaGFzRXhwb3J0cyA9IGZhbHNlXG4gIGNvbnN0IGFsbEV4cG9ydHNBcmVDb21wb25lbnRzT3JVbmNoYW5nZWQgPSBwcmVkaWNhdGVPbkV4cG9ydChcbiAgICBuZXh0RXhwb3J0cyxcbiAgICAoa2V5LCB2YWx1ZSkgPT4ge1xuICAgICAgaGFzRXhwb3J0cyA9IHRydWVcbiAgICAgIGlmIChleHBvcnRzLmlzTGlrZWx5Q29tcG9uZW50VHlwZSh2YWx1ZSkpIHJldHVybiB0cnVlXG4gICAgICByZXR1cm4gcHJldkV4cG9ydHNba2V5XSA9PT0gbmV4dEV4cG9ydHNba2V5XVxuICAgIH0sXG4gIClcbiAgaWYgKGhhc0V4cG9ydHMgJiYgYWxsRXhwb3J0c0FyZUNvbXBvbmVudHNPclVuY2hhbmdlZCkge1xuICAgIGVucXVldWVVcGRhdGUoKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiAnQ291bGQgbm90IEZhc3QgUmVmcmVzaC4gTGVhcm4gbW9yZSBhdCBodHRwczovL2dpdGh1Yi5jb20vdml0ZWpzL3ZpdGUtcGx1Z2luLXJlYWN0L3RyZWUvbWFpbi9wYWNrYWdlcy9wbHVnaW4tcmVhY3QjY29uc2lzdGVudC1jb21wb25lbnRzLWV4cG9ydHMnXG4gIH1cbn1cblxuZnVuY3Rpb24gcHJlZGljYXRlT25FeHBvcnQobW9kdWxlRXhwb3J0cywgcHJlZGljYXRlKSB7XG4gIGZvciAoY29uc3Qga2V5IGluIG1vZHVsZUV4cG9ydHMpIHtcbiAgICBpZiAoa2V5ID09PSAnX19lc01vZHVsZScpIGNvbnRpbnVlXG4gICAgY29uc3QgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobW9kdWxlRXhwb3J0cywga2V5KVxuICAgIGlmIChkZXNjICYmIGRlc2MuZ2V0KSByZXR1cm4gZmFsc2VcbiAgICBpZiAoIXByZWRpY2F0ZShrZXksIG1vZHVsZUV4cG9ydHNba2V5XSkpIHJldHVybiBmYWxzZVxuICB9XG4gIHJldHVybiB0cnVlXG59XG5cbi8vIEhpZGVzIHZpdGUtaWdub3JlZCBkeW5hbWljIGltcG9ydCBzbyB0aGF0IFZpdGUgY2FuIHNraXAgYW5hbHlzaXMgaWYgbm8gb3RoZXJcbi8vIGR5bmFtaWMgaW1wb3J0IGlzIHByZXNlbnQgKGh0dHBzOi8vZ2l0aHViLmNvbS92aXRlanMvdml0ZS9wdWxsLzEyNzMyKVxuZnVuY3Rpb24gX19obXJfaW1wb3J0KG1vZHVsZSkge1xuICByZXR1cm4gaW1wb3J0KC8qIEB2aXRlLWlnbm9yZSAqLyBtb2R1bGUpXG59XG5cbmV4cG9ydHMuX19obXJfaW1wb3J0ID0gX19obXJfaW1wb3J0XG5leHBvcnRzLnJlZ2lzdGVyRXhwb3J0c0ZvclJlYWN0UmVmcmVzaCA9IHJlZ2lzdGVyRXhwb3J0c0ZvclJlYWN0UmVmcmVzaFxuZXhwb3J0cy52YWxpZGF0ZVJlZnJlc2hCb3VuZGFyeUFuZEVucXVldWVVcGRhdGUgPVxuICB2YWxpZGF0ZVJlZnJlc2hCb3VuZGFyeUFuZEVucXVldWVVcGRhdGVcblxuZXhwb3J0IGRlZmF1bHQgZXhwb3J0c1xuIl0sIm1hcHBpbmdzIjoiQUFDQSxNQUFNLFVBQVUsQ0FBQztBQUNqQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFVQTtBQUVBLElBQUksTUFBdUM7QUFDekMsR0FBQyxXQUFXO0FBQ2Q7QUFHQSxRQUFJLHlCQUF5QixPQUFPLElBQUksbUJBQW1CO0FBQzNELFFBQUksa0JBQWtCLE9BQU8sSUFBSSxZQUFZO0FBRTdDLFFBQUksa0JBQWtCLE9BQU8sWUFBWSxhQUFhLFVBQVU7QUFHaEUsUUFBSSxrQkFBa0Isb0JBQUksSUFBSTtBQUM5QixRQUFJLG9CQUFvQixJQUFJLGdCQUFnQjtBQUM1QyxRQUFJLHNCQUFzQixJQUFJLGdCQUFnQjtBQUk5QyxRQUFJLHdCQUF3QixJQUFJLGdCQUFnQjtBQUdoRCxRQUFJLGlCQUFpQixDQUFDO0FBRXRCLFFBQUksc0JBQXNCLG9CQUFJLElBQUk7QUFDbEMsUUFBSSxnQkFBZ0Isb0JBQUksSUFBSTtBQUU1QixRQUFJLGVBQWUsb0JBQUksSUFBSTtBQUUzQixRQUFJLGNBQWMsb0JBQUksSUFBSTtBQUsxQixRQUFJO0FBQUE7QUFBQSxNQUNKLE9BQU8sWUFBWSxhQUFhLG9CQUFJLFFBQVEsSUFBSTtBQUFBO0FBQ2hELFFBQUksc0JBQXNCO0FBRTFCLGFBQVMsZUFBZSxXQUFXO0FBQ2pDLFVBQUksVUFBVSxZQUFZLE1BQU07QUFDOUIsZUFBTyxVQUFVO0FBQUEsTUFDbkI7QUFFQSxVQUFJLFVBQVUsVUFBVTtBQUN4QixVQUFJO0FBRUosVUFBSTtBQUNGLGdCQUFRLFVBQVUsZUFBZTtBQUFBLE1BQ25DLFNBQVMsS0FBSztBQUlaLGtCQUFVLGFBQWE7QUFDdkIsa0JBQVUsVUFBVTtBQUNwQixlQUFPO0FBQUEsTUFDVDtBQUVBLGVBQVMsSUFBSSxHQUFHLElBQUksTUFBTSxRQUFRLEtBQUs7QUFDckMsWUFBSSxPQUFPLE1BQU0sQ0FBQztBQUVsQixZQUFJLE9BQU8sU0FBUyxZQUFZO0FBRTlCLG9CQUFVLGFBQWE7QUFDdkIsb0JBQVUsVUFBVTtBQUNwQixpQkFBTztBQUFBLFFBQ1Q7QUFFQSxZQUFJLHNCQUFzQixvQkFBb0IsSUFBSSxJQUFJO0FBRXRELFlBQUksd0JBQXdCLFFBQVc7QUFHckM7QUFBQSxRQUNGO0FBRUEsWUFBSSxnQkFBZ0IsZUFBZSxtQkFBbUI7QUFFdEQsWUFBSSxvQkFBb0IsWUFBWTtBQUNsQyxvQkFBVSxhQUFhO0FBQUEsUUFDekI7QUFFQSxtQkFBVyxZQUFZO0FBQUEsTUFDekI7QUFFQSxnQkFBVSxVQUFVO0FBQ3BCLGFBQU87QUFBQSxJQUNUO0FBRUEsYUFBUyxvQkFBb0IsVUFBVSxVQUFVO0FBQy9DLFVBQUksZ0JBQWdCLG9CQUFvQixJQUFJLFFBQVE7QUFDcEQsVUFBSSxnQkFBZ0Isb0JBQW9CLElBQUksUUFBUTtBQUVwRCxVQUFJLGtCQUFrQixVQUFhLGtCQUFrQixRQUFXO0FBQzlELGVBQU87QUFBQSxNQUNUO0FBRUEsVUFBSSxrQkFBa0IsVUFBYSxrQkFBa0IsUUFBVztBQUM5RCxlQUFPO0FBQUEsTUFDVDtBQUVBLFVBQUksZUFBZSxhQUFhLE1BQU0sZUFBZSxhQUFhLEdBQUc7QUFDbkUsZUFBTztBQUFBLE1BQ1Q7QUFFQSxVQUFJLGNBQWMsWUFBWTtBQUM1QixlQUFPO0FBQUEsTUFDVDtBQUVBLGFBQU87QUFBQSxJQUNUO0FBRUEsYUFBUyxhQUFhLE1BQU07QUFDMUIsYUFBTyxLQUFLLGFBQWEsS0FBSyxVQUFVO0FBQUEsSUFDMUM7QUFFQSxhQUFTLHdCQUF3QixVQUFVLFVBQVU7QUFDbkQsVUFBSSxhQUFhLFFBQVEsS0FBSyxhQUFhLFFBQVEsR0FBRztBQUNwRCxlQUFPO0FBQUEsTUFDVDtBQUVBLFVBQUksb0JBQW9CLFVBQVUsUUFBUSxHQUFHO0FBQzNDLGVBQU87QUFBQSxNQUNUO0FBRUEsYUFBTztBQUFBLElBQ1Q7QUFFQSxhQUFTLGNBQWMsTUFBTTtBQUUzQixhQUFPLHNCQUFzQixJQUFJLElBQUk7QUFBQSxJQUN2QztBQUdBLGFBQVMsU0FBUyxLQUFLO0FBQ3JCLFVBQUksUUFBUSxvQkFBSSxJQUFJO0FBQ3BCLFVBQUksUUFBUSxTQUFVLE9BQU8sS0FBSztBQUNoQyxjQUFNLElBQUksS0FBSyxLQUFLO0FBQUEsTUFDdEIsQ0FBQztBQUNELGFBQU87QUFBQSxJQUNUO0FBRUEsYUFBUyxTQUFTLEtBQUs7QUFDckIsVUFBSSxRQUFRLG9CQUFJLElBQUk7QUFDcEIsVUFBSSxRQUFRLFNBQVUsT0FBTztBQUMzQixjQUFNLElBQUksS0FBSztBQUFBLE1BQ2pCLENBQUM7QUFDRCxhQUFPO0FBQUEsSUFDVDtBQUdBLGFBQVMsWUFBWSxRQUFRLFVBQVU7QUFDckMsVUFBSTtBQUNGLGVBQU8sT0FBTyxRQUFRO0FBQUEsTUFDeEIsU0FBUyxLQUFLO0FBRVosZUFBTztBQUFBLE1BQ1Q7QUFBQSxJQUNGO0FBRUEsYUFBUyxzQkFBc0I7QUFFN0IsVUFBSSxlQUFlLFdBQVcsR0FBRztBQUMvQixlQUFPO0FBQUEsTUFDVDtBQUVBLFVBQUkscUJBQXFCO0FBQ3ZCLGVBQU87QUFBQSxNQUNUO0FBRUEsNEJBQXNCO0FBRXRCLFVBQUk7QUFDRixZQUFJLGdCQUFnQixvQkFBSSxJQUFJO0FBQzVCLFlBQUksa0JBQWtCLG9CQUFJLElBQUk7QUFDOUIsWUFBSSxVQUFVO0FBQ2QseUJBQWlCLENBQUM7QUFDbEIsZ0JBQVEsUUFBUSxTQUFVLE1BQU07QUFDOUIsY0FBSSxTQUFTLEtBQUssQ0FBQyxHQUNmLFdBQVcsS0FBSyxDQUFDO0FBR3JCLGNBQUksV0FBVyxPQUFPO0FBQ3RCLGdDQUFzQixJQUFJLFVBQVUsTUFBTTtBQUMxQyxnQ0FBc0IsSUFBSSxVQUFVLE1BQU07QUFDMUMsaUJBQU8sVUFBVTtBQUVqQixjQUFJLHdCQUF3QixVQUFVLFFBQVEsR0FBRztBQUMvQyw0QkFBZ0IsSUFBSSxNQUFNO0FBQUEsVUFDNUIsT0FBTztBQUNMLDBCQUFjLElBQUksTUFBTTtBQUFBLFVBQzFCO0FBQUEsUUFDRixDQUFDO0FBRUQsWUFBSSxTQUFTO0FBQUEsVUFDWDtBQUFBO0FBQUEsVUFFQTtBQUFBO0FBQUEsUUFFRjtBQUNBLDRCQUFvQixRQUFRLFNBQVUsU0FBUztBQUc3QyxrQkFBUSxrQkFBa0IsYUFBYTtBQUFBLFFBQ3pDLENBQUM7QUFDRCxZQUFJLFdBQVc7QUFDZixZQUFJLGFBQWE7QUFLakIsWUFBSSxzQkFBc0IsU0FBUyxXQUFXO0FBQzlDLFlBQUksdUJBQXVCLFNBQVMsWUFBWTtBQUNoRCxZQUFJLHdCQUF3QixTQUFTLGFBQWE7QUFDbEQsNEJBQW9CLFFBQVEsU0FBVSxNQUFNO0FBQzFDLGNBQUksVUFBVSxzQkFBc0IsSUFBSSxJQUFJO0FBRTVDLGNBQUksWUFBWSxRQUFXO0FBQ3pCLGtCQUFNLElBQUksTUFBTSxvRUFBb0U7QUFBQSxVQUN0RjtBQUVBLGNBQUksQ0FBQyxZQUFZLElBQUksSUFBSSxHQUFHO0FBQUEsVUFDNUI7QUFFQSxjQUFJLGlCQUFpQixNQUFNO0FBQ3pCO0FBQUEsVUFDRjtBQUVBLGNBQUksQ0FBQyxhQUFhLElBQUksSUFBSSxHQUFHO0FBQzNCO0FBQUEsVUFDRjtBQUVBLGNBQUksVUFBVSxhQUFhLElBQUksSUFBSTtBQUVuQyxjQUFJO0FBQ0Ysb0JBQVEsYUFBYSxNQUFNLE9BQU87QUFBQSxVQUNwQyxTQUFTLEtBQUs7QUFDWixnQkFBSSxDQUFDLFVBQVU7QUFDYix5QkFBVztBQUNYLDJCQUFhO0FBQUEsWUFDZjtBQUFBLFVBRUY7QUFBQSxRQUNGLENBQUM7QUFDRCw2QkFBcUIsUUFBUSxTQUFVLE1BQU07QUFDM0MsY0FBSSxVQUFVLHNCQUFzQixJQUFJLElBQUk7QUFFNUMsY0FBSSxZQUFZLFFBQVc7QUFDekIsa0JBQU0sSUFBSSxNQUFNLG9FQUFvRTtBQUFBLFVBQ3RGO0FBRUEsY0FBSSxDQUFDLGFBQWEsSUFBSSxJQUFJLEdBQUc7QUFBQSxVQUM3QjtBQUVBLGNBQUk7QUFDRixvQkFBUSxnQkFBZ0IsTUFBTSxNQUFNO0FBQUEsVUFDdEMsU0FBUyxLQUFLO0FBQ1osZ0JBQUksQ0FBQyxVQUFVO0FBQ2IseUJBQVc7QUFDWCwyQkFBYTtBQUFBLFlBQ2Y7QUFBQSxVQUVGO0FBQUEsUUFDRixDQUFDO0FBRUQsWUFBSSxVQUFVO0FBQ1osZ0JBQU07QUFBQSxRQUNSO0FBRUEsZUFBTztBQUFBLE1BQ1QsVUFBRTtBQUNBLDhCQUFzQjtBQUFBLE1BQ3hCO0FBQUEsSUFDRjtBQUNBLGFBQVMsU0FBUyxNQUFNLElBQUk7QUFDMUI7QUFDRSxZQUFJLFNBQVMsTUFBTTtBQUNqQjtBQUFBLFFBQ0Y7QUFFQSxZQUFJLE9BQU8sU0FBUyxjQUFjLE9BQU8sU0FBUyxVQUFVO0FBQzFEO0FBQUEsUUFDRjtBQUtBLFlBQUksa0JBQWtCLElBQUksSUFBSSxHQUFHO0FBQy9CO0FBQUEsUUFDRjtBQUtBLFlBQUksU0FBUyxnQkFBZ0IsSUFBSSxFQUFFO0FBRW5DLFlBQUksV0FBVyxRQUFXO0FBQ3hCLG1CQUFTO0FBQUEsWUFDUCxTQUFTO0FBQUEsVUFDWDtBQUNBLDBCQUFnQixJQUFJLElBQUksTUFBTTtBQUFBLFFBQ2hDLE9BQU87QUFDTCx5QkFBZSxLQUFLLENBQUMsUUFBUSxJQUFJLENBQUM7QUFBQSxRQUNwQztBQUVBLDBCQUFrQixJQUFJLE1BQU0sTUFBTTtBQUVsQyxZQUFJLE9BQU8sU0FBUyxZQUFZLFNBQVMsTUFBTTtBQUM3QyxrQkFBUSxZQUFZLE1BQU0sVUFBVSxHQUFHO0FBQUEsWUFDckMsS0FBSztBQUNILHVCQUFTLEtBQUssUUFBUSxLQUFLLFNBQVM7QUFDcEM7QUFBQSxZQUVGLEtBQUs7QUFDSCx1QkFBUyxLQUFLLE1BQU0sS0FBSyxPQUFPO0FBQ2hDO0FBQUEsVUFDSjtBQUFBLFFBQ0Y7QUFBQSxNQUNGO0FBQUEsSUFDRjtBQUNBLGFBQVMsYUFBYSxNQUFNLEtBQUs7QUFDL0IsVUFBSSxhQUFhLFVBQVUsU0FBUyxLQUFLLFVBQVUsQ0FBQyxNQUFNLFNBQVksVUFBVSxDQUFDLElBQUk7QUFDckYsVUFBSSxpQkFBaUIsVUFBVSxTQUFTLElBQUksVUFBVSxDQUFDLElBQUk7QUFFM0Q7QUFDRSxZQUFJLENBQUMsb0JBQW9CLElBQUksSUFBSSxHQUFHO0FBQ2xDLDhCQUFvQixJQUFJLE1BQU07QUFBQSxZQUM1QjtBQUFBLFlBQ0EsUUFBUTtBQUFBLFlBQ1IsU0FBUztBQUFBLFlBQ1QsZ0JBQWdCLGtCQUFrQixXQUFZO0FBQzVDLHFCQUFPLENBQUM7QUFBQSxZQUNWO0FBQUEsVUFDRixDQUFDO0FBQUEsUUFDSDtBQUdBLFlBQUksT0FBTyxTQUFTLFlBQVksU0FBUyxNQUFNO0FBQzdDLGtCQUFRLFlBQVksTUFBTSxVQUFVLEdBQUc7QUFBQSxZQUNyQyxLQUFLO0FBQ0gsMkJBQWEsS0FBSyxRQUFRLEtBQUssWUFBWSxjQUFjO0FBQ3pEO0FBQUEsWUFFRixLQUFLO0FBQ0gsMkJBQWEsS0FBSyxNQUFNLEtBQUssWUFBWSxjQUFjO0FBQ3ZEO0FBQUEsVUFDSjtBQUFBLFFBQ0Y7QUFBQSxNQUNGO0FBQUEsSUFDRjtBQUdBLGFBQVMsK0JBQStCLE1BQU07QUFDNUM7QUFDRSxZQUFJLFlBQVksb0JBQW9CLElBQUksSUFBSTtBQUU1QyxZQUFJLGNBQWMsUUFBVztBQUMzQix5QkFBZSxTQUFTO0FBQUEsUUFDMUI7QUFBQSxNQUNGO0FBQUEsSUFDRjtBQUNBLGFBQVMsY0FBYyxJQUFJO0FBQ3pCO0FBQ0UsZUFBTyxnQkFBZ0IsSUFBSSxFQUFFO0FBQUEsTUFDL0I7QUFBQSxJQUNGO0FBQ0EsYUFBUyxnQkFBZ0IsTUFBTTtBQUM3QjtBQUNFLGVBQU8sa0JBQWtCLElBQUksSUFBSTtBQUFBLE1BQ25DO0FBQUEsSUFDRjtBQUNBLGFBQVMsMEJBQTBCLFVBQVU7QUFDM0M7QUFDRSxZQUFJLG9CQUFvQixvQkFBSSxJQUFJO0FBQ2hDLHFCQUFhLFFBQVEsU0FBVSxNQUFNO0FBQ25DLGNBQUksVUFBVSxjQUFjLElBQUksSUFBSTtBQUVwQyxjQUFJLFlBQVksUUFBVztBQUN6QixrQkFBTSxJQUFJLE1BQU0sb0VBQW9FO0FBQUEsVUFDdEY7QUFFQSxjQUFJLG1CQUFtQixRQUFRLDRCQUE0QixNQUFNLFFBQVE7QUFDekUsMkJBQWlCLFFBQVEsU0FBVSxNQUFNO0FBQ3ZDLDhCQUFrQixJQUFJLElBQUk7QUFBQSxVQUM1QixDQUFDO0FBQUEsUUFDSCxDQUFDO0FBQ0QsZUFBTztBQUFBLE1BQ1Q7QUFBQSxJQUNGO0FBQ0EsYUFBUyxxQkFBcUIsY0FBYztBQUMxQztBQUtFLFlBQUksT0FBTyxhQUFhO0FBRXhCLFlBQUksU0FBUyxRQUFXO0FBSXRCLGNBQUksU0FBUztBQUNiLHVCQUFhLGlDQUFpQyxPQUFPO0FBQUEsWUFDbkQsV0FBVyxvQkFBSSxJQUFJO0FBQUEsWUFDbkIsZUFBZTtBQUFBLFlBQ2YsUUFBUSxTQUFVLFVBQVU7QUFDMUIscUJBQU87QUFBQSxZQUNUO0FBQUEsWUFDQSxxQkFBcUIsU0FBVSxJQUFJLE1BQU0sVUFBVTtBQUFBLFlBQUM7QUFBQSxZQUNwRCxtQkFBbUIsU0FBVSxJQUFJLE1BQU0sb0JBQW9CLFVBQVU7QUFBQSxZQUFDO0FBQUEsWUFDdEUsc0JBQXNCLFdBQVk7QUFBQSxZQUFDO0FBQUEsVUFDckM7QUFBQSxRQUNGO0FBRUEsWUFBSSxLQUFLLFlBQVk7QUFJbkIsa0JBQVEsTUFBTSxFQUFFLDRKQUFpSztBQUNqTDtBQUFBLFFBQ0Y7QUFHQSxZQUFJLFlBQVksS0FBSztBQUVyQixhQUFLLFNBQVMsU0FBVSxVQUFVO0FBQ2hDLGNBQUksS0FBSyxVQUFVLE1BQU0sTUFBTSxTQUFTO0FBRXhDLGNBQUksT0FBTyxTQUFTLG9CQUFvQixjQUFjLE9BQU8sU0FBUyxzQkFBc0IsWUFBWTtBQUV0RyxnQ0FBb0IsSUFBSSxJQUFJLFFBQVE7QUFBQSxVQUN0QztBQUVBLGlCQUFPO0FBQUEsUUFDVDtBQUtBLGFBQUssVUFBVSxRQUFRLFNBQVUsVUFBVSxJQUFJO0FBQzdDLGNBQUksT0FBTyxTQUFTLG9CQUFvQixjQUFjLE9BQU8sU0FBUyxzQkFBc0IsWUFBWTtBQUV0RyxnQ0FBb0IsSUFBSSxJQUFJLFFBQVE7QUFBQSxVQUN0QztBQUFBLFFBQ0YsQ0FBQztBQUVELFlBQUksdUJBQXVCLEtBQUs7QUFFaEMsWUFBSSx5QkFBeUIsS0FBSyx1QkFBdUIsV0FBWTtBQUFBLFFBQUM7QUFFdEUsYUFBSyxzQkFBc0IsU0FBVSxJQUFJLE1BQU0sVUFBVTtBQUN2RCxjQUFJLENBQUMscUJBQXFCO0FBR3hCLHdCQUFZLE9BQU8sSUFBSTtBQUV2QixnQkFBSSxpQkFBaUIsTUFBTTtBQUN6QiwyQkFBYSxJQUFJLE1BQU0sUUFBUTtBQUFBLFlBQ2pDO0FBQUEsVUFDRjtBQUVBLGlCQUFPLHVCQUF1QixNQUFNLE1BQU0sU0FBUztBQUFBLFFBQ3JEO0FBRUEsYUFBSyxvQkFBb0IsU0FBVSxJQUFJLE1BQU0sb0JBQW9CLFVBQVU7QUFDekUsY0FBSSxVQUFVLG9CQUFvQixJQUFJLEVBQUU7QUFFeEMsY0FBSSxZQUFZLFFBQVc7QUFDekIsMEJBQWMsSUFBSSxNQUFNLE9BQU87QUFDL0IsZ0JBQUksVUFBVSxLQUFLO0FBQ25CLGdCQUFJLFlBQVksUUFBUTtBQUl4QixnQkFBSSxjQUFjLE1BQU07QUFDdEIsa0JBQUksYUFBYSxVQUFVLGlCQUFpQixRQUFRLFVBQVUsY0FBYyxXQUFXLFFBQVEsYUFBYSxJQUFJLElBQUk7QUFDcEgsa0JBQUksWUFBWSxRQUFRLGlCQUFpQixRQUFRLFFBQVEsY0FBYyxXQUFXO0FBRWxGLGtCQUFJLENBQUMsY0FBYyxXQUFXO0FBRTVCLDZCQUFhLElBQUksSUFBSTtBQUNyQiw0QkFBWSxPQUFPLElBQUk7QUFBQSxjQUN6QixXQUFXLGNBQWM7QUFBVztBQUFBLHVCQUFXLGNBQWMsQ0FBQyxXQUFXO0FBRXZFLDZCQUFhLE9BQU8sSUFBSTtBQUV4QixvQkFBSSxVQUFVO0FBRVosOEJBQVksSUFBSSxJQUFJO0FBQUEsZ0JBQ3RCLE9BQU87QUFDTCxnQ0FBYyxPQUFPLElBQUk7QUFBQSxnQkFDM0I7QUFBQSxjQUNGLFdBQVcsQ0FBQyxjQUFjLENBQUMsV0FBVztBQUNwQyxvQkFBSSxVQUFVO0FBRVosOEJBQVksSUFBSSxJQUFJO0FBQUEsZ0JBQ3RCO0FBQUEsY0FDRjtBQUFBLFlBQ0YsT0FBTztBQUVMLDJCQUFhLElBQUksSUFBSTtBQUFBLFlBQ3ZCO0FBQUEsVUFDRjtBQUdBLGlCQUFPLHFCQUFxQixNQUFNLE1BQU0sU0FBUztBQUFBLFFBQ25EO0FBQUEsTUFDRjtBQUFBLElBQ0Y7QUFDQSxhQUFTLHlCQUF5QjtBQUVoQyxhQUFPO0FBQUEsSUFDVDtBQUVBLGFBQVMsdUJBQXVCO0FBQzlCO0FBQ0UsZUFBTyxhQUFhO0FBQUEsTUFDdEI7QUFBQSxJQUNGO0FBdUJBLGFBQVMsc0NBQXNDO0FBQzdDO0FBQ0UsWUFBSTtBQUNKLFlBQUk7QUFDSixZQUFJLGtCQUFrQjtBQUN0QixlQUFPLFNBQVUsTUFBTSxLQUFLLFlBQVksZ0JBQWdCO0FBQ3RELGNBQUksT0FBTyxRQUFRLFVBQVU7QUFJM0IsZ0JBQUksQ0FBQyxXQUFXO0FBRWQsMEJBQVk7QUFDWiwrQkFBaUIsT0FBTyxtQkFBbUI7QUFBQSxZQUM3QztBQUtBLGdCQUFJLFFBQVEsU0FBUyxPQUFPLFNBQVMsY0FBYyxPQUFPLFNBQVMsV0FBVztBQUM1RSwyQkFBYSxNQUFNLEtBQUssWUFBWSxjQUFjO0FBQUEsWUFDcEQ7QUFFQSxtQkFBTztBQUFBLFVBQ1QsT0FBTztBQUlMLGdCQUFJLENBQUMsbUJBQW1CLGdCQUFnQjtBQUN0QyxnQ0FBa0I7QUFDbEIsNkNBQStCLFNBQVM7QUFBQSxZQUMxQztBQUFBLFVBQ0Y7QUFBQSxRQUNGO0FBQUEsTUFDRjtBQUFBLElBQ0Y7QUFDQSxhQUFTLHNCQUFzQixNQUFNO0FBQ25DO0FBQ0UsZ0JBQVEsT0FBTyxNQUFNO0FBQUEsVUFDbkIsS0FBSyxZQUNIO0FBRUUsZ0JBQUksS0FBSyxhQUFhLE1BQU07QUFDMUIsa0JBQUksS0FBSyxVQUFVLGtCQUFrQjtBQUVuQyx1QkFBTztBQUFBLGNBQ1Q7QUFFQSxrQkFBSSxXQUFXLE9BQU8sb0JBQW9CLEtBQUssU0FBUztBQUV4RCxrQkFBSSxTQUFTLFNBQVMsS0FBSyxTQUFTLENBQUMsTUFBTSxlQUFlO0FBRXhELHVCQUFPO0FBQUEsY0FDVDtBQUdBLGtCQUFJLEtBQUssVUFBVSxjQUFjLE9BQU8sV0FBVztBQUVqRCx1QkFBTztBQUFBLGNBQ1Q7QUFBQSxZQUdGO0FBR0EsZ0JBQUksT0FBTyxLQUFLLFFBQVEsS0FBSztBQUM3QixtQkFBTyxPQUFPLFNBQVMsWUFBWSxTQUFTLEtBQUssSUFBSTtBQUFBLFVBQ3ZEO0FBQUEsVUFFRixLQUFLLFVBQ0g7QUFDRSxnQkFBSSxRQUFRLE1BQU07QUFDaEIsc0JBQVEsWUFBWSxNQUFNLFVBQVUsR0FBRztBQUFBLGdCQUNyQyxLQUFLO0FBQUEsZ0JBQ0wsS0FBSztBQUVILHlCQUFPO0FBQUEsZ0JBRVQ7QUFDRSx5QkFBTztBQUFBLGNBQ1g7QUFBQSxZQUNGO0FBRUEsbUJBQU87QUFBQSxVQUNUO0FBQUEsVUFFRixTQUNFO0FBQ0UsbUJBQU87QUFBQSxVQUNUO0FBQUEsUUFDSjtBQUFBLE1BQ0Y7QUFBQSxJQUNGO0FBRUEsWUFBUSx1QkFBdUI7QUFDL0IsWUFBUSxpQ0FBaUM7QUFDekMsWUFBUSxzQ0FBc0M7QUFDOUMsWUFBUSw0QkFBNEI7QUFDcEMsWUFBUSxnQkFBZ0I7QUFDeEIsWUFBUSxrQkFBa0I7QUFDMUIsWUFBUSx5QkFBeUI7QUFDakMsWUFBUSx1QkFBdUI7QUFDL0IsWUFBUSx3QkFBd0I7QUFDaEMsWUFBUSxzQkFBc0I7QUFDOUIsWUFBUSxXQUFXO0FBQ25CLFlBQVEsZUFBZTtBQUFBLEVBQ3JCLEdBQUc7QUFDTDtBQUVBLFNBQVMsU0FBUyxJQUFJLE9BQU87QUFDM0IsTUFBSTtBQUNKLFNBQU8sTUFBTTtBQUNYLGlCQUFhLE1BQU07QUFDbkIsYUFBUyxXQUFXLElBQUksS0FBSztBQUFBLEVBQy9CO0FBQ0Y7QUFHQSxNQUFNLGdCQUFnQixTQUFTLFFBQVEscUJBQXFCLEVBQUU7QUFJOUQsU0FBUywrQkFBK0IsVUFBVSxlQUFlO0FBQy9ELGFBQVcsT0FBTyxlQUFlO0FBQy9CLFFBQUksUUFBUTtBQUFjO0FBQzFCLFVBQU0sY0FBYyxjQUFjLEdBQUc7QUFDckMsUUFBSSxRQUFRLHNCQUFzQixXQUFXLEdBQUc7QUFLOUMsY0FBUSxTQUFTLGFBQWEsV0FBVyxhQUFhLEdBQUc7QUFBQSxJQUMzRDtBQUFBLEVBQ0Y7QUFDRjtBQUVBLFNBQVMsd0NBQXdDLGFBQWEsYUFBYTtBQUN6RSxNQUFJLENBQUMsa0JBQWtCLGFBQWEsQ0FBQyxRQUFRLE9BQU8sV0FBVyxHQUFHO0FBQ2hFLFdBQU87QUFBQSxFQUNUO0FBQ0EsTUFBSSxDQUFDLGtCQUFrQixhQUFhLENBQUMsUUFBUSxPQUFPLFdBQVcsR0FBRztBQUNoRSxXQUFPO0FBQUEsRUFDVDtBQUVBLE1BQUksYUFBYTtBQUNqQixRQUFNLHFDQUFxQztBQUFBLElBQ3pDO0FBQUEsSUFDQSxDQUFDLEtBQUssVUFBVTtBQUNkLG1CQUFhO0FBQ2IsVUFBSSxRQUFRLHNCQUFzQixLQUFLO0FBQUcsZUFBTztBQUNqRCxhQUFPLFlBQVksR0FBRyxNQUFNLFlBQVksR0FBRztBQUFBLElBQzdDO0FBQUEsRUFDRjtBQUNBLE1BQUksY0FBYyxvQ0FBb0M7QUFDcEQsa0JBQWM7QUFBQSxFQUNoQixPQUFPO0FBQ0wsV0FBTztBQUFBLEVBQ1Q7QUFDRjtBQUVBLFNBQVMsa0JBQWtCLGVBQWUsV0FBVztBQUNuRCxhQUFXLE9BQU8sZUFBZTtBQUMvQixRQUFJLFFBQVE7QUFBYztBQUMxQixVQUFNLE9BQU8sT0FBTyx5QkFBeUIsZUFBZSxHQUFHO0FBQy9ELFFBQUksUUFBUSxLQUFLO0FBQUssYUFBTztBQUM3QixRQUFJLENBQUMsVUFBVSxLQUFLLGNBQWMsR0FBRyxDQUFDO0FBQUcsYUFBTztBQUFBLEVBQ2xEO0FBQ0EsU0FBTztBQUNUO0FBSUEsU0FBUyxhQUFhLFFBQVE7QUFDNUIsU0FBTztBQUFBO0FBQUEsSUFBMEI7QUFBQTtBQUNuQztBQUVBLFFBQVEsZUFBZTtBQUN2QixRQUFRLGlDQUFpQztBQUN6QyxRQUFRLDBDQUNOO0FBRUYsZUFBZTsiLCJuYW1lcyI6W119",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 62577,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 366,
            "endOffset": 15570,
            "count": 1
          },
          {
            "startOffset": 581,
            "endOffset": 586,
            "count": 0
          },
          {
            "startOffset": 1149,
            "endOffset": 1155,
            "count": 0
          }
        ]
      },
      {
        "functionName": "computeFullKey",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1204,
            "endOffset": 2211,
            "count": 4
          },
          {
            "startOffset": 1279,
            "endOffset": 1322,
            "count": 1
          },
          {
            "startOffset": 1322,
            "endOffset": 1442,
            "count": 3
          },
          {
            "startOffset": 1442,
            "endOffset": 1561,
            "count": 0
          },
          {
            "startOffset": 1561,
            "endOffset": 2148,
            "count": 3
          },
          {
            "startOffset": 1678,
            "endOffset": 1793,
            "count": 0
          },
          {
            "startOffset": 1903,
            "endOffset": 1934,
            "count": 1
          },
          {
            "startOffset": 1934,
            "endOffset": 2044,
            "count": 2
          },
          {
            "startOffset": 2044,
            "endOffset": 2094,
            "count": 0
          },
          {
            "startOffset": 2094,
            "endOffset": 2148,
            "count": 2
          },
          {
            "startOffset": 2148,
            "endOffset": 2210,
            "count": 3
          }
        ]
      },
      {
        "functionName": "haveEqualSignatures",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2216,
            "endOffset": 2779,
            "count": 0
          }
        ]
      },
      {
        "functionName": "isReactClass",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2784,
            "endOffset": 2883,
            "count": 0
          }
        ]
      },
      {
        "functionName": "canPreserveStateBetween",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2888,
            "endOffset": 3142,
            "count": 0
          }
        ]
      },
      {
        "functionName": "resolveFamily",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 3147,
            "endOffset": 3229,
            "count": 0
          }
        ]
      },
      {
        "functionName": "cloneMap",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 3234,
            "endOffset": 3411,
            "count": 0
          }
        ]
      },
      {
        "functionName": "cloneSet",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 3416,
            "endOffset": 3583,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getProperty",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 3588,
            "endOffset": 3732,
            "count": 0
          }
        ]
      },
      {
        "functionName": "performReactRefresh",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 3737,
            "endOffset": 6548,
            "count": 0
          }
        ]
      },
      {
        "functionName": "register",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 6553,
            "endOffset": 7480,
            "count": 16
          },
          {
            "startOffset": 6618,
            "endOffset": 6647,
            "count": 0
          },
          {
            "startOffset": 6687,
            "endOffset": 6714,
            "count": 0
          },
          {
            "startOffset": 6716,
            "endOffset": 6745,
            "count": 0
          },
          {
            "startOffset": 6787,
            "endOffset": 7008,
            "count": 8
          },
          {
            "startOffset": 7008,
            "endOffset": 7072,
            "count": 0
          },
          {
            "startOffset": 7072,
            "endOffset": 7155,
            "count": 8
          },
          {
            "startOffset": 7155,
            "endOffset": 7171,
            "count": 0
          },
          {
            "startOffset": 7173,
            "endOffset": 7466,
            "count": 0
          }
        ]
      },
      {
        "functionName": "setSignature",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7485,
            "endOffset": 8388,
            "count": 9
          },
          {
            "startOffset": 7591,
            "endOffset": 7605,
            "count": 4
          },
          {
            "startOffset": 7606,
            "endOffset": 7613,
            "count": 5
          },
          {
            "startOffset": 7678,
            "endOffset": 7686,
            "count": 0
          },
          {
            "startOffset": 7903,
            "endOffset": 7957,
            "count": 5
          },
          {
            "startOffset": 8019,
            "endOffset": 8035,
            "count": 0
          },
          {
            "startOffset": 8037,
            "endOffset": 8374,
            "count": 0
          }
        ]
      },
      {
        "functionName": "allSignaturesByType.set.getCustomHooks",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7906,
            "endOffset": 7957,
            "count": 1
          }
        ]
      },
      {
        "functionName": "collectCustomHooksForSignature",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 8393,
            "endOffset": 8600,
            "count": 2
          }
        ]
      },
      {
        "functionName": "getFamilyByID",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 8605,
            "endOffset": 8695,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getFamilyByType",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 8700,
            "endOffset": 8798,
            "count": 0
          }
        ]
      },
      {
        "functionName": "findAffectedHostInstances",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 8803,
            "endOffset": 9411,
            "count": 0
          }
        ]
      },
      {
        "functionName": "injectIntoGlobalHook",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 9416,
            "endOffset": 12764,
            "count": 1
          },
          {
            "startOffset": 10115,
            "endOffset": 10329,
            "count": 0
          },
          {
            "startOffset": 11042,
            "endOffset": 11067,
            "count": 0
          }
        ]
      },
      {
        "functionName": "inject",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 9759,
            "endOffset": 9824,
            "count": 1
          }
        ]
      },
      {
        "functionName": "onScheduleFiberRoot",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 9859,
            "endOffset": 9903,
            "count": 1
          }
        ]
      },
      {
        "functionName": "onCommitFiberRoot",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 9936,
            "endOffset": 10000,
            "count": 2
          }
        ]
      },
      {
        "functionName": "onCommitFiberUnmount",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10036,
            "endOffset": 10062,
            "count": 0
          }
        ]
      },
      {
        "functionName": "hook.inject",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10389,
            "endOffset": 10672,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10705,
            "endOffset": 10918,
            "count": 0
          }
        ]
      },
      {
        "functionName": "oldOnScheduleFiberRoot",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11045,
            "endOffset": 11067,
            "count": 0
          }
        ]
      },
      {
        "functionName": "hook.onScheduleFiberRoot",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 11104,
            "endOffset": 11399,
            "count": 1
          }
        ]
      },
      {
        "functionName": "hook.onCommitFiberRoot",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 11434,
            "endOffset": 12749,
            "count": 2
          },
          {
            "startOffset": 11851,
            "endOffset": 11876,
            "count": 1
          },
          {
            "startOffset": 12010,
            "endOffset": 12022,
            "count": 1
          },
          {
            "startOffset": 12024,
            "endOffset": 12592,
            "count": 1
          },
          {
            "startOffset": 12175,
            "endOffset": 12592,
            "count": 0
          },
          {
            "startOffset": 12606,
            "endOffset": 12665,
            "count": 0
          }
        ]
      },
      {
        "functionName": "hasUnrecoverableErrors",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12769,
            "endOffset": 12830,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_getMountedRootCount",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12835,
            "endOffset": 12924,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createSignatureFunctionForTransform",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 12929,
            "endOffset": 13741,
            "count": 9
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13089,
            "endOffset": 13726,
            "count": 27
          },
          {
            "startOffset": 13178,
            "endOffset": 13534,
            "count": 9
          },
          {
            "startOffset": 13385,
            "endOffset": 13412,
            "count": 0
          },
          {
            "startOffset": 13534,
            "endOffset": 13716,
            "count": 18
          },
          {
            "startOffset": 13575,
            "endOffset": 13592,
            "count": 16
          },
          {
            "startOffset": 13594,
            "endOffset": 13704,
            "count": 2
          }
        ]
      },
      {
        "functionName": "isLikelyComponentType",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13746,
            "endOffset": 14882,
            "count": 9
          },
          {
            "startOffset": 13893,
            "endOffset": 14312,
            "count": 1
          },
          {
            "startOffset": 13946,
            "endOffset": 13992,
            "count": 0
          },
          {
            "startOffset": 14138,
            "endOffset": 14185,
            "count": 0
          },
          {
            "startOffset": 14251,
            "endOffset": 14298,
            "count": 0
          },
          {
            "startOffset": 14346,
            "endOffset": 14365,
            "count": 0
          },
          {
            "startOffset": 14457,
            "endOffset": 14799,
            "count": 0
          },
          {
            "startOffset": 14810,
            "endOffset": 14858,
            "count": 0
          }
        ]
      },
      {
        "functionName": "debounce",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15577,
            "endOffset": 15707,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15631,
            "endOffset": 15704,
            "count": 0
          }
        ]
      },
      {
        "functionName": "registerExportsForReactRefresh",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15773,
            "endOffset": 16098,
            "count": 8
          },
          {
            "startOffset": 15875,
            "endOffset": 16096,
            "count": 9
          },
          {
            "startOffset": 15913,
            "endOffset": 15922,
            "count": 0
          },
          {
            "startOffset": 16019,
            "endOffset": 16092,
            "count": 8
          }
        ]
      },
      {
        "functionName": "validateRefreshBoundaryAndEnqueueUpdate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 16099,
            "endOffset": 16967,
            "count": 0
          }
        ]
      },
      {
        "functionName": "predicateOnExport",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 16968,
            "endOffset": 17307,
            "count": 0
          }
        ]
      },
      {
        "functionName": "__hmr_import",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 17308,
            "endOffset": 17428,
            "count": 8
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5173/@vite/client",
    "scriptId": "14",
    "source": "import \"/@fs/home/will/local_dev/portfolio/node_modules/.pnpm/vite@5.2.8_@types+node@20.11.30_sass@1.72.0/node_modules/vite/dist/client/env.mjs\";\n\nclass HMRContext {\n    constructor(hmrClient, ownerPath) {\n        this.hmrClient = hmrClient;\n        this.ownerPath = ownerPath;\n        if (!hmrClient.dataMap.has(ownerPath)) {\n            hmrClient.dataMap.set(ownerPath, {});\n        }\n        // when a file is hot updated, a new context is created\n        // clear its stale callbacks\n        const mod = hmrClient.hotModulesMap.get(ownerPath);\n        if (mod) {\n            mod.callbacks = [];\n        }\n        // clear stale custom event listeners\n        const staleListeners = hmrClient.ctxToListenersMap.get(ownerPath);\n        if (staleListeners) {\n            for (const [event, staleFns] of staleListeners) {\n                const listeners = hmrClient.customListenersMap.get(event);\n                if (listeners) {\n                    hmrClient.customListenersMap.set(event, listeners.filter((l) => !staleFns.includes(l)));\n                }\n            }\n        }\n        this.newListeners = new Map();\n        hmrClient.ctxToListenersMap.set(ownerPath, this.newListeners);\n    }\n    get data() {\n        return this.hmrClient.dataMap.get(this.ownerPath);\n    }\n    accept(deps, callback) {\n        if (typeof deps === 'function' || !deps) {\n            // self-accept: hot.accept(() => {})\n            this.acceptDeps([this.ownerPath], ([mod]) => deps === null || deps === void 0 ? void 0 : deps(mod));\n        }\n        else if (typeof deps === 'string') {\n            // explicit deps\n            this.acceptDeps([deps], ([mod]) => callback === null || callback === void 0 ? void 0 : callback(mod));\n        }\n        else if (Array.isArray(deps)) {\n            this.acceptDeps(deps, callback);\n        }\n        else {\n            throw new Error(`invalid hot.accept() usage.`);\n        }\n    }\n    // export names (first arg) are irrelevant on the client side, they're\n    // extracted in the server for propagation\n    acceptExports(_, callback) {\n        this.acceptDeps([this.ownerPath], ([mod]) => callback === null || callback === void 0 ? void 0 : callback(mod));\n    }\n    dispose(cb) {\n        this.hmrClient.disposeMap.set(this.ownerPath, cb);\n    }\n    prune(cb) {\n        this.hmrClient.pruneMap.set(this.ownerPath, cb);\n    }\n    // Kept for backward compatibility (#11036)\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    decline() { }\n    invalidate(message) {\n        this.hmrClient.notifyListeners('vite:invalidate', {\n            path: this.ownerPath,\n            message,\n        });\n        this.send('vite:invalidate', { path: this.ownerPath, message });\n        this.hmrClient.logger.debug(`[vite] invalidate ${this.ownerPath}${message ? `: ${message}` : ''}`);\n    }\n    on(event, cb) {\n        const addToMap = (map) => {\n            const existing = map.get(event) || [];\n            existing.push(cb);\n            map.set(event, existing);\n        };\n        addToMap(this.hmrClient.customListenersMap);\n        addToMap(this.newListeners);\n    }\n    off(event, cb) {\n        const removeFromMap = (map) => {\n            const existing = map.get(event);\n            if (existing === undefined) {\n                return;\n            }\n            const pruned = existing.filter((l) => l !== cb);\n            if (pruned.length === 0) {\n                map.delete(event);\n                return;\n            }\n            map.set(event, pruned);\n        };\n        removeFromMap(this.hmrClient.customListenersMap);\n        removeFromMap(this.newListeners);\n    }\n    send(event, data) {\n        this.hmrClient.messenger.send(JSON.stringify({ type: 'custom', event, data }));\n    }\n    acceptDeps(deps, callback = () => { }) {\n        const mod = this.hmrClient.hotModulesMap.get(this.ownerPath) || {\n            id: this.ownerPath,\n            callbacks: [],\n        };\n        mod.callbacks.push({\n            deps,\n            fn: callback,\n        });\n        this.hmrClient.hotModulesMap.set(this.ownerPath, mod);\n    }\n}\nclass HMRMessenger {\n    constructor(connection) {\n        this.connection = connection;\n        this.queue = [];\n    }\n    send(message) {\n        this.queue.push(message);\n        this.flush();\n    }\n    flush() {\n        if (this.connection.isReady()) {\n            this.queue.forEach((msg) => this.connection.send(msg));\n            this.queue = [];\n        }\n    }\n}\nclass HMRClient {\n    constructor(logger, connection, \n    // This allows implementing reloading via different methods depending on the environment\n    importUpdatedModule) {\n        this.logger = logger;\n        this.importUpdatedModule = importUpdatedModule;\n        this.hotModulesMap = new Map();\n        this.disposeMap = new Map();\n        this.pruneMap = new Map();\n        this.dataMap = new Map();\n        this.customListenersMap = new Map();\n        this.ctxToListenersMap = new Map();\n        this.updateQueue = [];\n        this.pendingUpdateQueue = false;\n        this.messenger = new HMRMessenger(connection);\n    }\n    async notifyListeners(event, data) {\n        const cbs = this.customListenersMap.get(event);\n        if (cbs) {\n            await Promise.allSettled(cbs.map((cb) => cb(data)));\n        }\n    }\n    clear() {\n        this.hotModulesMap.clear();\n        this.disposeMap.clear();\n        this.pruneMap.clear();\n        this.dataMap.clear();\n        this.customListenersMap.clear();\n        this.ctxToListenersMap.clear();\n    }\n    // After an HMR update, some modules are no longer imported on the page\n    // but they may have left behind side effects that need to be cleaned up\n    // (.e.g style injections)\n    async prunePaths(paths) {\n        await Promise.all(paths.map((path) => {\n            const disposer = this.disposeMap.get(path);\n            if (disposer)\n                return disposer(this.dataMap.get(path));\n        }));\n        paths.forEach((path) => {\n            const fn = this.pruneMap.get(path);\n            if (fn) {\n                fn(this.dataMap.get(path));\n            }\n        });\n    }\n    warnFailedUpdate(err, path) {\n        if (!err.message.includes('fetch')) {\n            this.logger.error(err);\n        }\n        this.logger.error(`[hmr] Failed to reload ${path}. ` +\n            `This could be due to syntax errors or importing non-existent ` +\n            `modules. (see errors above)`);\n    }\n    /**\n     * buffer multiple hot updates triggered by the same src change\n     * so that they are invoked in the same order they were sent.\n     * (otherwise the order may be inconsistent because of the http request round trip)\n     */\n    async queueUpdate(payload) {\n        this.updateQueue.push(this.fetchUpdate(payload));\n        if (!this.pendingUpdateQueue) {\n            this.pendingUpdateQueue = true;\n            await Promise.resolve();\n            this.pendingUpdateQueue = false;\n            const loading = [...this.updateQueue];\n            this.updateQueue = [];\n            (await Promise.all(loading)).forEach((fn) => fn && fn());\n        }\n    }\n    async fetchUpdate(update) {\n        const { path, acceptedPath } = update;\n        const mod = this.hotModulesMap.get(path);\n        if (!mod) {\n            // In a code-splitting project,\n            // it is common that the hot-updating module is not loaded yet.\n            // https://github.com/vitejs/vite/issues/721\n            return;\n        }\n        let fetchedModule;\n        const isSelfUpdate = path === acceptedPath;\n        // determine the qualified callbacks before we re-import the modules\n        const qualifiedCallbacks = mod.callbacks.filter(({ deps }) => deps.includes(acceptedPath));\n        if (isSelfUpdate || qualifiedCallbacks.length > 0) {\n            const disposer = this.disposeMap.get(acceptedPath);\n            if (disposer)\n                await disposer(this.dataMap.get(acceptedPath));\n            try {\n                fetchedModule = await this.importUpdatedModule(update);\n            }\n            catch (e) {\n                this.warnFailedUpdate(e, acceptedPath);\n            }\n        }\n        return () => {\n            for (const { deps, fn } of qualifiedCallbacks) {\n                fn(deps.map((dep) => (dep === acceptedPath ? fetchedModule : undefined)));\n            }\n            const loggedPath = isSelfUpdate ? path : `${acceptedPath} via ${path}`;\n            this.logger.debug(`[vite] hot updated: ${loggedPath}`);\n        };\n    }\n}\n\nconst hmrConfigName = \"vite.config.ts\";\nconst base$1 = \"/\" || '/';\n// Create an element with provided attributes and optional children\nfunction h(e, attrs = {}, ...children) {\n    const elem = document.createElement(e);\n    for (const [k, v] of Object.entries(attrs)) {\n        elem.setAttribute(k, v);\n    }\n    elem.append(...children);\n    return elem;\n}\n// set :host styles to make playwright detect the element as visible\nconst templateStyle = /*css*/ `\n:host {\n  position: fixed;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  z-index: 99999;\n  --monospace: 'SFMono-Regular', Consolas,\n  'Liberation Mono', Menlo, Courier, monospace;\n  --red: #ff5555;\n  --yellow: #e2aa53;\n  --purple: #cfa4ff;\n  --cyan: #2dd9da;\n  --dim: #c9c9c9;\n\n  --window-background: #181818;\n  --window-color: #d8d8d8;\n}\n\n.backdrop {\n  position: fixed;\n  z-index: 99999;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  overflow-y: scroll;\n  margin: 0;\n  background: rgba(0, 0, 0, 0.66);\n}\n\n.window {\n  font-family: var(--monospace);\n  line-height: 1.5;\n  max-width: 80vw;\n  color: var(--window-color);\n  box-sizing: border-box;\n  margin: 30px auto;\n  padding: 2.5vh 4vw;\n  position: relative;\n  background: var(--window-background);\n  border-radius: 6px 6px 8px 8px;\n  box-shadow: 0 19px 38px rgba(0,0,0,0.30), 0 15px 12px rgba(0,0,0,0.22);\n  overflow: hidden;\n  border-top: 8px solid var(--red);\n  direction: ltr;\n  text-align: left;\n}\n\npre {\n  font-family: var(--monospace);\n  font-size: 16px;\n  margin-top: 0;\n  margin-bottom: 1em;\n  overflow-x: scroll;\n  scrollbar-width: none;\n}\n\npre::-webkit-scrollbar {\n  display: none;\n}\n\npre.frame::-webkit-scrollbar {\n  display: block;\n  height: 5px;\n}\n\npre.frame::-webkit-scrollbar-thumb {\n  background: #999;\n  border-radius: 5px;\n}\n\npre.frame {\n  scrollbar-width: thin;\n}\n\n.message {\n  line-height: 1.3;\n  font-weight: 600;\n  white-space: pre-wrap;\n}\n\n.message-body {\n  color: var(--red);\n}\n\n.plugin {\n  color: var(--purple);\n}\n\n.file {\n  color: var(--cyan);\n  margin-bottom: 0;\n  white-space: pre-wrap;\n  word-break: break-all;\n}\n\n.frame {\n  color: var(--yellow);\n}\n\n.stack {\n  font-size: 13px;\n  color: var(--dim);\n}\n\n.tip {\n  font-size: 13px;\n  color: #999;\n  border-top: 1px dotted #999;\n  padding-top: 13px;\n  line-height: 1.8;\n}\n\ncode {\n  font-size: 13px;\n  font-family: var(--monospace);\n  color: var(--yellow);\n}\n\n.file-link {\n  text-decoration: underline;\n  cursor: pointer;\n}\n\nkbd {\n  line-height: 1.5;\n  font-family: ui-monospace, Menlo, Monaco, Consolas, \"Liberation Mono\", \"Courier New\", monospace;\n  font-size: 0.75rem;\n  font-weight: 700;\n  background-color: rgb(38, 40, 44);\n  color: rgb(166, 167, 171);\n  padding: 0.15rem 0.3rem;\n  border-radius: 0.25rem;\n  border-width: 0.0625rem 0.0625rem 0.1875rem;\n  border-style: solid;\n  border-color: rgb(54, 57, 64);\n  border-image: initial;\n}\n`;\n// Error Template\nlet template;\nconst createTemplate = () => h('div', { class: 'backdrop', part: 'backdrop' }, h('div', { class: 'window', part: 'window' }, h('pre', { class: 'message', part: 'message' }, h('span', { class: 'plugin', part: 'plugin' }), h('span', { class: 'message-body', part: 'message-body' })), h('pre', { class: 'file', part: 'file' }), h('pre', { class: 'frame', part: 'frame' }), h('pre', { class: 'stack', part: 'stack' }), h('div', { class: 'tip', part: 'tip' }, 'Click outside, press ', h('kbd', {}, 'Esc'), ' key, or fix the code to dismiss.', h('br'), 'You can also disable this overlay by setting ', h('code', { part: 'config-option-name' }, 'server.hmr.overlay'), ' to ', h('code', { part: 'config-option-value' }, 'false'), ' in ', h('code', { part: 'config-file-name' }, hmrConfigName), '.')), h('style', {}, templateStyle));\nconst fileRE = /(?:[a-zA-Z]:\\\\|\\/).*?:\\d+:\\d+/g;\nconst codeframeRE = /^(?:>?\\s*\\d+\\s+\\|.*|\\s+\\|\\s*\\^.*)\\r?\\n/gm;\n// Allow `ErrorOverlay` to extend `HTMLElement` even in environments where\n// `HTMLElement` was not originally defined.\nconst { HTMLElement = class {\n} } = globalThis;\nclass ErrorOverlay extends HTMLElement {\n    constructor(err, links = true) {\n        var _a;\n        super();\n        this.root = this.attachShadow({ mode: 'open' });\n        template !== null && template !== void 0 ? template : (template = createTemplate());\n        this.root.appendChild(template);\n        codeframeRE.lastIndex = 0;\n        const hasFrame = err.frame && codeframeRE.test(err.frame);\n        const message = hasFrame\n            ? err.message.replace(codeframeRE, '')\n            : err.message;\n        if (err.plugin) {\n            this.text('.plugin', `[plugin:${err.plugin}] `);\n        }\n        this.text('.message-body', message.trim());\n        const [file] = (((_a = err.loc) === null || _a === void 0 ? void 0 : _a.file) || err.id || 'unknown file').split(`?`);\n        if (err.loc) {\n            this.text('.file', `${file}:${err.loc.line}:${err.loc.column}`, links);\n        }\n        else if (err.id) {\n            this.text('.file', file);\n        }\n        if (hasFrame) {\n            this.text('.frame', err.frame.trim());\n        }\n        this.text('.stack', err.stack, links);\n        this.root.querySelector('.window').addEventListener('click', (e) => {\n            e.stopPropagation();\n        });\n        this.addEventListener('click', () => {\n            this.close();\n        });\n        this.closeOnEsc = (e) => {\n            if (e.key === 'Escape' || e.code === 'Escape') {\n                this.close();\n            }\n        };\n        document.addEventListener('keydown', this.closeOnEsc);\n    }\n    text(selector, text, linkFiles = false) {\n        const el = this.root.querySelector(selector);\n        if (!linkFiles) {\n            el.textContent = text;\n        }\n        else {\n            let curIndex = 0;\n            let match;\n            fileRE.lastIndex = 0;\n            while ((match = fileRE.exec(text))) {\n                const { 0: file, index } = match;\n                if (index != null) {\n                    const frag = text.slice(curIndex, index);\n                    el.appendChild(document.createTextNode(frag));\n                    const link = document.createElement('a');\n                    link.textContent = file;\n                    link.className = 'file-link';\n                    link.onclick = () => {\n                        fetch(new URL(`${base$1}__open-in-editor?file=${encodeURIComponent(file)}`, import.meta.url));\n                    };\n                    el.appendChild(link);\n                    curIndex += frag.length + file.length;\n                }\n            }\n        }\n    }\n    close() {\n        var _a;\n        (_a = this.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(this);\n        document.removeEventListener('keydown', this.closeOnEsc);\n    }\n}\nconst overlayId = 'vite-error-overlay';\nconst { customElements } = globalThis; // Ensure `customElements` is defined before the next line.\nif (customElements && !customElements.get(overlayId)) {\n    customElements.define(overlayId, ErrorOverlay);\n}\n\nvar _a;\nconsole.debug('[vite] connecting...');\nconst importMetaUrl = new URL(import.meta.url);\n// use server configuration, then fallback to inference\nconst serverHost = \"localhost:5173/\";\nconst socketProtocol = null || (importMetaUrl.protocol === 'https:' ? 'wss' : 'ws');\nconst hmrPort = null;\nconst socketHost = `${null || importMetaUrl.hostname}:${hmrPort || importMetaUrl.port}${\"/\"}`;\nconst directSocketHost = \"localhost:5173/\";\nconst base = \"/\" || '/';\nlet socket;\ntry {\n    let fallback;\n    // only use fallback when port is inferred to prevent confusion\n    if (!hmrPort) {\n        fallback = () => {\n            // fallback to connecting directly to the hmr server\n            // for servers which does not support proxying websocket\n            socket = setupWebSocket(socketProtocol, directSocketHost, () => {\n                const currentScriptHostURL = new URL(import.meta.url);\n                const currentScriptHost = currentScriptHostURL.host +\n                    currentScriptHostURL.pathname.replace(/@vite\\/client$/, '');\n                console.error('[vite] failed to connect to websocket.\\n' +\n                    'your current setup:\\n' +\n                    `  (browser) ${currentScriptHost} <--[HTTP]--> ${serverHost} (server)\\n` +\n                    `  (browser) ${socketHost} <--[WebSocket (failing)]--> ${directSocketHost} (server)\\n` +\n                    'Check out your Vite / network configuration and https://vitejs.dev/config/server-options.html#server-hmr .');\n            });\n            socket.addEventListener('open', () => {\n                console.info('[vite] Direct websocket connection fallback. Check out https://vitejs.dev/config/server-options.html#server-hmr to remove the previous connection error.');\n            }, { once: true });\n        };\n    }\n    socket = setupWebSocket(socketProtocol, socketHost, fallback);\n}\ncatch (error) {\n    console.error(`[vite] failed to connect to websocket (${error}). `);\n}\nfunction setupWebSocket(protocol, hostAndPath, onCloseWithoutOpen) {\n    const socket = new WebSocket(`${protocol}://${hostAndPath}`, 'vite-hmr');\n    let isOpened = false;\n    socket.addEventListener('open', () => {\n        isOpened = true;\n        notifyListeners('vite:ws:connect', { webSocket: socket });\n    }, { once: true });\n    // Listen for messages\n    socket.addEventListener('message', async ({ data }) => {\n        handleMessage(JSON.parse(data));\n    });\n    // ping server\n    socket.addEventListener('close', async ({ wasClean }) => {\n        if (wasClean)\n            return;\n        if (!isOpened && onCloseWithoutOpen) {\n            onCloseWithoutOpen();\n            return;\n        }\n        notifyListeners('vite:ws:disconnect', { webSocket: socket });\n        if (hasDocument) {\n            console.log(`[vite] server connection lost. polling for restart...`);\n            await waitForSuccessfulPing(protocol, hostAndPath);\n            location.reload();\n        }\n    });\n    return socket;\n}\nfunction cleanUrl(pathname) {\n    const url = new URL(pathname, 'http://vitejs.dev');\n    url.searchParams.delete('direct');\n    return url.pathname + url.search;\n}\nlet isFirstUpdate = true;\nconst outdatedLinkTags = new WeakSet();\nconst debounceReload = (time) => {\n    let timer;\n    return () => {\n        if (timer) {\n            clearTimeout(timer);\n            timer = null;\n        }\n        timer = setTimeout(() => {\n            location.reload();\n        }, time);\n    };\n};\nconst pageReload = debounceReload(50);\nconst hmrClient = new HMRClient(console, {\n    isReady: () => socket && socket.readyState === 1,\n    send: (message) => socket.send(message),\n}, async function importUpdatedModule({ acceptedPath, timestamp, explicitImportRequired, isWithinCircularImport, }) {\n    const [acceptedPathWithoutQuery, query] = acceptedPath.split(`?`);\n    const importPromise = import(\n    /* @vite-ignore */\n    base +\n        acceptedPathWithoutQuery.slice(1) +\n        `?${explicitImportRequired ? 'import&' : ''}t=${timestamp}${query ? `&${query}` : ''}`);\n    if (isWithinCircularImport) {\n        importPromise.catch(() => {\n            console.info(`[hmr] ${acceptedPath} failed to apply HMR as it's within a circular import. Reloading page to reset the execution order. ` +\n                `To debug and break the circular import, you can run \\`vite --debug hmr\\` to log the circular dependency path if a file change triggered it.`);\n            pageReload();\n        });\n    }\n    return await importPromise;\n});\nasync function handleMessage(payload) {\n    switch (payload.type) {\n        case 'connected':\n            console.debug(`[vite] connected.`);\n            hmrClient.messenger.flush();\n            // proxy(nginx, docker) hmr ws maybe caused timeout,\n            // so send ping package let ws keep alive.\n            setInterval(() => {\n                if (socket.readyState === socket.OPEN) {\n                    socket.send('{\"type\":\"ping\"}');\n                }\n            }, 30000);\n            break;\n        case 'update':\n            notifyListeners('vite:beforeUpdate', payload);\n            if (hasDocument) {\n                // if this is the first update and there's already an error overlay, it\n                // means the page opened with existing server compile error and the whole\n                // module script failed to load (since one of the nested imports is 500).\n                // in this case a normal update won't work and a full reload is needed.\n                if (isFirstUpdate && hasErrorOverlay()) {\n                    window.location.reload();\n                    return;\n                }\n                else {\n                    if (enableOverlay) {\n                        clearErrorOverlay();\n                    }\n                    isFirstUpdate = false;\n                }\n            }\n            await Promise.all(payload.updates.map(async (update) => {\n                if (update.type === 'js-update') {\n                    return hmrClient.queueUpdate(update);\n                }\n                // css-update\n                // this is only sent when a css file referenced with <link> is updated\n                const { path, timestamp } = update;\n                const searchUrl = cleanUrl(path);\n                // can't use querySelector with `[href*=]` here since the link may be\n                // using relative paths so we need to use link.href to grab the full\n                // URL for the include check.\n                const el = Array.from(document.querySelectorAll('link')).find((e) => !outdatedLinkTags.has(e) && cleanUrl(e.href).includes(searchUrl));\n                if (!el) {\n                    return;\n                }\n                const newPath = `${base}${searchUrl.slice(1)}${searchUrl.includes('?') ? '&' : '?'}t=${timestamp}`;\n                // rather than swapping the href on the existing tag, we will\n                // create a new link tag. Once the new stylesheet has loaded we\n                // will remove the existing link tag. This removes a Flash Of\n                // Unstyled Content that can occur when swapping out the tag href\n                // directly, as the new stylesheet has not yet been loaded.\n                return new Promise((resolve) => {\n                    const newLinkTag = el.cloneNode();\n                    newLinkTag.href = new URL(newPath, el.href).href;\n                    const removeOldEl = () => {\n                        el.remove();\n                        console.debug(`[vite] css hot updated: ${searchUrl}`);\n                        resolve();\n                    };\n                    newLinkTag.addEventListener('load', removeOldEl);\n                    newLinkTag.addEventListener('error', removeOldEl);\n                    outdatedLinkTags.add(el);\n                    el.after(newLinkTag);\n                });\n            }));\n            notifyListeners('vite:afterUpdate', payload);\n            break;\n        case 'custom': {\n            notifyListeners(payload.event, payload.data);\n            break;\n        }\n        case 'full-reload':\n            notifyListeners('vite:beforeFullReload', payload);\n            if (hasDocument) {\n                if (payload.path && payload.path.endsWith('.html')) {\n                    // if html file is edited, only reload the page if the browser is\n                    // currently on that page.\n                    const pagePath = decodeURI(location.pathname);\n                    const payloadPath = base + payload.path.slice(1);\n                    if (pagePath === payloadPath ||\n                        payload.path === '/index.html' ||\n                        (pagePath.endsWith('/') && pagePath + 'index.html' === payloadPath)) {\n                        pageReload();\n                    }\n                    return;\n                }\n                else {\n                    pageReload();\n                }\n            }\n            break;\n        case 'prune':\n            notifyListeners('vite:beforePrune', payload);\n            await hmrClient.prunePaths(payload.paths);\n            break;\n        case 'error': {\n            notifyListeners('vite:error', payload);\n            if (hasDocument) {\n                const err = payload.err;\n                if (enableOverlay) {\n                    createErrorOverlay(err);\n                }\n                else {\n                    console.error(`[vite] Internal Server Error\\n${err.message}\\n${err.stack}`);\n                }\n            }\n            break;\n        }\n        default: {\n            const check = payload;\n            return check;\n        }\n    }\n}\nfunction notifyListeners(event, data) {\n    hmrClient.notifyListeners(event, data);\n}\nconst enableOverlay = true;\nconst hasDocument = 'document' in globalThis;\nfunction createErrorOverlay(err) {\n    clearErrorOverlay();\n    document.body.appendChild(new ErrorOverlay(err));\n}\nfunction clearErrorOverlay() {\n    document.querySelectorAll(overlayId).forEach((n) => n.close());\n}\nfunction hasErrorOverlay() {\n    return document.querySelectorAll(overlayId).length;\n}\nasync function waitForSuccessfulPing(socketProtocol, hostAndPath, ms = 1000) {\n    const pingHostProtocol = socketProtocol === 'wss' ? 'https' : 'http';\n    const ping = async () => {\n        // A fetch on a websocket URL will return a successful promise with status 400,\n        // but will reject a networking error.\n        // When running on middleware mode, it returns status 426, and an cors error happens if mode is not no-cors\n        try {\n            await fetch(`${pingHostProtocol}://${hostAndPath}`, {\n                mode: 'no-cors',\n                headers: {\n                    // Custom headers won't be included in a request with no-cors so (ab)use one of the\n                    // safelisted headers to identify the ping request\n                    Accept: 'text/x-vite-ping',\n                },\n            });\n            return true;\n        }\n        catch { }\n        return false;\n    };\n    if (await ping()) {\n        return;\n    }\n    await wait(ms);\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n        if (document.visibilityState === 'visible') {\n            if (await ping()) {\n                break;\n            }\n            await wait(ms);\n        }\n        else {\n            await waitForWindowShow();\n        }\n    }\n}\nfunction wait(ms) {\n    return new Promise((resolve) => setTimeout(resolve, ms));\n}\nfunction waitForWindowShow() {\n    return new Promise((resolve) => {\n        const onChange = async () => {\n            if (document.visibilityState === 'visible') {\n                resolve();\n                document.removeEventListener('visibilitychange', onChange);\n            }\n        };\n        document.addEventListener('visibilitychange', onChange);\n    });\n}\nconst sheetsMap = new Map();\n// collect existing style elements that may have been inserted during SSR\n// to avoid FOUC or duplicate styles\nif ('document' in globalThis) {\n    document\n        .querySelectorAll('style[data-vite-dev-id]')\n        .forEach((el) => {\n        sheetsMap.set(el.getAttribute('data-vite-dev-id'), el);\n    });\n}\nconst cspNonce = 'document' in globalThis\n    ? (_a = document.querySelector('meta[property=csp-nonce]')) === null || _a === void 0 ? void 0 : _a.nonce\n    : undefined;\n// all css imports should be inserted at the same position\n// because after build it will be a single css file\nlet lastInsertedStyle;\nfunction updateStyle(id, content) {\n    let style = sheetsMap.get(id);\n    if (!style) {\n        style = document.createElement('style');\n        style.setAttribute('type', 'text/css');\n        style.setAttribute('data-vite-dev-id', id);\n        style.textContent = content;\n        if (cspNonce) {\n            style.setAttribute('nonce', cspNonce);\n        }\n        if (!lastInsertedStyle) {\n            document.head.appendChild(style);\n            // reset lastInsertedStyle after async\n            // because dynamically imported css will be splitted into a different file\n            setTimeout(() => {\n                lastInsertedStyle = undefined;\n            }, 0);\n        }\n        else {\n            lastInsertedStyle.insertAdjacentElement('afterend', style);\n        }\n        lastInsertedStyle = style;\n    }\n    else {\n        style.textContent = content;\n    }\n    sheetsMap.set(id, style);\n}\nfunction removeStyle(id) {\n    const style = sheetsMap.get(id);\n    if (style) {\n        document.head.removeChild(style);\n        sheetsMap.delete(id);\n    }\n}\nfunction createHotContext(ownerPath) {\n    return new HMRContext(hmrClient, ownerPath);\n}\n/**\n * urls here are dynamic import() urls that couldn't be statically analyzed\n */\nfunction injectQuery(url, queryToInject) {\n    // skip urls that won't be handled by vite\n    if (url[0] !== '.' && url[0] !== '/') {\n        return url;\n    }\n    // can't use pathname from URL since it may be relative like ../\n    const pathname = url.replace(/[?#].*$/, '');\n    const { search, hash } = new URL(url, 'http://vitejs.dev');\n    return `${pathname}?${queryToInject}${search ? `&` + search.slice(1) : ''}${hash || ''}`;\n}\n\nexport { ErrorOverlay, createHotContext, injectQuery, removeStyle, updateStyle };\n                                   \n\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2xpZW50Lm1qcyIsInNvdXJjZXMiOlsiaG1yLnRzIiwib3ZlcmxheS50cyIsImNsaWVudC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IFVwZGF0ZSB9IGZyb20gJ3R5cGVzL2htclBheWxvYWQnXG5pbXBvcnQgdHlwZSB7IE1vZHVsZU5hbWVzcGFjZSwgVml0ZUhvdENvbnRleHQgfSBmcm9tICd0eXBlcy9ob3QnXG5pbXBvcnQgdHlwZSB7IEluZmVyQ3VzdG9tRXZlbnRQYXlsb2FkIH0gZnJvbSAndHlwZXMvY3VzdG9tRXZlbnQnXG5cbnR5cGUgQ3VzdG9tTGlzdGVuZXJzTWFwID0gTWFwPHN0cmluZywgKChkYXRhOiBhbnkpID0+IHZvaWQpW10+XG5cbmludGVyZmFjZSBIb3RNb2R1bGUge1xuICBpZDogc3RyaW5nXG4gIGNhbGxiYWNrczogSG90Q2FsbGJhY2tbXVxufVxuXG5pbnRlcmZhY2UgSG90Q2FsbGJhY2sge1xuICAvLyB0aGUgZGVwZW5kZW5jaWVzIG11c3QgYmUgZmV0Y2hhYmxlIHBhdGhzXG4gIGRlcHM6IHN0cmluZ1tdXG4gIGZuOiAobW9kdWxlczogQXJyYXk8TW9kdWxlTmFtZXNwYWNlIHwgdW5kZWZpbmVkPikgPT4gdm9pZFxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEhNUkxvZ2dlciB7XG4gIGVycm9yKG1zZzogc3RyaW5nIHwgRXJyb3IpOiB2b2lkXG4gIGRlYnVnKC4uLm1zZzogdW5rbm93bltdKTogdm9pZFxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEhNUkNvbm5lY3Rpb24ge1xuICAvKipcbiAgICogQ2hlY2tlZCBiZWZvcmUgc2VuZGluZyBtZXNzYWdlcyB0byB0aGUgY2xpZW50LlxuICAgKi9cbiAgaXNSZWFkeSgpOiBib29sZWFuXG4gIC8qKlxuICAgKiBTZW5kIG1lc3NhZ2UgdG8gdGhlIGNsaWVudC5cbiAgICovXG4gIHNlbmQobWVzc2FnZXM6IHN0cmluZyk6IHZvaWRcbn1cblxuZXhwb3J0IGNsYXNzIEhNUkNvbnRleHQgaW1wbGVtZW50cyBWaXRlSG90Q29udGV4dCB7XG4gIHByaXZhdGUgbmV3TGlzdGVuZXJzOiBDdXN0b21MaXN0ZW5lcnNNYXBcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIGhtckNsaWVudDogSE1SQ2xpZW50LFxuICAgIHByaXZhdGUgb3duZXJQYXRoOiBzdHJpbmcsXG4gICkge1xuICAgIGlmICghaG1yQ2xpZW50LmRhdGFNYXAuaGFzKG93bmVyUGF0aCkpIHtcbiAgICAgIGhtckNsaWVudC5kYXRhTWFwLnNldChvd25lclBhdGgsIHt9KVxuICAgIH1cblxuICAgIC8vIHdoZW4gYSBmaWxlIGlzIGhvdCB1cGRhdGVkLCBhIG5ldyBjb250ZXh0IGlzIGNyZWF0ZWRcbiAgICAvLyBjbGVhciBpdHMgc3RhbGUgY2FsbGJhY2tzXG4gICAgY29uc3QgbW9kID0gaG1yQ2xpZW50LmhvdE1vZHVsZXNNYXAuZ2V0KG93bmVyUGF0aClcbiAgICBpZiAobW9kKSB7XG4gICAgICBtb2QuY2FsbGJhY2tzID0gW11cbiAgICB9XG5cbiAgICAvLyBjbGVhciBzdGFsZSBjdXN0b20gZXZlbnQgbGlzdGVuZXJzXG4gICAgY29uc3Qgc3RhbGVMaXN0ZW5lcnMgPSBobXJDbGllbnQuY3R4VG9MaXN0ZW5lcnNNYXAuZ2V0KG93bmVyUGF0aClcbiAgICBpZiAoc3RhbGVMaXN0ZW5lcnMpIHtcbiAgICAgIGZvciAoY29uc3QgW2V2ZW50LCBzdGFsZUZuc10gb2Ygc3RhbGVMaXN0ZW5lcnMpIHtcbiAgICAgICAgY29uc3QgbGlzdGVuZXJzID0gaG1yQ2xpZW50LmN1c3RvbUxpc3RlbmVyc01hcC5nZXQoZXZlbnQpXG4gICAgICAgIGlmIChsaXN0ZW5lcnMpIHtcbiAgICAgICAgICBobXJDbGllbnQuY3VzdG9tTGlzdGVuZXJzTWFwLnNldChcbiAgICAgICAgICAgIGV2ZW50LFxuICAgICAgICAgICAgbGlzdGVuZXJzLmZpbHRlcigobCkgPT4gIXN0YWxlRm5zLmluY2x1ZGVzKGwpKSxcbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLm5ld0xpc3RlbmVycyA9IG5ldyBNYXAoKVxuICAgIGhtckNsaWVudC5jdHhUb0xpc3RlbmVyc01hcC5zZXQob3duZXJQYXRoLCB0aGlzLm5ld0xpc3RlbmVycylcbiAgfVxuXG4gIGdldCBkYXRhKCk6IGFueSB7XG4gICAgcmV0dXJuIHRoaXMuaG1yQ2xpZW50LmRhdGFNYXAuZ2V0KHRoaXMub3duZXJQYXRoKVxuICB9XG5cbiAgYWNjZXB0KGRlcHM/OiBhbnksIGNhbGxiYWNrPzogYW55KTogdm9pZCB7XG4gICAgaWYgKHR5cGVvZiBkZXBzID09PSAnZnVuY3Rpb24nIHx8ICFkZXBzKSB7XG4gICAgICAvLyBzZWxmLWFjY2VwdDogaG90LmFjY2VwdCgoKSA9PiB7fSlcbiAgICAgIHRoaXMuYWNjZXB0RGVwcyhbdGhpcy5vd25lclBhdGhdLCAoW21vZF0pID0+IGRlcHM/Lihtb2QpKVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGRlcHMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBleHBsaWNpdCBkZXBzXG4gICAgICB0aGlzLmFjY2VwdERlcHMoW2RlcHNdLCAoW21vZF0pID0+IGNhbGxiYWNrPy4obW9kKSlcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoZGVwcykpIHtcbiAgICAgIHRoaXMuYWNjZXB0RGVwcyhkZXBzLCBjYWxsYmFjaylcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGhvdC5hY2NlcHQoKSB1c2FnZS5gKVxuICAgIH1cbiAgfVxuXG4gIC8vIGV4cG9ydCBuYW1lcyAoZmlyc3QgYXJnKSBhcmUgaXJyZWxldmFudCBvbiB0aGUgY2xpZW50IHNpZGUsIHRoZXkncmVcbiAgLy8gZXh0cmFjdGVkIGluIHRoZSBzZXJ2ZXIgZm9yIHByb3BhZ2F0aW9uXG4gIGFjY2VwdEV4cG9ydHMoXG4gICAgXzogc3RyaW5nIHwgcmVhZG9ubHkgc3RyaW5nW10sXG4gICAgY2FsbGJhY2s6IChkYXRhOiBhbnkpID0+IHZvaWQsXG4gICk6IHZvaWQge1xuICAgIHRoaXMuYWNjZXB0RGVwcyhbdGhpcy5vd25lclBhdGhdLCAoW21vZF0pID0+IGNhbGxiYWNrPy4obW9kKSlcbiAgfVxuXG4gIGRpc3Bvc2UoY2I6IChkYXRhOiBhbnkpID0+IHZvaWQpOiB2b2lkIHtcbiAgICB0aGlzLmhtckNsaWVudC5kaXNwb3NlTWFwLnNldCh0aGlzLm93bmVyUGF0aCwgY2IpXG4gIH1cblxuICBwcnVuZShjYjogKGRhdGE6IGFueSkgPT4gdm9pZCk6IHZvaWQge1xuICAgIHRoaXMuaG1yQ2xpZW50LnBydW5lTWFwLnNldCh0aGlzLm93bmVyUGF0aCwgY2IpXG4gIH1cblxuICAvLyBLZXB0IGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5ICgjMTEwMzYpXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZW1wdHktZnVuY3Rpb25cbiAgZGVjbGluZSgpOiB2b2lkIHt9XG5cbiAgaW52YWxpZGF0ZShtZXNzYWdlOiBzdHJpbmcpOiB2b2lkIHtcbiAgICB0aGlzLmhtckNsaWVudC5ub3RpZnlMaXN0ZW5lcnMoJ3ZpdGU6aW52YWxpZGF0ZScsIHtcbiAgICAgIHBhdGg6IHRoaXMub3duZXJQYXRoLFxuICAgICAgbWVzc2FnZSxcbiAgICB9KVxuICAgIHRoaXMuc2VuZCgndml0ZTppbnZhbGlkYXRlJywgeyBwYXRoOiB0aGlzLm93bmVyUGF0aCwgbWVzc2FnZSB9KVxuICAgIHRoaXMuaG1yQ2xpZW50LmxvZ2dlci5kZWJ1ZyhcbiAgICAgIGBbdml0ZV0gaW52YWxpZGF0ZSAke3RoaXMub3duZXJQYXRofSR7bWVzc2FnZSA/IGA6ICR7bWVzc2FnZX1gIDogJyd9YCxcbiAgICApXG4gIH1cblxuICBvbjxUIGV4dGVuZHMgc3RyaW5nPihcbiAgICBldmVudDogVCxcbiAgICBjYjogKHBheWxvYWQ6IEluZmVyQ3VzdG9tRXZlbnRQYXlsb2FkPFQ+KSA9PiB2b2lkLFxuICApOiB2b2lkIHtcbiAgICBjb25zdCBhZGRUb01hcCA9IChtYXA6IE1hcDxzdHJpbmcsIGFueVtdPikgPT4ge1xuICAgICAgY29uc3QgZXhpc3RpbmcgPSBtYXAuZ2V0KGV2ZW50KSB8fCBbXVxuICAgICAgZXhpc3RpbmcucHVzaChjYilcbiAgICAgIG1hcC5zZXQoZXZlbnQsIGV4aXN0aW5nKVxuICAgIH1cbiAgICBhZGRUb01hcCh0aGlzLmhtckNsaWVudC5jdXN0b21MaXN0ZW5lcnNNYXApXG4gICAgYWRkVG9NYXAodGhpcy5uZXdMaXN0ZW5lcnMpXG4gIH1cblxuICBvZmY8VCBleHRlbmRzIHN0cmluZz4oXG4gICAgZXZlbnQ6IFQsXG4gICAgY2I6IChwYXlsb2FkOiBJbmZlckN1c3RvbUV2ZW50UGF5bG9hZDxUPikgPT4gdm9pZCxcbiAgKTogdm9pZCB7XG4gICAgY29uc3QgcmVtb3ZlRnJvbU1hcCA9IChtYXA6IE1hcDxzdHJpbmcsIGFueVtdPikgPT4ge1xuICAgICAgY29uc3QgZXhpc3RpbmcgPSBtYXAuZ2V0KGV2ZW50KVxuICAgICAgaWYgKGV4aXN0aW5nID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICBjb25zdCBwcnVuZWQgPSBleGlzdGluZy5maWx0ZXIoKGwpID0+IGwgIT09IGNiKVxuICAgICAgaWYgKHBydW5lZC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgbWFwLmRlbGV0ZShldmVudClcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICBtYXAuc2V0KGV2ZW50LCBwcnVuZWQpXG4gICAgfVxuICAgIHJlbW92ZUZyb21NYXAodGhpcy5obXJDbGllbnQuY3VzdG9tTGlzdGVuZXJzTWFwKVxuICAgIHJlbW92ZUZyb21NYXAodGhpcy5uZXdMaXN0ZW5lcnMpXG4gIH1cblxuICBzZW5kPFQgZXh0ZW5kcyBzdHJpbmc+KGV2ZW50OiBULCBkYXRhPzogSW5mZXJDdXN0b21FdmVudFBheWxvYWQ8VD4pOiB2b2lkIHtcbiAgICB0aGlzLmhtckNsaWVudC5tZXNzZW5nZXIuc2VuZChcbiAgICAgIEpTT04uc3RyaW5naWZ5KHsgdHlwZTogJ2N1c3RvbScsIGV2ZW50LCBkYXRhIH0pLFxuICAgIClcbiAgfVxuXG4gIHByaXZhdGUgYWNjZXB0RGVwcyhcbiAgICBkZXBzOiBzdHJpbmdbXSxcbiAgICBjYWxsYmFjazogSG90Q2FsbGJhY2tbJ2ZuJ10gPSAoKSA9PiB7fSxcbiAgKTogdm9pZCB7XG4gICAgY29uc3QgbW9kOiBIb3RNb2R1bGUgPSB0aGlzLmhtckNsaWVudC5ob3RNb2R1bGVzTWFwLmdldCh0aGlzLm93bmVyUGF0aCkgfHwge1xuICAgICAgaWQ6IHRoaXMub3duZXJQYXRoLFxuICAgICAgY2FsbGJhY2tzOiBbXSxcbiAgICB9XG4gICAgbW9kLmNhbGxiYWNrcy5wdXNoKHtcbiAgICAgIGRlcHMsXG4gICAgICBmbjogY2FsbGJhY2ssXG4gICAgfSlcbiAgICB0aGlzLmhtckNsaWVudC5ob3RNb2R1bGVzTWFwLnNldCh0aGlzLm93bmVyUGF0aCwgbW9kKVxuICB9XG59XG5cbmNsYXNzIEhNUk1lc3NlbmdlciB7XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgY29ubmVjdGlvbjogSE1SQ29ubmVjdGlvbikge31cblxuICBwcml2YXRlIHF1ZXVlOiBzdHJpbmdbXSA9IFtdXG5cbiAgcHVibGljIHNlbmQobWVzc2FnZTogc3RyaW5nKTogdm9pZCB7XG4gICAgdGhpcy5xdWV1ZS5wdXNoKG1lc3NhZ2UpXG4gICAgdGhpcy5mbHVzaCgpXG4gIH1cblxuICBwdWJsaWMgZmx1c2goKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuY29ubmVjdGlvbi5pc1JlYWR5KCkpIHtcbiAgICAgIHRoaXMucXVldWUuZm9yRWFjaCgobXNnKSA9PiB0aGlzLmNvbm5lY3Rpb24uc2VuZChtc2cpKVxuICAgICAgdGhpcy5xdWV1ZSA9IFtdXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBITVJDbGllbnQge1xuICBwdWJsaWMgaG90TW9kdWxlc01hcCA9IG5ldyBNYXA8c3RyaW5nLCBIb3RNb2R1bGU+KClcbiAgcHVibGljIGRpc3Bvc2VNYXAgPSBuZXcgTWFwPHN0cmluZywgKGRhdGE6IGFueSkgPT4gdm9pZCB8IFByb21pc2U8dm9pZD4+KClcbiAgcHVibGljIHBydW5lTWFwID0gbmV3IE1hcDxzdHJpbmcsIChkYXRhOiBhbnkpID0+IHZvaWQgfCBQcm9taXNlPHZvaWQ+PigpXG4gIHB1YmxpYyBkYXRhTWFwID0gbmV3IE1hcDxzdHJpbmcsIGFueT4oKVxuICBwdWJsaWMgY3VzdG9tTGlzdGVuZXJzTWFwOiBDdXN0b21MaXN0ZW5lcnNNYXAgPSBuZXcgTWFwKClcbiAgcHVibGljIGN0eFRvTGlzdGVuZXJzTWFwID0gbmV3IE1hcDxzdHJpbmcsIEN1c3RvbUxpc3RlbmVyc01hcD4oKVxuXG4gIHB1YmxpYyBtZXNzZW5nZXI6IEhNUk1lc3NlbmdlclxuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHB1YmxpYyBsb2dnZXI6IEhNUkxvZ2dlcixcbiAgICBjb25uZWN0aW9uOiBITVJDb25uZWN0aW9uLFxuICAgIC8vIFRoaXMgYWxsb3dzIGltcGxlbWVudGluZyByZWxvYWRpbmcgdmlhIGRpZmZlcmVudCBtZXRob2RzIGRlcGVuZGluZyBvbiB0aGUgZW52aXJvbm1lbnRcbiAgICBwcml2YXRlIGltcG9ydFVwZGF0ZWRNb2R1bGU6ICh1cGRhdGU6IFVwZGF0ZSkgPT4gUHJvbWlzZTxNb2R1bGVOYW1lc3BhY2U+LFxuICApIHtcbiAgICB0aGlzLm1lc3NlbmdlciA9IG5ldyBITVJNZXNzZW5nZXIoY29ubmVjdGlvbilcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBub3RpZnlMaXN0ZW5lcnM8VCBleHRlbmRzIHN0cmluZz4oXG4gICAgZXZlbnQ6IFQsXG4gICAgZGF0YTogSW5mZXJDdXN0b21FdmVudFBheWxvYWQ8VD4sXG4gICk6IFByb21pc2U8dm9pZD5cbiAgcHVibGljIGFzeW5jIG5vdGlmeUxpc3RlbmVycyhldmVudDogc3RyaW5nLCBkYXRhOiBhbnkpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCBjYnMgPSB0aGlzLmN1c3RvbUxpc3RlbmVyc01hcC5nZXQoZXZlbnQpXG4gICAgaWYgKGNicykge1xuICAgICAgYXdhaXQgUHJvbWlzZS5hbGxTZXR0bGVkKGNicy5tYXAoKGNiKSA9PiBjYihkYXRhKSkpXG4gICAgfVxuICB9XG5cbiAgcHVibGljIGNsZWFyKCk6IHZvaWQge1xuICAgIHRoaXMuaG90TW9kdWxlc01hcC5jbGVhcigpXG4gICAgdGhpcy5kaXNwb3NlTWFwLmNsZWFyKClcbiAgICB0aGlzLnBydW5lTWFwLmNsZWFyKClcbiAgICB0aGlzLmRhdGFNYXAuY2xlYXIoKVxuICAgIHRoaXMuY3VzdG9tTGlzdGVuZXJzTWFwLmNsZWFyKClcbiAgICB0aGlzLmN0eFRvTGlzdGVuZXJzTWFwLmNsZWFyKClcbiAgfVxuXG4gIC8vIEFmdGVyIGFuIEhNUiB1cGRhdGUsIHNvbWUgbW9kdWxlcyBhcmUgbm8gbG9uZ2VyIGltcG9ydGVkIG9uIHRoZSBwYWdlXG4gIC8vIGJ1dCB0aGV5IG1heSBoYXZlIGxlZnQgYmVoaW5kIHNpZGUgZWZmZWN0cyB0aGF0IG5lZWQgdG8gYmUgY2xlYW5lZCB1cFxuICAvLyAoLmUuZyBzdHlsZSBpbmplY3Rpb25zKVxuICBwdWJsaWMgYXN5bmMgcHJ1bmVQYXRocyhwYXRoczogc3RyaW5nW10pOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgIHBhdGhzLm1hcCgocGF0aCkgPT4ge1xuICAgICAgICBjb25zdCBkaXNwb3NlciA9IHRoaXMuZGlzcG9zZU1hcC5nZXQocGF0aClcbiAgICAgICAgaWYgKGRpc3Bvc2VyKSByZXR1cm4gZGlzcG9zZXIodGhpcy5kYXRhTWFwLmdldChwYXRoKSlcbiAgICAgIH0pLFxuICAgIClcbiAgICBwYXRocy5mb3JFYWNoKChwYXRoKSA9PiB7XG4gICAgICBjb25zdCBmbiA9IHRoaXMucHJ1bmVNYXAuZ2V0KHBhdGgpXG4gICAgICBpZiAoZm4pIHtcbiAgICAgICAgZm4odGhpcy5kYXRhTWFwLmdldChwYXRoKSlcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgcHJvdGVjdGVkIHdhcm5GYWlsZWRVcGRhdGUoZXJyOiBFcnJvciwgcGF0aDogc3RyaW5nIHwgc3RyaW5nW10pOiB2b2lkIHtcbiAgICBpZiAoIWVyci5tZXNzYWdlLmluY2x1ZGVzKCdmZXRjaCcpKSB7XG4gICAgICB0aGlzLmxvZ2dlci5lcnJvcihlcnIpXG4gICAgfVxuICAgIHRoaXMubG9nZ2VyLmVycm9yKFxuICAgICAgYFtobXJdIEZhaWxlZCB0byByZWxvYWQgJHtwYXRofS4gYCArXG4gICAgICAgIGBUaGlzIGNvdWxkIGJlIGR1ZSB0byBzeW50YXggZXJyb3JzIG9yIGltcG9ydGluZyBub24tZXhpc3RlbnQgYCArXG4gICAgICAgIGBtb2R1bGVzLiAoc2VlIGVycm9ycyBhYm92ZSlgLFxuICAgIClcbiAgfVxuXG4gIHByaXZhdGUgdXBkYXRlUXVldWU6IFByb21pc2U8KCgpID0+IHZvaWQpIHwgdW5kZWZpbmVkPltdID0gW11cbiAgcHJpdmF0ZSBwZW5kaW5nVXBkYXRlUXVldWUgPSBmYWxzZVxuXG4gIC8qKlxuICAgKiBidWZmZXIgbXVsdGlwbGUgaG90IHVwZGF0ZXMgdHJpZ2dlcmVkIGJ5IHRoZSBzYW1lIHNyYyBjaGFuZ2VcbiAgICogc28gdGhhdCB0aGV5IGFyZSBpbnZva2VkIGluIHRoZSBzYW1lIG9yZGVyIHRoZXkgd2VyZSBzZW50LlxuICAgKiAob3RoZXJ3aXNlIHRoZSBvcmRlciBtYXkgYmUgaW5jb25zaXN0ZW50IGJlY2F1c2Ugb2YgdGhlIGh0dHAgcmVxdWVzdCByb3VuZCB0cmlwKVxuICAgKi9cbiAgcHVibGljIGFzeW5jIHF1ZXVlVXBkYXRlKHBheWxvYWQ6IFVwZGF0ZSk6IFByb21pc2U8dm9pZD4ge1xuICAgIHRoaXMudXBkYXRlUXVldWUucHVzaCh0aGlzLmZldGNoVXBkYXRlKHBheWxvYWQpKVxuICAgIGlmICghdGhpcy5wZW5kaW5nVXBkYXRlUXVldWUpIHtcbiAgICAgIHRoaXMucGVuZGluZ1VwZGF0ZVF1ZXVlID0gdHJ1ZVxuICAgICAgYXdhaXQgUHJvbWlzZS5yZXNvbHZlKClcbiAgICAgIHRoaXMucGVuZGluZ1VwZGF0ZVF1ZXVlID0gZmFsc2VcbiAgICAgIGNvbnN0IGxvYWRpbmcgPSBbLi4udGhpcy51cGRhdGVRdWV1ZV1cbiAgICAgIHRoaXMudXBkYXRlUXVldWUgPSBbXVxuICAgICAgOyhhd2FpdCBQcm9taXNlLmFsbChsb2FkaW5nKSkuZm9yRWFjaCgoZm4pID0+IGZuICYmIGZuKCkpXG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBmZXRjaFVwZGF0ZSh1cGRhdGU6IFVwZGF0ZSk6IFByb21pc2U8KCgpID0+IHZvaWQpIHwgdW5kZWZpbmVkPiB7XG4gICAgY29uc3QgeyBwYXRoLCBhY2NlcHRlZFBhdGggfSA9IHVwZGF0ZVxuICAgIGNvbnN0IG1vZCA9IHRoaXMuaG90TW9kdWxlc01hcC5nZXQocGF0aClcbiAgICBpZiAoIW1vZCkge1xuICAgICAgLy8gSW4gYSBjb2RlLXNwbGl0dGluZyBwcm9qZWN0LFxuICAgICAgLy8gaXQgaXMgY29tbW9uIHRoYXQgdGhlIGhvdC11cGRhdGluZyBtb2R1bGUgaXMgbm90IGxvYWRlZCB5ZXQuXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vdml0ZWpzL3ZpdGUvaXNzdWVzLzcyMVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgbGV0IGZldGNoZWRNb2R1bGU6IE1vZHVsZU5hbWVzcGFjZSB8IHVuZGVmaW5lZFxuICAgIGNvbnN0IGlzU2VsZlVwZGF0ZSA9IHBhdGggPT09IGFjY2VwdGVkUGF0aFxuXG4gICAgLy8gZGV0ZXJtaW5lIHRoZSBxdWFsaWZpZWQgY2FsbGJhY2tzIGJlZm9yZSB3ZSByZS1pbXBvcnQgdGhlIG1vZHVsZXNcbiAgICBjb25zdCBxdWFsaWZpZWRDYWxsYmFja3MgPSBtb2QuY2FsbGJhY2tzLmZpbHRlcigoeyBkZXBzIH0pID0+XG4gICAgICBkZXBzLmluY2x1ZGVzKGFjY2VwdGVkUGF0aCksXG4gICAgKVxuXG4gICAgaWYgKGlzU2VsZlVwZGF0ZSB8fCBxdWFsaWZpZWRDYWxsYmFja3MubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgZGlzcG9zZXIgPSB0aGlzLmRpc3Bvc2VNYXAuZ2V0KGFjY2VwdGVkUGF0aClcbiAgICAgIGlmIChkaXNwb3NlcikgYXdhaXQgZGlzcG9zZXIodGhpcy5kYXRhTWFwLmdldChhY2NlcHRlZFBhdGgpKVxuICAgICAgdHJ5IHtcbiAgICAgICAgZmV0Y2hlZE1vZHVsZSA9IGF3YWl0IHRoaXMuaW1wb3J0VXBkYXRlZE1vZHVsZSh1cGRhdGUpXG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHRoaXMud2FybkZhaWxlZFVwZGF0ZShlLCBhY2NlcHRlZFBhdGgpXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGZvciAoY29uc3QgeyBkZXBzLCBmbiB9IG9mIHF1YWxpZmllZENhbGxiYWNrcykge1xuICAgICAgICBmbihcbiAgICAgICAgICBkZXBzLm1hcCgoZGVwKSA9PiAoZGVwID09PSBhY2NlcHRlZFBhdGggPyBmZXRjaGVkTW9kdWxlIDogdW5kZWZpbmVkKSksXG4gICAgICAgIClcbiAgICAgIH1cbiAgICAgIGNvbnN0IGxvZ2dlZFBhdGggPSBpc1NlbGZVcGRhdGUgPyBwYXRoIDogYCR7YWNjZXB0ZWRQYXRofSB2aWEgJHtwYXRofWBcbiAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKGBbdml0ZV0gaG90IHVwZGF0ZWQ6ICR7bG9nZ2VkUGF0aH1gKVxuICAgIH1cbiAgfVxufVxuIiwiaW1wb3J0IHR5cGUgeyBFcnJvclBheWxvYWQgfSBmcm9tICd0eXBlcy9obXJQYXlsb2FkJ1xuXG4vLyBpbmplY3RlZCBieSB0aGUgaG1yIHBsdWdpbiB3aGVuIHNlcnZlZFxuZGVjbGFyZSBjb25zdCBfX0JBU0VfXzogc3RyaW5nXG5kZWNsYXJlIGNvbnN0IF9fSE1SX0NPTkZJR19OQU1FX186IHN0cmluZ1xuXG5jb25zdCBobXJDb25maWdOYW1lID0gX19ITVJfQ09ORklHX05BTUVfX1xuY29uc3QgYmFzZSA9IF9fQkFTRV9fIHx8ICcvJ1xuXG4vLyBDcmVhdGUgYW4gZWxlbWVudCB3aXRoIHByb3ZpZGVkIGF0dHJpYnV0ZXMgYW5kIG9wdGlvbmFsIGNoaWxkcmVuXG5mdW5jdGlvbiBoKFxuICBlOiBzdHJpbmcsXG4gIGF0dHJzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge30sXG4gIC4uLmNoaWxkcmVuOiAoc3RyaW5nIHwgTm9kZSlbXVxuKSB7XG4gIGNvbnN0IGVsZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGUpXG4gIGZvciAoY29uc3QgW2ssIHZdIG9mIE9iamVjdC5lbnRyaWVzKGF0dHJzKSkge1xuICAgIGVsZW0uc2V0QXR0cmlidXRlKGssIHYpXG4gIH1cbiAgZWxlbS5hcHBlbmQoLi4uY2hpbGRyZW4pXG4gIHJldHVybiBlbGVtXG59XG5cbi8vIHNldCA6aG9zdCBzdHlsZXMgdG8gbWFrZSBwbGF5d3JpZ2h0IGRldGVjdCB0aGUgZWxlbWVudCBhcyB2aXNpYmxlXG5jb25zdCB0ZW1wbGF0ZVN0eWxlID0gLypjc3MqLyBgXG46aG9zdCB7XG4gIHBvc2l0aW9uOiBmaXhlZDtcbiAgdG9wOiAwO1xuICBsZWZ0OiAwO1xuICB3aWR0aDogMTAwJTtcbiAgaGVpZ2h0OiAxMDAlO1xuICB6LWluZGV4OiA5OTk5OTtcbiAgLS1tb25vc3BhY2U6ICdTRk1vbm8tUmVndWxhcicsIENvbnNvbGFzLFxuICAnTGliZXJhdGlvbiBNb25vJywgTWVubG8sIENvdXJpZXIsIG1vbm9zcGFjZTtcbiAgLS1yZWQ6ICNmZjU1NTU7XG4gIC0teWVsbG93OiAjZTJhYTUzO1xuICAtLXB1cnBsZTogI2NmYTRmZjtcbiAgLS1jeWFuOiAjMmRkOWRhO1xuICAtLWRpbTogI2M5YzljOTtcblxuICAtLXdpbmRvdy1iYWNrZ3JvdW5kOiAjMTgxODE4O1xuICAtLXdpbmRvdy1jb2xvcjogI2Q4ZDhkODtcbn1cblxuLmJhY2tkcm9wIHtcbiAgcG9zaXRpb246IGZpeGVkO1xuICB6LWluZGV4OiA5OTk5OTtcbiAgdG9wOiAwO1xuICBsZWZ0OiAwO1xuICB3aWR0aDogMTAwJTtcbiAgaGVpZ2h0OiAxMDAlO1xuICBvdmVyZmxvdy15OiBzY3JvbGw7XG4gIG1hcmdpbjogMDtcbiAgYmFja2dyb3VuZDogcmdiYSgwLCAwLCAwLCAwLjY2KTtcbn1cblxuLndpbmRvdyB7XG4gIGZvbnQtZmFtaWx5OiB2YXIoLS1tb25vc3BhY2UpO1xuICBsaW5lLWhlaWdodDogMS41O1xuICBtYXgtd2lkdGg6IDgwdnc7XG4gIGNvbG9yOiB2YXIoLS13aW5kb3ctY29sb3IpO1xuICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuICBtYXJnaW46IDMwcHggYXV0bztcbiAgcGFkZGluZzogMi41dmggNHZ3O1xuICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gIGJhY2tncm91bmQ6IHZhcigtLXdpbmRvdy1iYWNrZ3JvdW5kKTtcbiAgYm9yZGVyLXJhZGl1czogNnB4IDZweCA4cHggOHB4O1xuICBib3gtc2hhZG93OiAwIDE5cHggMzhweCByZ2JhKDAsMCwwLDAuMzApLCAwIDE1cHggMTJweCByZ2JhKDAsMCwwLDAuMjIpO1xuICBvdmVyZmxvdzogaGlkZGVuO1xuICBib3JkZXItdG9wOiA4cHggc29saWQgdmFyKC0tcmVkKTtcbiAgZGlyZWN0aW9uOiBsdHI7XG4gIHRleHQtYWxpZ246IGxlZnQ7XG59XG5cbnByZSB7XG4gIGZvbnQtZmFtaWx5OiB2YXIoLS1tb25vc3BhY2UpO1xuICBmb250LXNpemU6IDE2cHg7XG4gIG1hcmdpbi10b3A6IDA7XG4gIG1hcmdpbi1ib3R0b206IDFlbTtcbiAgb3ZlcmZsb3cteDogc2Nyb2xsO1xuICBzY3JvbGxiYXItd2lkdGg6IG5vbmU7XG59XG5cbnByZTo6LXdlYmtpdC1zY3JvbGxiYXIge1xuICBkaXNwbGF5OiBub25lO1xufVxuXG5wcmUuZnJhbWU6Oi13ZWJraXQtc2Nyb2xsYmFyIHtcbiAgZGlzcGxheTogYmxvY2s7XG4gIGhlaWdodDogNXB4O1xufVxuXG5wcmUuZnJhbWU6Oi13ZWJraXQtc2Nyb2xsYmFyLXRodW1iIHtcbiAgYmFja2dyb3VuZDogIzk5OTtcbiAgYm9yZGVyLXJhZGl1czogNXB4O1xufVxuXG5wcmUuZnJhbWUge1xuICBzY3JvbGxiYXItd2lkdGg6IHRoaW47XG59XG5cbi5tZXNzYWdlIHtcbiAgbGluZS1oZWlnaHQ6IDEuMztcbiAgZm9udC13ZWlnaHQ6IDYwMDtcbiAgd2hpdGUtc3BhY2U6IHByZS13cmFwO1xufVxuXG4ubWVzc2FnZS1ib2R5IHtcbiAgY29sb3I6IHZhcigtLXJlZCk7XG59XG5cbi5wbHVnaW4ge1xuICBjb2xvcjogdmFyKC0tcHVycGxlKTtcbn1cblxuLmZpbGUge1xuICBjb2xvcjogdmFyKC0tY3lhbik7XG4gIG1hcmdpbi1ib3R0b206IDA7XG4gIHdoaXRlLXNwYWNlOiBwcmUtd3JhcDtcbiAgd29yZC1icmVhazogYnJlYWstYWxsO1xufVxuXG4uZnJhbWUge1xuICBjb2xvcjogdmFyKC0teWVsbG93KTtcbn1cblxuLnN0YWNrIHtcbiAgZm9udC1zaXplOiAxM3B4O1xuICBjb2xvcjogdmFyKC0tZGltKTtcbn1cblxuLnRpcCB7XG4gIGZvbnQtc2l6ZTogMTNweDtcbiAgY29sb3I6ICM5OTk7XG4gIGJvcmRlci10b3A6IDFweCBkb3R0ZWQgIzk5OTtcbiAgcGFkZGluZy10b3A6IDEzcHg7XG4gIGxpbmUtaGVpZ2h0OiAxLjg7XG59XG5cbmNvZGUge1xuICBmb250LXNpemU6IDEzcHg7XG4gIGZvbnQtZmFtaWx5OiB2YXIoLS1tb25vc3BhY2UpO1xuICBjb2xvcjogdmFyKC0teWVsbG93KTtcbn1cblxuLmZpbGUtbGluayB7XG4gIHRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lO1xuICBjdXJzb3I6IHBvaW50ZXI7XG59XG5cbmtiZCB7XG4gIGxpbmUtaGVpZ2h0OiAxLjU7XG4gIGZvbnQtZmFtaWx5OiB1aS1tb25vc3BhY2UsIE1lbmxvLCBNb25hY28sIENvbnNvbGFzLCBcIkxpYmVyYXRpb24gTW9ub1wiLCBcIkNvdXJpZXIgTmV3XCIsIG1vbm9zcGFjZTtcbiAgZm9udC1zaXplOiAwLjc1cmVtO1xuICBmb250LXdlaWdodDogNzAwO1xuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2IoMzgsIDQwLCA0NCk7XG4gIGNvbG9yOiByZ2IoMTY2LCAxNjcsIDE3MSk7XG4gIHBhZGRpbmc6IDAuMTVyZW0gMC4zcmVtO1xuICBib3JkZXItcmFkaXVzOiAwLjI1cmVtO1xuICBib3JkZXItd2lkdGg6IDAuMDYyNXJlbSAwLjA2MjVyZW0gMC4xODc1cmVtO1xuICBib3JkZXItc3R5bGU6IHNvbGlkO1xuICBib3JkZXItY29sb3I6IHJnYig1NCwgNTcsIDY0KTtcbiAgYm9yZGVyLWltYWdlOiBpbml0aWFsO1xufVxuYFxuXG4vLyBFcnJvciBUZW1wbGF0ZVxubGV0IHRlbXBsYXRlOiBIVE1MRWxlbWVudFxuY29uc3QgY3JlYXRlVGVtcGxhdGUgPSAoKSA9PlxuICBoKFxuICAgICdkaXYnLFxuICAgIHsgY2xhc3M6ICdiYWNrZHJvcCcsIHBhcnQ6ICdiYWNrZHJvcCcgfSxcbiAgICBoKFxuICAgICAgJ2RpdicsXG4gICAgICB7IGNsYXNzOiAnd2luZG93JywgcGFydDogJ3dpbmRvdycgfSxcbiAgICAgIGgoXG4gICAgICAgICdwcmUnLFxuICAgICAgICB7IGNsYXNzOiAnbWVzc2FnZScsIHBhcnQ6ICdtZXNzYWdlJyB9LFxuICAgICAgICBoKCdzcGFuJywgeyBjbGFzczogJ3BsdWdpbicsIHBhcnQ6ICdwbHVnaW4nIH0pLFxuICAgICAgICBoKCdzcGFuJywgeyBjbGFzczogJ21lc3NhZ2UtYm9keScsIHBhcnQ6ICdtZXNzYWdlLWJvZHknIH0pLFxuICAgICAgKSxcbiAgICAgIGgoJ3ByZScsIHsgY2xhc3M6ICdmaWxlJywgcGFydDogJ2ZpbGUnIH0pLFxuICAgICAgaCgncHJlJywgeyBjbGFzczogJ2ZyYW1lJywgcGFydDogJ2ZyYW1lJyB9KSxcbiAgICAgIGgoJ3ByZScsIHsgY2xhc3M6ICdzdGFjaycsIHBhcnQ6ICdzdGFjaycgfSksXG4gICAgICBoKFxuICAgICAgICAnZGl2JyxcbiAgICAgICAgeyBjbGFzczogJ3RpcCcsIHBhcnQ6ICd0aXAnIH0sXG4gICAgICAgICdDbGljayBvdXRzaWRlLCBwcmVzcyAnLFxuICAgICAgICBoKCdrYmQnLCB7fSwgJ0VzYycpLFxuICAgICAgICAnIGtleSwgb3IgZml4IHRoZSBjb2RlIHRvIGRpc21pc3MuJyxcbiAgICAgICAgaCgnYnInKSxcbiAgICAgICAgJ1lvdSBjYW4gYWxzbyBkaXNhYmxlIHRoaXMgb3ZlcmxheSBieSBzZXR0aW5nICcsXG4gICAgICAgIGgoJ2NvZGUnLCB7IHBhcnQ6ICdjb25maWctb3B0aW9uLW5hbWUnIH0sICdzZXJ2ZXIuaG1yLm92ZXJsYXknKSxcbiAgICAgICAgJyB0byAnLFxuICAgICAgICBoKCdjb2RlJywgeyBwYXJ0OiAnY29uZmlnLW9wdGlvbi12YWx1ZScgfSwgJ2ZhbHNlJyksXG4gICAgICAgICcgaW4gJyxcbiAgICAgICAgaCgnY29kZScsIHsgcGFydDogJ2NvbmZpZy1maWxlLW5hbWUnIH0sIGhtckNvbmZpZ05hbWUpLFxuICAgICAgICAnLicsXG4gICAgICApLFxuICAgICksXG4gICAgaCgnc3R5bGUnLCB7fSwgdGVtcGxhdGVTdHlsZSksXG4gIClcblxuY29uc3QgZmlsZVJFID0gLyg/OlthLXpBLVpdOlxcXFx8XFwvKS4qPzpcXGQrOlxcZCsvZ1xuY29uc3QgY29kZWZyYW1lUkUgPSAvXig/Oj4/XFxzKlxcZCtcXHMrXFx8Lip8XFxzK1xcfFxccypcXF4uKilcXHI/XFxuL2dtXG5cbi8vIEFsbG93IGBFcnJvck92ZXJsYXlgIHRvIGV4dGVuZCBgSFRNTEVsZW1lbnRgIGV2ZW4gaW4gZW52aXJvbm1lbnRzIHdoZXJlXG4vLyBgSFRNTEVsZW1lbnRgIHdhcyBub3Qgb3JpZ2luYWxseSBkZWZpbmVkLlxuY29uc3QgeyBIVE1MRWxlbWVudCA9IGNsYXNzIHt9IGFzIHR5cGVvZiBnbG9iYWxUaGlzLkhUTUxFbGVtZW50IH0gPSBnbG9iYWxUaGlzXG5leHBvcnQgY2xhc3MgRXJyb3JPdmVybGF5IGV4dGVuZHMgSFRNTEVsZW1lbnQge1xuICByb290OiBTaGFkb3dSb290XG4gIGNsb3NlT25Fc2M6IChlOiBLZXlib2FyZEV2ZW50KSA9PiB2b2lkXG5cbiAgY29uc3RydWN0b3IoZXJyOiBFcnJvclBheWxvYWRbJ2VyciddLCBsaW5rcyA9IHRydWUpIHtcbiAgICBzdXBlcigpXG4gICAgdGhpcy5yb290ID0gdGhpcy5hdHRhY2hTaGFkb3coeyBtb2RlOiAnb3BlbicgfSlcblxuICAgIHRlbXBsYXRlID8/PSBjcmVhdGVUZW1wbGF0ZSgpXG4gICAgdGhpcy5yb290LmFwcGVuZENoaWxkKHRlbXBsYXRlKVxuXG4gICAgY29kZWZyYW1lUkUubGFzdEluZGV4ID0gMFxuICAgIGNvbnN0IGhhc0ZyYW1lID0gZXJyLmZyYW1lICYmIGNvZGVmcmFtZVJFLnRlc3QoZXJyLmZyYW1lKVxuICAgIGNvbnN0IG1lc3NhZ2UgPSBoYXNGcmFtZVxuICAgICAgPyBlcnIubWVzc2FnZS5yZXBsYWNlKGNvZGVmcmFtZVJFLCAnJylcbiAgICAgIDogZXJyLm1lc3NhZ2VcbiAgICBpZiAoZXJyLnBsdWdpbikge1xuICAgICAgdGhpcy50ZXh0KCcucGx1Z2luJywgYFtwbHVnaW46JHtlcnIucGx1Z2lufV0gYClcbiAgICB9XG4gICAgdGhpcy50ZXh0KCcubWVzc2FnZS1ib2R5JywgbWVzc2FnZS50cmltKCkpXG5cbiAgICBjb25zdCBbZmlsZV0gPSAoZXJyLmxvYz8uZmlsZSB8fCBlcnIuaWQgfHwgJ3Vua25vd24gZmlsZScpLnNwbGl0KGA/YClcbiAgICBpZiAoZXJyLmxvYykge1xuICAgICAgdGhpcy50ZXh0KCcuZmlsZScsIGAke2ZpbGV9OiR7ZXJyLmxvYy5saW5lfToke2Vyci5sb2MuY29sdW1ufWAsIGxpbmtzKVxuICAgIH0gZWxzZSBpZiAoZXJyLmlkKSB7XG4gICAgICB0aGlzLnRleHQoJy5maWxlJywgZmlsZSlcbiAgICB9XG5cbiAgICBpZiAoaGFzRnJhbWUpIHtcbiAgICAgIHRoaXMudGV4dCgnLmZyYW1lJywgZXJyLmZyYW1lIS50cmltKCkpXG4gICAgfVxuICAgIHRoaXMudGV4dCgnLnN0YWNrJywgZXJyLnN0YWNrLCBsaW5rcylcblxuICAgIHRoaXMucm9vdC5xdWVyeVNlbGVjdG9yKCcud2luZG93JykhLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGUpID0+IHtcbiAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKClcbiAgICB9KVxuXG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgICAgIHRoaXMuY2xvc2UoKVxuICAgIH0pXG5cbiAgICB0aGlzLmNsb3NlT25Fc2MgPSAoZTogS2V5Ym9hcmRFdmVudCkgPT4ge1xuICAgICAgaWYgKGUua2V5ID09PSAnRXNjYXBlJyB8fCBlLmNvZGUgPT09ICdFc2NhcGUnKSB7XG4gICAgICAgIHRoaXMuY2xvc2UoKVxuICAgICAgfVxuICAgIH1cblxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLmNsb3NlT25Fc2MpXG4gIH1cblxuICB0ZXh0KHNlbGVjdG9yOiBzdHJpbmcsIHRleHQ6IHN0cmluZywgbGlua0ZpbGVzID0gZmFsc2UpOiB2b2lkIHtcbiAgICBjb25zdCBlbCA9IHRoaXMucm9vdC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKSFcbiAgICBpZiAoIWxpbmtGaWxlcykge1xuICAgICAgZWwudGV4dENvbnRlbnQgPSB0ZXh0XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBjdXJJbmRleCA9IDBcbiAgICAgIGxldCBtYXRjaDogUmVnRXhwRXhlY0FycmF5IHwgbnVsbFxuICAgICAgZmlsZVJFLmxhc3RJbmRleCA9IDBcbiAgICAgIHdoaWxlICgobWF0Y2ggPSBmaWxlUkUuZXhlYyh0ZXh0KSkpIHtcbiAgICAgICAgY29uc3QgeyAwOiBmaWxlLCBpbmRleCB9ID0gbWF0Y2hcbiAgICAgICAgaWYgKGluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgICBjb25zdCBmcmFnID0gdGV4dC5zbGljZShjdXJJbmRleCwgaW5kZXgpXG4gICAgICAgICAgZWwuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoZnJhZykpXG4gICAgICAgICAgY29uc3QgbGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKVxuICAgICAgICAgIGxpbmsudGV4dENvbnRlbnQgPSBmaWxlXG4gICAgICAgICAgbGluay5jbGFzc05hbWUgPSAnZmlsZS1saW5rJ1xuICAgICAgICAgIGxpbmsub25jbGljayA9ICgpID0+IHtcbiAgICAgICAgICAgIGZldGNoKFxuICAgICAgICAgICAgICBuZXcgVVJMKFxuICAgICAgICAgICAgICAgIGAke2Jhc2V9X19vcGVuLWluLWVkaXRvcj9maWxlPSR7ZW5jb2RlVVJJQ29tcG9uZW50KGZpbGUpfWAsXG4gICAgICAgICAgICAgICAgaW1wb3J0Lm1ldGEudXJsLFxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgKVxuICAgICAgICAgIH1cbiAgICAgICAgICBlbC5hcHBlbmRDaGlsZChsaW5rKVxuICAgICAgICAgIGN1ckluZGV4ICs9IGZyYWcubGVuZ3RoICsgZmlsZS5sZW5ndGhcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBjbG9zZSgpOiB2b2lkIHtcbiAgICB0aGlzLnBhcmVudE5vZGU/LnJlbW92ZUNoaWxkKHRoaXMpXG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuY2xvc2VPbkVzYylcbiAgfVxufVxuXG5leHBvcnQgY29uc3Qgb3ZlcmxheUlkID0gJ3ZpdGUtZXJyb3Itb3ZlcmxheSdcbmNvbnN0IHsgY3VzdG9tRWxlbWVudHMgfSA9IGdsb2JhbFRoaXMgLy8gRW5zdXJlIGBjdXN0b21FbGVtZW50c2AgaXMgZGVmaW5lZCBiZWZvcmUgdGhlIG5leHQgbGluZS5cbmlmIChjdXN0b21FbGVtZW50cyAmJiAhY3VzdG9tRWxlbWVudHMuZ2V0KG92ZXJsYXlJZCkpIHtcbiAgY3VzdG9tRWxlbWVudHMuZGVmaW5lKG92ZXJsYXlJZCwgRXJyb3JPdmVybGF5KVxufVxuIiwiaW1wb3J0IHR5cGUgeyBFcnJvclBheWxvYWQsIEhNUlBheWxvYWQgfSBmcm9tICd0eXBlcy9obXJQYXlsb2FkJ1xuaW1wb3J0IHR5cGUgeyBWaXRlSG90Q29udGV4dCB9IGZyb20gJ3R5cGVzL2hvdCdcbmltcG9ydCB0eXBlIHsgSW5mZXJDdXN0b21FdmVudFBheWxvYWQgfSBmcm9tICd0eXBlcy9jdXN0b21FdmVudCdcbmltcG9ydCB7IEhNUkNsaWVudCwgSE1SQ29udGV4dCB9IGZyb20gJy4uL3NoYXJlZC9obXInXG5pbXBvcnQgeyBFcnJvck92ZXJsYXksIG92ZXJsYXlJZCB9IGZyb20gJy4vb3ZlcmxheSdcbmltcG9ydCAnQHZpdGUvZW52J1xuXG4vLyBpbmplY3RlZCBieSB0aGUgaG1yIHBsdWdpbiB3aGVuIHNlcnZlZFxuZGVjbGFyZSBjb25zdCBfX0JBU0VfXzogc3RyaW5nXG5kZWNsYXJlIGNvbnN0IF9fU0VSVkVSX0hPU1RfXzogc3RyaW5nXG5kZWNsYXJlIGNvbnN0IF9fSE1SX1BST1RPQ09MX186IHN0cmluZyB8IG51bGxcbmRlY2xhcmUgY29uc3QgX19ITVJfSE9TVE5BTUVfXzogc3RyaW5nIHwgbnVsbFxuZGVjbGFyZSBjb25zdCBfX0hNUl9QT1JUX186IG51bWJlciB8IG51bGxcbmRlY2xhcmUgY29uc3QgX19ITVJfRElSRUNUX1RBUkdFVF9fOiBzdHJpbmdcbmRlY2xhcmUgY29uc3QgX19ITVJfQkFTRV9fOiBzdHJpbmdcbmRlY2xhcmUgY29uc3QgX19ITVJfVElNRU9VVF9fOiBudW1iZXJcbmRlY2xhcmUgY29uc3QgX19ITVJfRU5BQkxFX09WRVJMQVlfXzogYm9vbGVhblxuXG5jb25zb2xlLmRlYnVnKCdbdml0ZV0gY29ubmVjdGluZy4uLicpXG5cbmNvbnN0IGltcG9ydE1ldGFVcmwgPSBuZXcgVVJMKGltcG9ydC5tZXRhLnVybClcblxuLy8gdXNlIHNlcnZlciBjb25maWd1cmF0aW9uLCB0aGVuIGZhbGxiYWNrIHRvIGluZmVyZW5jZVxuY29uc3Qgc2VydmVySG9zdCA9IF9fU0VSVkVSX0hPU1RfX1xuY29uc3Qgc29ja2V0UHJvdG9jb2wgPVxuICBfX0hNUl9QUk9UT0NPTF9fIHx8IChpbXBvcnRNZXRhVXJsLnByb3RvY29sID09PSAnaHR0cHM6JyA/ICd3c3MnIDogJ3dzJylcbmNvbnN0IGhtclBvcnQgPSBfX0hNUl9QT1JUX19cbmNvbnN0IHNvY2tldEhvc3QgPSBgJHtfX0hNUl9IT1NUTkFNRV9fIHx8IGltcG9ydE1ldGFVcmwuaG9zdG5hbWV9OiR7XG4gIGhtclBvcnQgfHwgaW1wb3J0TWV0YVVybC5wb3J0XG59JHtfX0hNUl9CQVNFX199YFxuY29uc3QgZGlyZWN0U29ja2V0SG9zdCA9IF9fSE1SX0RJUkVDVF9UQVJHRVRfX1xuY29uc3QgYmFzZSA9IF9fQkFTRV9fIHx8ICcvJ1xuXG5sZXQgc29ja2V0OiBXZWJTb2NrZXRcbnRyeSB7XG4gIGxldCBmYWxsYmFjazogKCgpID0+IHZvaWQpIHwgdW5kZWZpbmVkXG4gIC8vIG9ubHkgdXNlIGZhbGxiYWNrIHdoZW4gcG9ydCBpcyBpbmZlcnJlZCB0byBwcmV2ZW50IGNvbmZ1c2lvblxuICBpZiAoIWhtclBvcnQpIHtcbiAgICBmYWxsYmFjayA9ICgpID0+IHtcbiAgICAgIC8vIGZhbGxiYWNrIHRvIGNvbm5lY3RpbmcgZGlyZWN0bHkgdG8gdGhlIGhtciBzZXJ2ZXJcbiAgICAgIC8vIGZvciBzZXJ2ZXJzIHdoaWNoIGRvZXMgbm90IHN1cHBvcnQgcHJveHlpbmcgd2Vic29ja2V0XG4gICAgICBzb2NrZXQgPSBzZXR1cFdlYlNvY2tldChzb2NrZXRQcm90b2NvbCwgZGlyZWN0U29ja2V0SG9zdCwgKCkgPT4ge1xuICAgICAgICBjb25zdCBjdXJyZW50U2NyaXB0SG9zdFVSTCA9IG5ldyBVUkwoaW1wb3J0Lm1ldGEudXJsKVxuICAgICAgICBjb25zdCBjdXJyZW50U2NyaXB0SG9zdCA9XG4gICAgICAgICAgY3VycmVudFNjcmlwdEhvc3RVUkwuaG9zdCArXG4gICAgICAgICAgY3VycmVudFNjcmlwdEhvc3RVUkwucGF0aG5hbWUucmVwbGFjZSgvQHZpdGVcXC9jbGllbnQkLywgJycpXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgJ1t2aXRlXSBmYWlsZWQgdG8gY29ubmVjdCB0byB3ZWJzb2NrZXQuXFxuJyArXG4gICAgICAgICAgICAneW91ciBjdXJyZW50IHNldHVwOlxcbicgK1xuICAgICAgICAgICAgYCAgKGJyb3dzZXIpICR7Y3VycmVudFNjcmlwdEhvc3R9IDwtLVtIVFRQXS0tPiAke3NlcnZlckhvc3R9IChzZXJ2ZXIpXFxuYCArXG4gICAgICAgICAgICBgICAoYnJvd3NlcikgJHtzb2NrZXRIb3N0fSA8LS1bV2ViU29ja2V0IChmYWlsaW5nKV0tLT4gJHtkaXJlY3RTb2NrZXRIb3N0fSAoc2VydmVyKVxcbmAgK1xuICAgICAgICAgICAgJ0NoZWNrIG91dCB5b3VyIFZpdGUgLyBuZXR3b3JrIGNvbmZpZ3VyYXRpb24gYW5kIGh0dHBzOi8vdml0ZWpzLmRldi9jb25maWcvc2VydmVyLW9wdGlvbnMuaHRtbCNzZXJ2ZXItaG1yIC4nLFxuICAgICAgICApXG4gICAgICB9KVxuICAgICAgc29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgICdvcGVuJyxcbiAgICAgICAgKCkgPT4ge1xuICAgICAgICAgIGNvbnNvbGUuaW5mbyhcbiAgICAgICAgICAgICdbdml0ZV0gRGlyZWN0IHdlYnNvY2tldCBjb25uZWN0aW9uIGZhbGxiYWNrLiBDaGVjayBvdXQgaHR0cHM6Ly92aXRlanMuZGV2L2NvbmZpZy9zZXJ2ZXItb3B0aW9ucy5odG1sI3NlcnZlci1obXIgdG8gcmVtb3ZlIHRoZSBwcmV2aW91cyBjb25uZWN0aW9uIGVycm9yLicsXG4gICAgICAgICAgKVxuICAgICAgICB9LFxuICAgICAgICB7IG9uY2U6IHRydWUgfSxcbiAgICAgIClcbiAgICB9XG4gIH1cblxuICBzb2NrZXQgPSBzZXR1cFdlYlNvY2tldChzb2NrZXRQcm90b2NvbCwgc29ja2V0SG9zdCwgZmFsbGJhY2spXG59IGNhdGNoIChlcnJvcikge1xuICBjb25zb2xlLmVycm9yKGBbdml0ZV0gZmFpbGVkIHRvIGNvbm5lY3QgdG8gd2Vic29ja2V0ICgke2Vycm9yfSkuIGApXG59XG5cbmZ1bmN0aW9uIHNldHVwV2ViU29ja2V0KFxuICBwcm90b2NvbDogc3RyaW5nLFxuICBob3N0QW5kUGF0aDogc3RyaW5nLFxuICBvbkNsb3NlV2l0aG91dE9wZW4/OiAoKSA9PiB2b2lkLFxuKSB7XG4gIGNvbnN0IHNvY2tldCA9IG5ldyBXZWJTb2NrZXQoYCR7cHJvdG9jb2x9Oi8vJHtob3N0QW5kUGF0aH1gLCAndml0ZS1obXInKVxuICBsZXQgaXNPcGVuZWQgPSBmYWxzZVxuXG4gIHNvY2tldC5hZGRFdmVudExpc3RlbmVyKFxuICAgICdvcGVuJyxcbiAgICAoKSA9PiB7XG4gICAgICBpc09wZW5lZCA9IHRydWVcbiAgICAgIG5vdGlmeUxpc3RlbmVycygndml0ZTp3czpjb25uZWN0JywgeyB3ZWJTb2NrZXQ6IHNvY2tldCB9KVxuICAgIH0sXG4gICAgeyBvbmNlOiB0cnVlIH0sXG4gIClcblxuICAvLyBMaXN0ZW4gZm9yIG1lc3NhZ2VzXG4gIHNvY2tldC5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgYXN5bmMgKHsgZGF0YSB9KSA9PiB7XG4gICAgaGFuZGxlTWVzc2FnZShKU09OLnBhcnNlKGRhdGEpKVxuICB9KVxuXG4gIC8vIHBpbmcgc2VydmVyXG4gIHNvY2tldC5hZGRFdmVudExpc3RlbmVyKCdjbG9zZScsIGFzeW5jICh7IHdhc0NsZWFuIH0pID0+IHtcbiAgICBpZiAod2FzQ2xlYW4pIHJldHVyblxuXG4gICAgaWYgKCFpc09wZW5lZCAmJiBvbkNsb3NlV2l0aG91dE9wZW4pIHtcbiAgICAgIG9uQ2xvc2VXaXRob3V0T3BlbigpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBub3RpZnlMaXN0ZW5lcnMoJ3ZpdGU6d3M6ZGlzY29ubmVjdCcsIHsgd2ViU29ja2V0OiBzb2NrZXQgfSlcblxuICAgIGlmIChoYXNEb2N1bWVudCkge1xuICAgICAgY29uc29sZS5sb2coYFt2aXRlXSBzZXJ2ZXIgY29ubmVjdGlvbiBsb3N0LiBwb2xsaW5nIGZvciByZXN0YXJ0Li4uYClcbiAgICAgIGF3YWl0IHdhaXRGb3JTdWNjZXNzZnVsUGluZyhwcm90b2NvbCwgaG9zdEFuZFBhdGgpXG4gICAgICBsb2NhdGlvbi5yZWxvYWQoKVxuICAgIH1cbiAgfSlcblxuICByZXR1cm4gc29ja2V0XG59XG5cbmZ1bmN0aW9uIGNsZWFuVXJsKHBhdGhuYW1lOiBzdHJpbmcpOiBzdHJpbmcge1xuICBjb25zdCB1cmwgPSBuZXcgVVJMKHBhdGhuYW1lLCAnaHR0cDovL3ZpdGVqcy5kZXYnKVxuICB1cmwuc2VhcmNoUGFyYW1zLmRlbGV0ZSgnZGlyZWN0JylcbiAgcmV0dXJuIHVybC5wYXRobmFtZSArIHVybC5zZWFyY2hcbn1cblxubGV0IGlzRmlyc3RVcGRhdGUgPSB0cnVlXG5jb25zdCBvdXRkYXRlZExpbmtUYWdzID0gbmV3IFdlYWtTZXQ8SFRNTExpbmtFbGVtZW50PigpXG5cbmNvbnN0IGRlYm91bmNlUmVsb2FkID0gKHRpbWU6IG51bWJlcikgPT4ge1xuICBsZXQgdGltZXI6IFJldHVyblR5cGU8dHlwZW9mIHNldFRpbWVvdXQ+IHwgbnVsbFxuICByZXR1cm4gKCkgPT4ge1xuICAgIGlmICh0aW1lcikge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKVxuICAgICAgdGltZXIgPSBudWxsXG4gICAgfVxuICAgIHRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBsb2NhdGlvbi5yZWxvYWQoKVxuICAgIH0sIHRpbWUpXG4gIH1cbn1cbmNvbnN0IHBhZ2VSZWxvYWQgPSBkZWJvdW5jZVJlbG9hZCg1MClcblxuY29uc3QgaG1yQ2xpZW50ID0gbmV3IEhNUkNsaWVudChcbiAgY29uc29sZSxcbiAge1xuICAgIGlzUmVhZHk6ICgpID0+IHNvY2tldCAmJiBzb2NrZXQucmVhZHlTdGF0ZSA9PT0gMSxcbiAgICBzZW5kOiAobWVzc2FnZSkgPT4gc29ja2V0LnNlbmQobWVzc2FnZSksXG4gIH0sXG4gIGFzeW5jIGZ1bmN0aW9uIGltcG9ydFVwZGF0ZWRNb2R1bGUoe1xuICAgIGFjY2VwdGVkUGF0aCxcbiAgICB0aW1lc3RhbXAsXG4gICAgZXhwbGljaXRJbXBvcnRSZXF1aXJlZCxcbiAgICBpc1dpdGhpbkNpcmN1bGFySW1wb3J0LFxuICB9KSB7XG4gICAgY29uc3QgW2FjY2VwdGVkUGF0aFdpdGhvdXRRdWVyeSwgcXVlcnldID0gYWNjZXB0ZWRQYXRoLnNwbGl0KGA/YClcbiAgICBjb25zdCBpbXBvcnRQcm9taXNlID0gaW1wb3J0KFxuICAgICAgLyogQHZpdGUtaWdub3JlICovXG4gICAgICBiYXNlICtcbiAgICAgICAgYWNjZXB0ZWRQYXRoV2l0aG91dFF1ZXJ5LnNsaWNlKDEpICtcbiAgICAgICAgYD8ke2V4cGxpY2l0SW1wb3J0UmVxdWlyZWQgPyAnaW1wb3J0JicgOiAnJ310PSR7dGltZXN0YW1wfSR7XG4gICAgICAgICAgcXVlcnkgPyBgJiR7cXVlcnl9YCA6ICcnXG4gICAgICAgIH1gXG4gICAgKVxuICAgIGlmIChpc1dpdGhpbkNpcmN1bGFySW1wb3J0KSB7XG4gICAgICBpbXBvcnRQcm9taXNlLmNhdGNoKCgpID0+IHtcbiAgICAgICAgY29uc29sZS5pbmZvKFxuICAgICAgICAgIGBbaG1yXSAke2FjY2VwdGVkUGF0aH0gZmFpbGVkIHRvIGFwcGx5IEhNUiBhcyBpdCdzIHdpdGhpbiBhIGNpcmN1bGFyIGltcG9ydC4gUmVsb2FkaW5nIHBhZ2UgdG8gcmVzZXQgdGhlIGV4ZWN1dGlvbiBvcmRlci4gYCArXG4gICAgICAgICAgICBgVG8gZGVidWcgYW5kIGJyZWFrIHRoZSBjaXJjdWxhciBpbXBvcnQsIHlvdSBjYW4gcnVuIFxcYHZpdGUgLS1kZWJ1ZyBobXJcXGAgdG8gbG9nIHRoZSBjaXJjdWxhciBkZXBlbmRlbmN5IHBhdGggaWYgYSBmaWxlIGNoYW5nZSB0cmlnZ2VyZWQgaXQuYCxcbiAgICAgICAgKVxuICAgICAgICBwYWdlUmVsb2FkKClcbiAgICAgIH0pXG4gICAgfVxuICAgIHJldHVybiBhd2FpdCBpbXBvcnRQcm9taXNlXG4gIH0sXG4pXG5cbmFzeW5jIGZ1bmN0aW9uIGhhbmRsZU1lc3NhZ2UocGF5bG9hZDogSE1SUGF5bG9hZCkge1xuICBzd2l0Y2ggKHBheWxvYWQudHlwZSkge1xuICAgIGNhc2UgJ2Nvbm5lY3RlZCc6XG4gICAgICBjb25zb2xlLmRlYnVnKGBbdml0ZV0gY29ubmVjdGVkLmApXG4gICAgICBobXJDbGllbnQubWVzc2VuZ2VyLmZsdXNoKClcbiAgICAgIC8vIHByb3h5KG5naW54LCBkb2NrZXIpIGhtciB3cyBtYXliZSBjYXVzZWQgdGltZW91dCxcbiAgICAgIC8vIHNvIHNlbmQgcGluZyBwYWNrYWdlIGxldCB3cyBrZWVwIGFsaXZlLlxuICAgICAgc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICBpZiAoc29ja2V0LnJlYWR5U3RhdGUgPT09IHNvY2tldC5PUEVOKSB7XG4gICAgICAgICAgc29ja2V0LnNlbmQoJ3tcInR5cGVcIjpcInBpbmdcIn0nKVxuICAgICAgICB9XG4gICAgICB9LCBfX0hNUl9USU1FT1VUX18pXG4gICAgICBicmVha1xuICAgIGNhc2UgJ3VwZGF0ZSc6XG4gICAgICBub3RpZnlMaXN0ZW5lcnMoJ3ZpdGU6YmVmb3JlVXBkYXRlJywgcGF5bG9hZClcbiAgICAgIGlmIChoYXNEb2N1bWVudCkge1xuICAgICAgICAvLyBpZiB0aGlzIGlzIHRoZSBmaXJzdCB1cGRhdGUgYW5kIHRoZXJlJ3MgYWxyZWFkeSBhbiBlcnJvciBvdmVybGF5LCBpdFxuICAgICAgICAvLyBtZWFucyB0aGUgcGFnZSBvcGVuZWQgd2l0aCBleGlzdGluZyBzZXJ2ZXIgY29tcGlsZSBlcnJvciBhbmQgdGhlIHdob2xlXG4gICAgICAgIC8vIG1vZHVsZSBzY3JpcHQgZmFpbGVkIHRvIGxvYWQgKHNpbmNlIG9uZSBvZiB0aGUgbmVzdGVkIGltcG9ydHMgaXMgNTAwKS5cbiAgICAgICAgLy8gaW4gdGhpcyBjYXNlIGEgbm9ybWFsIHVwZGF0ZSB3b24ndCB3b3JrIGFuZCBhIGZ1bGwgcmVsb2FkIGlzIG5lZWRlZC5cbiAgICAgICAgaWYgKGlzRmlyc3RVcGRhdGUgJiYgaGFzRXJyb3JPdmVybGF5KCkpIHtcbiAgICAgICAgICB3aW5kb3cubG9jYXRpb24ucmVsb2FkKClcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoZW5hYmxlT3ZlcmxheSkge1xuICAgICAgICAgICAgY2xlYXJFcnJvck92ZXJsYXkoKVxuICAgICAgICAgIH1cbiAgICAgICAgICBpc0ZpcnN0VXBkYXRlID0gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICAgIHBheWxvYWQudXBkYXRlcy5tYXAoYXN5bmMgKHVwZGF0ZSk6IFByb21pc2U8dm9pZD4gPT4ge1xuICAgICAgICAgIGlmICh1cGRhdGUudHlwZSA9PT0gJ2pzLXVwZGF0ZScpIHtcbiAgICAgICAgICAgIHJldHVybiBobXJDbGllbnQucXVldWVVcGRhdGUodXBkYXRlKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIGNzcy11cGRhdGVcbiAgICAgICAgICAvLyB0aGlzIGlzIG9ubHkgc2VudCB3aGVuIGEgY3NzIGZpbGUgcmVmZXJlbmNlZCB3aXRoIDxsaW5rPiBpcyB1cGRhdGVkXG4gICAgICAgICAgY29uc3QgeyBwYXRoLCB0aW1lc3RhbXAgfSA9IHVwZGF0ZVxuICAgICAgICAgIGNvbnN0IHNlYXJjaFVybCA9IGNsZWFuVXJsKHBhdGgpXG4gICAgICAgICAgLy8gY2FuJ3QgdXNlIHF1ZXJ5U2VsZWN0b3Igd2l0aCBgW2hyZWYqPV1gIGhlcmUgc2luY2UgdGhlIGxpbmsgbWF5IGJlXG4gICAgICAgICAgLy8gdXNpbmcgcmVsYXRpdmUgcGF0aHMgc28gd2UgbmVlZCB0byB1c2UgbGluay5ocmVmIHRvIGdyYWIgdGhlIGZ1bGxcbiAgICAgICAgICAvLyBVUkwgZm9yIHRoZSBpbmNsdWRlIGNoZWNrLlxuICAgICAgICAgIGNvbnN0IGVsID0gQXJyYXkuZnJvbShcbiAgICAgICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGw8SFRNTExpbmtFbGVtZW50PignbGluaycpLFxuICAgICAgICAgICkuZmluZChcbiAgICAgICAgICAgIChlKSA9PlxuICAgICAgICAgICAgICAhb3V0ZGF0ZWRMaW5rVGFncy5oYXMoZSkgJiYgY2xlYW5VcmwoZS5ocmVmKS5pbmNsdWRlcyhzZWFyY2hVcmwpLFxuICAgICAgICAgIClcblxuICAgICAgICAgIGlmICghZWwpIHtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IG5ld1BhdGggPSBgJHtiYXNlfSR7c2VhcmNoVXJsLnNsaWNlKDEpfSR7XG4gICAgICAgICAgICBzZWFyY2hVcmwuaW5jbHVkZXMoJz8nKSA/ICcmJyA6ICc/J1xuICAgICAgICAgIH10PSR7dGltZXN0YW1wfWBcblxuICAgICAgICAgIC8vIHJhdGhlciB0aGFuIHN3YXBwaW5nIHRoZSBocmVmIG9uIHRoZSBleGlzdGluZyB0YWcsIHdlIHdpbGxcbiAgICAgICAgICAvLyBjcmVhdGUgYSBuZXcgbGluayB0YWcuIE9uY2UgdGhlIG5ldyBzdHlsZXNoZWV0IGhhcyBsb2FkZWQgd2VcbiAgICAgICAgICAvLyB3aWxsIHJlbW92ZSB0aGUgZXhpc3RpbmcgbGluayB0YWcuIFRoaXMgcmVtb3ZlcyBhIEZsYXNoIE9mXG4gICAgICAgICAgLy8gVW5zdHlsZWQgQ29udGVudCB0aGF0IGNhbiBvY2N1ciB3aGVuIHN3YXBwaW5nIG91dCB0aGUgdGFnIGhyZWZcbiAgICAgICAgICAvLyBkaXJlY3RseSwgYXMgdGhlIG5ldyBzdHlsZXNoZWV0IGhhcyBub3QgeWV0IGJlZW4gbG9hZGVkLlxuICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbmV3TGlua1RhZyA9IGVsLmNsb25lTm9kZSgpIGFzIEhUTUxMaW5rRWxlbWVudFxuICAgICAgICAgICAgbmV3TGlua1RhZy5ocmVmID0gbmV3IFVSTChuZXdQYXRoLCBlbC5ocmVmKS5ocmVmXG4gICAgICAgICAgICBjb25zdCByZW1vdmVPbGRFbCA9ICgpID0+IHtcbiAgICAgICAgICAgICAgZWwucmVtb3ZlKClcbiAgICAgICAgICAgICAgY29uc29sZS5kZWJ1ZyhgW3ZpdGVdIGNzcyBob3QgdXBkYXRlZDogJHtzZWFyY2hVcmx9YClcbiAgICAgICAgICAgICAgcmVzb2x2ZSgpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXdMaW5rVGFnLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCByZW1vdmVPbGRFbClcbiAgICAgICAgICAgIG5ld0xpbmtUYWcuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCByZW1vdmVPbGRFbClcbiAgICAgICAgICAgIG91dGRhdGVkTGlua1RhZ3MuYWRkKGVsKVxuICAgICAgICAgICAgZWwuYWZ0ZXIobmV3TGlua1RhZylcbiAgICAgICAgICB9KVxuICAgICAgICB9KSxcbiAgICAgIClcbiAgICAgIG5vdGlmeUxpc3RlbmVycygndml0ZTphZnRlclVwZGF0ZScsIHBheWxvYWQpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2N1c3RvbSc6IHtcbiAgICAgIG5vdGlmeUxpc3RlbmVycyhwYXlsb2FkLmV2ZW50LCBwYXlsb2FkLmRhdGEpXG4gICAgICBicmVha1xuICAgIH1cbiAgICBjYXNlICdmdWxsLXJlbG9hZCc6XG4gICAgICBub3RpZnlMaXN0ZW5lcnMoJ3ZpdGU6YmVmb3JlRnVsbFJlbG9hZCcsIHBheWxvYWQpXG4gICAgICBpZiAoaGFzRG9jdW1lbnQpIHtcbiAgICAgICAgaWYgKHBheWxvYWQucGF0aCAmJiBwYXlsb2FkLnBhdGguZW5kc1dpdGgoJy5odG1sJykpIHtcbiAgICAgICAgICAvLyBpZiBodG1sIGZpbGUgaXMgZWRpdGVkLCBvbmx5IHJlbG9hZCB0aGUgcGFnZSBpZiB0aGUgYnJvd3NlciBpc1xuICAgICAgICAgIC8vIGN1cnJlbnRseSBvbiB0aGF0IHBhZ2UuXG4gICAgICAgICAgY29uc3QgcGFnZVBhdGggPSBkZWNvZGVVUkkobG9jYXRpb24ucGF0aG5hbWUpXG4gICAgICAgICAgY29uc3QgcGF5bG9hZFBhdGggPSBiYXNlICsgcGF5bG9hZC5wYXRoLnNsaWNlKDEpXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgcGFnZVBhdGggPT09IHBheWxvYWRQYXRoIHx8XG4gICAgICAgICAgICBwYXlsb2FkLnBhdGggPT09ICcvaW5kZXguaHRtbCcgfHxcbiAgICAgICAgICAgIChwYWdlUGF0aC5lbmRzV2l0aCgnLycpICYmIHBhZ2VQYXRoICsgJ2luZGV4Lmh0bWwnID09PSBwYXlsb2FkUGF0aClcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHBhZ2VSZWxvYWQoKVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYWdlUmVsb2FkKClcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWtcbiAgICBjYXNlICdwcnVuZSc6XG4gICAgICBub3RpZnlMaXN0ZW5lcnMoJ3ZpdGU6YmVmb3JlUHJ1bmUnLCBwYXlsb2FkKVxuICAgICAgYXdhaXQgaG1yQ2xpZW50LnBydW5lUGF0aHMocGF5bG9hZC5wYXRocylcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnZXJyb3InOiB7XG4gICAgICBub3RpZnlMaXN0ZW5lcnMoJ3ZpdGU6ZXJyb3InLCBwYXlsb2FkKVxuICAgICAgaWYgKGhhc0RvY3VtZW50KSB7XG4gICAgICAgIGNvbnN0IGVyciA9IHBheWxvYWQuZXJyXG4gICAgICAgIGlmIChlbmFibGVPdmVybGF5KSB7XG4gICAgICAgICAgY3JlYXRlRXJyb3JPdmVybGF5KGVycilcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgYFt2aXRlXSBJbnRlcm5hbCBTZXJ2ZXIgRXJyb3JcXG4ke2Vyci5tZXNzYWdlfVxcbiR7ZXJyLnN0YWNrfWAsXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVha1xuICAgIH1cbiAgICBkZWZhdWx0OiB7XG4gICAgICBjb25zdCBjaGVjazogbmV2ZXIgPSBwYXlsb2FkXG4gICAgICByZXR1cm4gY2hlY2tcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gbm90aWZ5TGlzdGVuZXJzPFQgZXh0ZW5kcyBzdHJpbmc+KFxuICBldmVudDogVCxcbiAgZGF0YTogSW5mZXJDdXN0b21FdmVudFBheWxvYWQ8VD4sXG4pOiB2b2lkXG5mdW5jdGlvbiBub3RpZnlMaXN0ZW5lcnMoZXZlbnQ6IHN0cmluZywgZGF0YTogYW55KTogdm9pZCB7XG4gIGhtckNsaWVudC5ub3RpZnlMaXN0ZW5lcnMoZXZlbnQsIGRhdGEpXG59XG5cbmNvbnN0IGVuYWJsZU92ZXJsYXkgPSBfX0hNUl9FTkFCTEVfT1ZFUkxBWV9fXG5jb25zdCBoYXNEb2N1bWVudCA9ICdkb2N1bWVudCcgaW4gZ2xvYmFsVGhpc1xuXG5mdW5jdGlvbiBjcmVhdGVFcnJvck92ZXJsYXkoZXJyOiBFcnJvclBheWxvYWRbJ2VyciddKSB7XG4gIGNsZWFyRXJyb3JPdmVybGF5KClcbiAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChuZXcgRXJyb3JPdmVybGF5KGVycikpXG59XG5cbmZ1bmN0aW9uIGNsZWFyRXJyb3JPdmVybGF5KCkge1xuICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsPEVycm9yT3ZlcmxheT4ob3ZlcmxheUlkKS5mb3JFYWNoKChuKSA9PiBuLmNsb3NlKCkpXG59XG5cbmZ1bmN0aW9uIGhhc0Vycm9yT3ZlcmxheSgpIHtcbiAgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwob3ZlcmxheUlkKS5sZW5ndGhcbn1cblxuYXN5bmMgZnVuY3Rpb24gd2FpdEZvclN1Y2Nlc3NmdWxQaW5nKFxuICBzb2NrZXRQcm90b2NvbDogc3RyaW5nLFxuICBob3N0QW5kUGF0aDogc3RyaW5nLFxuICBtcyA9IDEwMDAsXG4pIHtcbiAgY29uc3QgcGluZ0hvc3RQcm90b2NvbCA9IHNvY2tldFByb3RvY29sID09PSAnd3NzJyA/ICdodHRwcycgOiAnaHR0cCdcblxuICBjb25zdCBwaW5nID0gYXN5bmMgKCkgPT4ge1xuICAgIC8vIEEgZmV0Y2ggb24gYSB3ZWJzb2NrZXQgVVJMIHdpbGwgcmV0dXJuIGEgc3VjY2Vzc2Z1bCBwcm9taXNlIHdpdGggc3RhdHVzIDQwMCxcbiAgICAvLyBidXQgd2lsbCByZWplY3QgYSBuZXR3b3JraW5nIGVycm9yLlxuICAgIC8vIFdoZW4gcnVubmluZyBvbiBtaWRkbGV3YXJlIG1vZGUsIGl0IHJldHVybnMgc3RhdHVzIDQyNiwgYW5kIGFuIGNvcnMgZXJyb3IgaGFwcGVucyBpZiBtb2RlIGlzIG5vdCBuby1jb3JzXG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IGZldGNoKGAke3BpbmdIb3N0UHJvdG9jb2x9Oi8vJHtob3N0QW5kUGF0aH1gLCB7XG4gICAgICAgIG1vZGU6ICduby1jb3JzJyxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIC8vIEN1c3RvbSBoZWFkZXJzIHdvbid0IGJlIGluY2x1ZGVkIGluIGEgcmVxdWVzdCB3aXRoIG5vLWNvcnMgc28gKGFiKXVzZSBvbmUgb2YgdGhlXG4gICAgICAgICAgLy8gc2FmZWxpc3RlZCBoZWFkZXJzIHRvIGlkZW50aWZ5IHRoZSBwaW5nIHJlcXVlc3RcbiAgICAgICAgICBBY2NlcHQ6ICd0ZXh0L3gtdml0ZS1waW5nJyxcbiAgICAgICAgfSxcbiAgICAgIH0pXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH0gY2F0Y2gge31cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGlmIChhd2FpdCBwaW5nKCkpIHtcbiAgICByZXR1cm5cbiAgfVxuICBhd2FpdCB3YWl0KG1zKVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zdGFudC1jb25kaXRpb25cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBpZiAoZG9jdW1lbnQudmlzaWJpbGl0eVN0YXRlID09PSAndmlzaWJsZScpIHtcbiAgICAgIGlmIChhd2FpdCBwaW5nKCkpIHtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIGF3YWl0IHdhaXQobXMpXG4gICAgfSBlbHNlIHtcbiAgICAgIGF3YWl0IHdhaXRGb3JXaW5kb3dTaG93KClcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gd2FpdChtczogbnVtYmVyKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCBtcykpXG59XG5cbmZ1bmN0aW9uIHdhaXRGb3JXaW5kb3dTaG93KCkge1xuICByZXR1cm4gbmV3IFByb21pc2U8dm9pZD4oKHJlc29sdmUpID0+IHtcbiAgICBjb25zdCBvbkNoYW5nZSA9IGFzeW5jICgpID0+IHtcbiAgICAgIGlmIChkb2N1bWVudC52aXNpYmlsaXR5U3RhdGUgPT09ICd2aXNpYmxlJykge1xuICAgICAgICByZXNvbHZlKClcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndmlzaWJpbGl0eWNoYW5nZScsIG9uQ2hhbmdlKVxuICAgICAgfVxuICAgIH1cbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd2aXNpYmlsaXR5Y2hhbmdlJywgb25DaGFuZ2UpXG4gIH0pXG59XG5cbmNvbnN0IHNoZWV0c01hcCA9IG5ldyBNYXA8c3RyaW5nLCBIVE1MU3R5bGVFbGVtZW50PigpXG5cbi8vIGNvbGxlY3QgZXhpc3Rpbmcgc3R5bGUgZWxlbWVudHMgdGhhdCBtYXkgaGF2ZSBiZWVuIGluc2VydGVkIGR1cmluZyBTU1Jcbi8vIHRvIGF2b2lkIEZPVUMgb3IgZHVwbGljYXRlIHN0eWxlc1xuaWYgKCdkb2N1bWVudCcgaW4gZ2xvYmFsVGhpcykge1xuICBkb2N1bWVudFxuICAgIC5xdWVyeVNlbGVjdG9yQWxsPEhUTUxTdHlsZUVsZW1lbnQ+KCdzdHlsZVtkYXRhLXZpdGUtZGV2LWlkXScpXG4gICAgLmZvckVhY2goKGVsKSA9PiB7XG4gICAgICBzaGVldHNNYXAuc2V0KGVsLmdldEF0dHJpYnV0ZSgnZGF0YS12aXRlLWRldi1pZCcpISwgZWwpXG4gICAgfSlcbn1cblxuY29uc3QgY3NwTm9uY2UgPVxuICAnZG9jdW1lbnQnIGluIGdsb2JhbFRoaXNcbiAgICA/IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3I8SFRNTE1ldGFFbGVtZW50PignbWV0YVtwcm9wZXJ0eT1jc3Atbm9uY2VdJyk/Lm5vbmNlXG4gICAgOiB1bmRlZmluZWRcblxuLy8gYWxsIGNzcyBpbXBvcnRzIHNob3VsZCBiZSBpbnNlcnRlZCBhdCB0aGUgc2FtZSBwb3NpdGlvblxuLy8gYmVjYXVzZSBhZnRlciBidWlsZCBpdCB3aWxsIGJlIGEgc2luZ2xlIGNzcyBmaWxlXG5sZXQgbGFzdEluc2VydGVkU3R5bGU6IEhUTUxTdHlsZUVsZW1lbnQgfCB1bmRlZmluZWRcblxuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZVN0eWxlKGlkOiBzdHJpbmcsIGNvbnRlbnQ6IHN0cmluZyk6IHZvaWQge1xuICBsZXQgc3R5bGUgPSBzaGVldHNNYXAuZ2V0KGlkKVxuICBpZiAoIXN0eWxlKSB7XG4gICAgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpXG4gICAgc3R5bGUuc2V0QXR0cmlidXRlKCd0eXBlJywgJ3RleHQvY3NzJylcbiAgICBzdHlsZS5zZXRBdHRyaWJ1dGUoJ2RhdGEtdml0ZS1kZXYtaWQnLCBpZClcbiAgICBzdHlsZS50ZXh0Q29udGVudCA9IGNvbnRlbnRcbiAgICBpZiAoY3NwTm9uY2UpIHtcbiAgICAgIHN0eWxlLnNldEF0dHJpYnV0ZSgnbm9uY2UnLCBjc3BOb25jZSlcbiAgICB9XG5cbiAgICBpZiAoIWxhc3RJbnNlcnRlZFN0eWxlKSB7XG4gICAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHN0eWxlKVxuXG4gICAgICAvLyByZXNldCBsYXN0SW5zZXJ0ZWRTdHlsZSBhZnRlciBhc3luY1xuICAgICAgLy8gYmVjYXVzZSBkeW5hbWljYWxseSBpbXBvcnRlZCBjc3Mgd2lsbCBiZSBzcGxpdHRlZCBpbnRvIGEgZGlmZmVyZW50IGZpbGVcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBsYXN0SW5zZXJ0ZWRTdHlsZSA9IHVuZGVmaW5lZFxuICAgICAgfSwgMClcbiAgICB9IGVsc2Uge1xuICAgICAgbGFzdEluc2VydGVkU3R5bGUuaW5zZXJ0QWRqYWNlbnRFbGVtZW50KCdhZnRlcmVuZCcsIHN0eWxlKVxuICAgIH1cbiAgICBsYXN0SW5zZXJ0ZWRTdHlsZSA9IHN0eWxlXG4gIH0gZWxzZSB7XG4gICAgc3R5bGUudGV4dENvbnRlbnQgPSBjb250ZW50XG4gIH1cbiAgc2hlZXRzTWFwLnNldChpZCwgc3R5bGUpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVTdHlsZShpZDogc3RyaW5nKTogdm9pZCB7XG4gIGNvbnN0IHN0eWxlID0gc2hlZXRzTWFwLmdldChpZClcbiAgaWYgKHN0eWxlKSB7XG4gICAgZG9jdW1lbnQuaGVhZC5yZW1vdmVDaGlsZChzdHlsZSlcbiAgICBzaGVldHNNYXAuZGVsZXRlKGlkKVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVIb3RDb250ZXh0KG93bmVyUGF0aDogc3RyaW5nKTogVml0ZUhvdENvbnRleHQge1xuICByZXR1cm4gbmV3IEhNUkNvbnRleHQoaG1yQ2xpZW50LCBvd25lclBhdGgpXG59XG5cbi8qKlxuICogdXJscyBoZXJlIGFyZSBkeW5hbWljIGltcG9ydCgpIHVybHMgdGhhdCBjb3VsZG4ndCBiZSBzdGF0aWNhbGx5IGFuYWx5emVkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbmplY3RRdWVyeSh1cmw6IHN0cmluZywgcXVlcnlUb0luamVjdDogc3RyaW5nKTogc3RyaW5nIHtcbiAgLy8gc2tpcCB1cmxzIHRoYXQgd29uJ3QgYmUgaGFuZGxlZCBieSB2aXRlXG4gIGlmICh1cmxbMF0gIT09ICcuJyAmJiB1cmxbMF0gIT09ICcvJykge1xuICAgIHJldHVybiB1cmxcbiAgfVxuXG4gIC8vIGNhbid0IHVzZSBwYXRobmFtZSBmcm9tIFVSTCBzaW5jZSBpdCBtYXkgYmUgcmVsYXRpdmUgbGlrZSAuLi9cbiAgY29uc3QgcGF0aG5hbWUgPSB1cmwucmVwbGFjZSgvWz8jXS4qJC8sICcnKVxuICBjb25zdCB7IHNlYXJjaCwgaGFzaCB9ID0gbmV3IFVSTCh1cmwsICdodHRwOi8vdml0ZWpzLmRldicpXG5cbiAgcmV0dXJuIGAke3BhdGhuYW1lfT8ke3F1ZXJ5VG9JbmplY3R9JHtzZWFyY2ggPyBgJmAgKyBzZWFyY2guc2xpY2UoMSkgOiAnJ30ke1xuICAgIGhhc2ggfHwgJydcbiAgfWBcbn1cblxuZXhwb3J0IHsgRXJyb3JPdmVybGF5IH1cbiJdLCJuYW1lcyI6WyJiYXNlIl0sIm1hcHBpbmdzIjoiOztNQWlDYSxVQUFVLENBQUE7SUFHckIsV0FDVSxDQUFBLFNBQW9CLEVBQ3BCLFNBQWlCLEVBQUE7UUFEakIsSUFBUyxDQUFBLFNBQUEsR0FBVCxTQUFTLENBQVc7UUFDcEIsSUFBUyxDQUFBLFNBQUEsR0FBVCxTQUFTLENBQVE7UUFFekIsSUFBSSxDQUFDLFNBQVMsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLFNBQVMsQ0FBQyxFQUFFO1lBQ3JDLFNBQVMsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLFNBQVMsRUFBRSxFQUFFLENBQUMsQ0FBQTtBQUNyQyxTQUFBOzs7UUFJRCxNQUFNLEdBQUcsR0FBRyxTQUFTLENBQUMsYUFBYSxDQUFDLEdBQUcsQ0FBQyxTQUFTLENBQUMsQ0FBQTtBQUNsRCxRQUFBLElBQUksR0FBRyxFQUFFO0FBQ1AsWUFBQSxHQUFHLENBQUMsU0FBUyxHQUFHLEVBQUUsQ0FBQTtBQUNuQixTQUFBOztRQUdELE1BQU0sY0FBYyxHQUFHLFNBQVMsQ0FBQyxpQkFBaUIsQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLENBQUE7QUFDakUsUUFBQSxJQUFJLGNBQWMsRUFBRTtZQUNsQixLQUFLLE1BQU0sQ0FBQyxLQUFLLEVBQUUsUUFBUSxDQUFDLElBQUksY0FBYyxFQUFFO2dCQUM5QyxNQUFNLFNBQVMsR0FBRyxTQUFTLENBQUMsa0JBQWtCLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFBO0FBQ3pELGdCQUFBLElBQUksU0FBUyxFQUFFO29CQUNiLFNBQVMsQ0FBQyxrQkFBa0IsQ0FBQyxHQUFHLENBQzlCLEtBQUssRUFDTCxTQUFTLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUMvQyxDQUFBO0FBQ0YsaUJBQUE7QUFDRixhQUFBO0FBQ0YsU0FBQTtBQUVELFFBQUEsSUFBSSxDQUFDLFlBQVksR0FBRyxJQUFJLEdBQUcsRUFBRSxDQUFBO1FBQzdCLFNBQVMsQ0FBQyxpQkFBaUIsQ0FBQyxHQUFHLENBQUMsU0FBUyxFQUFFLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQTtLQUM5RDtBQUVELElBQUEsSUFBSSxJQUFJLEdBQUE7QUFDTixRQUFBLE9BQU8sSUFBSSxDQUFDLFNBQVMsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQTtLQUNsRDtJQUVELE1BQU0sQ0FBQyxJQUFVLEVBQUUsUUFBYyxFQUFBO0FBQy9CLFFBQUEsSUFBSSxPQUFPLElBQUksS0FBSyxVQUFVLElBQUksQ0FBQyxJQUFJLEVBQUU7O1lBRXZDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxLQUFLLElBQUksS0FBSixJQUFBLElBQUEsSUFBSSxLQUFKLEtBQUEsQ0FBQSxHQUFBLEtBQUEsQ0FBQSxHQUFBLElBQUksQ0FBRyxHQUFHLENBQUMsQ0FBQyxDQUFBO0FBQzFELFNBQUE7QUFBTSxhQUFBLElBQUksT0FBTyxJQUFJLEtBQUssUUFBUSxFQUFFOztZQUVuQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxLQUFLLFFBQVEsS0FBQSxJQUFBLElBQVIsUUFBUSxLQUFBLEtBQUEsQ0FBQSxHQUFBLEtBQUEsQ0FBQSxHQUFSLFFBQVEsQ0FBRyxHQUFHLENBQUMsQ0FBQyxDQUFBO0FBQ3BELFNBQUE7QUFBTSxhQUFBLElBQUksS0FBSyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsRUFBRTtBQUM5QixZQUFBLElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxFQUFFLFFBQVEsQ0FBQyxDQUFBO0FBQ2hDLFNBQUE7QUFBTSxhQUFBO0FBQ0wsWUFBQSxNQUFNLElBQUksS0FBSyxDQUFDLENBQUEsMkJBQUEsQ0FBNkIsQ0FBQyxDQUFBO0FBQy9DLFNBQUE7S0FDRjs7O0lBSUQsYUFBYSxDQUNYLENBQTZCLEVBQzdCLFFBQTZCLEVBQUE7UUFFN0IsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsRUFBRSxDQUFDLENBQUMsR0FBRyxDQUFDLEtBQUssUUFBUSxLQUFSLElBQUEsSUFBQSxRQUFRLEtBQVIsS0FBQSxDQUFBLEdBQUEsS0FBQSxDQUFBLEdBQUEsUUFBUSxDQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUE7S0FDOUQ7QUFFRCxJQUFBLE9BQU8sQ0FBQyxFQUF1QixFQUFBO0FBQzdCLFFBQUEsSUFBSSxDQUFDLFNBQVMsQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxTQUFTLEVBQUUsRUFBRSxDQUFDLENBQUE7S0FDbEQ7QUFFRCxJQUFBLEtBQUssQ0FBQyxFQUF1QixFQUFBO0FBQzNCLFFBQUEsSUFBSSxDQUFDLFNBQVMsQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxTQUFTLEVBQUUsRUFBRSxDQUFDLENBQUE7S0FDaEQ7OztBQUlELElBQUEsT0FBTyxNQUFXO0FBRWxCLElBQUEsVUFBVSxDQUFDLE9BQWUsRUFBQTtBQUN4QixRQUFBLElBQUksQ0FBQyxTQUFTLENBQUMsZUFBZSxDQUFDLGlCQUFpQixFQUFFO1lBQ2hELElBQUksRUFBRSxJQUFJLENBQUMsU0FBUztZQUNwQixPQUFPO0FBQ1IsU0FBQSxDQUFDLENBQUE7QUFDRixRQUFBLElBQUksQ0FBQyxJQUFJLENBQUMsaUJBQWlCLEVBQUUsRUFBRSxJQUFJLEVBQUUsSUFBSSxDQUFDLFNBQVMsRUFBRSxPQUFPLEVBQUUsQ0FBQyxDQUFBO1FBQy9ELElBQUksQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FDekIsQ0FBQSxrQkFBQSxFQUFxQixJQUFJLENBQUMsU0FBUyxDQUFBLEVBQUcsT0FBTyxHQUFHLENBQUEsRUFBQSxFQUFLLE9BQU8sQ0FBQSxDQUFFLEdBQUcsRUFBRSxDQUFFLENBQUEsQ0FDdEUsQ0FBQTtLQUNGO0lBRUQsRUFBRSxDQUNBLEtBQVEsRUFDUixFQUFpRCxFQUFBO0FBRWpELFFBQUEsTUFBTSxRQUFRLEdBQUcsQ0FBQyxHQUF1QixLQUFJO1lBQzNDLE1BQU0sUUFBUSxHQUFHLEdBQUcsQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLElBQUksRUFBRSxDQUFBO0FBQ3JDLFlBQUEsUUFBUSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQTtBQUNqQixZQUFBLEdBQUcsQ0FBQyxHQUFHLENBQUMsS0FBSyxFQUFFLFFBQVEsQ0FBQyxDQUFBO0FBQzFCLFNBQUMsQ0FBQTtBQUNELFFBQUEsUUFBUSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsa0JBQWtCLENBQUMsQ0FBQTtBQUMzQyxRQUFBLFFBQVEsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUE7S0FDNUI7SUFFRCxHQUFHLENBQ0QsS0FBUSxFQUNSLEVBQWlELEVBQUE7QUFFakQsUUFBQSxNQUFNLGFBQWEsR0FBRyxDQUFDLEdBQXVCLEtBQUk7WUFDaEQsTUFBTSxRQUFRLEdBQUcsR0FBRyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQTtZQUMvQixJQUFJLFFBQVEsS0FBSyxTQUFTLEVBQUU7Z0JBQzFCLE9BQU07QUFDUCxhQUFBO0FBQ0QsWUFBQSxNQUFNLE1BQU0sR0FBRyxRQUFRLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQTtBQUMvQyxZQUFBLElBQUksTUFBTSxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7QUFDdkIsZ0JBQUEsR0FBRyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQTtnQkFDakIsT0FBTTtBQUNQLGFBQUE7QUFDRCxZQUFBLEdBQUcsQ0FBQyxHQUFHLENBQUMsS0FBSyxFQUFFLE1BQU0sQ0FBQyxDQUFBO0FBQ3hCLFNBQUMsQ0FBQTtBQUNELFFBQUEsYUFBYSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsa0JBQWtCLENBQUMsQ0FBQTtBQUNoRCxRQUFBLGFBQWEsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUE7S0FDakM7SUFFRCxJQUFJLENBQW1CLEtBQVEsRUFBRSxJQUFpQyxFQUFBO1FBQ2hFLElBQUksQ0FBQyxTQUFTLENBQUMsU0FBUyxDQUFDLElBQUksQ0FDM0IsSUFBSSxDQUFDLFNBQVMsQ0FBQyxFQUFFLElBQUksRUFBRSxRQUFRLEVBQUUsS0FBSyxFQUFFLElBQUksRUFBRSxDQUFDLENBQ2hELENBQUE7S0FDRjtBQUVPLElBQUEsVUFBVSxDQUNoQixJQUFjLEVBQ2QsV0FBOEIsU0FBUSxFQUFBO0FBRXRDLFFBQUEsTUFBTSxHQUFHLEdBQWMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxhQUFhLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSTtZQUN6RSxFQUFFLEVBQUUsSUFBSSxDQUFDLFNBQVM7QUFDbEIsWUFBQSxTQUFTLEVBQUUsRUFBRTtTQUNkLENBQUE7QUFDRCxRQUFBLEdBQUcsQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDO1lBQ2pCLElBQUk7QUFDSixZQUFBLEVBQUUsRUFBRSxRQUFRO0FBQ2IsU0FBQSxDQUFDLENBQUE7QUFDRixRQUFBLElBQUksQ0FBQyxTQUFTLENBQUMsYUFBYSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsU0FBUyxFQUFFLEdBQUcsQ0FBQyxDQUFBO0tBQ3REO0FBQ0YsQ0FBQTtBQUVELE1BQU0sWUFBWSxDQUFBO0FBQ2hCLElBQUEsV0FBQSxDQUFvQixVQUF5QixFQUFBO1FBQXpCLElBQVUsQ0FBQSxVQUFBLEdBQVYsVUFBVSxDQUFlO1FBRXJDLElBQUssQ0FBQSxLQUFBLEdBQWEsRUFBRSxDQUFBO0tBRnFCO0FBSTFDLElBQUEsSUFBSSxDQUFDLE9BQWUsRUFBQTtBQUN6QixRQUFBLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFBO1FBQ3hCLElBQUksQ0FBQyxLQUFLLEVBQUUsQ0FBQTtLQUNiO0lBRU0sS0FBSyxHQUFBO0FBQ1YsUUFBQSxJQUFJLElBQUksQ0FBQyxVQUFVLENBQUMsT0FBTyxFQUFFLEVBQUU7QUFDN0IsWUFBQSxJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDLEdBQUcsS0FBSyxJQUFJLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFBO0FBQ3RELFlBQUEsSUFBSSxDQUFDLEtBQUssR0FBRyxFQUFFLENBQUE7QUFDaEIsU0FBQTtLQUNGO0FBQ0YsQ0FBQTtNQUVZLFNBQVMsQ0FBQTtJQVVwQixXQUNTLENBQUEsTUFBaUIsRUFDeEIsVUFBeUI7O0lBRWpCLG1CQUFpRSxFQUFBO1FBSGxFLElBQU0sQ0FBQSxNQUFBLEdBQU4sTUFBTSxDQUFXO1FBR2hCLElBQW1CLENBQUEsbUJBQUEsR0FBbkIsbUJBQW1CLENBQThDO0FBYnBFLFFBQUEsSUFBQSxDQUFBLGFBQWEsR0FBRyxJQUFJLEdBQUcsRUFBcUIsQ0FBQTtBQUM1QyxRQUFBLElBQUEsQ0FBQSxVQUFVLEdBQUcsSUFBSSxHQUFHLEVBQStDLENBQUE7QUFDbkUsUUFBQSxJQUFBLENBQUEsUUFBUSxHQUFHLElBQUksR0FBRyxFQUErQyxDQUFBO0FBQ2pFLFFBQUEsSUFBQSxDQUFBLE9BQU8sR0FBRyxJQUFJLEdBQUcsRUFBZSxDQUFBO0FBQ2hDLFFBQUEsSUFBQSxDQUFBLGtCQUFrQixHQUF1QixJQUFJLEdBQUcsRUFBRSxDQUFBO0FBQ2xELFFBQUEsSUFBQSxDQUFBLGlCQUFpQixHQUFHLElBQUksR0FBRyxFQUE4QixDQUFBO1FBOER4RCxJQUFXLENBQUEsV0FBQSxHQUF3QyxFQUFFLENBQUE7UUFDckQsSUFBa0IsQ0FBQSxrQkFBQSxHQUFHLEtBQUssQ0FBQTtRQXJEaEMsSUFBSSxDQUFDLFNBQVMsR0FBRyxJQUFJLFlBQVksQ0FBQyxVQUFVLENBQUMsQ0FBQTtLQUM5QztBQU1NLElBQUEsTUFBTSxlQUFlLENBQUMsS0FBYSxFQUFFLElBQVMsRUFBQTtRQUNuRCxNQUFNLEdBQUcsR0FBRyxJQUFJLENBQUMsa0JBQWtCLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFBO0FBQzlDLFFBQUEsSUFBSSxHQUFHLEVBQUU7QUFDUCxZQUFBLE1BQU0sT0FBTyxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxLQUFLLEVBQUUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUE7QUFDcEQsU0FBQTtLQUNGO0lBRU0sS0FBSyxHQUFBO0FBQ1YsUUFBQSxJQUFJLENBQUMsYUFBYSxDQUFDLEtBQUssRUFBRSxDQUFBO0FBQzFCLFFBQUEsSUFBSSxDQUFDLFVBQVUsQ0FBQyxLQUFLLEVBQUUsQ0FBQTtBQUN2QixRQUFBLElBQUksQ0FBQyxRQUFRLENBQUMsS0FBSyxFQUFFLENBQUE7QUFDckIsUUFBQSxJQUFJLENBQUMsT0FBTyxDQUFDLEtBQUssRUFBRSxDQUFBO0FBQ3BCLFFBQUEsSUFBSSxDQUFDLGtCQUFrQixDQUFDLEtBQUssRUFBRSxDQUFBO0FBQy9CLFFBQUEsSUFBSSxDQUFDLGlCQUFpQixDQUFDLEtBQUssRUFBRSxDQUFBO0tBQy9COzs7O0lBS00sTUFBTSxVQUFVLENBQUMsS0FBZSxFQUFBO1FBQ3JDLE1BQU0sT0FBTyxDQUFDLEdBQUcsQ0FDZixLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxLQUFJO1lBQ2pCLE1BQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFBO0FBQzFDLFlBQUEsSUFBSSxRQUFRO2dCQUFFLE9BQU8sUUFBUSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUE7U0FDdEQsQ0FBQyxDQUNILENBQUE7QUFDRCxRQUFBLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQyxJQUFJLEtBQUk7WUFDckIsTUFBTSxFQUFFLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUE7QUFDbEMsWUFBQSxJQUFJLEVBQUUsRUFBRTtnQkFDTixFQUFFLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQTtBQUMzQixhQUFBO0FBQ0gsU0FBQyxDQUFDLENBQUE7S0FDSDtJQUVTLGdCQUFnQixDQUFDLEdBQVUsRUFBRSxJQUF1QixFQUFBO1FBQzVELElBQUksQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsRUFBRTtBQUNsQyxZQUFBLElBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFBO0FBQ3ZCLFNBQUE7QUFDRCxRQUFBLElBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUNmLENBQUEsdUJBQUEsRUFBMEIsSUFBSSxDQUFJLEVBQUEsQ0FBQTtZQUNoQyxDQUErRCw2REFBQSxDQUFBO0FBQy9ELFlBQUEsQ0FBQSwyQkFBQSxDQUE2QixDQUNoQyxDQUFBO0tBQ0Y7QUFLRDs7OztBQUlHO0lBQ0ksTUFBTSxXQUFXLENBQUMsT0FBZSxFQUFBO0FBQ3RDLFFBQUEsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFBO0FBQ2hELFFBQUEsSUFBSSxDQUFDLElBQUksQ0FBQyxrQkFBa0IsRUFBRTtBQUM1QixZQUFBLElBQUksQ0FBQyxrQkFBa0IsR0FBRyxJQUFJLENBQUE7QUFDOUIsWUFBQSxNQUFNLE9BQU8sQ0FBQyxPQUFPLEVBQUUsQ0FBQTtBQUN2QixZQUFBLElBQUksQ0FBQyxrQkFBa0IsR0FBRyxLQUFLLENBQUE7WUFDL0IsTUFBTSxPQUFPLEdBQUcsQ0FBQyxHQUFHLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQTtBQUNyQyxZQUFBLElBQUksQ0FBQyxXQUFXLEdBQUcsRUFBRSxDQUNwQjtZQUFBLENBQUMsTUFBTSxPQUFPLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxFQUFFLE9BQU8sQ0FBQyxDQUFDLEVBQUUsS0FBSyxFQUFFLElBQUksRUFBRSxFQUFFLENBQUMsQ0FBQTtBQUMxRCxTQUFBO0tBQ0Y7SUFFTyxNQUFNLFdBQVcsQ0FBQyxNQUFjLEVBQUE7QUFDdEMsUUFBQSxNQUFNLEVBQUUsSUFBSSxFQUFFLFlBQVksRUFBRSxHQUFHLE1BQU0sQ0FBQTtRQUNyQyxNQUFNLEdBQUcsR0FBRyxJQUFJLENBQUMsYUFBYSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQTtRQUN4QyxJQUFJLENBQUMsR0FBRyxFQUFFOzs7O1lBSVIsT0FBTTtBQUNQLFNBQUE7QUFFRCxRQUFBLElBQUksYUFBMEMsQ0FBQTtBQUM5QyxRQUFBLE1BQU0sWUFBWSxHQUFHLElBQUksS0FBSyxZQUFZLENBQUE7O1FBRzFDLE1BQU0sa0JBQWtCLEdBQUcsR0FBRyxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFFLElBQUksRUFBRSxLQUN2RCxJQUFJLENBQUMsUUFBUSxDQUFDLFlBQVksQ0FBQyxDQUM1QixDQUFBO0FBRUQsUUFBQSxJQUFJLFlBQVksSUFBSSxrQkFBa0IsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFO1lBQ2pELE1BQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLFlBQVksQ0FBQyxDQUFBO0FBQ2xELFlBQUEsSUFBSSxRQUFRO2dCQUFFLE1BQU0sUUFBUSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUE7WUFDNUQsSUFBSTtnQkFDRixhQUFhLEdBQUcsTUFBTSxJQUFJLENBQUMsbUJBQW1CLENBQUMsTUFBTSxDQUFDLENBQUE7QUFDdkQsYUFBQTtBQUFDLFlBQUEsT0FBTyxDQUFDLEVBQUU7QUFDVixnQkFBQSxJQUFJLENBQUMsZ0JBQWdCLENBQUMsQ0FBQyxFQUFFLFlBQVksQ0FBQyxDQUFBO0FBQ3ZDLGFBQUE7QUFDRixTQUFBO0FBRUQsUUFBQSxPQUFPLE1BQUs7WUFDVixLQUFLLE1BQU0sRUFBRSxJQUFJLEVBQUUsRUFBRSxFQUFFLElBQUksa0JBQWtCLEVBQUU7Z0JBQzdDLEVBQUUsQ0FDQSxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxNQUFNLEdBQUcsS0FBSyxZQUFZLEdBQUcsYUFBYSxHQUFHLFNBQVMsQ0FBQyxDQUFDLENBQ3RFLENBQUE7QUFDRixhQUFBO0FBQ0QsWUFBQSxNQUFNLFVBQVUsR0FBRyxZQUFZLEdBQUcsSUFBSSxHQUFHLENBQUcsRUFBQSxZQUFZLENBQVEsS0FBQSxFQUFBLElBQUksRUFBRSxDQUFBO1lBQ3RFLElBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQXVCLG9CQUFBLEVBQUEsVUFBVSxDQUFFLENBQUEsQ0FBQyxDQUFBO0FBQ3hELFNBQUMsQ0FBQTtLQUNGO0FBQ0Y7O0FDeFRELE1BQU0sYUFBYSxHQUFHLG1CQUFtQixDQUFBO0FBQ3pDLE1BQU1BLE1BQUksR0FBRyxRQUFRLElBQUksR0FBRyxDQUFBO0FBRTVCO0FBQ0EsU0FBUyxDQUFDLENBQ1IsQ0FBUyxFQUNULFFBQWdDLEVBQUUsRUFDbEMsR0FBRyxRQUEyQixFQUFBO0lBRTlCLE1BQU0sSUFBSSxHQUFHLFFBQVEsQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDLENBQUE7QUFDdEMsSUFBQSxLQUFLLE1BQU0sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLElBQUksTUFBTSxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsRUFBRTtBQUMxQyxRQUFBLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFBO0FBQ3hCLEtBQUE7QUFDRCxJQUFBLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxRQUFRLENBQUMsQ0FBQTtBQUN4QixJQUFBLE9BQU8sSUFBSSxDQUFBO0FBQ2IsQ0FBQztBQUVEO0FBQ0EsTUFBTSxhQUFhLFdBQVcsQ0FBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0E0STdCLENBQUE7QUFFRDtBQUNBLElBQUksUUFBcUIsQ0FBQTtBQUN6QixNQUFNLGNBQWMsR0FBRyxNQUNyQixDQUFDLENBQ0MsS0FBSyxFQUNMLEVBQUUsS0FBSyxFQUFFLFVBQVUsRUFBRSxJQUFJLEVBQUUsVUFBVSxFQUFFLEVBQ3ZDLENBQUMsQ0FDQyxLQUFLLEVBQ0wsRUFBRSxLQUFLLEVBQUUsUUFBUSxFQUFFLElBQUksRUFBRSxRQUFRLEVBQUUsRUFDbkMsQ0FBQyxDQUNDLEtBQUssRUFDTCxFQUFFLEtBQUssRUFBRSxTQUFTLEVBQUUsSUFBSSxFQUFFLFNBQVMsRUFBRSxFQUNyQyxDQUFDLENBQUMsTUFBTSxFQUFFLEVBQUUsS0FBSyxFQUFFLFFBQVEsRUFBRSxJQUFJLEVBQUUsUUFBUSxFQUFFLENBQUMsRUFDOUMsQ0FBQyxDQUFDLE1BQU0sRUFBRSxFQUFFLEtBQUssRUFBRSxjQUFjLEVBQUUsSUFBSSxFQUFFLGNBQWMsRUFBRSxDQUFDLENBQzNELEVBQ0QsQ0FBQyxDQUFDLEtBQUssRUFBRSxFQUFFLEtBQUssRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFLE1BQU0sRUFBRSxDQUFDLEVBQ3pDLENBQUMsQ0FBQyxLQUFLLEVBQUUsRUFBRSxLQUFLLEVBQUUsT0FBTyxFQUFFLElBQUksRUFBRSxPQUFPLEVBQUUsQ0FBQyxFQUMzQyxDQUFDLENBQUMsS0FBSyxFQUFFLEVBQUUsS0FBSyxFQUFFLE9BQU8sRUFBRSxJQUFJLEVBQUUsT0FBTyxFQUFFLENBQUMsRUFDM0MsQ0FBQyxDQUNDLEtBQUssRUFDTCxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUUsSUFBSSxFQUFFLEtBQUssRUFBRSxFQUM3Qix1QkFBdUIsRUFDdkIsQ0FBQyxDQUFDLEtBQUssRUFBRSxFQUFFLEVBQUUsS0FBSyxDQUFDLEVBQ25CLG1DQUFtQyxFQUNuQyxDQUFDLENBQUMsSUFBSSxDQUFDLEVBQ1AsK0NBQStDLEVBQy9DLENBQUMsQ0FBQyxNQUFNLEVBQUUsRUFBRSxJQUFJLEVBQUUsb0JBQW9CLEVBQUUsRUFBRSxvQkFBb0IsQ0FBQyxFQUMvRCxNQUFNLEVBQ04sQ0FBQyxDQUFDLE1BQU0sRUFBRSxFQUFFLElBQUksRUFBRSxxQkFBcUIsRUFBRSxFQUFFLE9BQU8sQ0FBQyxFQUNuRCxNQUFNLEVBQ04sQ0FBQyxDQUFDLE1BQU0sRUFBRSxFQUFFLElBQUksRUFBRSxrQkFBa0IsRUFBRSxFQUFFLGFBQWEsQ0FBQyxFQUN0RCxHQUFHLENBQ0osQ0FDRixFQUNELENBQUMsQ0FBQyxPQUFPLEVBQUUsRUFBRSxFQUFFLGFBQWEsQ0FBQyxDQUM5QixDQUFBO0FBRUgsTUFBTSxNQUFNLEdBQUcsZ0NBQWdDLENBQUE7QUFDL0MsTUFBTSxXQUFXLEdBQUcsMENBQTBDLENBQUE7QUFFOUQ7QUFDQTtBQUNBLE1BQU0sRUFBRSxXQUFXLEdBQUcsTUFBQTtDQUF5QyxFQUFFLEdBQUcsVUFBVSxDQUFBO0FBQ3hFLE1BQU8sWUFBYSxTQUFRLFdBQVcsQ0FBQTtBQUkzQyxJQUFBLFdBQUEsQ0FBWSxHQUF3QixFQUFFLEtBQUssR0FBRyxJQUFJLEVBQUE7O0FBQ2hELFFBQUEsS0FBSyxFQUFFLENBQUE7QUFDUCxRQUFBLElBQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxFQUFFLElBQUksRUFBRSxNQUFNLEVBQUUsQ0FBQyxDQUFBO1FBRS9DLFFBQVEsS0FBQSxJQUFBLElBQVIsUUFBUSxLQUFSLEtBQUEsQ0FBQSxHQUFBLFFBQVEsSUFBUixRQUFRLEdBQUssY0FBYyxFQUFFLENBQUEsQ0FBQTtBQUM3QixRQUFBLElBQUksQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLFFBQVEsQ0FBQyxDQUFBO0FBRS9CLFFBQUEsV0FBVyxDQUFDLFNBQVMsR0FBRyxDQUFDLENBQUE7QUFDekIsUUFBQSxNQUFNLFFBQVEsR0FBRyxHQUFHLENBQUMsS0FBSyxJQUFJLFdBQVcsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFBO1FBQ3pELE1BQU0sT0FBTyxHQUFHLFFBQVE7Y0FDcEIsR0FBRyxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsV0FBVyxFQUFFLEVBQUUsQ0FBQztBQUN0QyxjQUFFLEdBQUcsQ0FBQyxPQUFPLENBQUE7UUFDZixJQUFJLEdBQUcsQ0FBQyxNQUFNLEVBQUU7WUFDZCxJQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsRUFBRSxDQUFXLFFBQUEsRUFBQSxHQUFHLENBQUMsTUFBTSxDQUFJLEVBQUEsQ0FBQSxDQUFDLENBQUE7QUFDaEQsU0FBQTtRQUNELElBQUksQ0FBQyxJQUFJLENBQUMsZUFBZSxFQUFFLE9BQU8sQ0FBQyxJQUFJLEVBQUUsQ0FBQyxDQUFBO1FBRTFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUEsQ0FBQSxFQUFBLEdBQUEsR0FBRyxDQUFDLEdBQUcsTUFBRSxJQUFBLElBQUEsRUFBQSxLQUFBLEtBQUEsQ0FBQSxHQUFBLEtBQUEsQ0FBQSxHQUFBLEVBQUEsQ0FBQSxJQUFJLEtBQUksR0FBRyxDQUFDLEVBQUUsSUFBSSxjQUFjLEVBQUUsS0FBSyxDQUFDLENBQUcsQ0FBQSxDQUFBLENBQUMsQ0FBQTtRQUNyRSxJQUFJLEdBQUcsQ0FBQyxHQUFHLEVBQUU7WUFDWCxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxDQUFHLEVBQUEsSUFBSSxDQUFJLENBQUEsRUFBQSxHQUFHLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQSxDQUFBLEVBQUksR0FBRyxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUUsQ0FBQSxFQUFFLEtBQUssQ0FBQyxDQUFBO0FBQ3ZFLFNBQUE7YUFBTSxJQUFJLEdBQUcsQ0FBQyxFQUFFLEVBQUU7QUFDakIsWUFBQSxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxJQUFJLENBQUMsQ0FBQTtBQUN6QixTQUFBO0FBRUQsUUFBQSxJQUFJLFFBQVEsRUFBRTtBQUNaLFlBQUEsSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUUsR0FBRyxDQUFDLEtBQU0sQ0FBQyxJQUFJLEVBQUUsQ0FBQyxDQUFBO0FBQ3ZDLFNBQUE7UUFDRCxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxHQUFHLENBQUMsS0FBSyxFQUFFLEtBQUssQ0FBQyxDQUFBO0FBRXJDLFFBQUEsSUFBSSxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsU0FBUyxDQUFFLENBQUMsZ0JBQWdCLENBQUMsT0FBTyxFQUFFLENBQUMsQ0FBQyxLQUFJO1lBQ2xFLENBQUMsQ0FBQyxlQUFlLEVBQUUsQ0FBQTtBQUNyQixTQUFDLENBQUMsQ0FBQTtBQUVGLFFBQUEsSUFBSSxDQUFDLGdCQUFnQixDQUFDLE9BQU8sRUFBRSxNQUFLO1lBQ2xDLElBQUksQ0FBQyxLQUFLLEVBQUUsQ0FBQTtBQUNkLFNBQUMsQ0FBQyxDQUFBO0FBRUYsUUFBQSxJQUFJLENBQUMsVUFBVSxHQUFHLENBQUMsQ0FBZ0IsS0FBSTtZQUNyQyxJQUFJLENBQUMsQ0FBQyxHQUFHLEtBQUssUUFBUSxJQUFJLENBQUMsQ0FBQyxJQUFJLEtBQUssUUFBUSxFQUFFO2dCQUM3QyxJQUFJLENBQUMsS0FBSyxFQUFFLENBQUE7QUFDYixhQUFBO0FBQ0gsU0FBQyxDQUFBO1FBRUQsUUFBUSxDQUFDLGdCQUFnQixDQUFDLFNBQVMsRUFBRSxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUE7S0FDdEQ7QUFFRCxJQUFBLElBQUksQ0FBQyxRQUFnQixFQUFFLElBQVksRUFBRSxTQUFTLEdBQUcsS0FBSyxFQUFBO1FBQ3BELE1BQU0sRUFBRSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLFFBQVEsQ0FBRSxDQUFBO1FBQzdDLElBQUksQ0FBQyxTQUFTLEVBQUU7QUFDZCxZQUFBLEVBQUUsQ0FBQyxXQUFXLEdBQUcsSUFBSSxDQUFBO0FBQ3RCLFNBQUE7QUFBTSxhQUFBO1lBQ0wsSUFBSSxRQUFRLEdBQUcsQ0FBQyxDQUFBO0FBQ2hCLFlBQUEsSUFBSSxLQUE2QixDQUFBO0FBQ2pDLFlBQUEsTUFBTSxDQUFDLFNBQVMsR0FBRyxDQUFDLENBQUE7WUFDcEIsUUFBUSxLQUFLLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRztnQkFDbEMsTUFBTSxFQUFFLENBQUMsRUFBRSxJQUFJLEVBQUUsS0FBSyxFQUFFLEdBQUcsS0FBSyxDQUFBO2dCQUNoQyxJQUFJLEtBQUssSUFBSSxJQUFJLEVBQUU7b0JBQ2pCLE1BQU0sSUFBSSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsUUFBUSxFQUFFLEtBQUssQ0FBQyxDQUFBO29CQUN4QyxFQUFFLENBQUMsV0FBVyxDQUFDLFFBQVEsQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQTtvQkFDN0MsTUFBTSxJQUFJLEdBQUcsUUFBUSxDQUFDLGFBQWEsQ0FBQyxHQUFHLENBQUMsQ0FBQTtBQUN4QyxvQkFBQSxJQUFJLENBQUMsV0FBVyxHQUFHLElBQUksQ0FBQTtBQUN2QixvQkFBQSxJQUFJLENBQUMsU0FBUyxHQUFHLFdBQVcsQ0FBQTtBQUM1QixvQkFBQSxJQUFJLENBQUMsT0FBTyxHQUFHLE1BQUs7d0JBQ2xCLEtBQUssQ0FDSCxJQUFJLEdBQUcsQ0FDTCxHQUFHQSxNQUFJLENBQUEsc0JBQUEsRUFBeUIsa0JBQWtCLENBQUMsSUFBSSxDQUFDLENBQUUsQ0FBQSxFQUMxRCxNQUFNLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FDaEIsQ0FDRixDQUFBO0FBQ0gscUJBQUMsQ0FBQTtBQUNELG9CQUFBLEVBQUUsQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLENBQUE7b0JBQ3BCLFFBQVEsSUFBSSxJQUFJLENBQUMsTUFBTSxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUE7QUFDdEMsaUJBQUE7QUFDRixhQUFBO0FBQ0YsU0FBQTtLQUNGO0lBQ0QsS0FBSyxHQUFBOztRQUNILENBQUEsRUFBQSxHQUFBLElBQUksQ0FBQyxVQUFVLE1BQUEsSUFBQSxJQUFBLEVBQUEsS0FBQSxLQUFBLENBQUEsR0FBQSxLQUFBLENBQUEsR0FBQSxFQUFBLENBQUUsV0FBVyxDQUFDLElBQUksQ0FBQyxDQUFBO1FBQ2xDLFFBQVEsQ0FBQyxtQkFBbUIsQ0FBQyxTQUFTLEVBQUUsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFBO0tBQ3pEO0FBQ0YsQ0FBQTtBQUVNLE1BQU0sU0FBUyxHQUFHLG9CQUFvQixDQUFBO0FBQzdDLE1BQU0sRUFBRSxjQUFjLEVBQUUsR0FBRyxVQUFVLENBQUE7QUFDckMsSUFBSSxjQUFjLElBQUksQ0FBQyxjQUFjLENBQUMsR0FBRyxDQUFDLFNBQVMsQ0FBQyxFQUFFO0FBQ3BELElBQUEsY0FBYyxDQUFDLE1BQU0sQ0FBQyxTQUFTLEVBQUUsWUFBWSxDQUFDLENBQUE7QUFDL0M7OztBQ3pSRCxPQUFPLENBQUMsS0FBSyxDQUFDLHNCQUFzQixDQUFDLENBQUE7QUFFckMsTUFBTSxhQUFhLEdBQUcsSUFBSSxHQUFHLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQTtBQUU5QztBQUNBLE1BQU0sVUFBVSxHQUFHLGVBQWUsQ0FBQTtBQUNsQyxNQUFNLGNBQWMsR0FDbEIsZ0JBQWdCLEtBQUssYUFBYSxDQUFDLFFBQVEsS0FBSyxRQUFRLEdBQUcsS0FBSyxHQUFHLElBQUksQ0FBQyxDQUFBO0FBQzFFLE1BQU0sT0FBTyxHQUFHLFlBQVksQ0FBQTtBQUM1QixNQUFNLFVBQVUsR0FBRyxDQUFBLEVBQUcsZ0JBQWdCLElBQUksYUFBYSxDQUFDLFFBQVEsQ0FDOUQsQ0FBQSxFQUFBLE9BQU8sSUFBSSxhQUFhLENBQUMsSUFDM0IsQ0FBRyxFQUFBLFlBQVksRUFBRSxDQUFBO0FBQ2pCLE1BQU0sZ0JBQWdCLEdBQUcscUJBQXFCLENBQUE7QUFDOUMsTUFBTSxJQUFJLEdBQUcsUUFBUSxJQUFJLEdBQUcsQ0FBQTtBQUU1QixJQUFJLE1BQWlCLENBQUE7QUFDckIsSUFBSTtBQUNGLElBQUEsSUFBSSxRQUFrQyxDQUFBOztJQUV0QyxJQUFJLENBQUMsT0FBTyxFQUFFO1FBQ1osUUFBUSxHQUFHLE1BQUs7OztZQUdkLE1BQU0sR0FBRyxjQUFjLENBQUMsY0FBYyxFQUFFLGdCQUFnQixFQUFFLE1BQUs7Z0JBQzdELE1BQU0sb0JBQW9CLEdBQUcsSUFBSSxHQUFHLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQTtBQUNyRCxnQkFBQSxNQUFNLGlCQUFpQixHQUNyQixvQkFBb0IsQ0FBQyxJQUFJO29CQUN6QixvQkFBb0IsQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLGdCQUFnQixFQUFFLEVBQUUsQ0FBQyxDQUFBO2dCQUM3RCxPQUFPLENBQUMsS0FBSyxDQUNYLDBDQUEwQztvQkFDeEMsdUJBQXVCO29CQUN2QixDQUFlLFlBQUEsRUFBQSxpQkFBaUIsQ0FBaUIsY0FBQSxFQUFBLFVBQVUsQ0FBYSxXQUFBLENBQUE7b0JBQ3hFLENBQWUsWUFBQSxFQUFBLFVBQVUsQ0FBZ0MsNkJBQUEsRUFBQSxnQkFBZ0IsQ0FBYSxXQUFBLENBQUE7QUFDdEYsb0JBQUEsNEdBQTRHLENBQy9HLENBQUE7QUFDSCxhQUFDLENBQUMsQ0FBQTtBQUNGLFlBQUEsTUFBTSxDQUFDLGdCQUFnQixDQUNyQixNQUFNLEVBQ04sTUFBSztBQUNILGdCQUFBLE9BQU8sQ0FBQyxJQUFJLENBQ1YsMEpBQTBKLENBQzNKLENBQUE7QUFDSCxhQUFDLEVBQ0QsRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLENBQ2YsQ0FBQTtBQUNILFNBQUMsQ0FBQTtBQUNGLEtBQUE7SUFFRCxNQUFNLEdBQUcsY0FBYyxDQUFDLGNBQWMsRUFBRSxVQUFVLEVBQUUsUUFBUSxDQUFDLENBQUE7QUFDOUQsQ0FBQTtBQUFDLE9BQU8sS0FBSyxFQUFFO0FBQ2QsSUFBQSxPQUFPLENBQUMsS0FBSyxDQUFDLDBDQUEwQyxLQUFLLENBQUEsR0FBQSxDQUFLLENBQUMsQ0FBQTtBQUNwRSxDQUFBO0FBRUQsU0FBUyxjQUFjLENBQ3JCLFFBQWdCLEVBQ2hCLFdBQW1CLEVBQ25CLGtCQUErQixFQUFBO0FBRS9CLElBQUEsTUFBTSxNQUFNLEdBQUcsSUFBSSxTQUFTLENBQUMsQ0FBQSxFQUFHLFFBQVEsQ0FBQSxHQUFBLEVBQU0sV0FBVyxDQUFBLENBQUUsRUFBRSxVQUFVLENBQUMsQ0FBQTtJQUN4RSxJQUFJLFFBQVEsR0FBRyxLQUFLLENBQUE7QUFFcEIsSUFBQSxNQUFNLENBQUMsZ0JBQWdCLENBQ3JCLE1BQU0sRUFDTixNQUFLO1FBQ0gsUUFBUSxHQUFHLElBQUksQ0FBQTtRQUNmLGVBQWUsQ0FBQyxpQkFBaUIsRUFBRSxFQUFFLFNBQVMsRUFBRSxNQUFNLEVBQUUsQ0FBQyxDQUFBO0FBQzNELEtBQUMsRUFDRCxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsQ0FDZixDQUFBOztJQUdELE1BQU0sQ0FBQyxnQkFBZ0IsQ0FBQyxTQUFTLEVBQUUsT0FBTyxFQUFFLElBQUksRUFBRSxLQUFJO1FBQ3BELGFBQWEsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUE7QUFDakMsS0FBQyxDQUFDLENBQUE7O0lBR0YsTUFBTSxDQUFDLGdCQUFnQixDQUFDLE9BQU8sRUFBRSxPQUFPLEVBQUUsUUFBUSxFQUFFLEtBQUk7QUFDdEQsUUFBQSxJQUFJLFFBQVE7WUFBRSxPQUFNO0FBRXBCLFFBQUEsSUFBSSxDQUFDLFFBQVEsSUFBSSxrQkFBa0IsRUFBRTtBQUNuQyxZQUFBLGtCQUFrQixFQUFFLENBQUE7WUFDcEIsT0FBTTtBQUNQLFNBQUE7UUFFRCxlQUFlLENBQUMsb0JBQW9CLEVBQUUsRUFBRSxTQUFTLEVBQUUsTUFBTSxFQUFFLENBQUMsQ0FBQTtBQUU1RCxRQUFBLElBQUksV0FBVyxFQUFFO0FBQ2YsWUFBQSxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUEscURBQUEsQ0FBdUQsQ0FBQyxDQUFBO0FBQ3BFLFlBQUEsTUFBTSxxQkFBcUIsQ0FBQyxRQUFRLEVBQUUsV0FBVyxDQUFDLENBQUE7WUFDbEQsUUFBUSxDQUFDLE1BQU0sRUFBRSxDQUFBO0FBQ2xCLFNBQUE7QUFDSCxLQUFDLENBQUMsQ0FBQTtBQUVGLElBQUEsT0FBTyxNQUFNLENBQUE7QUFDZixDQUFDO0FBRUQsU0FBUyxRQUFRLENBQUMsUUFBZ0IsRUFBQTtJQUNoQyxNQUFNLEdBQUcsR0FBRyxJQUFJLEdBQUcsQ0FBQyxRQUFRLEVBQUUsbUJBQW1CLENBQUMsQ0FBQTtBQUNsRCxJQUFBLEdBQUcsQ0FBQyxZQUFZLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxDQUFBO0FBQ2pDLElBQUEsT0FBTyxHQUFHLENBQUMsUUFBUSxHQUFHLEdBQUcsQ0FBQyxNQUFNLENBQUE7QUFDbEMsQ0FBQztBQUVELElBQUksYUFBYSxHQUFHLElBQUksQ0FBQTtBQUN4QixNQUFNLGdCQUFnQixHQUFHLElBQUksT0FBTyxFQUFtQixDQUFBO0FBRXZELE1BQU0sY0FBYyxHQUFHLENBQUMsSUFBWSxLQUFJO0FBQ3RDLElBQUEsSUFBSSxLQUEyQyxDQUFBO0FBQy9DLElBQUEsT0FBTyxNQUFLO0FBQ1YsUUFBQSxJQUFJLEtBQUssRUFBRTtZQUNULFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQTtZQUNuQixLQUFLLEdBQUcsSUFBSSxDQUFBO0FBQ2IsU0FBQTtBQUNELFFBQUEsS0FBSyxHQUFHLFVBQVUsQ0FBQyxNQUFLO1lBQ3RCLFFBQVEsQ0FBQyxNQUFNLEVBQUUsQ0FBQTtTQUNsQixFQUFFLElBQUksQ0FBQyxDQUFBO0FBQ1YsS0FBQyxDQUFBO0FBQ0gsQ0FBQyxDQUFBO0FBQ0QsTUFBTSxVQUFVLEdBQUcsY0FBYyxDQUFDLEVBQUUsQ0FBQyxDQUFBO0FBRXJDLE1BQU0sU0FBUyxHQUFHLElBQUksU0FBUyxDQUM3QixPQUFPLEVBQ1A7SUFDRSxPQUFPLEVBQUUsTUFBTSxNQUFNLElBQUksTUFBTSxDQUFDLFVBQVUsS0FBSyxDQUFDO0lBQ2hELElBQUksRUFBRSxDQUFDLE9BQU8sS0FBSyxNQUFNLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQztBQUN4QyxDQUFBLEVBQ0QsZUFBZSxtQkFBbUIsQ0FBQyxFQUNqQyxZQUFZLEVBQ1osU0FBUyxFQUNULHNCQUFzQixFQUN0QixzQkFBc0IsR0FDdkIsRUFBQTtBQUNDLElBQUEsTUFBTSxDQUFDLHdCQUF3QixFQUFFLEtBQUssQ0FBQyxHQUFHLFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBRyxDQUFBLENBQUEsQ0FBQyxDQUFBO0lBQ2pFLE1BQU0sYUFBYSxHQUFHOztJQUVwQixJQUFJO0FBQ0YsUUFBQSx3QkFBd0IsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO1FBQ2pDLENBQUksQ0FBQSxFQUFBLHNCQUFzQixHQUFHLFNBQVMsR0FBRyxFQUFFLENBQUEsRUFBQSxFQUFLLFNBQVMsQ0FBQSxFQUN2RCxLQUFLLEdBQUcsQ0FBQSxDQUFBLEVBQUksS0FBSyxDQUFBLENBQUUsR0FBRyxFQUN4QixDQUFFLENBQUEsQ0FDTCxDQUFBO0FBQ0QsSUFBQSxJQUFJLHNCQUFzQixFQUFFO0FBQzFCLFFBQUEsYUFBYSxDQUFDLEtBQUssQ0FBQyxNQUFLO0FBQ3ZCLFlBQUEsT0FBTyxDQUFDLElBQUksQ0FDVixDQUFBLE1BQUEsRUFBUyxZQUFZLENBQXNHLG9HQUFBLENBQUE7QUFDekgsZ0JBQUEsQ0FBQSwySUFBQSxDQUE2SSxDQUNoSixDQUFBO0FBQ0QsWUFBQSxVQUFVLEVBQUUsQ0FBQTtBQUNkLFNBQUMsQ0FBQyxDQUFBO0FBQ0gsS0FBQTtJQUNELE9BQU8sTUFBTSxhQUFhLENBQUE7QUFDNUIsQ0FBQyxDQUNGLENBQUE7QUFFRCxlQUFlLGFBQWEsQ0FBQyxPQUFtQixFQUFBO0lBQzlDLFFBQVEsT0FBTyxDQUFDLElBQUk7QUFDbEIsUUFBQSxLQUFLLFdBQVc7QUFDZCxZQUFBLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQSxpQkFBQSxDQUFtQixDQUFDLENBQUE7QUFDbEMsWUFBQSxTQUFTLENBQUMsU0FBUyxDQUFDLEtBQUssRUFBRSxDQUFBOzs7WUFHM0IsV0FBVyxDQUFDLE1BQUs7QUFDZixnQkFBQSxJQUFJLE1BQU0sQ0FBQyxVQUFVLEtBQUssTUFBTSxDQUFDLElBQUksRUFBRTtBQUNyQyxvQkFBQSxNQUFNLENBQUMsSUFBSSxDQUFDLGlCQUFpQixDQUFDLENBQUE7QUFDL0IsaUJBQUE7YUFDRixFQUFFLGVBQWUsQ0FBQyxDQUFBO1lBQ25CLE1BQUs7QUFDUCxRQUFBLEtBQUssUUFBUTtBQUNYLFlBQUEsZUFBZSxDQUFDLG1CQUFtQixFQUFFLE9BQU8sQ0FBQyxDQUFBO0FBQzdDLFlBQUEsSUFBSSxXQUFXLEVBQUU7Ozs7O0FBS2YsZ0JBQUEsSUFBSSxhQUFhLElBQUksZUFBZSxFQUFFLEVBQUU7QUFDdEMsb0JBQUEsTUFBTSxDQUFDLFFBQVEsQ0FBQyxNQUFNLEVBQUUsQ0FBQTtvQkFDeEIsT0FBTTtBQUNQLGlCQUFBO0FBQU0scUJBQUE7QUFDTCxvQkFBQSxJQUFJLGFBQWEsRUFBRTtBQUNqQix3QkFBQSxpQkFBaUIsRUFBRSxDQUFBO0FBQ3BCLHFCQUFBO29CQUNELGFBQWEsR0FBRyxLQUFLLENBQUE7QUFDdEIsaUJBQUE7QUFDRixhQUFBO0FBQ0QsWUFBQSxNQUFNLE9BQU8sQ0FBQyxHQUFHLENBQ2YsT0FBTyxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsT0FBTyxNQUFNLEtBQW1CO0FBQ2xELGdCQUFBLElBQUksTUFBTSxDQUFDLElBQUksS0FBSyxXQUFXLEVBQUU7QUFDL0Isb0JBQUEsT0FBTyxTQUFTLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQyxDQUFBO0FBQ3JDLGlCQUFBOzs7QUFJRCxnQkFBQSxNQUFNLEVBQUUsSUFBSSxFQUFFLFNBQVMsRUFBRSxHQUFHLE1BQU0sQ0FBQTtBQUNsQyxnQkFBQSxNQUFNLFNBQVMsR0FBRyxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUE7Ozs7QUFJaEMsZ0JBQUEsTUFBTSxFQUFFLEdBQUcsS0FBSyxDQUFDLElBQUksQ0FDbkIsUUFBUSxDQUFDLGdCQUFnQixDQUFrQixNQUFNLENBQUMsQ0FDbkQsQ0FBQyxJQUFJLENBQ0osQ0FBQyxDQUFDLEtBQ0EsQ0FBQyxnQkFBZ0IsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLElBQUksUUFBUSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxRQUFRLENBQUMsU0FBUyxDQUFDLENBQ25FLENBQUE7Z0JBRUQsSUFBSSxDQUFDLEVBQUUsRUFBRTtvQkFDUCxPQUFNO0FBQ1AsaUJBQUE7QUFFRCxnQkFBQSxNQUFNLE9BQU8sR0FBRyxDQUFHLEVBQUEsSUFBSSxDQUFHLEVBQUEsU0FBUyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQSxFQUMxQyxTQUFTLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUNsQyxDQUFLLEVBQUEsRUFBQSxTQUFTLEVBQUUsQ0FBQTs7Ozs7O0FBT2hCLGdCQUFBLE9BQU8sSUFBSSxPQUFPLENBQUMsQ0FBQyxPQUFPLEtBQUk7QUFDN0Isb0JBQUEsTUFBTSxVQUFVLEdBQUcsRUFBRSxDQUFDLFNBQVMsRUFBcUIsQ0FBQTtBQUNwRCxvQkFBQSxVQUFVLENBQUMsSUFBSSxHQUFHLElBQUksR0FBRyxDQUFDLE9BQU8sRUFBRSxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFBO29CQUNoRCxNQUFNLFdBQVcsR0FBRyxNQUFLO3dCQUN2QixFQUFFLENBQUMsTUFBTSxFQUFFLENBQUE7QUFDWCx3QkFBQSxPQUFPLENBQUMsS0FBSyxDQUFDLDJCQUEyQixTQUFTLENBQUEsQ0FBRSxDQUFDLENBQUE7QUFDckQsd0JBQUEsT0FBTyxFQUFFLENBQUE7QUFDWCxxQkFBQyxDQUFBO0FBQ0Qsb0JBQUEsVUFBVSxDQUFDLGdCQUFnQixDQUFDLE1BQU0sRUFBRSxXQUFXLENBQUMsQ0FBQTtBQUNoRCxvQkFBQSxVQUFVLENBQUMsZ0JBQWdCLENBQUMsT0FBTyxFQUFFLFdBQVcsQ0FBQyxDQUFBO0FBQ2pELG9CQUFBLGdCQUFnQixDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQTtBQUN4QixvQkFBQSxFQUFFLENBQUMsS0FBSyxDQUFDLFVBQVUsQ0FBQyxDQUFBO0FBQ3RCLGlCQUFDLENBQUMsQ0FBQTthQUNILENBQUMsQ0FDSCxDQUFBO0FBQ0QsWUFBQSxlQUFlLENBQUMsa0JBQWtCLEVBQUUsT0FBTyxDQUFDLENBQUE7WUFDNUMsTUFBSztRQUNQLEtBQUssUUFBUSxFQUFFO1lBQ2IsZUFBZSxDQUFDLE9BQU8sQ0FBQyxLQUFLLEVBQUUsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFBO1lBQzVDLE1BQUs7QUFDTixTQUFBO0FBQ0QsUUFBQSxLQUFLLGFBQWE7QUFDaEIsWUFBQSxlQUFlLENBQUMsdUJBQXVCLEVBQUUsT0FBTyxDQUFDLENBQUE7QUFDakQsWUFBQSxJQUFJLFdBQVcsRUFBRTtBQUNmLGdCQUFBLElBQUksT0FBTyxDQUFDLElBQUksSUFBSSxPQUFPLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsRUFBRTs7O29CQUdsRCxNQUFNLFFBQVEsR0FBRyxTQUFTLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxDQUFBO0FBQzdDLG9CQUFBLE1BQU0sV0FBVyxHQUFHLElBQUksR0FBRyxPQUFPLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQTtvQkFDaEQsSUFDRSxRQUFRLEtBQUssV0FBVzt3QkFDeEIsT0FBTyxDQUFDLElBQUksS0FBSyxhQUFhO0FBQzlCLHlCQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLElBQUksUUFBUSxHQUFHLFlBQVksS0FBSyxXQUFXLENBQUMsRUFDbkU7QUFDQSx3QkFBQSxVQUFVLEVBQUUsQ0FBQTtBQUNiLHFCQUFBO29CQUNELE9BQU07QUFDUCxpQkFBQTtBQUFNLHFCQUFBO0FBQ0wsb0JBQUEsVUFBVSxFQUFFLENBQUE7QUFDYixpQkFBQTtBQUNGLGFBQUE7WUFDRCxNQUFLO0FBQ1AsUUFBQSxLQUFLLE9BQU87QUFDVixZQUFBLGVBQWUsQ0FBQyxrQkFBa0IsRUFBRSxPQUFPLENBQUMsQ0FBQTtZQUM1QyxNQUFNLFNBQVMsQ0FBQyxVQUFVLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFBO1lBQ3pDLE1BQUs7UUFDUCxLQUFLLE9BQU8sRUFBRTtBQUNaLFlBQUEsZUFBZSxDQUFDLFlBQVksRUFBRSxPQUFPLENBQUMsQ0FBQTtBQUN0QyxZQUFBLElBQUksV0FBVyxFQUFFO0FBQ2YsZ0JBQUEsTUFBTSxHQUFHLEdBQUcsT0FBTyxDQUFDLEdBQUcsQ0FBQTtBQUN2QixnQkFBQSxJQUFJLGFBQWEsRUFBRTtvQkFDakIsa0JBQWtCLENBQUMsR0FBRyxDQUFDLENBQUE7QUFDeEIsaUJBQUE7QUFBTSxxQkFBQTtBQUNMLG9CQUFBLE9BQU8sQ0FBQyxLQUFLLENBQ1gsQ0FBQSw4QkFBQSxFQUFpQyxHQUFHLENBQUMsT0FBTyxDQUFBLEVBQUEsRUFBSyxHQUFHLENBQUMsS0FBSyxDQUFBLENBQUUsQ0FDN0QsQ0FBQTtBQUNGLGlCQUFBO0FBQ0YsYUFBQTtZQUNELE1BQUs7QUFDTixTQUFBO0FBQ0QsUUFBQSxTQUFTO1lBQ1AsTUFBTSxLQUFLLEdBQVUsT0FBTyxDQUFBO0FBQzVCLFlBQUEsT0FBTyxLQUFLLENBQUE7QUFDYixTQUFBO0FBQ0YsS0FBQTtBQUNILENBQUM7QUFNRCxTQUFTLGVBQWUsQ0FBQyxLQUFhLEVBQUUsSUFBUyxFQUFBO0FBQy9DLElBQUEsU0FBUyxDQUFDLGVBQWUsQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLENBQUE7QUFDeEMsQ0FBQztBQUVELE1BQU0sYUFBYSxHQUFHLHNCQUFzQixDQUFBO0FBQzVDLE1BQU0sV0FBVyxHQUFHLFVBQVUsSUFBSSxVQUFVLENBQUE7QUFFNUMsU0FBUyxrQkFBa0IsQ0FBQyxHQUF3QixFQUFBO0FBQ2xELElBQUEsaUJBQWlCLEVBQUUsQ0FBQTtJQUNuQixRQUFRLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLFlBQVksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFBO0FBQ2xELENBQUM7QUFFRCxTQUFTLGlCQUFpQixHQUFBO0FBQ3hCLElBQUEsUUFBUSxDQUFDLGdCQUFnQixDQUFlLFNBQVMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQTtBQUM5RSxDQUFDO0FBRUQsU0FBUyxlQUFlLEdBQUE7SUFDdEIsT0FBTyxRQUFRLENBQUMsZ0JBQWdCLENBQUMsU0FBUyxDQUFDLENBQUMsTUFBTSxDQUFBO0FBQ3BELENBQUM7QUFFRCxlQUFlLHFCQUFxQixDQUNsQyxjQUFzQixFQUN0QixXQUFtQixFQUNuQixFQUFFLEdBQUcsSUFBSSxFQUFBO0FBRVQsSUFBQSxNQUFNLGdCQUFnQixHQUFHLGNBQWMsS0FBSyxLQUFLLEdBQUcsT0FBTyxHQUFHLE1BQU0sQ0FBQTtBQUVwRSxJQUFBLE1BQU0sSUFBSSxHQUFHLFlBQVc7Ozs7UUFJdEIsSUFBSTtBQUNGLFlBQUEsTUFBTSxLQUFLLENBQUMsQ0FBQSxFQUFHLGdCQUFnQixDQUFNLEdBQUEsRUFBQSxXQUFXLEVBQUUsRUFBRTtBQUNsRCxnQkFBQSxJQUFJLEVBQUUsU0FBUztBQUNmLGdCQUFBLE9BQU8sRUFBRTs7O0FBR1Asb0JBQUEsTUFBTSxFQUFFLGtCQUFrQjtBQUMzQixpQkFBQTtBQUNGLGFBQUEsQ0FBQyxDQUFBO0FBQ0YsWUFBQSxPQUFPLElBQUksQ0FBQTtBQUNaLFNBQUE7QUFBQyxRQUFBLE1BQU0sR0FBRTtBQUNWLFFBQUEsT0FBTyxLQUFLLENBQUE7QUFDZCxLQUFDLENBQUE7SUFFRCxJQUFJLE1BQU0sSUFBSSxFQUFFLEVBQUU7UUFDaEIsT0FBTTtBQUNQLEtBQUE7QUFDRCxJQUFBLE1BQU0sSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFBOztBQUdkLElBQUEsT0FBTyxJQUFJLEVBQUU7QUFDWCxRQUFBLElBQUksUUFBUSxDQUFDLGVBQWUsS0FBSyxTQUFTLEVBQUU7WUFDMUMsSUFBSSxNQUFNLElBQUksRUFBRSxFQUFFO2dCQUNoQixNQUFLO0FBQ04sYUFBQTtBQUNELFlBQUEsTUFBTSxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUE7QUFDZixTQUFBO0FBQU0sYUFBQTtZQUNMLE1BQU0saUJBQWlCLEVBQUUsQ0FBQTtBQUMxQixTQUFBO0FBQ0YsS0FBQTtBQUNILENBQUM7QUFFRCxTQUFTLElBQUksQ0FBQyxFQUFVLEVBQUE7QUFDdEIsSUFBQSxPQUFPLElBQUksT0FBTyxDQUFDLENBQUMsT0FBTyxLQUFLLFVBQVUsQ0FBQyxPQUFPLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQTtBQUMxRCxDQUFDO0FBRUQsU0FBUyxpQkFBaUIsR0FBQTtBQUN4QixJQUFBLE9BQU8sSUFBSSxPQUFPLENBQU8sQ0FBQyxPQUFPLEtBQUk7QUFDbkMsUUFBQSxNQUFNLFFBQVEsR0FBRyxZQUFXO0FBQzFCLFlBQUEsSUFBSSxRQUFRLENBQUMsZUFBZSxLQUFLLFNBQVMsRUFBRTtBQUMxQyxnQkFBQSxPQUFPLEVBQUUsQ0FBQTtBQUNULGdCQUFBLFFBQVEsQ0FBQyxtQkFBbUIsQ0FBQyxrQkFBa0IsRUFBRSxRQUFRLENBQUMsQ0FBQTtBQUMzRCxhQUFBO0FBQ0gsU0FBQyxDQUFBO0FBQ0QsUUFBQSxRQUFRLENBQUMsZ0JBQWdCLENBQUMsa0JBQWtCLEVBQUUsUUFBUSxDQUFDLENBQUE7QUFDekQsS0FBQyxDQUFDLENBQUE7QUFDSixDQUFDO0FBRUQsTUFBTSxTQUFTLEdBQUcsSUFBSSxHQUFHLEVBQTRCLENBQUE7QUFFckQ7QUFDQTtBQUNBLElBQUksVUFBVSxJQUFJLFVBQVUsRUFBRTtJQUM1QixRQUFRO1NBQ0wsZ0JBQWdCLENBQW1CLHlCQUF5QixDQUFDO0FBQzdELFNBQUEsT0FBTyxDQUFDLENBQUMsRUFBRSxLQUFJO0FBQ2QsUUFBQSxTQUFTLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxZQUFZLENBQUMsa0JBQWtCLENBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQTtBQUN6RCxLQUFDLENBQUMsQ0FBQTtBQUNMLENBQUE7QUFFRCxNQUFNLFFBQVEsR0FDWixVQUFVLElBQUksVUFBVTtNQUNwQixNQUFBLFFBQVEsQ0FBQyxhQUFhLENBQWtCLDBCQUEwQixDQUFDLE1BQUEsSUFBQSxJQUFBLEVBQUEsS0FBQSxLQUFBLENBQUEsR0FBQSxLQUFBLENBQUEsR0FBQSxFQUFBLENBQUUsS0FBSztNQUMxRSxTQUFTLENBQUE7QUFFZjtBQUNBO0FBQ0EsSUFBSSxpQkFBK0MsQ0FBQTtBQUVuQyxTQUFBLFdBQVcsQ0FBQyxFQUFVLEVBQUUsT0FBZSxFQUFBO0lBQ3JELElBQUksS0FBSyxHQUFHLFNBQVMsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUE7SUFDN0IsSUFBSSxDQUFDLEtBQUssRUFBRTtBQUNWLFFBQUEsS0FBSyxHQUFHLFFBQVEsQ0FBQyxhQUFhLENBQUMsT0FBTyxDQUFDLENBQUE7QUFDdkMsUUFBQSxLQUFLLENBQUMsWUFBWSxDQUFDLE1BQU0sRUFBRSxVQUFVLENBQUMsQ0FBQTtBQUN0QyxRQUFBLEtBQUssQ0FBQyxZQUFZLENBQUMsa0JBQWtCLEVBQUUsRUFBRSxDQUFDLENBQUE7QUFDMUMsUUFBQSxLQUFLLENBQUMsV0FBVyxHQUFHLE9BQU8sQ0FBQTtBQUMzQixRQUFBLElBQUksUUFBUSxFQUFFO0FBQ1osWUFBQSxLQUFLLENBQUMsWUFBWSxDQUFDLE9BQU8sRUFBRSxRQUFRLENBQUMsQ0FBQTtBQUN0QyxTQUFBO1FBRUQsSUFBSSxDQUFDLGlCQUFpQixFQUFFO0FBQ3RCLFlBQUEsUUFBUSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsS0FBSyxDQUFDLENBQUE7OztZQUloQyxVQUFVLENBQUMsTUFBSztnQkFDZCxpQkFBaUIsR0FBRyxTQUFTLENBQUE7YUFDOUIsRUFBRSxDQUFDLENBQUMsQ0FBQTtBQUNOLFNBQUE7QUFBTSxhQUFBO0FBQ0wsWUFBQSxpQkFBaUIsQ0FBQyxxQkFBcUIsQ0FBQyxVQUFVLEVBQUUsS0FBSyxDQUFDLENBQUE7QUFDM0QsU0FBQTtRQUNELGlCQUFpQixHQUFHLEtBQUssQ0FBQTtBQUMxQixLQUFBO0FBQU0sU0FBQTtBQUNMLFFBQUEsS0FBSyxDQUFDLFdBQVcsR0FBRyxPQUFPLENBQUE7QUFDNUIsS0FBQTtBQUNELElBQUEsU0FBUyxDQUFDLEdBQUcsQ0FBQyxFQUFFLEVBQUUsS0FBSyxDQUFDLENBQUE7QUFDMUIsQ0FBQztBQUVLLFNBQVUsV0FBVyxDQUFDLEVBQVUsRUFBQTtJQUNwQyxNQUFNLEtBQUssR0FBRyxTQUFTLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFBO0FBQy9CLElBQUEsSUFBSSxLQUFLLEVBQUU7QUFDVCxRQUFBLFFBQVEsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQyxDQUFBO0FBQ2hDLFFBQUEsU0FBUyxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsQ0FBQTtBQUNyQixLQUFBO0FBQ0gsQ0FBQztBQUVLLFNBQVUsZ0JBQWdCLENBQUMsU0FBaUIsRUFBQTtBQUNoRCxJQUFBLE9BQU8sSUFBSSxVQUFVLENBQUMsU0FBUyxFQUFFLFNBQVMsQ0FBQyxDQUFBO0FBQzdDLENBQUM7QUFFRDs7QUFFRztBQUNhLFNBQUEsV0FBVyxDQUFDLEdBQVcsRUFBRSxhQUFxQixFQUFBOztBQUU1RCxJQUFBLElBQUksR0FBRyxDQUFDLENBQUMsQ0FBQyxLQUFLLEdBQUcsSUFBSSxHQUFHLENBQUMsQ0FBQyxDQUFDLEtBQUssR0FBRyxFQUFFO0FBQ3BDLFFBQUEsT0FBTyxHQUFHLENBQUE7QUFDWCxLQUFBOztJQUdELE1BQU0sUUFBUSxHQUFHLEdBQUcsQ0FBQyxPQUFPLENBQUMsU0FBUyxFQUFFLEVBQUUsQ0FBQyxDQUFBO0FBQzNDLElBQUEsTUFBTSxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUUsR0FBRyxJQUFJLEdBQUcsQ0FBQyxHQUFHLEVBQUUsbUJBQW1CLENBQUMsQ0FBQTtJQUUxRCxPQUFPLENBQUEsRUFBRyxRQUFRLENBQUEsQ0FBQSxFQUFJLGFBQWEsQ0FBQSxFQUFHLE1BQU0sR0FBRyxDQUFHLENBQUEsQ0FBQSxHQUFHLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFBLEVBQ3ZFLElBQUksSUFBSSxFQUNWLENBQUEsQ0FBRSxDQUFBO0FBQ0o7Ozs7IiwieF9nb29nbGVfaWdub3JlTGlzdCI6WzAsMSwyXX0=",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 105630,
            "count": 1
          },
          {
            "startOffset": 8556,
            "endOffset": 8562,
            "count": 0
          },
          {
            "startOffset": 15752,
            "endOffset": 15759,
            "count": 0
          },
          {
            "startOffset": 15947,
            "endOffset": 15953,
            "count": 0
          },
          {
            "startOffset": 17368,
            "endOffset": 17458,
            "count": 0
          },
          {
            "startOffset": 27770,
            "endOffset": 27786,
            "count": 0
          },
          {
            "startOffset": 27796,
            "endOffset": 27806,
            "count": 0
          },
          {
            "startOffset": 27811,
            "endOffset": 27822,
            "count": 0
          }
        ]
      },
      {
        "functionName": "HMRContext",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 170,
            "endOffset": 1196,
            "count": 12
          },
          {
            "startOffset": 565,
            "endOffset": 608,
            "count": 0
          },
          {
            "startOffset": 758,
            "endOffset": 1080,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1007,
            "endOffset": 1035,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get data",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1201,
            "endOffset": 1278,
            "count": 0
          }
        ]
      },
      {
        "functionName": "accept",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1283,
            "endOffset": 1915,
            "count": 9
          },
          {
            "startOffset": 1347,
            "endOffset": 1355,
            "count": 1
          },
          {
            "startOffset": 1530,
            "endOffset": 1909,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1454,
            "endOffset": 1518,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1641,
            "endOffset": 1717,
            "count": 0
          }
        ]
      },
      {
        "functionName": "acceptExports",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2042,
            "endOffset": 2197,
            "count": 0
          }
        ]
      },
      {
        "functionName": "dispose",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2202,
            "endOffset": 2280,
            "count": 0
          }
        ]
      },
      {
        "functionName": "prune",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 2285,
            "endOffset": 2359,
            "count": 4
          }
        ]
      },
      {
        "functionName": "decline",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2481,
            "endOffset": 2494,
            "count": 0
          }
        ]
      },
      {
        "functionName": "invalidate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2499,
            "endOffset": 2834,
            "count": 0
          }
        ]
      },
      {
        "functionName": "on",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2839,
            "endOffset": 3117,
            "count": 0
          }
        ]
      },
      {
        "functionName": "off",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 3122,
            "endOffset": 3630,
            "count": 0
          }
        ]
      },
      {
        "functionName": "send",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 3635,
            "endOffset": 3748,
            "count": 0
          }
        ]
      },
      {
        "functionName": "acceptDeps",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 3753,
            "endOffset": 4091,
            "count": 9
          }
        ]
      },
      {
        "functionName": "callback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 3781,
            "endOffset": 3790,
            "count": 0
          }
        ]
      },
      {
        "functionName": "HMRMessenger",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 4119,
            "endOffset": 4213,
            "count": 1
          }
        ]
      },
      {
        "functionName": "send",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4218,
            "endOffset": 4295,
            "count": 0
          }
        ]
      },
      {
        "functionName": "flush",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 4300,
            "endOffset": 4463,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4382,
            "endOffset": 4416,
            "count": 0
          }
        ]
      },
      {
        "functionName": "HMRClient",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 4488,
            "endOffset": 5094,
            "count": 1
          }
        ]
      },
      {
        "functionName": "notifyListeners",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5099,
            "endOffset": 5291,
            "count": 1
          },
          {
            "startOffset": 5209,
            "endOffset": 5285,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 5256,
            "endOffset": 5272,
            "count": 0
          }
        ]
      },
      {
        "functionName": "clear",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 5296,
            "endOffset": 5522,
            "count": 0
          }
        ]
      },
      {
        "functionName": "prunePaths",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 5711,
            "endOffset": 6116,
            "count": 0
          }
        ]
      },
      {
        "functionName": "warnFailedUpdate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 6121,
            "endOffset": 6433,
            "count": 0
          }
        ]
      },
      {
        "functionName": "queueUpdate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 6676,
            "endOffset": 7100,
            "count": 0
          }
        ]
      },
      {
        "functionName": "fetchUpdate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 7105,
            "endOffset": 8493,
            "count": 0
          }
        ]
      },
      {
        "functionName": "h",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 8632,
            "endOffset": 8854,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11395,
            "endOffset": 12195,
            "count": 0
          }
        ]
      },
      {
        "functionName": "ErrorOverlay",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12523,
            "endOffset": 14020,
            "count": 0
          }
        ]
      },
      {
        "functionName": "text",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14025,
            "endOffset": 15050,
            "count": 0
          }
        ]
      },
      {
        "functionName": "close",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15055,
            "endOffset": 15242,
            "count": 0
          }
        ]
      },
      {
        "functionName": "fallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 16098,
            "endOffset": 17291,
            "count": 0
          }
        ]
      },
      {
        "functionName": "setupWebSocket",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 17459,
            "endOffset": 18476,
            "count": 1
          }
        ]
      },
      {
        "functionName": "socket.addEventListener.once",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 17668,
            "endOffset": 17773,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 17858,
            "endOffset": 17926,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 17985,
            "endOffset": 18453,
            "count": 0
          }
        ]
      },
      {
        "functionName": "cleanUrl",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 18477,
            "endOffset": 18641,
            "count": 0
          }
        ]
      },
      {
        "functionName": "debounceReload",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 18731,
            "endOffset": 18959,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 18769,
            "endOffset": 18956,
            "count": 0
          }
        ]
      },
      {
        "functionName": "isReady",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 19056,
            "endOffset": 19095,
            "count": 1
          }
        ]
      },
      {
        "functionName": "send",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 19107,
            "endOffset": 19140,
            "count": 0
          }
        ]
      },
      {
        "functionName": "importUpdatedModule",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 19145,
            "endOffset": 19998,
            "count": 0
          }
        ]
      },
      {
        "functionName": "handleMessage",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 20001,
            "endOffset": 25111,
            "count": 1
          },
          {
            "startOffset": 20513,
            "endOffset": 23437,
            "count": 0
          },
          {
            "startOffset": 23446,
            "endOffset": 23549,
            "count": 0
          },
          {
            "startOffset": 23558,
            "endOffset": 24430,
            "count": 0
          },
          {
            "startOffset": 24439,
            "endOffset": 24584,
            "count": 0
          },
          {
            "startOffset": 24593,
            "endOffset": 25013,
            "count": 0
          },
          {
            "startOffset": 25022,
            "endOffset": 25103,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 20328,
            "endOffset": 20476,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 21380,
            "endOffset": 23357,
            "count": 0
          }
        ]
      },
      {
        "functionName": "notifyListeners",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 25112,
            "endOffset": 25197,
            "count": 1
          }
        ]
      },
      {
        "functionName": "createErrorOverlay",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 25272,
            "endOffset": 25387,
            "count": 0
          }
        ]
      },
      {
        "functionName": "clearErrorOverlay",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 25388,
            "endOffset": 25488,
            "count": 0
          }
        ]
      },
      {
        "functionName": "hasErrorOverlay",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 25489,
            "endOffset": 25575,
            "count": 0
          }
        ]
      },
      {
        "functionName": "waitForSuccessfulPing",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 25576,
            "endOffset": 26862,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wait",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 26863,
            "endOffset": 26946,
            "count": 0
          }
        ]
      },
      {
        "functionName": "waitForWindowShow",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 26947,
            "endOffset": 27315,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 27571,
            "endOffset": 27650,
            "count": 0
          }
        ]
      },
      {
        "functionName": "updateStyle",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 27958,
            "endOffset": 28866,
            "count": 4
          },
          {
            "startOffset": 28255,
            "endOffset": 28317,
            "count": 0
          },
          {
            "startOffset": 28350,
            "endOffset": 28642,
            "count": 1
          },
          {
            "startOffset": 28642,
            "endOffset": 28739,
            "count": 3
          },
          {
            "startOffset": 28780,
            "endOffset": 28834,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 28559,
            "endOffset": 28627,
            "count": 1
          }
        ]
      },
      {
        "functionName": "removeStyle",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 28867,
            "endOffset": 29027,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createHotContext",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 29028,
            "endOffset": 29117,
            "count": 12
          }
        ]
      },
      {
        "functionName": "injectQuery",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 29202,
            "endOffset": 29639,
            "count": 8
          },
          {
            "startOffset": 29361,
            "endOffset": 29616,
            "count": 0
          },
          {
            "startOffset": 29617,
            "endOffset": 29621,
            "count": 0
          },
          {
            "startOffset": 29629,
            "endOffset": 29634,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5173/@fs/home/will/local_dev/portfolio/node_modules/.pnpm/vite@5.2.8_@types+node@20.11.30_sass@1.72.0/node_modules/vite/dist/client/env.mjs",
    "scriptId": "17",
    "source": "const context = (() => {\n    if (typeof globalThis !== 'undefined') {\n        return globalThis;\n    }\n    else if (typeof self !== 'undefined') {\n        return self;\n    }\n    else if (typeof window !== 'undefined') {\n        return window;\n    }\n    else {\n        return Function('return this')();\n    }\n})();\n// assign defines\nconst defines = {};\nObject.keys(defines).forEach((key) => {\n    const segments = key.split('.');\n    let target = context;\n    for (let i = 0; i < segments.length; i++) {\n        const segment = segments[i];\n        if (i === segments.length - 1) {\n            target[segment] = defines[key];\n        }\n        else {\n            target = target[segment] || (target[segment] = {});\n        }\n    }\n});\n                                \n\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZW52Lm1qcyIsInNvdXJjZXMiOlsiZW52LnRzIl0sInNvdXJjZXNDb250ZW50IjpbImRlY2xhcmUgY29uc3QgX19NT0RFX186IHN0cmluZ1xuZGVjbGFyZSBjb25zdCBfX0RFRklORVNfXzogUmVjb3JkPHN0cmluZywgYW55PlxuXG5jb25zdCBjb250ZXh0ID0gKCgpID0+IHtcbiAgaWYgKHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBnbG9iYWxUaGlzXG4gIH0gZWxzZSBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIHNlbGZcbiAgfSBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiB3aW5kb3dcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKVxuICB9XG59KSgpXG5cbi8vIGFzc2lnbiBkZWZpbmVzXG5jb25zdCBkZWZpbmVzID0gX19ERUZJTkVTX19cbk9iamVjdC5rZXlzKGRlZmluZXMpLmZvckVhY2goKGtleSkgPT4ge1xuICBjb25zdCBzZWdtZW50cyA9IGtleS5zcGxpdCgnLicpXG4gIGxldCB0YXJnZXQgPSBjb250ZXh0XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc2VnbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBzZWdtZW50ID0gc2VnbWVudHNbaV1cbiAgICBpZiAoaSA9PT0gc2VnbWVudHMubGVuZ3RoIC0gMSkge1xuICAgICAgdGFyZ2V0W3NlZ21lbnRdID0gZGVmaW5lc1trZXldXG4gICAgfSBlbHNlIHtcbiAgICAgIHRhcmdldCA9IHRhcmdldFtzZWdtZW50XSB8fCAodGFyZ2V0W3NlZ21lbnRdID0ge30pXG4gICAgfVxuICB9XG59KVxuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUdBLE1BQU0sT0FBTyxHQUFHLENBQUMsTUFBSztBQUNwQixJQUFBLElBQUksT0FBTyxVQUFVLEtBQUssV0FBVyxFQUFFO0FBQ3JDLFFBQUEsT0FBTyxVQUFVLENBQUE7QUFDbEIsS0FBQTtBQUFNLFNBQUEsSUFBSSxPQUFPLElBQUksS0FBSyxXQUFXLEVBQUU7QUFDdEMsUUFBQSxPQUFPLElBQUksQ0FBQTtBQUNaLEtBQUE7QUFBTSxTQUFBLElBQUksT0FBTyxNQUFNLEtBQUssV0FBVyxFQUFFO0FBQ3hDLFFBQUEsT0FBTyxNQUFNLENBQUE7QUFDZCxLQUFBO0FBQU0sU0FBQTtBQUNMLFFBQUEsT0FBTyxRQUFRLENBQUMsYUFBYSxDQUFDLEVBQUUsQ0FBQTtBQUNqQyxLQUFBO0FBQ0gsQ0FBQyxHQUFHLENBQUE7QUFFSjtBQUNBLE1BQU0sT0FBTyxHQUFHLFdBQVcsQ0FBQTtBQUMzQixNQUFNLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLEdBQUcsS0FBSTtJQUNuQyxNQUFNLFFBQVEsR0FBRyxHQUFHLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFBO0lBQy9CLElBQUksTUFBTSxHQUFHLE9BQU8sQ0FBQTtBQUNwQixJQUFBLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxRQUFRLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO0FBQ3hDLFFBQUEsTUFBTSxPQUFPLEdBQUcsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFBO0FBQzNCLFFBQUEsSUFBSSxDQUFDLEtBQUssUUFBUSxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUU7WUFDN0IsTUFBTSxDQUFDLE9BQU8sQ0FBQyxHQUFHLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQTtBQUMvQixTQUFBO0FBQU0sYUFBQTtBQUNMLFlBQUEsTUFBTSxHQUFHLE1BQU0sQ0FBQyxPQUFPLENBQUMsS0FBSyxNQUFNLENBQUMsT0FBTyxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUE7QUFDbkQsU0FBQTtBQUNGLEtBQUE7QUFDSCxDQUFDLENBQUMiLCJ4X2dvb2dsZV9pZ25vcmVMaXN0IjpbMF19",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 3226,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 17,
            "endOffset": 309,
            "count": 1
          },
          {
            "startOffset": 102,
            "endOffset": 307,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 381,
            "endOffset": 731,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5173/",
    "scriptId": "18",
    "source": "\n      console.log('[HTML] Initial scroll position:', window.scrollY);\n      window.history.scrollRestoration = 'manual';\n      window.scrollTo(0, 0);\n      console.log('[HTML] After manual scrollTo(0,0):', window.scrollY);\n      \n      // Monitor scroll changes\n      let scrollCount = 0;\n      window.addEventListener('scroll', function() {\n        scrollCount++;\n        console.log(`[HTML] Scroll event #${scrollCount}, scrollY:`, window.scrollY, 'at', new Date().toISOString());\n      }, { passive: true });\n    ",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 517,
            "count": 1
          }
        ]
      },
      {
        "functionName": "window.addEventListener.passive",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 330,
            "endOffset": 491,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5173/src/main.tsx?t=1750726948502",
    "scriptId": "15",
    "source": "import __vite__cjsImport0_react_jsxDevRuntime from \"/node_modules/.vite/deps/react_jsx-dev-runtime.js?v=a50bb159\"; const jsxDEV = __vite__cjsImport0_react_jsxDevRuntime[\"jsxDEV\"];\nimport __vite__cjsImport1_react from \"/node_modules/.vite/deps/react.js?v=a50bb159\"; const React = __vite__cjsImport1_react.__esModule ? __vite__cjsImport1_react.default : __vite__cjsImport1_react;\nimport __vite__cjsImport2_reactDom_client from \"/node_modules/.vite/deps/react-dom_client.js?v=a50bb159\"; const ReactDOM = __vite__cjsImport2_reactDom_client.__esModule ? __vite__cjsImport2_reactDom_client.default : __vite__cjsImport2_reactDom_client;\nimport App from \"/src/App.tsx?t=1750726948502\";\nimport \"/src/index.css\";\nReactDOM.createRoot(document.getElementById(\"root\")).render(\n  /* @__PURE__ */ jsxDEV(React.StrictMode, { children: /* @__PURE__ */ jsxDEV(App, {}, void 0, false, {\n    fileName: \"/home/will/local_dev/portfolio/apps/robin-noguier/src/main.tsx\",\n    lineNumber: 8,\n    columnNumber: 5\n  }, this) }, void 0, false, {\n    fileName: \"/home/will/local_dev/portfolio/apps/robin-noguier/src/main.tsx\",\n    lineNumber: 7,\n    columnNumber: 3\n  }, this)\n);\n\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJtYXBwaW5ncyI6IkFBT0k7QUFQSixPQUFPQSxXQUFXO0FBQ2xCLE9BQU9DLGNBQWM7QUFDckIsT0FBT0MsU0FBUztBQUNoQixPQUFPO0FBRVBELFNBQVNFLFdBQVdDLFNBQVNDLGVBQWUsTUFBTSxDQUFFLEVBQUVDO0FBQUFBLEVBQ3BELHVCQUFDLE1BQU0sWUFBTixFQUNDLGlDQUFDLFNBQUQ7QUFBQTtBQUFBO0FBQUE7QUFBQSxTQUFJLEtBRE47QUFBQTtBQUFBO0FBQUE7QUFBQSxTQUVBO0FBQ0YiLCJuYW1lcyI6WyJSZWFjdCIsIlJlYWN0RE9NIiwiQXBwIiwiY3JlYXRlUm9vdCIsImRvY3VtZW50IiwiZ2V0RWxlbWVudEJ5SWQiLCJyZW5kZXIiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZXMiOlsibWFpbi50c3giXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0J1xuaW1wb3J0IFJlYWN0RE9NIGZyb20gJ3JlYWN0LWRvbS9jbGllbnQnXG5pbXBvcnQgQXBwIGZyb20gJy4vQXBwJ1xuaW1wb3J0ICcuL2luZGV4LmNzcydcblxuUmVhY3RET00uY3JlYXRlUm9vdChkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncm9vdCcpISkucmVuZGVyKFxuICA8UmVhY3QuU3RyaWN0TW9kZT5cbiAgICA8QXBwIC8+XG4gIDwvUmVhY3QuU3RyaWN0TW9kZT5cbilcbiJdLCJmaWxlIjoiL2hvbWUvd2lsbC9sb2NhbF9kZXYvcG9ydGZvbGlvL2FwcHMvcm9iaW4tbm9ndWllci9zcmMvbWFpbi50c3gifQ==",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 2138,
            "count": 1
          },
          {
            "startOffset": 315,
            "endOffset": 349,
            "count": 0
          },
          {
            "startOffset": 547,
            "endOffset": 591,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5173/node_modules/.vite/deps/react.js?v=a50bb159",
    "scriptId": "20",
    "source": "import {\n  require_react\n} from \"/node_modules/.vite/deps/chunk-R7U5S34U.js?v=a50bb159\";\nimport \"/node_modules/.vite/deps/chunk-LNEMQRCO.js?v=a50bb159\";\nexport default require_react();\n//# sourceMappingURL=react.js.map\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 219,
            "count": 1
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5173/node_modules/.vite/deps/react_jsx-dev-runtime.js?v=a50bb159",
    "scriptId": "19",
    "source": "import {\n  require_react\n} from \"/node_modules/.vite/deps/chunk-R7U5S34U.js?v=a50bb159\";\nimport {\n  __commonJS\n} from \"/node_modules/.vite/deps/chunk-LNEMQRCO.js?v=a50bb159\";\n\n// ../../node_modules/.pnpm/react@18.2.0/node_modules/react/cjs/react-jsx-dev-runtime.development.js\nvar require_react_jsx_dev_runtime_development = __commonJS({\n  \"../../node_modules/.pnpm/react@18.2.0/node_modules/react/cjs/react-jsx-dev-runtime.development.js\"(exports) {\n    \"use strict\";\n    if (true) {\n      (function() {\n        \"use strict\";\n        var React = require_react();\n        var REACT_ELEMENT_TYPE = Symbol.for(\"react.element\");\n        var REACT_PORTAL_TYPE = Symbol.for(\"react.portal\");\n        var REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\");\n        var REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\");\n        var REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\");\n        var REACT_PROVIDER_TYPE = Symbol.for(\"react.provider\");\n        var REACT_CONTEXT_TYPE = Symbol.for(\"react.context\");\n        var REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\");\n        var REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\");\n        var REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\");\n        var REACT_MEMO_TYPE = Symbol.for(\"react.memo\");\n        var REACT_LAZY_TYPE = Symbol.for(\"react.lazy\");\n        var REACT_OFFSCREEN_TYPE = Symbol.for(\"react.offscreen\");\n        var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\n        var FAUX_ITERATOR_SYMBOL = \"@@iterator\";\n        function getIteratorFn(maybeIterable) {\n          if (maybeIterable === null || typeof maybeIterable !== \"object\") {\n            return null;\n          }\n          var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n          if (typeof maybeIterator === \"function\") {\n            return maybeIterator;\n          }\n          return null;\n        }\n        var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n        function error(format) {\n          {\n            {\n              for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n                args[_key2 - 1] = arguments[_key2];\n              }\n              printWarning(\"error\", format, args);\n            }\n          }\n        }\n        function printWarning(level, format, args) {\n          {\n            var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;\n            var stack = ReactDebugCurrentFrame2.getStackAddendum();\n            if (stack !== \"\") {\n              format += \"%s\";\n              args = args.concat([stack]);\n            }\n            var argsWithFormat = args.map(function(item) {\n              return String(item);\n            });\n            argsWithFormat.unshift(\"Warning: \" + format);\n            Function.prototype.apply.call(console[level], console, argsWithFormat);\n          }\n        }\n        var enableScopeAPI = false;\n        var enableCacheElement = false;\n        var enableTransitionTracing = false;\n        var enableLegacyHidden = false;\n        var enableDebugTracing = false;\n        var REACT_MODULE_REFERENCE;\n        {\n          REACT_MODULE_REFERENCE = Symbol.for(\"react.module.reference\");\n        }\n        function isValidElementType(type) {\n          if (typeof type === \"string\" || typeof type === \"function\") {\n            return true;\n          }\n          if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {\n            return true;\n          }\n          if (typeof type === \"object\" && type !== null) {\n            if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object\n            // types supported by any Flight configuration anywhere since\n            // we don't know which Flight build this will end up being used\n            // with.\n            type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== void 0) {\n              return true;\n            }\n          }\n          return false;\n        }\n        function getWrappedName(outerType, innerType, wrapperName) {\n          var displayName = outerType.displayName;\n          if (displayName) {\n            return displayName;\n          }\n          var functionName = innerType.displayName || innerType.name || \"\";\n          return functionName !== \"\" ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n        }\n        function getContextName(type) {\n          return type.displayName || \"Context\";\n        }\n        function getComponentNameFromType(type) {\n          if (type == null) {\n            return null;\n          }\n          {\n            if (typeof type.tag === \"number\") {\n              error(\"Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.\");\n            }\n          }\n          if (typeof type === \"function\") {\n            return type.displayName || type.name || null;\n          }\n          if (typeof type === \"string\") {\n            return type;\n          }\n          switch (type) {\n            case REACT_FRAGMENT_TYPE:\n              return \"Fragment\";\n            case REACT_PORTAL_TYPE:\n              return \"Portal\";\n            case REACT_PROFILER_TYPE:\n              return \"Profiler\";\n            case REACT_STRICT_MODE_TYPE:\n              return \"StrictMode\";\n            case REACT_SUSPENSE_TYPE:\n              return \"Suspense\";\n            case REACT_SUSPENSE_LIST_TYPE:\n              return \"SuspenseList\";\n          }\n          if (typeof type === \"object\") {\n            switch (type.$$typeof) {\n              case REACT_CONTEXT_TYPE:\n                var context = type;\n                return getContextName(context) + \".Consumer\";\n              case REACT_PROVIDER_TYPE:\n                var provider = type;\n                return getContextName(provider._context) + \".Provider\";\n              case REACT_FORWARD_REF_TYPE:\n                return getWrappedName(type, type.render, \"ForwardRef\");\n              case REACT_MEMO_TYPE:\n                var outerName = type.displayName || null;\n                if (outerName !== null) {\n                  return outerName;\n                }\n                return getComponentNameFromType(type.type) || \"Memo\";\n              case REACT_LAZY_TYPE: {\n                var lazyComponent = type;\n                var payload = lazyComponent._payload;\n                var init = lazyComponent._init;\n                try {\n                  return getComponentNameFromType(init(payload));\n                } catch (x) {\n                  return null;\n                }\n              }\n            }\n          }\n          return null;\n        }\n        var assign = Object.assign;\n        var disabledDepth = 0;\n        var prevLog;\n        var prevInfo;\n        var prevWarn;\n        var prevError;\n        var prevGroup;\n        var prevGroupCollapsed;\n        var prevGroupEnd;\n        function disabledLog() {\n        }\n        disabledLog.__reactDisabledLog = true;\n        function disableLogs() {\n          {\n            if (disabledDepth === 0) {\n              prevLog = console.log;\n              prevInfo = console.info;\n              prevWarn = console.warn;\n              prevError = console.error;\n              prevGroup = console.group;\n              prevGroupCollapsed = console.groupCollapsed;\n              prevGroupEnd = console.groupEnd;\n              var props = {\n                configurable: true,\n                enumerable: true,\n                value: disabledLog,\n                writable: true\n              };\n              Object.defineProperties(console, {\n                info: props,\n                log: props,\n                warn: props,\n                error: props,\n                group: props,\n                groupCollapsed: props,\n                groupEnd: props\n              });\n            }\n            disabledDepth++;\n          }\n        }\n        function reenableLogs() {\n          {\n            disabledDepth--;\n            if (disabledDepth === 0) {\n              var props = {\n                configurable: true,\n                enumerable: true,\n                writable: true\n              };\n              Object.defineProperties(console, {\n                log: assign({}, props, {\n                  value: prevLog\n                }),\n                info: assign({}, props, {\n                  value: prevInfo\n                }),\n                warn: assign({}, props, {\n                  value: prevWarn\n                }),\n                error: assign({}, props, {\n                  value: prevError\n                }),\n                group: assign({}, props, {\n                  value: prevGroup\n                }),\n                groupCollapsed: assign({}, props, {\n                  value: prevGroupCollapsed\n                }),\n                groupEnd: assign({}, props, {\n                  value: prevGroupEnd\n                })\n              });\n            }\n            if (disabledDepth < 0) {\n              error(\"disabledDepth fell below zero. This is a bug in React. Please file an issue.\");\n            }\n          }\n        }\n        var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\n        var prefix;\n        function describeBuiltInComponentFrame(name, source, ownerFn) {\n          {\n            if (prefix === void 0) {\n              try {\n                throw Error();\n              } catch (x) {\n                var match = x.stack.trim().match(/\\n( *(at )?)/);\n                prefix = match && match[1] || \"\";\n              }\n            }\n            return \"\\n\" + prefix + name;\n          }\n        }\n        var reentry = false;\n        var componentFrameCache;\n        {\n          var PossiblyWeakMap = typeof WeakMap === \"function\" ? WeakMap : Map;\n          componentFrameCache = new PossiblyWeakMap();\n        }\n        function describeNativeComponentFrame(fn, construct) {\n          if (!fn || reentry) {\n            return \"\";\n          }\n          {\n            var frame = componentFrameCache.get(fn);\n            if (frame !== void 0) {\n              return frame;\n            }\n          }\n          var control;\n          reentry = true;\n          var previousPrepareStackTrace = Error.prepareStackTrace;\n          Error.prepareStackTrace = void 0;\n          var previousDispatcher;\n          {\n            previousDispatcher = ReactCurrentDispatcher.current;\n            ReactCurrentDispatcher.current = null;\n            disableLogs();\n          }\n          try {\n            if (construct) {\n              var Fake = function() {\n                throw Error();\n              };\n              Object.defineProperty(Fake.prototype, \"props\", {\n                set: function() {\n                  throw Error();\n                }\n              });\n              if (typeof Reflect === \"object\" && Reflect.construct) {\n                try {\n                  Reflect.construct(Fake, []);\n                } catch (x) {\n                  control = x;\n                }\n                Reflect.construct(fn, [], Fake);\n              } else {\n                try {\n                  Fake.call();\n                } catch (x) {\n                  control = x;\n                }\n                fn.call(Fake.prototype);\n              }\n            } else {\n              try {\n                throw Error();\n              } catch (x) {\n                control = x;\n              }\n              fn();\n            }\n          } catch (sample) {\n            if (sample && control && typeof sample.stack === \"string\") {\n              var sampleLines = sample.stack.split(\"\\n\");\n              var controlLines = control.stack.split(\"\\n\");\n              var s = sampleLines.length - 1;\n              var c = controlLines.length - 1;\n              while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {\n                c--;\n              }\n              for (; s >= 1 && c >= 0; s--, c--) {\n                if (sampleLines[s] !== controlLines[c]) {\n                  if (s !== 1 || c !== 1) {\n                    do {\n                      s--;\n                      c--;\n                      if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                        var _frame = \"\\n\" + sampleLines[s].replace(\" at new \", \" at \");\n                        if (fn.displayName && _frame.includes(\"<anonymous>\")) {\n                          _frame = _frame.replace(\"<anonymous>\", fn.displayName);\n                        }\n                        {\n                          if (typeof fn === \"function\") {\n                            componentFrameCache.set(fn, _frame);\n                          }\n                        }\n                        return _frame;\n                      }\n                    } while (s >= 1 && c >= 0);\n                  }\n                  break;\n                }\n              }\n            }\n          } finally {\n            reentry = false;\n            {\n              ReactCurrentDispatcher.current = previousDispatcher;\n              reenableLogs();\n            }\n            Error.prepareStackTrace = previousPrepareStackTrace;\n          }\n          var name = fn ? fn.displayName || fn.name : \"\";\n          var syntheticFrame = name ? describeBuiltInComponentFrame(name) : \"\";\n          {\n            if (typeof fn === \"function\") {\n              componentFrameCache.set(fn, syntheticFrame);\n            }\n          }\n          return syntheticFrame;\n        }\n        function describeFunctionComponentFrame(fn, source, ownerFn) {\n          {\n            return describeNativeComponentFrame(fn, false);\n          }\n        }\n        function shouldConstruct(Component) {\n          var prototype = Component.prototype;\n          return !!(prototype && prototype.isReactComponent);\n        }\n        function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {\n          if (type == null) {\n            return \"\";\n          }\n          if (typeof type === \"function\") {\n            {\n              return describeNativeComponentFrame(type, shouldConstruct(type));\n            }\n          }\n          if (typeof type === \"string\") {\n            return describeBuiltInComponentFrame(type);\n          }\n          switch (type) {\n            case REACT_SUSPENSE_TYPE:\n              return describeBuiltInComponentFrame(\"Suspense\");\n            case REACT_SUSPENSE_LIST_TYPE:\n              return describeBuiltInComponentFrame(\"SuspenseList\");\n          }\n          if (typeof type === \"object\") {\n            switch (type.$$typeof) {\n              case REACT_FORWARD_REF_TYPE:\n                return describeFunctionComponentFrame(type.render);\n              case REACT_MEMO_TYPE:\n                return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);\n              case REACT_LAZY_TYPE: {\n                var lazyComponent = type;\n                var payload = lazyComponent._payload;\n                var init = lazyComponent._init;\n                try {\n                  return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);\n                } catch (x) {\n                }\n              }\n            }\n          }\n          return \"\";\n        }\n        var hasOwnProperty = Object.prototype.hasOwnProperty;\n        var loggedTypeFailures = {};\n        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n        function setCurrentlyValidatingElement(element) {\n          {\n            if (element) {\n              var owner = element._owner;\n              var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n              ReactDebugCurrentFrame.setExtraStackFrame(stack);\n            } else {\n              ReactDebugCurrentFrame.setExtraStackFrame(null);\n            }\n          }\n        }\n        function checkPropTypes(typeSpecs, values, location, componentName, element) {\n          {\n            var has = Function.call.bind(hasOwnProperty);\n            for (var typeSpecName in typeSpecs) {\n              if (has(typeSpecs, typeSpecName)) {\n                var error$1 = void 0;\n                try {\n                  if (typeof typeSpecs[typeSpecName] !== \"function\") {\n                    var err = Error((componentName || \"React class\") + \": \" + location + \" type `\" + typeSpecName + \"` is invalid; it must be a function, usually from the `prop-types` package, but received `\" + typeof typeSpecs[typeSpecName] + \"`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.\");\n                    err.name = \"Invariant Violation\";\n                    throw err;\n                  }\n                  error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, \"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED\");\n                } catch (ex) {\n                  error$1 = ex;\n                }\n                if (error$1 && !(error$1 instanceof Error)) {\n                  setCurrentlyValidatingElement(element);\n                  error(\"%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).\", componentName || \"React class\", location, typeSpecName, typeof error$1);\n                  setCurrentlyValidatingElement(null);\n                }\n                if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {\n                  loggedTypeFailures[error$1.message] = true;\n                  setCurrentlyValidatingElement(element);\n                  error(\"Failed %s type: %s\", location, error$1.message);\n                  setCurrentlyValidatingElement(null);\n                }\n              }\n            }\n          }\n        }\n        var isArrayImpl = Array.isArray;\n        function isArray(a) {\n          return isArrayImpl(a);\n        }\n        function typeName(value) {\n          {\n            var hasToStringTag = typeof Symbol === \"function\" && Symbol.toStringTag;\n            var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || \"Object\";\n            return type;\n          }\n        }\n        function willCoercionThrow(value) {\n          {\n            try {\n              testStringCoercion(value);\n              return false;\n            } catch (e) {\n              return true;\n            }\n          }\n        }\n        function testStringCoercion(value) {\n          return \"\" + value;\n        }\n        function checkKeyStringCoercion(value) {\n          {\n            if (willCoercionThrow(value)) {\n              error(\"The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.\", typeName(value));\n              return testStringCoercion(value);\n            }\n          }\n        }\n        var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\n        var RESERVED_PROPS = {\n          key: true,\n          ref: true,\n          __self: true,\n          __source: true\n        };\n        var specialPropKeyWarningShown;\n        var specialPropRefWarningShown;\n        var didWarnAboutStringRefs;\n        {\n          didWarnAboutStringRefs = {};\n        }\n        function hasValidRef(config) {\n          {\n            if (hasOwnProperty.call(config, \"ref\")) {\n              var getter = Object.getOwnPropertyDescriptor(config, \"ref\").get;\n              if (getter && getter.isReactWarning) {\n                return false;\n              }\n            }\n          }\n          return config.ref !== void 0;\n        }\n        function hasValidKey(config) {\n          {\n            if (hasOwnProperty.call(config, \"key\")) {\n              var getter = Object.getOwnPropertyDescriptor(config, \"key\").get;\n              if (getter && getter.isReactWarning) {\n                return false;\n              }\n            }\n          }\n          return config.key !== void 0;\n        }\n        function warnIfStringRefCannotBeAutoConverted(config, self) {\n          {\n            if (typeof config.ref === \"string\" && ReactCurrentOwner.current && self && ReactCurrentOwner.current.stateNode !== self) {\n              var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);\n              if (!didWarnAboutStringRefs[componentName]) {\n                error('Component \"%s\" contains the string ref \"%s\". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', getComponentNameFromType(ReactCurrentOwner.current.type), config.ref);\n                didWarnAboutStringRefs[componentName] = true;\n              }\n            }\n          }\n        }\n        function defineKeyPropWarningGetter(props, displayName) {\n          {\n            var warnAboutAccessingKey = function() {\n              if (!specialPropKeyWarningShown) {\n                specialPropKeyWarningShown = true;\n                error(\"%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)\", displayName);\n              }\n            };\n            warnAboutAccessingKey.isReactWarning = true;\n            Object.defineProperty(props, \"key\", {\n              get: warnAboutAccessingKey,\n              configurable: true\n            });\n          }\n        }\n        function defineRefPropWarningGetter(props, displayName) {\n          {\n            var warnAboutAccessingRef = function() {\n              if (!specialPropRefWarningShown) {\n                specialPropRefWarningShown = true;\n                error(\"%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)\", displayName);\n              }\n            };\n            warnAboutAccessingRef.isReactWarning = true;\n            Object.defineProperty(props, \"ref\", {\n              get: warnAboutAccessingRef,\n              configurable: true\n            });\n          }\n        }\n        var ReactElement = function(type, key, ref, self, source, owner, props) {\n          var element = {\n            // This tag allows us to uniquely identify this as a React Element\n            $$typeof: REACT_ELEMENT_TYPE,\n            // Built-in properties that belong on the element\n            type,\n            key,\n            ref,\n            props,\n            // Record the component responsible for creating this element.\n            _owner: owner\n          };\n          {\n            element._store = {};\n            Object.defineProperty(element._store, \"validated\", {\n              configurable: false,\n              enumerable: false,\n              writable: true,\n              value: false\n            });\n            Object.defineProperty(element, \"_self\", {\n              configurable: false,\n              enumerable: false,\n              writable: false,\n              value: self\n            });\n            Object.defineProperty(element, \"_source\", {\n              configurable: false,\n              enumerable: false,\n              writable: false,\n              value: source\n            });\n            if (Object.freeze) {\n              Object.freeze(element.props);\n              Object.freeze(element);\n            }\n          }\n          return element;\n        };\n        function jsxDEV(type, config, maybeKey, source, self) {\n          {\n            var propName;\n            var props = {};\n            var key = null;\n            var ref = null;\n            if (maybeKey !== void 0) {\n              {\n                checkKeyStringCoercion(maybeKey);\n              }\n              key = \"\" + maybeKey;\n            }\n            if (hasValidKey(config)) {\n              {\n                checkKeyStringCoercion(config.key);\n              }\n              key = \"\" + config.key;\n            }\n            if (hasValidRef(config)) {\n              ref = config.ref;\n              warnIfStringRefCannotBeAutoConverted(config, self);\n            }\n            for (propName in config) {\n              if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n                props[propName] = config[propName];\n              }\n            }\n            if (type && type.defaultProps) {\n              var defaultProps = type.defaultProps;\n              for (propName in defaultProps) {\n                if (props[propName] === void 0) {\n                  props[propName] = defaultProps[propName];\n                }\n              }\n            }\n            if (key || ref) {\n              var displayName = typeof type === \"function\" ? type.displayName || type.name || \"Unknown\" : type;\n              if (key) {\n                defineKeyPropWarningGetter(props, displayName);\n              }\n              if (ref) {\n                defineRefPropWarningGetter(props, displayName);\n              }\n            }\n            return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);\n          }\n        }\n        var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;\n        var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;\n        function setCurrentlyValidatingElement$1(element) {\n          {\n            if (element) {\n              var owner = element._owner;\n              var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n              ReactDebugCurrentFrame$1.setExtraStackFrame(stack);\n            } else {\n              ReactDebugCurrentFrame$1.setExtraStackFrame(null);\n            }\n          }\n        }\n        var propTypesMisspellWarningShown;\n        {\n          propTypesMisspellWarningShown = false;\n        }\n        function isValidElement(object) {\n          {\n            return typeof object === \"object\" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n          }\n        }\n        function getDeclarationErrorAddendum() {\n          {\n            if (ReactCurrentOwner$1.current) {\n              var name = getComponentNameFromType(ReactCurrentOwner$1.current.type);\n              if (name) {\n                return \"\\n\\nCheck the render method of `\" + name + \"`.\";\n              }\n            }\n            return \"\";\n          }\n        }\n        function getSourceInfoErrorAddendum(source) {\n          {\n            if (source !== void 0) {\n              var fileName = source.fileName.replace(/^.*[\\\\\\/]/, \"\");\n              var lineNumber = source.lineNumber;\n              return \"\\n\\nCheck your code at \" + fileName + \":\" + lineNumber + \".\";\n            }\n            return \"\";\n          }\n        }\n        var ownerHasKeyUseWarning = {};\n        function getCurrentComponentErrorInfo(parentType) {\n          {\n            var info = getDeclarationErrorAddendum();\n            if (!info) {\n              var parentName = typeof parentType === \"string\" ? parentType : parentType.displayName || parentType.name;\n              if (parentName) {\n                info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\n              }\n            }\n            return info;\n          }\n        }\n        function validateExplicitKey(element, parentType) {\n          {\n            if (!element._store || element._store.validated || element.key != null) {\n              return;\n            }\n            element._store.validated = true;\n            var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n            if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n              return;\n            }\n            ownerHasKeyUseWarning[currentComponentErrorInfo] = true;\n            var childOwner = \"\";\n            if (element && element._owner && element._owner !== ReactCurrentOwner$1.current) {\n              childOwner = \" It was passed a child from \" + getComponentNameFromType(element._owner.type) + \".\";\n            }\n            setCurrentlyValidatingElement$1(element);\n            error('Each child in a list should have a unique \"key\" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);\n            setCurrentlyValidatingElement$1(null);\n          }\n        }\n        function validateChildKeys(node, parentType) {\n          {\n            if (typeof node !== \"object\") {\n              return;\n            }\n            if (isArray(node)) {\n              for (var i = 0; i < node.length; i++) {\n                var child = node[i];\n                if (isValidElement(child)) {\n                  validateExplicitKey(child, parentType);\n                }\n              }\n            } else if (isValidElement(node)) {\n              if (node._store) {\n                node._store.validated = true;\n              }\n            } else if (node) {\n              var iteratorFn = getIteratorFn(node);\n              if (typeof iteratorFn === \"function\") {\n                if (iteratorFn !== node.entries) {\n                  var iterator = iteratorFn.call(node);\n                  var step;\n                  while (!(step = iterator.next()).done) {\n                    if (isValidElement(step.value)) {\n                      validateExplicitKey(step.value, parentType);\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n        function validatePropTypes(element) {\n          {\n            var type = element.type;\n            if (type === null || type === void 0 || typeof type === \"string\") {\n              return;\n            }\n            var propTypes;\n            if (typeof type === \"function\") {\n              propTypes = type.propTypes;\n            } else if (typeof type === \"object\" && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.\n            // Inner props are checked in the reconciler.\n            type.$$typeof === REACT_MEMO_TYPE)) {\n              propTypes = type.propTypes;\n            } else {\n              return;\n            }\n            if (propTypes) {\n              var name = getComponentNameFromType(type);\n              checkPropTypes(propTypes, element.props, \"prop\", name, element);\n            } else if (type.PropTypes !== void 0 && !propTypesMisspellWarningShown) {\n              propTypesMisspellWarningShown = true;\n              var _name = getComponentNameFromType(type);\n              error(\"Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?\", _name || \"Unknown\");\n            }\n            if (typeof type.getDefaultProps === \"function\" && !type.getDefaultProps.isReactClassApproved) {\n              error(\"getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.\");\n            }\n          }\n        }\n        function validateFragmentProps(fragment) {\n          {\n            var keys = Object.keys(fragment.props);\n            for (var i = 0; i < keys.length; i++) {\n              var key = keys[i];\n              if (key !== \"children\" && key !== \"key\") {\n                setCurrentlyValidatingElement$1(fragment);\n                error(\"Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.\", key);\n                setCurrentlyValidatingElement$1(null);\n                break;\n              }\n            }\n            if (fragment.ref !== null) {\n              setCurrentlyValidatingElement$1(fragment);\n              error(\"Invalid attribute `ref` supplied to `React.Fragment`.\");\n              setCurrentlyValidatingElement$1(null);\n            }\n          }\n        }\n        function jsxWithValidation(type, props, key, isStaticChildren, source, self) {\n          {\n            var validType = isValidElementType(type);\n            if (!validType) {\n              var info = \"\";\n              if (type === void 0 || typeof type === \"object\" && type !== null && Object.keys(type).length === 0) {\n                info += \" You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.\";\n              }\n              var sourceInfo = getSourceInfoErrorAddendum(source);\n              if (sourceInfo) {\n                info += sourceInfo;\n              } else {\n                info += getDeclarationErrorAddendum();\n              }\n              var typeString;\n              if (type === null) {\n                typeString = \"null\";\n              } else if (isArray(type)) {\n                typeString = \"array\";\n              } else if (type !== void 0 && type.$$typeof === REACT_ELEMENT_TYPE) {\n                typeString = \"<\" + (getComponentNameFromType(type.type) || \"Unknown\") + \" />\";\n                info = \" Did you accidentally export a JSX literal instead of a component?\";\n              } else {\n                typeString = typeof type;\n              }\n              error(\"React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s\", typeString, info);\n            }\n            var element = jsxDEV(type, props, key, source, self);\n            if (element == null) {\n              return element;\n            }\n            if (validType) {\n              var children = props.children;\n              if (children !== void 0) {\n                if (isStaticChildren) {\n                  if (isArray(children)) {\n                    for (var i = 0; i < children.length; i++) {\n                      validateChildKeys(children[i], type);\n                    }\n                    if (Object.freeze) {\n                      Object.freeze(children);\n                    }\n                  } else {\n                    error(\"React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.\");\n                  }\n                } else {\n                  validateChildKeys(children, type);\n                }\n              }\n            }\n            if (type === REACT_FRAGMENT_TYPE) {\n              validateFragmentProps(element);\n            } else {\n              validatePropTypes(element);\n            }\n            return element;\n          }\n        }\n        var jsxDEV$1 = jsxWithValidation;\n        exports.Fragment = REACT_FRAGMENT_TYPE;\n        exports.jsxDEV = jsxDEV$1;\n      })();\n    }\n  }\n});\n\n// ../../node_modules/.pnpm/react@18.2.0/node_modules/react/jsx-dev-runtime.js\nvar require_jsx_dev_runtime = __commonJS({\n  \"../../node_modules/.pnpm/react@18.2.0/node_modules/react/jsx-dev-runtime.js\"(exports, module) {\n    if (false) {\n      module.exports = null;\n    } else {\n      module.exports = require_react_jsx_dev_runtime_development();\n    }\n  }\n});\nexport default require_jsx_dev_runtime();\n/*! Bundled license information:\n\nreact/cjs/react-jsx-dev-runtime.development.js:\n  (**\n   * @license React\n   * react-jsx-dev-runtime.development.js\n   *\n   * Copyright (c) Facebook, Inc. and its affiliates.\n   *\n   * This source code is licensed under the MIT license found in the\n   * LICENSE file in the root directory of this source tree.\n   *)\n*/\n//# sourceMappingURL=react_jsx-dev-runtime.js.map\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 36143,
            "count": 1
          }
        ]
      },
      {
        "functionName": "../../node_modules/.pnpm/react@18.2.0/node_modules/react/cjs/react-jsx-dev-runtime.development.js",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 340,
            "endOffset": 35330,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 492,
            "endOffset": 35316,
            "count": 1
          },
          {
            "startOffset": 10259,
            "endOffset": 10264,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getIteratorFn",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1506,
            "endOffset": 1923,
            "count": 0
          }
        ]
      },
      {
        "functionName": "error",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2025,
            "endOffset": 2361,
            "count": 0
          }
        ]
      },
      {
        "functionName": "printWarning",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2370,
            "endOffset": 2974,
            "count": 0
          }
        ]
      },
      {
        "functionName": "isValidElementType",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 3313,
            "endOffset": 4501,
            "count": 150
          },
          {
            "startOffset": 3388,
            "endOffset": 3417,
            "count": 16
          },
          {
            "startOffset": 3419,
            "endOffset": 3457,
            "count": 145
          },
          {
            "startOffset": 3457,
            "endOffset": 3501,
            "count": 5
          },
          {
            "startOffset": 3501,
            "endOffset": 3532,
            "count": 3
          },
          {
            "startOffset": 3533,
            "endOffset": 3554,
            "count": 3
          },
          {
            "startOffset": 3555,
            "endOffset": 3589,
            "count": 3
          },
          {
            "startOffset": 3590,
            "endOffset": 3621,
            "count": 2
          },
          {
            "startOffset": 3622,
            "endOffset": 3658,
            "count": 2
          },
          {
            "startOffset": 3659,
            "endOffset": 3680,
            "count": 2
          },
          {
            "startOffset": 3681,
            "endOffset": 3713,
            "count": 2
          },
          {
            "startOffset": 3714,
            "endOffset": 3731,
            "count": 2
          },
          {
            "startOffset": 3732,
            "endOffset": 3753,
            "count": 2
          },
          {
            "startOffset": 3754,
            "endOffset": 3780,
            "count": 2
          },
          {
            "startOffset": 3782,
            "endOffset": 3820,
            "count": 3
          },
          {
            "startOffset": 3820,
            "endOffset": 3876,
            "count": 2
          },
          {
            "startOffset": 3878,
            "endOffset": 4467,
            "count": 2
          },
          {
            "startOffset": 4008,
            "endOffset": 4047,
            "count": 0
          },
          {
            "startOffset": 4048,
            "endOffset": 4091,
            "count": 0
          },
          {
            "startOffset": 4092,
            "endOffset": 4380,
            "count": 0
          },
          {
            "startOffset": 4381,
            "endOffset": 4411,
            "count": 0
          },
          {
            "startOffset": 4467,
            "endOffset": 4500,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getWrappedName",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4510,
            "endOffset": 4873,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getContextName",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4882,
            "endOffset": 4971,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getComponentNameFromType",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4980,
            "endOffset": 7143,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disabledLog",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 7388,
            "endOffset": 7422,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disableLogs",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 7478,
            "endOffset": 8387,
            "count": 0
          }
        ]
      },
      {
        "functionName": "reenableLogs",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 8396,
            "endOffset": 9603,
            "count": 0
          }
        ]
      },
      {
        "functionName": "describeBuiltInComponentFrame",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 9714,
            "endOffset": 10114,
            "count": 0
          }
        ]
      },
      {
        "functionName": "describeNativeComponentFrame",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10339,
            "endOffset": 13923,
            "count": 0
          }
        ]
      },
      {
        "functionName": "describeFunctionComponentFrame",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13932,
            "endOffset": 14088,
            "count": 0
          }
        ]
      },
      {
        "functionName": "shouldConstruct",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14097,
            "endOffset": 14253,
            "count": 0
          }
        ]
      },
      {
        "functionName": "describeUnknownElementTypeFrameInDEV",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14262,
            "endOffset": 15657,
            "count": 0
          }
        ]
      },
      {
        "functionName": "setCurrentlyValidatingElement",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15847,
            "endOffset": 16283,
            "count": 0
          }
        ]
      },
      {
        "functionName": "checkPropTypes",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 16292,
            "endOffset": 18340,
            "count": 0
          }
        ]
      },
      {
        "functionName": "isArray",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 18390,
            "endOffset": 18454,
            "count": 107
          }
        ]
      },
      {
        "functionName": "typeName",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 18463,
            "endOffset": 18739,
            "count": 0
          }
        ]
      },
      {
        "functionName": "willCoercionThrow",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 18748,
            "endOffset": 18971,
            "count": 48
          },
          {
            "startOffset": 18897,
            "endOffset": 18949,
            "count": 0
          }
        ]
      },
      {
        "functionName": "testStringCoercion",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 18980,
            "endOffset": 19055,
            "count": 48
          }
        ]
      },
      {
        "functionName": "checkKeyStringCoercion",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 19064,
            "endOffset": 19397,
            "count": 48
          },
          {
            "startOffset": 19159,
            "endOffset": 19375,
            "count": 0
          }
        ]
      },
      {
        "functionName": "hasValidRef",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 19786,
            "endOffset": 20136,
            "count": 150
          },
          {
            "startOffset": 19881,
            "endOffset": 20074,
            "count": 20
          },
          {
            "startOffset": 19987,
            "endOffset": 20011,
            "count": 0
          },
          {
            "startOffset": 20013,
            "endOffset": 20060,
            "count": 0
          }
        ]
      },
      {
        "functionName": "hasValidKey",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 20145,
            "endOffset": 20495,
            "count": 150
          },
          {
            "startOffset": 20240,
            "endOffset": 20433,
            "count": 0
          }
        ]
      },
      {
        "functionName": "warnIfStringRefCannotBeAutoConverted",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 20504,
            "endOffset": 21420,
            "count": 20
          },
          {
            "startOffset": 20625,
            "endOffset": 20653,
            "count": 0
          },
          {
            "startOffset": 20654,
            "endOffset": 20661,
            "count": 0
          },
          {
            "startOffset": 20662,
            "endOffset": 20709,
            "count": 0
          },
          {
            "startOffset": 20711,
            "endOffset": 21398,
            "count": 0
          }
        ]
      },
      {
        "functionName": "defineKeyPropWarningGetter",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 21429,
            "endOffset": 22175,
            "count": 48
          }
        ]
      },
      {
        "functionName": "warnAboutAccessingKey",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 21539,
            "endOffset": 21954,
            "count": 0
          }
        ]
      },
      {
        "functionName": "defineRefPropWarningGetter",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 22184,
            "endOffset": 22930,
            "count": 20
          }
        ]
      },
      {
        "functionName": "warnAboutAccessingRef",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 22294,
            "endOffset": 22709,
            "count": 0
          }
        ]
      },
      {
        "functionName": "ReactElement",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 22958,
            "endOffset": 24228,
            "count": 150
          }
        ]
      },
      {
        "functionName": "jsxDEV",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 24238,
            "endOffset": 25921,
            "count": 150
          },
          {
            "startOffset": 24453,
            "endOffset": 24585,
            "count": 48
          },
          {
            "startOffset": 24623,
            "endOffset": 24759,
            "count": 0
          },
          {
            "startOffset": 24797,
            "endOffset": 24910,
            "count": 20
          },
          {
            "startOffset": 24948,
            "endOffset": 25134,
            "count": 303
          },
          {
            "startOffset": 25051,
            "endOffset": 25120,
            "count": 283
          },
          {
            "startOffset": 25178,
            "endOffset": 25436,
            "count": 0
          },
          {
            "startOffset": 25457,
            "endOffset": 25463,
            "count": 102
          },
          {
            "startOffset": 25465,
            "endOffset": 25802,
            "count": 68
          },
          {
            "startOffset": 25526,
            "endOffset": 25570,
            "count": 0
          },
          {
            "startOffset": 25602,
            "endOffset": 25683,
            "count": 48
          },
          {
            "startOffset": 25707,
            "endOffset": 25788,
            "count": 20
          }
        ]
      },
      {
        "functionName": "setCurrentlyValidatingElement$1",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 26088,
            "endOffset": 26530,
            "count": 0
          }
        ]
      },
      {
        "functionName": "isValidElement",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 26651,
            "endOffset": 26826,
            "count": 143
          }
        ]
      },
      {
        "functionName": "getDeclarationErrorAddendum",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 26835,
            "endOffset": 27193,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getSourceInfoErrorAddendum",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 27202,
            "endOffset": 27560,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getCurrentComponentErrorInfo",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 27609,
            "endOffset": 28070,
            "count": 0
          }
        ]
      },
      {
        "functionName": "validateExplicitKey",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 28079,
            "endOffset": 29133,
            "count": 54
          },
          {
            "startOffset": 28203,
            "endOffset": 28225,
            "count": 48
          },
          {
            "startOffset": 28264,
            "endOffset": 28643,
            "count": 0
          },
          {
            "startOffset": 28644,
            "endOffset": 28693,
            "count": 0
          },
          {
            "startOffset": 28695,
            "endOffset": 29132,
            "count": 0
          }
        ]
      },
      {
        "functionName": "validateChildKeys",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 29142,
            "endOffset": 30247,
            "count": 157
          },
          {
            "startOffset": 29243,
            "endOffset": 29280,
            "count": 62
          },
          {
            "startOffset": 29280,
            "endOffset": 29312,
            "count": 95
          },
          {
            "startOffset": 29312,
            "endOffset": 29555,
            "count": 6
          },
          {
            "startOffset": 29366,
            "endOffset": 29541,
            "count": 54
          },
          {
            "startOffset": 29555,
            "endOffset": 30225,
            "count": 89
          },
          {
            "startOffset": 29697,
            "endOffset": 30225,
            "count": 0
          }
        ]
      },
      {
        "functionName": "validatePropTypes",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 30256,
            "endOffset": 31730,
            "count": 148
          },
          {
            "startOffset": 30421,
            "endOffset": 30458,
            "count": 134
          },
          {
            "startOffset": 30458,
            "endOffset": 30530,
            "count": 14
          },
          {
            "startOffset": 30530,
            "endOffset": 30587,
            "count": 11
          },
          {
            "startOffset": 30587,
            "endOffset": 30920,
            "count": 3
          },
          {
            "startOffset": 30622,
            "endOffset": 30818,
            "count": 2
          },
          {
            "startOffset": 30820,
            "endOffset": 30877,
            "count": 0
          },
          {
            "startOffset": 30920,
            "endOffset": 30948,
            "count": 11
          },
          {
            "startOffset": 30948,
            "endOffset": 31099,
            "count": 0
          },
          {
            "startOffset": 31099,
            "endOffset": 31439,
            "count": 11
          },
          {
            "startOffset": 31135,
            "endOffset": 31168,
            "count": 0
          },
          {
            "startOffset": 31170,
            "endOffset": 31439,
            "count": 0
          },
          {
            "startOffset": 31439,
            "endOffset": 31499,
            "count": 11
          },
          {
            "startOffset": 31499,
            "endOffset": 31544,
            "count": 0
          },
          {
            "startOffset": 31546,
            "endOffset": 31708,
            "count": 0
          }
        ]
      },
      {
        "functionName": "validateFragmentProps",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 31739,
            "endOffset": 32555,
            "count": 2
          },
          {
            "startOffset": 31968,
            "endOffset": 31984,
            "count": 0
          },
          {
            "startOffset": 31986,
            "endOffset": 32276,
            "count": 0
          },
          {
            "startOffset": 32330,
            "endOffset": 32533,
            "count": 0
          }
        ]
      },
      {
        "functionName": "jsxWithValidation",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 32564,
            "endOffset": 35183,
            "count": 150
          },
          {
            "startOffset": 32737,
            "endOffset": 34011,
            "count": 0
          },
          {
            "startOffset": 34111,
            "endOffset": 34156,
            "count": 0
          },
          {
            "startOffset": 34270,
            "endOffset": 34948,
            "count": 135
          },
          {
            "startOffset": 34310,
            "endOffset": 34854,
            "count": 12
          },
          {
            "startOffset": 34417,
            "endOffset": 34500,
            "count": 34
          },
          {
            "startOffset": 34630,
            "endOffset": 34836,
            "count": 0
          },
          {
            "startOffset": 34854,
            "endOffset": 34932,
            "count": 123
          },
          {
            "startOffset": 35009,
            "endOffset": 35070,
            "count": 2
          },
          {
            "startOffset": 35070,
            "endOffset": 35133,
            "count": 148
          }
        ]
      },
      {
        "functionName": "../../node_modules/.pnpm/react@18.2.0/node_modules/react/jsx-dev-runtime.js",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 35460,
            "endOffset": 35693,
            "count": 1
          },
          {
            "startOffset": 35572,
            "endOffset": 35608,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5173/src/index.css",
    "scriptId": "23",
    "source": "import { createHotContext as __vite__createHotContext } from \"/@vite/client\";import.meta.hot = __vite__createHotContext(\"/src/index.css\");import { updateStyle as __vite__updateStyle, removeStyle as __vite__removeStyle } from \"/@vite/client\"\nconst __vite__id = \"/home/will/local_dev/portfolio/apps/robin-noguier/src/index.css\"\nconst __vite__css = \"* {\\n  margin: 0;\\n  padding: 0;\\n  box-sizing: border-box;\\n  cursor: none !important;\\n}\\n\\n:root {\\n  /* Default theme - Sunset */\\n  --bg-primary: #1a0b2e;\\n  --bg-secondary: #2d1b69;\\n  --text-primary: #ff8c94;\\n  --text-secondary: rgba(255, 140, 148, 0.85);\\n  --accent: #ffd166;\\n  --border: rgba(255, 140, 148, 0.15);\\n\\n  /* Typography */\\n  --font-system: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Helvetica Neue',\\n    Arial, sans-serif;\\n  --font-serif-fashion: 'Playfair Display', serif;\\n  --font-serif-editorial: 'Bodoni Moda', serif;\\n  --font-serif-modern: 'Lora', serif;\\n  --font-sans-clean: 'Helvetica Neue', Arial, sans-serif;\\n  --font-sans-modern: 'Montserrat', sans-serif;\\n  --font-sans-strong: 'Oswald', sans-serif;\\n  --font-display-bold: 'Bebas Neue', sans-serif;\\n  --font-display-tech: 'Russo One', sans-serif;\\n  --font-display-impact: 'Archivo Black', sans-serif;\\n\\n  /* Active font selections */\\n  --font-heading: var(--font-serif-fashion);\\n  --font-subtitle: var(--font-sans-modern);\\n  --font-body: var(--font-system);\\n  --font-display: var(--font-serif-fashion);\\n\\n  /* Motion system colors */\\n  --color-background: var(--bg-primary);\\n  --color-text: var(--text-primary);\\n  --color-border: var(--border);\\n\\n  font-family: var(--font-body);\\n  line-height: 1.5;\\n  font-weight: 400;\\n\\n  color-scheme: dark;\\n  color: var(--text-primary);\\n  background-color: var(--bg-primary);\\n\\n  font-synthesis: none;\\n  text-rendering: optimizeLegibility;\\n  -webkit-font-smoothing: antialiased;\\n  -moz-osx-font-smoothing: grayscale;\\n  -webkit-text-size-adjust: 100%;\\n  text-size-adjust: 100%;\\n}\\n\\n/* Theme variations */\\n[data-theme='sunset'] {\\n  --bg-primary: #1a0b2e;\\n  --bg-secondary: #2d1b69;\\n  --text-primary: #ff8c94;\\n  --text-secondary: rgba(255, 140, 148, 0.85);\\n  --accent: #ffd166;\\n  --border: rgba(255, 140, 148, 0.15);\\n  --font-heading: var(--font-serif-fashion);\\n}\\n\\n[data-theme='cyberpunk'] {\\n  --bg-primary: #0a0a14;\\n  --bg-secondary: #141428;\\n  --text-primary: #00ffaa;\\n  --text-secondary: rgba(0, 255, 170, 0.85);\\n  --accent: #ff0080;\\n  --border: rgba(0, 255, 170, 0.15);\\n  --font-heading: var(--font-display-tech);\\n}\\n\\n[data-theme='att'] {\\n  --bg-primary: #000000;\\n  --bg-secondary: #0d0d0d;\\n  --text-primary: #ffffff;\\n  --text-secondary: rgba(255, 255, 255, 0.9);\\n  --accent: #00a8e0;\\n  --border: rgba(0, 168, 224, 0.25);\\n  --font-heading: var(--font-sans-modern);\\n}\\n\\n[data-theme='msu'] {\\n  --bg-primary: #18453b;\\n  --bg-secondary: #1e5a4c;\\n  --text-primary: #ffffff;\\n  --text-secondary: rgba(255, 255, 255, 0.9);\\n  --accent: #ffffff;\\n  --border: rgba(255, 255, 255, 0.25);\\n  --font-heading: var(--font-display-bold);\\n}\\n\\nhtml {\\n  scroll-behavior: auto;\\n}\\n\\nbody {\\n  margin: 0;\\n  min-width: 320px;\\n  min-height: 100vh;\\n  overflow-x: hidden;\\n  background-color: var(--bg-primary);\\n  color: var(--text-primary);\\n  transition:\\n    background-color 0.3s ease,\\n    color 0.3s ease;\\n}\\n\\nmain {\\n  width: 100%;\\n  min-height: 100vh;\\n}\\n\\nh1,\\nh2,\\nh3,\\nh4,\\nh5,\\nh6 {\\n  font-weight: 700;\\n  line-height: 1.2;\\n}\\n\\na {\\n  color: inherit;\\n  text-decoration: none;\\n}\\n\\nbutton {\\n  border: none;\\n  background: none;\\n  font: inherit;\\n  cursor: none;\\n}\\n\\ncanvas {\\n  display: block;\\n}\\n\"\n__vite__updateStyle(__vite__id, __vite__css)\nimport.meta.hot.accept()\nimport.meta.hot.prune(() => __vite__removeStyle(__vite__id))",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 3779,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 3741,
            "endOffset": 3778,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5173/src/App.tsx?t=1750726948502",
    "scriptId": "22",
    "source": "import { createHotContext as __vite__createHotContext } from \"/@vite/client\";import.meta.hot = __vite__createHotContext(\"/src/App.tsx\");import __vite__cjsImport0_react_jsxDevRuntime from \"/node_modules/.vite/deps/react_jsx-dev-runtime.js?v=a50bb159\"; const jsxDEV = __vite__cjsImport0_react_jsxDevRuntime[\"jsxDEV\"];\nimport RefreshRuntime from \"/@react-refresh\";\nconst inWebWorker = typeof WorkerGlobalScope !== \"undefined\" && self instanceof WorkerGlobalScope;\nlet prevRefreshReg;\nlet prevRefreshSig;\nif (import.meta.hot && !inWebWorker) {\n  if (!window.__vite_plugin_react_preamble_installed__) {\n    throw new Error(\"@vitejs/plugin-react can't detect preamble. Something is wrong. See https://github.com/vitejs/vite-plugin-react/pull/11#discussion_r430879201\");\n  }\n  prevRefreshReg = window.$RefreshReg$;\n  prevRefreshSig = window.$RefreshSig$;\n  window.$RefreshReg$ = (type, id) => {\n    RefreshRuntime.register(type, \"/home/will/local_dev/portfolio/apps/robin-noguier/src/App.tsx \" + id);\n  };\n  window.$RefreshSig$ = RefreshRuntime.createSignatureFunctionForTransform;\n}\nvar _s = $RefreshSig$();\nimport __vite__cjsImport3_react from \"/node_modules/.vite/deps/react.js?v=a50bb159\"; const useState = __vite__cjsImport3_react[\"useState\"];\nimport { gsap } from \"/node_modules/.vite/deps/gsap.js?v=a50bb159\";\nimport { ScrollTrigger } from \"/node_modules/.vite/deps/gsap_ScrollTrigger.js?v=a50bb159\";\nimport { ScrollToPlugin } from \"/node_modules/.vite/deps/gsap_ScrollToPlugin.js?v=a50bb159\";\nimport {\n  MotionProvider,\n  HeroToContactHeaderOrchestrator\n} from \"/@fs/home/will/local_dev/portfolio/packages/motion-system/src/index.ts?t=1750724128976\";\nimport HeroSectionWebGL from \"/src/components/Hero/HeroSectionWebGL.tsx?t=1750726948502\";\nimport CustomCursor from \"/src/components/CustomCursor/CustomCursor.tsx\";\ngsap.registerPlugin(ScrollTrigger, ScrollToPlugin);\nfunction App() {\n  _s();\n  const [currentSection, setCurrentSection] = useState(\"hero\");\n  const [showThemeMenu, setShowThemeMenu] = useState(false);\n  const handleMenuItemClick = (item) => {\n    gsap.to(window, {\n      scrollTo: { y: window.innerHeight, autoKill: false },\n      duration: 1,\n      ease: \"power3.inOut\",\n      onComplete: () => {\n        setCurrentSection(item.id);\n        document.documentElement.setAttribute(\n          \"data-theme\",\n          item.theme || \"sunset\"\n        );\n      }\n    });\n  };\n  const renderSection = () => {\n    switch (currentSection) {\n      case \"poster\":\n        return /* @__PURE__ */ jsxDEV(\n          \"div\",\n          {\n            style: {\n              height: \"100vh\",\n              display: \"flex\",\n              alignItems: \"center\",\n              justifyContent: \"center\"\n            },\n            children: /* @__PURE__ */ jsxDEV(\"h1\", { children: \"Poster Section - Coming Soon\" }, void 0, false, {\n              fileName: \"/home/will/local_dev/portfolio/apps/robin-noguier/src/App.tsx\",\n              lineNumber: 51,\n              columnNumber: 13\n            }, this)\n          },\n          void 0,\n          false,\n          {\n            fileName: \"/home/will/local_dev/portfolio/apps/robin-noguier/src/App.tsx\",\n            lineNumber: 43,\n            columnNumber: 11\n          },\n          this\n        );\n      case \"aaf\":\n        return /* @__PURE__ */ jsxDEV(\n          \"div\",\n          {\n            style: {\n              height: \"100vh\",\n              display: \"flex\",\n              alignItems: \"center\",\n              justifyContent: \"center\"\n            },\n            children: /* @__PURE__ */ jsxDEV(\"h1\", { children: \"AAF Section - Coming Soon\" }, void 0, false, {\n              fileName: \"/home/will/local_dev/portfolio/apps/robin-noguier/src/App.tsx\",\n              lineNumber: 64,\n              columnNumber: 13\n            }, this)\n          },\n          void 0,\n          false,\n          {\n            fileName: \"/home/will/local_dev/portfolio/apps/robin-noguier/src/App.tsx\",\n            lineNumber: 56,\n            columnNumber: 11\n          },\n          this\n        );\n      case \"video\":\n        return /* @__PURE__ */ jsxDEV(\n          \"div\",\n          {\n            style: {\n              height: \"100vh\",\n              display: \"flex\",\n              alignItems: \"center\",\n              justifyContent: \"center\"\n            },\n            children: /* @__PURE__ */ jsxDEV(\"h1\", { children: \"Video Section - Coming Soon\" }, void 0, false, {\n              fileName: \"/home/will/local_dev/portfolio/apps/robin-noguier/src/App.tsx\",\n              lineNumber: 77,\n              columnNumber: 13\n            }, this)\n          },\n          void 0,\n          false,\n          {\n            fileName: \"/home/will/local_dev/portfolio/apps/robin-noguier/src/App.tsx\",\n            lineNumber: 69,\n            columnNumber: 11\n          },\n          this\n        );\n      case \"research\":\n        return /* @__PURE__ */ jsxDEV(\n          \"div\",\n          {\n            style: {\n              height: \"100vh\",\n              display: \"flex\",\n              alignItems: \"center\",\n              justifyContent: \"center\"\n            },\n            children: /* @__PURE__ */ jsxDEV(\"h1\", { children: \"Research Section - Coming Soon\" }, void 0, false, {\n              fileName: \"/home/will/local_dev/portfolio/apps/robin-noguier/src/App.tsx\",\n              lineNumber: 90,\n              columnNumber: 13\n            }, this)\n          },\n          void 0,\n          false,\n          {\n            fileName: \"/home/will/local_dev/portfolio/apps/robin-noguier/src/App.tsx\",\n            lineNumber: 82,\n            columnNumber: 11\n          },\n          this\n        );\n      default:\n        return null;\n    }\n  };\n  return /* @__PURE__ */ jsxDEV(MotionProvider, { children: [\n    /* @__PURE__ */ jsxDEV(CustomCursor, {}, void 0, false, {\n      fileName: \"/home/will/local_dev/portfolio/apps/robin-noguier/src/App.tsx\",\n      lineNumber: 100,\n      columnNumber: 7\n    }, this),\n    /* @__PURE__ */ jsxDEV(HeroToContactHeaderOrchestrator, {}, void 0, false, {\n      fileName: \"/home/will/local_dev/portfolio/apps/robin-noguier/src/App.tsx\",\n      lineNumber: 101,\n      columnNumber: 7\n    }, this),\n    /* @__PURE__ */ jsxDEV(\"main\", { children: /* @__PURE__ */ jsxDEV(HeroSectionWebGL, {}, void 0, false, {\n      fileName: \"/home/will/local_dev/portfolio/apps/robin-noguier/src/App.tsx\",\n      lineNumber: 103,\n      columnNumber: 9\n    }, this) }, void 0, false, {\n      fileName: \"/home/will/local_dev/portfolio/apps/robin-noguier/src/App.tsx\",\n      lineNumber: 102,\n      columnNumber: 7\n    }, this)\n  ] }, void 0, true, {\n    fileName: \"/home/will/local_dev/portfolio/apps/robin-noguier/src/App.tsx\",\n    lineNumber: 99,\n    columnNumber: 5\n  }, this);\n}\n_s(App, \"ME07PCnF8rXDpFdQlV1u49xzU6k=\");\n_c = App;\nexport default App;\nvar _c;\n$RefreshReg$(_c, \"App\");\nif (import.meta.hot && !inWebWorker) {\n  window.$RefreshReg$ = prevRefreshReg;\n  window.$RefreshSig$ = prevRefreshSig;\n  RefreshRuntime.__hmr_import(import.meta.url).then((currentExports) => {\n    RefreshRuntime.registerExportsForReactRefresh(\"/home/will/local_dev/portfolio/apps/robin-noguier/src/App.tsx\", currentExports);\n    import.meta.hot.accept((nextExports) => {\n      if (!nextExports)\n        return;\n      const invalidateMessage = RefreshRuntime.validateRefreshBoundaryAndEnqueueUpdate(currentExports, nextExports);\n      if (invalidateMessage)\n        import.meta.hot.invalidate(invalidateMessage);\n    });\n  });\n}\n\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJtYXBwaW5ncyI6IkFBa0RZOzJCQWxEWjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUVBLFNBQVNBLGdCQUFtQztBQUM1QyxTQUFTQyxZQUFZO0FBQ3JCLFNBQVNDLHFCQUFxQjtBQUM5QixTQUFTQyxzQkFBc0I7QUFDL0I7QUFBQSxFQUNFQztBQUFBQSxFQUNBQztBQUFBQSxPQUNLO0FBQ1AsT0FBT0Msc0JBQXNCO0FBQzdCLE9BQU9DLGtCQUFrQjtBQUl6Qk4sS0FBS08sZUFBZU4sZUFBZUMsY0FBYztBQUVqRCxTQUFTTSxNQUFNO0FBQUFDLEtBQUE7QUFDYixRQUFNLENBQUNDLGdCQUFnQkMsaUJBQWlCLElBQUlaLFNBQWlCLE1BQU07QUFDbkUsUUFBTSxDQUFDYSxlQUFlQyxnQkFBZ0IsSUFBSWQsU0FBUyxLQUFLO0FBRXhELFFBQU1lLHNCQUFzQkEsQ0FBQ0MsU0FBYztBQUV6Q2YsU0FBS2dCLEdBQUdDLFFBQVE7QUFBQSxNQUNkQyxVQUFVLEVBQUVDLEdBQUdGLE9BQU9HLGFBQWFDLFVBQVUsTUFBTTtBQUFBLE1BQ25EQyxVQUFVO0FBQUEsTUFDVkMsTUFBTTtBQUFBLE1BQ05DLFlBQVlBLE1BQU07QUFDaEJiLDBCQUFrQkksS0FBS1UsRUFBRTtBQUV6QkMsaUJBQVNDLGdCQUFnQkM7QUFBQUEsVUFDdkI7QUFBQSxVQUNBYixLQUFLYyxTQUFTO0FBQUEsUUFDaEI7QUFBQSxNQUNGO0FBQUEsSUFDRixDQUFDO0FBQUEsRUFDSDtBQUVBLFFBQU1DLGdCQUFnQkEsTUFBTTtBQUMxQixZQUFRcEIsZ0JBQWM7QUFBQSxNQUNwQixLQUFLO0FBQ0gsZUFDRTtBQUFBLFVBQUM7QUFBQTtBQUFBLFlBQ0MsT0FBTztBQUFBLGNBQ0xxQixRQUFRO0FBQUEsY0FDUkMsU0FBUztBQUFBLGNBQ1RDLFlBQVk7QUFBQSxjQUNaQyxnQkFBZ0I7QUFBQSxZQUNsQjtBQUFBLFlBRUEsaUNBQUMsUUFBRyw0Q0FBSjtBQUFBO0FBQUE7QUFBQTtBQUFBLG1CQUFnQztBQUFBO0FBQUEsVUFSbEM7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFFBU0E7QUFBQSxNQUVKLEtBQUs7QUFDSCxlQUNFO0FBQUEsVUFBQztBQUFBO0FBQUEsWUFDQyxPQUFPO0FBQUEsY0FDTEgsUUFBUTtBQUFBLGNBQ1JDLFNBQVM7QUFBQSxjQUNUQyxZQUFZO0FBQUEsY0FDWkMsZ0JBQWdCO0FBQUEsWUFDbEI7QUFBQSxZQUVBLGlDQUFDLFFBQUcseUNBQUo7QUFBQTtBQUFBO0FBQUE7QUFBQSxtQkFBNkI7QUFBQTtBQUFBLFVBUi9CO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxRQVNBO0FBQUEsTUFFSixLQUFLO0FBQ0gsZUFDRTtBQUFBLFVBQUM7QUFBQTtBQUFBLFlBQ0MsT0FBTztBQUFBLGNBQ0xILFFBQVE7QUFBQSxjQUNSQyxTQUFTO0FBQUEsY0FDVEMsWUFBWTtBQUFBLGNBQ1pDLGdCQUFnQjtBQUFBLFlBQ2xCO0FBQUEsWUFFQSxpQ0FBQyxRQUFHLDJDQUFKO0FBQUE7QUFBQTtBQUFBO0FBQUEsbUJBQStCO0FBQUE7QUFBQSxVQVJqQztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsUUFTQTtBQUFBLE1BRUosS0FBSztBQUNILGVBQ0U7QUFBQSxVQUFDO0FBQUE7QUFBQSxZQUNDLE9BQU87QUFBQSxjQUNMSCxRQUFRO0FBQUEsY0FDUkMsU0FBUztBQUFBLGNBQ1RDLFlBQVk7QUFBQSxjQUNaQyxnQkFBZ0I7QUFBQSxZQUNsQjtBQUFBLFlBRUEsaUNBQUMsUUFBRyw4Q0FBSjtBQUFBO0FBQUE7QUFBQTtBQUFBLG1CQUFrQztBQUFBO0FBQUEsVUFScEM7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFFBU0E7QUFBQSxNQUVKO0FBQ0UsZUFBTztBQUFBLElBQ1g7QUFBQSxFQUNGO0FBRUEsU0FDRSx1QkFBQyxrQkFDQztBQUFBLDJCQUFDLGtCQUFEO0FBQUE7QUFBQTtBQUFBO0FBQUEsV0FBYTtBQUFBLElBQ2IsdUJBQUMscUNBQUQ7QUFBQTtBQUFBO0FBQUE7QUFBQSxXQUFnQztBQUFBLElBQ2hDLHVCQUFDLFVBQ0MsaUNBQUMsc0JBQUQ7QUFBQTtBQUFBO0FBQUE7QUFBQSxXQUFpQixLQURuQjtBQUFBO0FBQUE7QUFBQTtBQUFBLFdBV0E7QUFBQSxPQWRGO0FBQUE7QUFBQTtBQUFBO0FBQUEsU0FlQTtBQUVKO0FBQUN6QixHQWxHUUQsS0FBRztBQUFBMkIsS0FBSDNCO0FBb0dULGVBQWVBO0FBQUcsSUFBQTJCO0FBQUFDLGFBQUFELElBQUEiLCJuYW1lcyI6WyJ1c2VTdGF0ZSIsImdzYXAiLCJTY3JvbGxUcmlnZ2VyIiwiU2Nyb2xsVG9QbHVnaW4iLCJNb3Rpb25Qcm92aWRlciIsIkhlcm9Ub0NvbnRhY3RIZWFkZXJPcmNoZXN0cmF0b3IiLCJIZXJvU2VjdGlvbldlYkdMIiwiQ3VzdG9tQ3Vyc29yIiwicmVnaXN0ZXJQbHVnaW4iLCJBcHAiLCJfcyIsImN1cnJlbnRTZWN0aW9uIiwic2V0Q3VycmVudFNlY3Rpb24iLCJzaG93VGhlbWVNZW51Iiwic2V0U2hvd1RoZW1lTWVudSIsImhhbmRsZU1lbnVJdGVtQ2xpY2siLCJpdGVtIiwidG8iLCJ3aW5kb3ciLCJzY3JvbGxUbyIsInkiLCJpbm5lckhlaWdodCIsImF1dG9LaWxsIiwiZHVyYXRpb24iLCJlYXNlIiwib25Db21wbGV0ZSIsImlkIiwiZG9jdW1lbnQiLCJkb2N1bWVudEVsZW1lbnQiLCJzZXRBdHRyaWJ1dGUiLCJ0aGVtZSIsInJlbmRlclNlY3Rpb24iLCJoZWlnaHQiLCJkaXNwbGF5IiwiYWxpZ25JdGVtcyIsImp1c3RpZnlDb250ZW50IiwiX2MiLCIkUmVmcmVzaFJlZyQiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZXMiOlsiQXBwLnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnMgKi9cbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgKi9cbmltcG9ydCB7IHVzZVN0YXRlLCB1c2VSZWYsIHVzZUVmZmVjdCB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHsgZ3NhcCB9IGZyb20gJ2dzYXAnXG5pbXBvcnQgeyBTY3JvbGxUcmlnZ2VyIH0gZnJvbSAnZ3NhcC9TY3JvbGxUcmlnZ2VyJ1xuaW1wb3J0IHsgU2Nyb2xsVG9QbHVnaW4gfSBmcm9tICdnc2FwL1Njcm9sbFRvUGx1Z2luJ1xuaW1wb3J0IHtcbiAgTW90aW9uUHJvdmlkZXIsXG4gIEhlcm9Ub0NvbnRhY3RIZWFkZXJPcmNoZXN0cmF0b3IsXG59IGZyb20gJ0ByeWxlZWJyYXNzZXVyL21vdGlvbi1zeXN0ZW0nXG5pbXBvcnQgSGVyb1NlY3Rpb25XZWJHTCBmcm9tICcuL2NvbXBvbmVudHMvSGVyby9IZXJvU2VjdGlvbldlYkdMJ1xuaW1wb3J0IEN1c3RvbUN1cnNvciBmcm9tICcuL2NvbXBvbmVudHMvQ3VzdG9tQ3Vyc29yL0N1c3RvbUN1cnNvcidcbmltcG9ydCBJbnRlcmFjdGl2ZU1lbnUgZnJvbSAnLi9jb21wb25lbnRzL0ludGVyYWN0aXZlTWVudS9JbnRlcmFjdGl2ZU1lbnUnXG5pbXBvcnQgeyBLaW5ldGljUGhvbmUgfSBmcm9tICcuL2NvbXBvbmVudHMvS2luZXRpY1Bob25lL0tpbmV0aWNQaG9uZSdcblxuZ3NhcC5yZWdpc3RlclBsdWdpbihTY3JvbGxUcmlnZ2VyLCBTY3JvbGxUb1BsdWdpbilcblxuZnVuY3Rpb24gQXBwKCkge1xuICBjb25zdCBbY3VycmVudFNlY3Rpb24sIHNldEN1cnJlbnRTZWN0aW9uXSA9IHVzZVN0YXRlPHN0cmluZz4oJ2hlcm8nKVxuICBjb25zdCBbc2hvd1RoZW1lTWVudSwgc2V0U2hvd1RoZW1lTWVudV0gPSB1c2VTdGF0ZShmYWxzZSlcblxuICBjb25zdCBoYW5kbGVNZW51SXRlbUNsaWNrID0gKGl0ZW06IGFueSkgPT4ge1xuICAgIC8vIEFuaW1hdGUgdHJhbnNpdGlvbiB0byBuZXcgc2VjdGlvblxuICAgIGdzYXAudG8od2luZG93LCB7XG4gICAgICBzY3JvbGxUbzogeyB5OiB3aW5kb3cuaW5uZXJIZWlnaHQsIGF1dG9LaWxsOiBmYWxzZSB9LFxuICAgICAgZHVyYXRpb246IDEsXG4gICAgICBlYXNlOiAncG93ZXIzLmluT3V0JyxcbiAgICAgIG9uQ29tcGxldGU6ICgpID0+IHtcbiAgICAgICAgc2V0Q3VycmVudFNlY3Rpb24oaXRlbS5pZClcbiAgICAgICAgLy8gQXBwbHkgdGhlbWVcbiAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNldEF0dHJpYnV0ZShcbiAgICAgICAgICAnZGF0YS10aGVtZScsXG4gICAgICAgICAgaXRlbS50aGVtZSB8fCAnc3Vuc2V0J1xuICAgICAgICApXG4gICAgICB9LFxuICAgIH0pXG4gIH1cblxuICBjb25zdCByZW5kZXJTZWN0aW9uID0gKCkgPT4ge1xuICAgIHN3aXRjaCAoY3VycmVudFNlY3Rpb24pIHtcbiAgICAgIGNhc2UgJ3Bvc3Rlcic6XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgPGRpdlxuICAgICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgICAgaGVpZ2h0OiAnMTAwdmgnLFxuICAgICAgICAgICAgICBkaXNwbGF5OiAnZmxleCcsXG4gICAgICAgICAgICAgIGFsaWduSXRlbXM6ICdjZW50ZXInLFxuICAgICAgICAgICAgICBqdXN0aWZ5Q29udGVudDogJ2NlbnRlcicsXG4gICAgICAgICAgICB9fVxuICAgICAgICAgID5cbiAgICAgICAgICAgIDxoMT5Qb3N0ZXIgU2VjdGlvbiAtIENvbWluZyBTb29uPC9oMT5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgKVxuICAgICAgY2FzZSAnYWFmJzpcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICBzdHlsZT17e1xuICAgICAgICAgICAgICBoZWlnaHQ6ICcxMDB2aCcsXG4gICAgICAgICAgICAgIGRpc3BsYXk6ICdmbGV4JyxcbiAgICAgICAgICAgICAgYWxpZ25JdGVtczogJ2NlbnRlcicsXG4gICAgICAgICAgICAgIGp1c3RpZnlDb250ZW50OiAnY2VudGVyJyxcbiAgICAgICAgICAgIH19XG4gICAgICAgICAgPlxuICAgICAgICAgICAgPGgxPkFBRiBTZWN0aW9uIC0gQ29taW5nIFNvb248L2gxPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICApXG4gICAgICBjYXNlICd2aWRlbyc6XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgPGRpdlxuICAgICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgICAgaGVpZ2h0OiAnMTAwdmgnLFxuICAgICAgICAgICAgICBkaXNwbGF5OiAnZmxleCcsXG4gICAgICAgICAgICAgIGFsaWduSXRlbXM6ICdjZW50ZXInLFxuICAgICAgICAgICAgICBqdXN0aWZ5Q29udGVudDogJ2NlbnRlcicsXG4gICAgICAgICAgICB9fVxuICAgICAgICAgID5cbiAgICAgICAgICAgIDxoMT5WaWRlbyBTZWN0aW9uIC0gQ29taW5nIFNvb248L2gxPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICApXG4gICAgICBjYXNlICdyZXNlYXJjaCc6XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgPGRpdlxuICAgICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgICAgaGVpZ2h0OiAnMTAwdmgnLFxuICAgICAgICAgICAgICBkaXNwbGF5OiAnZmxleCcsXG4gICAgICAgICAgICAgIGFsaWduSXRlbXM6ICdjZW50ZXInLFxuICAgICAgICAgICAgICBqdXN0aWZ5Q29udGVudDogJ2NlbnRlcicsXG4gICAgICAgICAgICB9fVxuICAgICAgICAgID5cbiAgICAgICAgICAgIDxoMT5SZXNlYXJjaCBTZWN0aW9uIC0gQ29taW5nIFNvb248L2gxPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICApXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAoXG4gICAgPE1vdGlvblByb3ZpZGVyPlxuICAgICAgPEN1c3RvbUN1cnNvciAvPlxuICAgICAgPEhlcm9Ub0NvbnRhY3RIZWFkZXJPcmNoZXN0cmF0b3IgLz5cbiAgICAgIDxtYWluPlxuICAgICAgICA8SGVyb1NlY3Rpb25XZWJHTCAvPlxuICAgICAgICB7LyogVGVtcG9yYXJpbHkgZGlzYWJsZWQgSW50ZXJhY3RpdmVNZW51XG4gICAgICAgIDxzZWN0aW9uIGNsYXNzTmFtZT1cIm1lbnUtc2VjdGlvblwiPlxuICAgICAgICAgIDxJbnRlcmFjdGl2ZU1lbnUgXG4gICAgICAgICAgICBvbkl0ZW1DbGljaz17aGFuZGxlTWVudUl0ZW1DbGlja31cbiAgICAgICAgICAgIGN1cnJlbnRTZWN0aW9uPXtjdXJyZW50U2VjdGlvbn1cbiAgICAgICAgICAvPlxuICAgICAgICA8L3NlY3Rpb24+XG4gICAgICAgIHtjdXJyZW50U2VjdGlvbiAhPT0gJ2hlcm8nICYmIHJlbmRlclNlY3Rpb24oKX0gKi99XG5cbiAgICAgIDwvbWFpbj5cbiAgICA8L01vdGlvblByb3ZpZGVyPlxuICApXG59XG5cbmV4cG9ydCBkZWZhdWx0IEFwcFxuIl0sImZpbGUiOiIvaG9tZS93aWxsL2xvY2FsX2Rldi9wb3J0Zm9saW8vYXBwcy9yb2Jpbi1ub2d1aWVyL3NyYy9BcHAudHN4In0=",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 15523,
            "count": 1
          },
          {
            "startOffset": 423,
            "endOffset": 459,
            "count": 0
          },
          {
            "startOffset": 596,
            "endOffset": 767,
            "count": 0
          }
        ]
      },
      {
        "functionName": "window.$RefreshReg$",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 872,
            "endOffset": 997,
            "count": 1
          }
        ]
      },
      {
        "functionName": "App",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1868,
            "endOffset": 6699,
            "count": 2
          }
        ]
      },
      {
        "functionName": "handleMenuItemClick",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2048,
            "endOffset": 2385,
            "count": 0
          }
        ]
      },
      {
        "functionName": "renderSection",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2411,
            "endOffset": 5650,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 6975,
            "endOffset": 7427,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 7156,
            "endOffset": 7421,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5173/node_modules/.vite/deps/chunk-R7U5S34U.js?v=a50bb159",
    "scriptId": "24",
    "source": "import {\n  __commonJS\n} from \"/node_modules/.vite/deps/chunk-LNEMQRCO.js?v=a50bb159\";\n\n// ../../node_modules/.pnpm/react@18.2.0/node_modules/react/cjs/react.development.js\nvar require_react_development = __commonJS({\n  \"../../node_modules/.pnpm/react@18.2.0/node_modules/react/cjs/react.development.js\"(exports, module) {\n    \"use strict\";\n    if (true) {\n      (function() {\n        \"use strict\";\n        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== \"undefined\" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === \"function\") {\n          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());\n        }\n        var ReactVersion = \"18.2.0\";\n        var REACT_ELEMENT_TYPE = Symbol.for(\"react.element\");\n        var REACT_PORTAL_TYPE = Symbol.for(\"react.portal\");\n        var REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\");\n        var REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\");\n        var REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\");\n        var REACT_PROVIDER_TYPE = Symbol.for(\"react.provider\");\n        var REACT_CONTEXT_TYPE = Symbol.for(\"react.context\");\n        var REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\");\n        var REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\");\n        var REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\");\n        var REACT_MEMO_TYPE = Symbol.for(\"react.memo\");\n        var REACT_LAZY_TYPE = Symbol.for(\"react.lazy\");\n        var REACT_OFFSCREEN_TYPE = Symbol.for(\"react.offscreen\");\n        var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\n        var FAUX_ITERATOR_SYMBOL = \"@@iterator\";\n        function getIteratorFn(maybeIterable) {\n          if (maybeIterable === null || typeof maybeIterable !== \"object\") {\n            return null;\n          }\n          var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n          if (typeof maybeIterator === \"function\") {\n            return maybeIterator;\n          }\n          return null;\n        }\n        var ReactCurrentDispatcher = {\n          /**\n           * @internal\n           * @type {ReactComponent}\n           */\n          current: null\n        };\n        var ReactCurrentBatchConfig = {\n          transition: null\n        };\n        var ReactCurrentActQueue = {\n          current: null,\n          // Used to reproduce behavior of `batchedUpdates` in legacy mode.\n          isBatchingLegacy: false,\n          didScheduleLegacyUpdate: false\n        };\n        var ReactCurrentOwner = {\n          /**\n           * @internal\n           * @type {ReactComponent}\n           */\n          current: null\n        };\n        var ReactDebugCurrentFrame = {};\n        var currentExtraStackFrame = null;\n        function setExtraStackFrame(stack) {\n          {\n            currentExtraStackFrame = stack;\n          }\n        }\n        {\n          ReactDebugCurrentFrame.setExtraStackFrame = function(stack) {\n            {\n              currentExtraStackFrame = stack;\n            }\n          };\n          ReactDebugCurrentFrame.getCurrentStack = null;\n          ReactDebugCurrentFrame.getStackAddendum = function() {\n            var stack = \"\";\n            if (currentExtraStackFrame) {\n              stack += currentExtraStackFrame;\n            }\n            var impl = ReactDebugCurrentFrame.getCurrentStack;\n            if (impl) {\n              stack += impl() || \"\";\n            }\n            return stack;\n          };\n        }\n        var enableScopeAPI = false;\n        var enableCacheElement = false;\n        var enableTransitionTracing = false;\n        var enableLegacyHidden = false;\n        var enableDebugTracing = false;\n        var ReactSharedInternals = {\n          ReactCurrentDispatcher,\n          ReactCurrentBatchConfig,\n          ReactCurrentOwner\n        };\n        {\n          ReactSharedInternals.ReactDebugCurrentFrame = ReactDebugCurrentFrame;\n          ReactSharedInternals.ReactCurrentActQueue = ReactCurrentActQueue;\n        }\n        function warn(format) {\n          {\n            {\n              for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n                args[_key - 1] = arguments[_key];\n              }\n              printWarning(\"warn\", format, args);\n            }\n          }\n        }\n        function error(format) {\n          {\n            {\n              for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n                args[_key2 - 1] = arguments[_key2];\n              }\n              printWarning(\"error\", format, args);\n            }\n          }\n        }\n        function printWarning(level, format, args) {\n          {\n            var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;\n            var stack = ReactDebugCurrentFrame2.getStackAddendum();\n            if (stack !== \"\") {\n              format += \"%s\";\n              args = args.concat([stack]);\n            }\n            var argsWithFormat = args.map(function(item) {\n              return String(item);\n            });\n            argsWithFormat.unshift(\"Warning: \" + format);\n            Function.prototype.apply.call(console[level], console, argsWithFormat);\n          }\n        }\n        var didWarnStateUpdateForUnmountedComponent = {};\n        function warnNoop(publicInstance, callerName) {\n          {\n            var _constructor = publicInstance.constructor;\n            var componentName = _constructor && (_constructor.displayName || _constructor.name) || \"ReactClass\";\n            var warningKey = componentName + \".\" + callerName;\n            if (didWarnStateUpdateForUnmountedComponent[warningKey]) {\n              return;\n            }\n            error(\"Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.\", callerName, componentName);\n            didWarnStateUpdateForUnmountedComponent[warningKey] = true;\n          }\n        }\n        var ReactNoopUpdateQueue = {\n          /**\n           * Checks whether or not this composite component is mounted.\n           * @param {ReactClass} publicInstance The instance we want to test.\n           * @return {boolean} True if mounted, false otherwise.\n           * @protected\n           * @final\n           */\n          isMounted: function(publicInstance) {\n            return false;\n          },\n          /**\n           * Forces an update. This should only be invoked when it is known with\n           * certainty that we are **not** in a DOM transaction.\n           *\n           * You may want to call this when you know that some deeper aspect of the\n           * component's state has changed but `setState` was not called.\n           *\n           * This will not invoke `shouldComponentUpdate`, but it will invoke\n           * `componentWillUpdate` and `componentDidUpdate`.\n           *\n           * @param {ReactClass} publicInstance The instance that should rerender.\n           * @param {?function} callback Called after component is updated.\n           * @param {?string} callerName name of the calling function in the public API.\n           * @internal\n           */\n          enqueueForceUpdate: function(publicInstance, callback, callerName) {\n            warnNoop(publicInstance, \"forceUpdate\");\n          },\n          /**\n           * Replaces all of the state. Always use this or `setState` to mutate state.\n           * You should treat `this.state` as immutable.\n           *\n           * There is no guarantee that `this.state` will be immediately updated, so\n           * accessing `this.state` after calling this method may return the old value.\n           *\n           * @param {ReactClass} publicInstance The instance that should rerender.\n           * @param {object} completeState Next state.\n           * @param {?function} callback Called after component is updated.\n           * @param {?string} callerName name of the calling function in the public API.\n           * @internal\n           */\n          enqueueReplaceState: function(publicInstance, completeState, callback, callerName) {\n            warnNoop(publicInstance, \"replaceState\");\n          },\n          /**\n           * Sets a subset of the state. This only exists because _pendingState is\n           * internal. This provides a merging strategy that is not available to deep\n           * properties which is confusing. TODO: Expose pendingState or don't use it\n           * during the merge.\n           *\n           * @param {ReactClass} publicInstance The instance that should rerender.\n           * @param {object} partialState Next partial state to be merged with state.\n           * @param {?function} callback Called after component is updated.\n           * @param {?string} Name of the calling function in the public API.\n           * @internal\n           */\n          enqueueSetState: function(publicInstance, partialState, callback, callerName) {\n            warnNoop(publicInstance, \"setState\");\n          }\n        };\n        var assign = Object.assign;\n        var emptyObject = {};\n        {\n          Object.freeze(emptyObject);\n        }\n        function Component(props, context, updater) {\n          this.props = props;\n          this.context = context;\n          this.refs = emptyObject;\n          this.updater = updater || ReactNoopUpdateQueue;\n        }\n        Component.prototype.isReactComponent = {};\n        Component.prototype.setState = function(partialState, callback) {\n          if (typeof partialState !== \"object\" && typeof partialState !== \"function\" && partialState != null) {\n            throw new Error(\"setState(...): takes an object of state variables to update or a function which returns an object of state variables.\");\n          }\n          this.updater.enqueueSetState(this, partialState, callback, \"setState\");\n        };\n        Component.prototype.forceUpdate = function(callback) {\n          this.updater.enqueueForceUpdate(this, callback, \"forceUpdate\");\n        };\n        {\n          var deprecatedAPIs = {\n            isMounted: [\"isMounted\", \"Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks.\"],\n            replaceState: [\"replaceState\", \"Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236).\"]\n          };\n          var defineDeprecationWarning = function(methodName, info) {\n            Object.defineProperty(Component.prototype, methodName, {\n              get: function() {\n                warn(\"%s(...) is deprecated in plain JavaScript React classes. %s\", info[0], info[1]);\n                return void 0;\n              }\n            });\n          };\n          for (var fnName in deprecatedAPIs) {\n            if (deprecatedAPIs.hasOwnProperty(fnName)) {\n              defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);\n            }\n          }\n        }\n        function ComponentDummy() {\n        }\n        ComponentDummy.prototype = Component.prototype;\n        function PureComponent(props, context, updater) {\n          this.props = props;\n          this.context = context;\n          this.refs = emptyObject;\n          this.updater = updater || ReactNoopUpdateQueue;\n        }\n        var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();\n        pureComponentPrototype.constructor = PureComponent;\n        assign(pureComponentPrototype, Component.prototype);\n        pureComponentPrototype.isPureReactComponent = true;\n        function createRef() {\n          var refObject = {\n            current: null\n          };\n          {\n            Object.seal(refObject);\n          }\n          return refObject;\n        }\n        var isArrayImpl = Array.isArray;\n        function isArray(a) {\n          return isArrayImpl(a);\n        }\n        function typeName(value) {\n          {\n            var hasToStringTag = typeof Symbol === \"function\" && Symbol.toStringTag;\n            var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || \"Object\";\n            return type;\n          }\n        }\n        function willCoercionThrow(value) {\n          {\n            try {\n              testStringCoercion(value);\n              return false;\n            } catch (e) {\n              return true;\n            }\n          }\n        }\n        function testStringCoercion(value) {\n          return \"\" + value;\n        }\n        function checkKeyStringCoercion(value) {\n          {\n            if (willCoercionThrow(value)) {\n              error(\"The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.\", typeName(value));\n              return testStringCoercion(value);\n            }\n          }\n        }\n        function getWrappedName(outerType, innerType, wrapperName) {\n          var displayName = outerType.displayName;\n          if (displayName) {\n            return displayName;\n          }\n          var functionName = innerType.displayName || innerType.name || \"\";\n          return functionName !== \"\" ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n        }\n        function getContextName(type) {\n          return type.displayName || \"Context\";\n        }\n        function getComponentNameFromType(type) {\n          if (type == null) {\n            return null;\n          }\n          {\n            if (typeof type.tag === \"number\") {\n              error(\"Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.\");\n            }\n          }\n          if (typeof type === \"function\") {\n            return type.displayName || type.name || null;\n          }\n          if (typeof type === \"string\") {\n            return type;\n          }\n          switch (type) {\n            case REACT_FRAGMENT_TYPE:\n              return \"Fragment\";\n            case REACT_PORTAL_TYPE:\n              return \"Portal\";\n            case REACT_PROFILER_TYPE:\n              return \"Profiler\";\n            case REACT_STRICT_MODE_TYPE:\n              return \"StrictMode\";\n            case REACT_SUSPENSE_TYPE:\n              return \"Suspense\";\n            case REACT_SUSPENSE_LIST_TYPE:\n              return \"SuspenseList\";\n          }\n          if (typeof type === \"object\") {\n            switch (type.$$typeof) {\n              case REACT_CONTEXT_TYPE:\n                var context = type;\n                return getContextName(context) + \".Consumer\";\n              case REACT_PROVIDER_TYPE:\n                var provider = type;\n                return getContextName(provider._context) + \".Provider\";\n              case REACT_FORWARD_REF_TYPE:\n                return getWrappedName(type, type.render, \"ForwardRef\");\n              case REACT_MEMO_TYPE:\n                var outerName = type.displayName || null;\n                if (outerName !== null) {\n                  return outerName;\n                }\n                return getComponentNameFromType(type.type) || \"Memo\";\n              case REACT_LAZY_TYPE: {\n                var lazyComponent = type;\n                var payload = lazyComponent._payload;\n                var init = lazyComponent._init;\n                try {\n                  return getComponentNameFromType(init(payload));\n                } catch (x) {\n                  return null;\n                }\n              }\n            }\n          }\n          return null;\n        }\n        var hasOwnProperty = Object.prototype.hasOwnProperty;\n        var RESERVED_PROPS = {\n          key: true,\n          ref: true,\n          __self: true,\n          __source: true\n        };\n        var specialPropKeyWarningShown, specialPropRefWarningShown, didWarnAboutStringRefs;\n        {\n          didWarnAboutStringRefs = {};\n        }\n        function hasValidRef(config) {\n          {\n            if (hasOwnProperty.call(config, \"ref\")) {\n              var getter = Object.getOwnPropertyDescriptor(config, \"ref\").get;\n              if (getter && getter.isReactWarning) {\n                return false;\n              }\n            }\n          }\n          return config.ref !== void 0;\n        }\n        function hasValidKey(config) {\n          {\n            if (hasOwnProperty.call(config, \"key\")) {\n              var getter = Object.getOwnPropertyDescriptor(config, \"key\").get;\n              if (getter && getter.isReactWarning) {\n                return false;\n              }\n            }\n          }\n          return config.key !== void 0;\n        }\n        function defineKeyPropWarningGetter(props, displayName) {\n          var warnAboutAccessingKey = function() {\n            {\n              if (!specialPropKeyWarningShown) {\n                specialPropKeyWarningShown = true;\n                error(\"%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)\", displayName);\n              }\n            }\n          };\n          warnAboutAccessingKey.isReactWarning = true;\n          Object.defineProperty(props, \"key\", {\n            get: warnAboutAccessingKey,\n            configurable: true\n          });\n        }\n        function defineRefPropWarningGetter(props, displayName) {\n          var warnAboutAccessingRef = function() {\n            {\n              if (!specialPropRefWarningShown) {\n                specialPropRefWarningShown = true;\n                error(\"%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)\", displayName);\n              }\n            }\n          };\n          warnAboutAccessingRef.isReactWarning = true;\n          Object.defineProperty(props, \"ref\", {\n            get: warnAboutAccessingRef,\n            configurable: true\n          });\n        }\n        function warnIfStringRefCannotBeAutoConverted(config) {\n          {\n            if (typeof config.ref === \"string\" && ReactCurrentOwner.current && config.__self && ReactCurrentOwner.current.stateNode !== config.__self) {\n              var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);\n              if (!didWarnAboutStringRefs[componentName]) {\n                error('Component \"%s\" contains the string ref \"%s\". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', componentName, config.ref);\n                didWarnAboutStringRefs[componentName] = true;\n              }\n            }\n          }\n        }\n        var ReactElement = function(type, key, ref, self, source, owner, props) {\n          var element = {\n            // This tag allows us to uniquely identify this as a React Element\n            $$typeof: REACT_ELEMENT_TYPE,\n            // Built-in properties that belong on the element\n            type,\n            key,\n            ref,\n            props,\n            // Record the component responsible for creating this element.\n            _owner: owner\n          };\n          {\n            element._store = {};\n            Object.defineProperty(element._store, \"validated\", {\n              configurable: false,\n              enumerable: false,\n              writable: true,\n              value: false\n            });\n            Object.defineProperty(element, \"_self\", {\n              configurable: false,\n              enumerable: false,\n              writable: false,\n              value: self\n            });\n            Object.defineProperty(element, \"_source\", {\n              configurable: false,\n              enumerable: false,\n              writable: false,\n              value: source\n            });\n            if (Object.freeze) {\n              Object.freeze(element.props);\n              Object.freeze(element);\n            }\n          }\n          return element;\n        };\n        function createElement(type, config, children) {\n          var propName;\n          var props = {};\n          var key = null;\n          var ref = null;\n          var self = null;\n          var source = null;\n          if (config != null) {\n            if (hasValidRef(config)) {\n              ref = config.ref;\n              {\n                warnIfStringRefCannotBeAutoConverted(config);\n              }\n            }\n            if (hasValidKey(config)) {\n              {\n                checkKeyStringCoercion(config.key);\n              }\n              key = \"\" + config.key;\n            }\n            self = config.__self === void 0 ? null : config.__self;\n            source = config.__source === void 0 ? null : config.__source;\n            for (propName in config) {\n              if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n                props[propName] = config[propName];\n              }\n            }\n          }\n          var childrenLength = arguments.length - 2;\n          if (childrenLength === 1) {\n            props.children = children;\n          } else if (childrenLength > 1) {\n            var childArray = Array(childrenLength);\n            for (var i = 0; i < childrenLength; i++) {\n              childArray[i] = arguments[i + 2];\n            }\n            {\n              if (Object.freeze) {\n                Object.freeze(childArray);\n              }\n            }\n            props.children = childArray;\n          }\n          if (type && type.defaultProps) {\n            var defaultProps = type.defaultProps;\n            for (propName in defaultProps) {\n              if (props[propName] === void 0) {\n                props[propName] = defaultProps[propName];\n              }\n            }\n          }\n          {\n            if (key || ref) {\n              var displayName = typeof type === \"function\" ? type.displayName || type.name || \"Unknown\" : type;\n              if (key) {\n                defineKeyPropWarningGetter(props, displayName);\n              }\n              if (ref) {\n                defineRefPropWarningGetter(props, displayName);\n              }\n            }\n          }\n          return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);\n        }\n        function cloneAndReplaceKey(oldElement, newKey) {\n          var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);\n          return newElement;\n        }\n        function cloneElement(element, config, children) {\n          if (element === null || element === void 0) {\n            throw new Error(\"React.cloneElement(...): The argument must be a React element, but you passed \" + element + \".\");\n          }\n          var propName;\n          var props = assign({}, element.props);\n          var key = element.key;\n          var ref = element.ref;\n          var self = element._self;\n          var source = element._source;\n          var owner = element._owner;\n          if (config != null) {\n            if (hasValidRef(config)) {\n              ref = config.ref;\n              owner = ReactCurrentOwner.current;\n            }\n            if (hasValidKey(config)) {\n              {\n                checkKeyStringCoercion(config.key);\n              }\n              key = \"\" + config.key;\n            }\n            var defaultProps;\n            if (element.type && element.type.defaultProps) {\n              defaultProps = element.type.defaultProps;\n            }\n            for (propName in config) {\n              if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n                if (config[propName] === void 0 && defaultProps !== void 0) {\n                  props[propName] = defaultProps[propName];\n                } else {\n                  props[propName] = config[propName];\n                }\n              }\n            }\n          }\n          var childrenLength = arguments.length - 2;\n          if (childrenLength === 1) {\n            props.children = children;\n          } else if (childrenLength > 1) {\n            var childArray = Array(childrenLength);\n            for (var i = 0; i < childrenLength; i++) {\n              childArray[i] = arguments[i + 2];\n            }\n            props.children = childArray;\n          }\n          return ReactElement(element.type, key, ref, self, source, owner, props);\n        }\n        function isValidElement(object) {\n          return typeof object === \"object\" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n        }\n        var SEPARATOR = \".\";\n        var SUBSEPARATOR = \":\";\n        function escape(key) {\n          var escapeRegex = /[=:]/g;\n          var escaperLookup = {\n            \"=\": \"=0\",\n            \":\": \"=2\"\n          };\n          var escapedString = key.replace(escapeRegex, function(match) {\n            return escaperLookup[match];\n          });\n          return \"$\" + escapedString;\n        }\n        var didWarnAboutMaps = false;\n        var userProvidedKeyEscapeRegex = /\\/+/g;\n        function escapeUserProvidedKey(text) {\n          return text.replace(userProvidedKeyEscapeRegex, \"$&/\");\n        }\n        function getElementKey(element, index) {\n          if (typeof element === \"object\" && element !== null && element.key != null) {\n            {\n              checkKeyStringCoercion(element.key);\n            }\n            return escape(\"\" + element.key);\n          }\n          return index.toString(36);\n        }\n        function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {\n          var type = typeof children;\n          if (type === \"undefined\" || type === \"boolean\") {\n            children = null;\n          }\n          var invokeCallback = false;\n          if (children === null) {\n            invokeCallback = true;\n          } else {\n            switch (type) {\n              case \"string\":\n              case \"number\":\n                invokeCallback = true;\n                break;\n              case \"object\":\n                switch (children.$$typeof) {\n                  case REACT_ELEMENT_TYPE:\n                  case REACT_PORTAL_TYPE:\n                    invokeCallback = true;\n                }\n            }\n          }\n          if (invokeCallback) {\n            var _child = children;\n            var mappedChild = callback(_child);\n            var childKey = nameSoFar === \"\" ? SEPARATOR + getElementKey(_child, 0) : nameSoFar;\n            if (isArray(mappedChild)) {\n              var escapedChildKey = \"\";\n              if (childKey != null) {\n                escapedChildKey = escapeUserProvidedKey(childKey) + \"/\";\n              }\n              mapIntoArray(mappedChild, array, escapedChildKey, \"\", function(c) {\n                return c;\n              });\n            } else if (mappedChild != null) {\n              if (isValidElement(mappedChild)) {\n                {\n                  if (mappedChild.key && (!_child || _child.key !== mappedChild.key)) {\n                    checkKeyStringCoercion(mappedChild.key);\n                  }\n                }\n                mappedChild = cloneAndReplaceKey(\n                  mappedChild,\n                  // Keep both the (mapped) and old keys if they differ, just as\n                  // traverseAllChildren used to do for objects as children\n                  escapedPrefix + // $FlowFixMe Flow incorrectly thinks React.Portal doesn't have a key\n                  (mappedChild.key && (!_child || _child.key !== mappedChild.key) ? (\n                    // $FlowFixMe Flow incorrectly thinks existing element's key can be a number\n                    // eslint-disable-next-line react-internal/safe-string-coercion\n                    escapeUserProvidedKey(\"\" + mappedChild.key) + \"/\"\n                  ) : \"\") + childKey\n                );\n              }\n              array.push(mappedChild);\n            }\n            return 1;\n          }\n          var child;\n          var nextName;\n          var subtreeCount = 0;\n          var nextNamePrefix = nameSoFar === \"\" ? SEPARATOR : nameSoFar + SUBSEPARATOR;\n          if (isArray(children)) {\n            for (var i = 0; i < children.length; i++) {\n              child = children[i];\n              nextName = nextNamePrefix + getElementKey(child, i);\n              subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);\n            }\n          } else {\n            var iteratorFn = getIteratorFn(children);\n            if (typeof iteratorFn === \"function\") {\n              var iterableChildren = children;\n              {\n                if (iteratorFn === iterableChildren.entries) {\n                  if (!didWarnAboutMaps) {\n                    warn(\"Using Maps as children is not supported. Use an array of keyed ReactElements instead.\");\n                  }\n                  didWarnAboutMaps = true;\n                }\n              }\n              var iterator = iteratorFn.call(iterableChildren);\n              var step;\n              var ii = 0;\n              while (!(step = iterator.next()).done) {\n                child = step.value;\n                nextName = nextNamePrefix + getElementKey(child, ii++);\n                subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);\n              }\n            } else if (type === \"object\") {\n              var childrenString = String(children);\n              throw new Error(\"Objects are not valid as a React child (found: \" + (childrenString === \"[object Object]\" ? \"object with keys {\" + Object.keys(children).join(\", \") + \"}\" : childrenString) + \"). If you meant to render a collection of children, use an array instead.\");\n            }\n          }\n          return subtreeCount;\n        }\n        function mapChildren(children, func, context) {\n          if (children == null) {\n            return children;\n          }\n          var result = [];\n          var count = 0;\n          mapIntoArray(children, result, \"\", \"\", function(child) {\n            return func.call(context, child, count++);\n          });\n          return result;\n        }\n        function countChildren(children) {\n          var n = 0;\n          mapChildren(children, function() {\n            n++;\n          });\n          return n;\n        }\n        function forEachChildren(children, forEachFunc, forEachContext) {\n          mapChildren(children, function() {\n            forEachFunc.apply(this, arguments);\n          }, forEachContext);\n        }\n        function toArray(children) {\n          return mapChildren(children, function(child) {\n            return child;\n          }) || [];\n        }\n        function onlyChild(children) {\n          if (!isValidElement(children)) {\n            throw new Error(\"React.Children.only expected to receive a single React element child.\");\n          }\n          return children;\n        }\n        function createContext(defaultValue) {\n          var context = {\n            $$typeof: REACT_CONTEXT_TYPE,\n            // As a workaround to support multiple concurrent renderers, we categorize\n            // some renderers as primary and others as secondary. We only expect\n            // there to be two concurrent renderers at most: React Native (primary) and\n            // Fabric (secondary); React DOM (primary) and React ART (secondary).\n            // Secondary renderers store their context values on separate fields.\n            _currentValue: defaultValue,\n            _currentValue2: defaultValue,\n            // Used to track how many concurrent renderers this context currently\n            // supports within in a single renderer. Such as parallel server rendering.\n            _threadCount: 0,\n            // These are circular\n            Provider: null,\n            Consumer: null,\n            // Add these to use same hidden class in VM as ServerContext\n            _defaultValue: null,\n            _globalName: null\n          };\n          context.Provider = {\n            $$typeof: REACT_PROVIDER_TYPE,\n            _context: context\n          };\n          var hasWarnedAboutUsingNestedContextConsumers = false;\n          var hasWarnedAboutUsingConsumerProvider = false;\n          var hasWarnedAboutDisplayNameOnConsumer = false;\n          {\n            var Consumer = {\n              $$typeof: REACT_CONTEXT_TYPE,\n              _context: context\n            };\n            Object.defineProperties(Consumer, {\n              Provider: {\n                get: function() {\n                  if (!hasWarnedAboutUsingConsumerProvider) {\n                    hasWarnedAboutUsingConsumerProvider = true;\n                    error(\"Rendering <Context.Consumer.Provider> is not supported and will be removed in a future major release. Did you mean to render <Context.Provider> instead?\");\n                  }\n                  return context.Provider;\n                },\n                set: function(_Provider) {\n                  context.Provider = _Provider;\n                }\n              },\n              _currentValue: {\n                get: function() {\n                  return context._currentValue;\n                },\n                set: function(_currentValue) {\n                  context._currentValue = _currentValue;\n                }\n              },\n              _currentValue2: {\n                get: function() {\n                  return context._currentValue2;\n                },\n                set: function(_currentValue2) {\n                  context._currentValue2 = _currentValue2;\n                }\n              },\n              _threadCount: {\n                get: function() {\n                  return context._threadCount;\n                },\n                set: function(_threadCount) {\n                  context._threadCount = _threadCount;\n                }\n              },\n              Consumer: {\n                get: function() {\n                  if (!hasWarnedAboutUsingNestedContextConsumers) {\n                    hasWarnedAboutUsingNestedContextConsumers = true;\n                    error(\"Rendering <Context.Consumer.Consumer> is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?\");\n                  }\n                  return context.Consumer;\n                }\n              },\n              displayName: {\n                get: function() {\n                  return context.displayName;\n                },\n                set: function(displayName) {\n                  if (!hasWarnedAboutDisplayNameOnConsumer) {\n                    warn(\"Setting `displayName` on Context.Consumer has no effect. You should set it directly on the context with Context.displayName = '%s'.\", displayName);\n                    hasWarnedAboutDisplayNameOnConsumer = true;\n                  }\n                }\n              }\n            });\n            context.Consumer = Consumer;\n          }\n          {\n            context._currentRenderer = null;\n            context._currentRenderer2 = null;\n          }\n          return context;\n        }\n        var Uninitialized = -1;\n        var Pending = 0;\n        var Resolved = 1;\n        var Rejected = 2;\n        function lazyInitializer(payload) {\n          if (payload._status === Uninitialized) {\n            var ctor = payload._result;\n            var thenable = ctor();\n            thenable.then(function(moduleObject2) {\n              if (payload._status === Pending || payload._status === Uninitialized) {\n                var resolved = payload;\n                resolved._status = Resolved;\n                resolved._result = moduleObject2;\n              }\n            }, function(error2) {\n              if (payload._status === Pending || payload._status === Uninitialized) {\n                var rejected = payload;\n                rejected._status = Rejected;\n                rejected._result = error2;\n              }\n            });\n            if (payload._status === Uninitialized) {\n              var pending = payload;\n              pending._status = Pending;\n              pending._result = thenable;\n            }\n          }\n          if (payload._status === Resolved) {\n            var moduleObject = payload._result;\n            {\n              if (moduleObject === void 0) {\n                error(\"lazy: Expected the result of a dynamic import() call. Instead received: %s\\n\\nYour code should look like: \\n  const MyComponent = lazy(() => import('./MyComponent'))\\n\\nDid you accidentally put curly braces around the import?\", moduleObject);\n              }\n            }\n            {\n              if (!(\"default\" in moduleObject)) {\n                error(\"lazy: Expected the result of a dynamic import() call. Instead received: %s\\n\\nYour code should look like: \\n  const MyComponent = lazy(() => import('./MyComponent'))\", moduleObject);\n              }\n            }\n            return moduleObject.default;\n          } else {\n            throw payload._result;\n          }\n        }\n        function lazy(ctor) {\n          var payload = {\n            // We use these fields to store the result.\n            _status: Uninitialized,\n            _result: ctor\n          };\n          var lazyType = {\n            $$typeof: REACT_LAZY_TYPE,\n            _payload: payload,\n            _init: lazyInitializer\n          };\n          {\n            var defaultProps;\n            var propTypes;\n            Object.defineProperties(lazyType, {\n              defaultProps: {\n                configurable: true,\n                get: function() {\n                  return defaultProps;\n                },\n                set: function(newDefaultProps) {\n                  error(\"React.lazy(...): It is not supported to assign `defaultProps` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it.\");\n                  defaultProps = newDefaultProps;\n                  Object.defineProperty(lazyType, \"defaultProps\", {\n                    enumerable: true\n                  });\n                }\n              },\n              propTypes: {\n                configurable: true,\n                get: function() {\n                  return propTypes;\n                },\n                set: function(newPropTypes) {\n                  error(\"React.lazy(...): It is not supported to assign `propTypes` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it.\");\n                  propTypes = newPropTypes;\n                  Object.defineProperty(lazyType, \"propTypes\", {\n                    enumerable: true\n                  });\n                }\n              }\n            });\n          }\n          return lazyType;\n        }\n        function forwardRef(render) {\n          {\n            if (render != null && render.$$typeof === REACT_MEMO_TYPE) {\n              error(\"forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...)).\");\n            } else if (typeof render !== \"function\") {\n              error(\"forwardRef requires a render function but was given %s.\", render === null ? \"null\" : typeof render);\n            } else {\n              if (render.length !== 0 && render.length !== 2) {\n                error(\"forwardRef render functions accept exactly two parameters: props and ref. %s\", render.length === 1 ? \"Did you forget to use the ref parameter?\" : \"Any additional parameter will be undefined.\");\n              }\n            }\n            if (render != null) {\n              if (render.defaultProps != null || render.propTypes != null) {\n                error(\"forwardRef render functions do not support propTypes or defaultProps. Did you accidentally pass a React component?\");\n              }\n            }\n          }\n          var elementType = {\n            $$typeof: REACT_FORWARD_REF_TYPE,\n            render\n          };\n          {\n            var ownName;\n            Object.defineProperty(elementType, \"displayName\", {\n              enumerable: false,\n              configurable: true,\n              get: function() {\n                return ownName;\n              },\n              set: function(name) {\n                ownName = name;\n                if (!render.name && !render.displayName) {\n                  render.displayName = name;\n                }\n              }\n            });\n          }\n          return elementType;\n        }\n        var REACT_MODULE_REFERENCE;\n        {\n          REACT_MODULE_REFERENCE = Symbol.for(\"react.module.reference\");\n        }\n        function isValidElementType(type) {\n          if (typeof type === \"string\" || typeof type === \"function\") {\n            return true;\n          }\n          if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {\n            return true;\n          }\n          if (typeof type === \"object\" && type !== null) {\n            if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object\n            // types supported by any Flight configuration anywhere since\n            // we don't know which Flight build this will end up being used\n            // with.\n            type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== void 0) {\n              return true;\n            }\n          }\n          return false;\n        }\n        function memo(type, compare) {\n          {\n            if (!isValidElementType(type)) {\n              error(\"memo: The first argument must be a component. Instead received: %s\", type === null ? \"null\" : typeof type);\n            }\n          }\n          var elementType = {\n            $$typeof: REACT_MEMO_TYPE,\n            type,\n            compare: compare === void 0 ? null : compare\n          };\n          {\n            var ownName;\n            Object.defineProperty(elementType, \"displayName\", {\n              enumerable: false,\n              configurable: true,\n              get: function() {\n                return ownName;\n              },\n              set: function(name) {\n                ownName = name;\n                if (!type.name && !type.displayName) {\n                  type.displayName = name;\n                }\n              }\n            });\n          }\n          return elementType;\n        }\n        function resolveDispatcher() {\n          var dispatcher = ReactCurrentDispatcher.current;\n          {\n            if (dispatcher === null) {\n              error(\"Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\\n1. You might have mismatching versions of React and the renderer (such as React DOM)\\n2. You might be breaking the Rules of Hooks\\n3. You might have more than one copy of React in the same app\\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.\");\n            }\n          }\n          return dispatcher;\n        }\n        function useContext(Context) {\n          var dispatcher = resolveDispatcher();\n          {\n            if (Context._context !== void 0) {\n              var realContext = Context._context;\n              if (realContext.Consumer === Context) {\n                error(\"Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be removed in a future major release. Did you mean to call useContext(Context) instead?\");\n              } else if (realContext.Provider === Context) {\n                error(\"Calling useContext(Context.Provider) is not supported. Did you mean to call useContext(Context) instead?\");\n              }\n            }\n          }\n          return dispatcher.useContext(Context);\n        }\n        function useState(initialState) {\n          var dispatcher = resolveDispatcher();\n          return dispatcher.useState(initialState);\n        }\n        function useReducer(reducer, initialArg, init) {\n          var dispatcher = resolveDispatcher();\n          return dispatcher.useReducer(reducer, initialArg, init);\n        }\n        function useRef(initialValue) {\n          var dispatcher = resolveDispatcher();\n          return dispatcher.useRef(initialValue);\n        }\n        function useEffect(create, deps) {\n          var dispatcher = resolveDispatcher();\n          return dispatcher.useEffect(create, deps);\n        }\n        function useInsertionEffect(create, deps) {\n          var dispatcher = resolveDispatcher();\n          return dispatcher.useInsertionEffect(create, deps);\n        }\n        function useLayoutEffect(create, deps) {\n          var dispatcher = resolveDispatcher();\n          return dispatcher.useLayoutEffect(create, deps);\n        }\n        function useCallback(callback, deps) {\n          var dispatcher = resolveDispatcher();\n          return dispatcher.useCallback(callback, deps);\n        }\n        function useMemo(create, deps) {\n          var dispatcher = resolveDispatcher();\n          return dispatcher.useMemo(create, deps);\n        }\n        function useImperativeHandle(ref, create, deps) {\n          var dispatcher = resolveDispatcher();\n          return dispatcher.useImperativeHandle(ref, create, deps);\n        }\n        function useDebugValue(value, formatterFn) {\n          {\n            var dispatcher = resolveDispatcher();\n            return dispatcher.useDebugValue(value, formatterFn);\n          }\n        }\n        function useTransition() {\n          var dispatcher = resolveDispatcher();\n          return dispatcher.useTransition();\n        }\n        function useDeferredValue(value) {\n          var dispatcher = resolveDispatcher();\n          return dispatcher.useDeferredValue(value);\n        }\n        function useId() {\n          var dispatcher = resolveDispatcher();\n          return dispatcher.useId();\n        }\n        function useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {\n          var dispatcher = resolveDispatcher();\n          return dispatcher.useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n        }\n        var disabledDepth = 0;\n        var prevLog;\n        var prevInfo;\n        var prevWarn;\n        var prevError;\n        var prevGroup;\n        var prevGroupCollapsed;\n        var prevGroupEnd;\n        function disabledLog() {\n        }\n        disabledLog.__reactDisabledLog = true;\n        function disableLogs() {\n          {\n            if (disabledDepth === 0) {\n              prevLog = console.log;\n              prevInfo = console.info;\n              prevWarn = console.warn;\n              prevError = console.error;\n              prevGroup = console.group;\n              prevGroupCollapsed = console.groupCollapsed;\n              prevGroupEnd = console.groupEnd;\n              var props = {\n                configurable: true,\n                enumerable: true,\n                value: disabledLog,\n                writable: true\n              };\n              Object.defineProperties(console, {\n                info: props,\n                log: props,\n                warn: props,\n                error: props,\n                group: props,\n                groupCollapsed: props,\n                groupEnd: props\n              });\n            }\n            disabledDepth++;\n          }\n        }\n        function reenableLogs() {\n          {\n            disabledDepth--;\n            if (disabledDepth === 0) {\n              var props = {\n                configurable: true,\n                enumerable: true,\n                writable: true\n              };\n              Object.defineProperties(console, {\n                log: assign({}, props, {\n                  value: prevLog\n                }),\n                info: assign({}, props, {\n                  value: prevInfo\n                }),\n                warn: assign({}, props, {\n                  value: prevWarn\n                }),\n                error: assign({}, props, {\n                  value: prevError\n                }),\n                group: assign({}, props, {\n                  value: prevGroup\n                }),\n                groupCollapsed: assign({}, props, {\n                  value: prevGroupCollapsed\n                }),\n                groupEnd: assign({}, props, {\n                  value: prevGroupEnd\n                })\n              });\n            }\n            if (disabledDepth < 0) {\n              error(\"disabledDepth fell below zero. This is a bug in React. Please file an issue.\");\n            }\n          }\n        }\n        var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;\n        var prefix;\n        function describeBuiltInComponentFrame(name, source, ownerFn) {\n          {\n            if (prefix === void 0) {\n              try {\n                throw Error();\n              } catch (x) {\n                var match = x.stack.trim().match(/\\n( *(at )?)/);\n                prefix = match && match[1] || \"\";\n              }\n            }\n            return \"\\n\" + prefix + name;\n          }\n        }\n        var reentry = false;\n        var componentFrameCache;\n        {\n          var PossiblyWeakMap = typeof WeakMap === \"function\" ? WeakMap : Map;\n          componentFrameCache = new PossiblyWeakMap();\n        }\n        function describeNativeComponentFrame(fn, construct) {\n          if (!fn || reentry) {\n            return \"\";\n          }\n          {\n            var frame = componentFrameCache.get(fn);\n            if (frame !== void 0) {\n              return frame;\n            }\n          }\n          var control;\n          reentry = true;\n          var previousPrepareStackTrace = Error.prepareStackTrace;\n          Error.prepareStackTrace = void 0;\n          var previousDispatcher;\n          {\n            previousDispatcher = ReactCurrentDispatcher$1.current;\n            ReactCurrentDispatcher$1.current = null;\n            disableLogs();\n          }\n          try {\n            if (construct) {\n              var Fake = function() {\n                throw Error();\n              };\n              Object.defineProperty(Fake.prototype, \"props\", {\n                set: function() {\n                  throw Error();\n                }\n              });\n              if (typeof Reflect === \"object\" && Reflect.construct) {\n                try {\n                  Reflect.construct(Fake, []);\n                } catch (x) {\n                  control = x;\n                }\n                Reflect.construct(fn, [], Fake);\n              } else {\n                try {\n                  Fake.call();\n                } catch (x) {\n                  control = x;\n                }\n                fn.call(Fake.prototype);\n              }\n            } else {\n              try {\n                throw Error();\n              } catch (x) {\n                control = x;\n              }\n              fn();\n            }\n          } catch (sample) {\n            if (sample && control && typeof sample.stack === \"string\") {\n              var sampleLines = sample.stack.split(\"\\n\");\n              var controlLines = control.stack.split(\"\\n\");\n              var s = sampleLines.length - 1;\n              var c = controlLines.length - 1;\n              while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {\n                c--;\n              }\n              for (; s >= 1 && c >= 0; s--, c--) {\n                if (sampleLines[s] !== controlLines[c]) {\n                  if (s !== 1 || c !== 1) {\n                    do {\n                      s--;\n                      c--;\n                      if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                        var _frame = \"\\n\" + sampleLines[s].replace(\" at new \", \" at \");\n                        if (fn.displayName && _frame.includes(\"<anonymous>\")) {\n                          _frame = _frame.replace(\"<anonymous>\", fn.displayName);\n                        }\n                        {\n                          if (typeof fn === \"function\") {\n                            componentFrameCache.set(fn, _frame);\n                          }\n                        }\n                        return _frame;\n                      }\n                    } while (s >= 1 && c >= 0);\n                  }\n                  break;\n                }\n              }\n            }\n          } finally {\n            reentry = false;\n            {\n              ReactCurrentDispatcher$1.current = previousDispatcher;\n              reenableLogs();\n            }\n            Error.prepareStackTrace = previousPrepareStackTrace;\n          }\n          var name = fn ? fn.displayName || fn.name : \"\";\n          var syntheticFrame = name ? describeBuiltInComponentFrame(name) : \"\";\n          {\n            if (typeof fn === \"function\") {\n              componentFrameCache.set(fn, syntheticFrame);\n            }\n          }\n          return syntheticFrame;\n        }\n        function describeFunctionComponentFrame(fn, source, ownerFn) {\n          {\n            return describeNativeComponentFrame(fn, false);\n          }\n        }\n        function shouldConstruct(Component2) {\n          var prototype = Component2.prototype;\n          return !!(prototype && prototype.isReactComponent);\n        }\n        function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {\n          if (type == null) {\n            return \"\";\n          }\n          if (typeof type === \"function\") {\n            {\n              return describeNativeComponentFrame(type, shouldConstruct(type));\n            }\n          }\n          if (typeof type === \"string\") {\n            return describeBuiltInComponentFrame(type);\n          }\n          switch (type) {\n            case REACT_SUSPENSE_TYPE:\n              return describeBuiltInComponentFrame(\"Suspense\");\n            case REACT_SUSPENSE_LIST_TYPE:\n              return describeBuiltInComponentFrame(\"SuspenseList\");\n          }\n          if (typeof type === \"object\") {\n            switch (type.$$typeof) {\n              case REACT_FORWARD_REF_TYPE:\n                return describeFunctionComponentFrame(type.render);\n              case REACT_MEMO_TYPE:\n                return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);\n              case REACT_LAZY_TYPE: {\n                var lazyComponent = type;\n                var payload = lazyComponent._payload;\n                var init = lazyComponent._init;\n                try {\n                  return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);\n                } catch (x) {\n                }\n              }\n            }\n          }\n          return \"\";\n        }\n        var loggedTypeFailures = {};\n        var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;\n        function setCurrentlyValidatingElement(element) {\n          {\n            if (element) {\n              var owner = element._owner;\n              var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n              ReactDebugCurrentFrame$1.setExtraStackFrame(stack);\n            } else {\n              ReactDebugCurrentFrame$1.setExtraStackFrame(null);\n            }\n          }\n        }\n        function checkPropTypes(typeSpecs, values, location, componentName, element) {\n          {\n            var has = Function.call.bind(hasOwnProperty);\n            for (var typeSpecName in typeSpecs) {\n              if (has(typeSpecs, typeSpecName)) {\n                var error$1 = void 0;\n                try {\n                  if (typeof typeSpecs[typeSpecName] !== \"function\") {\n                    var err = Error((componentName || \"React class\") + \": \" + location + \" type `\" + typeSpecName + \"` is invalid; it must be a function, usually from the `prop-types` package, but received `\" + typeof typeSpecs[typeSpecName] + \"`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.\");\n                    err.name = \"Invariant Violation\";\n                    throw err;\n                  }\n                  error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, \"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED\");\n                } catch (ex) {\n                  error$1 = ex;\n                }\n                if (error$1 && !(error$1 instanceof Error)) {\n                  setCurrentlyValidatingElement(element);\n                  error(\"%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).\", componentName || \"React class\", location, typeSpecName, typeof error$1);\n                  setCurrentlyValidatingElement(null);\n                }\n                if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {\n                  loggedTypeFailures[error$1.message] = true;\n                  setCurrentlyValidatingElement(element);\n                  error(\"Failed %s type: %s\", location, error$1.message);\n                  setCurrentlyValidatingElement(null);\n                }\n              }\n            }\n          }\n        }\n        function setCurrentlyValidatingElement$1(element) {\n          {\n            if (element) {\n              var owner = element._owner;\n              var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n              setExtraStackFrame(stack);\n            } else {\n              setExtraStackFrame(null);\n            }\n          }\n        }\n        var propTypesMisspellWarningShown;\n        {\n          propTypesMisspellWarningShown = false;\n        }\n        function getDeclarationErrorAddendum() {\n          if (ReactCurrentOwner.current) {\n            var name = getComponentNameFromType(ReactCurrentOwner.current.type);\n            if (name) {\n              return \"\\n\\nCheck the render method of `\" + name + \"`.\";\n            }\n          }\n          return \"\";\n        }\n        function getSourceInfoErrorAddendum(source) {\n          if (source !== void 0) {\n            var fileName = source.fileName.replace(/^.*[\\\\\\/]/, \"\");\n            var lineNumber = source.lineNumber;\n            return \"\\n\\nCheck your code at \" + fileName + \":\" + lineNumber + \".\";\n          }\n          return \"\";\n        }\n        function getSourceInfoErrorAddendumForProps(elementProps) {\n          if (elementProps !== null && elementProps !== void 0) {\n            return getSourceInfoErrorAddendum(elementProps.__source);\n          }\n          return \"\";\n        }\n        var ownerHasKeyUseWarning = {};\n        function getCurrentComponentErrorInfo(parentType) {\n          var info = getDeclarationErrorAddendum();\n          if (!info) {\n            var parentName = typeof parentType === \"string\" ? parentType : parentType.displayName || parentType.name;\n            if (parentName) {\n              info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\n            }\n          }\n          return info;\n        }\n        function validateExplicitKey(element, parentType) {\n          if (!element._store || element._store.validated || element.key != null) {\n            return;\n          }\n          element._store.validated = true;\n          var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n          if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n            return;\n          }\n          ownerHasKeyUseWarning[currentComponentErrorInfo] = true;\n          var childOwner = \"\";\n          if (element && element._owner && element._owner !== ReactCurrentOwner.current) {\n            childOwner = \" It was passed a child from \" + getComponentNameFromType(element._owner.type) + \".\";\n          }\n          {\n            setCurrentlyValidatingElement$1(element);\n            error('Each child in a list should have a unique \"key\" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);\n            setCurrentlyValidatingElement$1(null);\n          }\n        }\n        function validateChildKeys(node, parentType) {\n          if (typeof node !== \"object\") {\n            return;\n          }\n          if (isArray(node)) {\n            for (var i = 0; i < node.length; i++) {\n              var child = node[i];\n              if (isValidElement(child)) {\n                validateExplicitKey(child, parentType);\n              }\n            }\n          } else if (isValidElement(node)) {\n            if (node._store) {\n              node._store.validated = true;\n            }\n          } else if (node) {\n            var iteratorFn = getIteratorFn(node);\n            if (typeof iteratorFn === \"function\") {\n              if (iteratorFn !== node.entries) {\n                var iterator = iteratorFn.call(node);\n                var step;\n                while (!(step = iterator.next()).done) {\n                  if (isValidElement(step.value)) {\n                    validateExplicitKey(step.value, parentType);\n                  }\n                }\n              }\n            }\n          }\n        }\n        function validatePropTypes(element) {\n          {\n            var type = element.type;\n            if (type === null || type === void 0 || typeof type === \"string\") {\n              return;\n            }\n            var propTypes;\n            if (typeof type === \"function\") {\n              propTypes = type.propTypes;\n            } else if (typeof type === \"object\" && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.\n            // Inner props are checked in the reconciler.\n            type.$$typeof === REACT_MEMO_TYPE)) {\n              propTypes = type.propTypes;\n            } else {\n              return;\n            }\n            if (propTypes) {\n              var name = getComponentNameFromType(type);\n              checkPropTypes(propTypes, element.props, \"prop\", name, element);\n            } else if (type.PropTypes !== void 0 && !propTypesMisspellWarningShown) {\n              propTypesMisspellWarningShown = true;\n              var _name = getComponentNameFromType(type);\n              error(\"Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?\", _name || \"Unknown\");\n            }\n            if (typeof type.getDefaultProps === \"function\" && !type.getDefaultProps.isReactClassApproved) {\n              error(\"getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.\");\n            }\n          }\n        }\n        function validateFragmentProps(fragment) {\n          {\n            var keys = Object.keys(fragment.props);\n            for (var i = 0; i < keys.length; i++) {\n              var key = keys[i];\n              if (key !== \"children\" && key !== \"key\") {\n                setCurrentlyValidatingElement$1(fragment);\n                error(\"Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.\", key);\n                setCurrentlyValidatingElement$1(null);\n                break;\n              }\n            }\n            if (fragment.ref !== null) {\n              setCurrentlyValidatingElement$1(fragment);\n              error(\"Invalid attribute `ref` supplied to `React.Fragment`.\");\n              setCurrentlyValidatingElement$1(null);\n            }\n          }\n        }\n        function createElementWithValidation(type, props, children) {\n          var validType = isValidElementType(type);\n          if (!validType) {\n            var info = \"\";\n            if (type === void 0 || typeof type === \"object\" && type !== null && Object.keys(type).length === 0) {\n              info += \" You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.\";\n            }\n            var sourceInfo = getSourceInfoErrorAddendumForProps(props);\n            if (sourceInfo) {\n              info += sourceInfo;\n            } else {\n              info += getDeclarationErrorAddendum();\n            }\n            var typeString;\n            if (type === null) {\n              typeString = \"null\";\n            } else if (isArray(type)) {\n              typeString = \"array\";\n            } else if (type !== void 0 && type.$$typeof === REACT_ELEMENT_TYPE) {\n              typeString = \"<\" + (getComponentNameFromType(type.type) || \"Unknown\") + \" />\";\n              info = \" Did you accidentally export a JSX literal instead of a component?\";\n            } else {\n              typeString = typeof type;\n            }\n            {\n              error(\"React.createElement: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s\", typeString, info);\n            }\n          }\n          var element = createElement.apply(this, arguments);\n          if (element == null) {\n            return element;\n          }\n          if (validType) {\n            for (var i = 2; i < arguments.length; i++) {\n              validateChildKeys(arguments[i], type);\n            }\n          }\n          if (type === REACT_FRAGMENT_TYPE) {\n            validateFragmentProps(element);\n          } else {\n            validatePropTypes(element);\n          }\n          return element;\n        }\n        var didWarnAboutDeprecatedCreateFactory = false;\n        function createFactoryWithValidation(type) {\n          var validatedFactory = createElementWithValidation.bind(null, type);\n          validatedFactory.type = type;\n          {\n            if (!didWarnAboutDeprecatedCreateFactory) {\n              didWarnAboutDeprecatedCreateFactory = true;\n              warn(\"React.createFactory() is deprecated and will be removed in a future major release. Consider using JSX or use React.createElement() directly instead.\");\n            }\n            Object.defineProperty(validatedFactory, \"type\", {\n              enumerable: false,\n              get: function() {\n                warn(\"Factory.type is deprecated. Access the class directly before passing it to createFactory.\");\n                Object.defineProperty(this, \"type\", {\n                  value: type\n                });\n                return type;\n              }\n            });\n          }\n          return validatedFactory;\n        }\n        function cloneElementWithValidation(element, props, children) {\n          var newElement = cloneElement.apply(this, arguments);\n          for (var i = 2; i < arguments.length; i++) {\n            validateChildKeys(arguments[i], newElement.type);\n          }\n          validatePropTypes(newElement);\n          return newElement;\n        }\n        function startTransition(scope, options) {\n          var prevTransition = ReactCurrentBatchConfig.transition;\n          ReactCurrentBatchConfig.transition = {};\n          var currentTransition = ReactCurrentBatchConfig.transition;\n          {\n            ReactCurrentBatchConfig.transition._updatedFibers = /* @__PURE__ */ new Set();\n          }\n          try {\n            scope();\n          } finally {\n            ReactCurrentBatchConfig.transition = prevTransition;\n            {\n              if (prevTransition === null && currentTransition._updatedFibers) {\n                var updatedFibersCount = currentTransition._updatedFibers.size;\n                if (updatedFibersCount > 10) {\n                  warn(\"Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table.\");\n                }\n                currentTransition._updatedFibers.clear();\n              }\n            }\n          }\n        }\n        var didWarnAboutMessageChannel = false;\n        var enqueueTaskImpl = null;\n        function enqueueTask(task) {\n          if (enqueueTaskImpl === null) {\n            try {\n              var requireString = (\"require\" + Math.random()).slice(0, 7);\n              var nodeRequire = module && module[requireString];\n              enqueueTaskImpl = nodeRequire.call(module, \"timers\").setImmediate;\n            } catch (_err) {\n              enqueueTaskImpl = function(callback) {\n                {\n                  if (didWarnAboutMessageChannel === false) {\n                    didWarnAboutMessageChannel = true;\n                    if (typeof MessageChannel === \"undefined\") {\n                      error(\"This browser does not have a MessageChannel implementation, so enqueuing tasks via await act(async () => ...) will fail. Please file an issue at https://github.com/facebook/react/issues if you encounter this warning.\");\n                    }\n                  }\n                }\n                var channel = new MessageChannel();\n                channel.port1.onmessage = callback;\n                channel.port2.postMessage(void 0);\n              };\n            }\n          }\n          return enqueueTaskImpl(task);\n        }\n        var actScopeDepth = 0;\n        var didWarnNoAwaitAct = false;\n        function act(callback) {\n          {\n            var prevActScopeDepth = actScopeDepth;\n            actScopeDepth++;\n            if (ReactCurrentActQueue.current === null) {\n              ReactCurrentActQueue.current = [];\n            }\n            var prevIsBatchingLegacy = ReactCurrentActQueue.isBatchingLegacy;\n            var result;\n            try {\n              ReactCurrentActQueue.isBatchingLegacy = true;\n              result = callback();\n              if (!prevIsBatchingLegacy && ReactCurrentActQueue.didScheduleLegacyUpdate) {\n                var queue = ReactCurrentActQueue.current;\n                if (queue !== null) {\n                  ReactCurrentActQueue.didScheduleLegacyUpdate = false;\n                  flushActQueue(queue);\n                }\n              }\n            } catch (error2) {\n              popActScope(prevActScopeDepth);\n              throw error2;\n            } finally {\n              ReactCurrentActQueue.isBatchingLegacy = prevIsBatchingLegacy;\n            }\n            if (result !== null && typeof result === \"object\" && typeof result.then === \"function\") {\n              var thenableResult = result;\n              var wasAwaited = false;\n              var thenable = {\n                then: function(resolve, reject) {\n                  wasAwaited = true;\n                  thenableResult.then(function(returnValue2) {\n                    popActScope(prevActScopeDepth);\n                    if (actScopeDepth === 0) {\n                      recursivelyFlushAsyncActWork(returnValue2, resolve, reject);\n                    } else {\n                      resolve(returnValue2);\n                    }\n                  }, function(error2) {\n                    popActScope(prevActScopeDepth);\n                    reject(error2);\n                  });\n                }\n              };\n              {\n                if (!didWarnNoAwaitAct && typeof Promise !== \"undefined\") {\n                  Promise.resolve().then(function() {\n                  }).then(function() {\n                    if (!wasAwaited) {\n                      didWarnNoAwaitAct = true;\n                      error(\"You called act(async () => ...) without await. This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - await act(async () => ...);\");\n                    }\n                  });\n                }\n              }\n              return thenable;\n            } else {\n              var returnValue = result;\n              popActScope(prevActScopeDepth);\n              if (actScopeDepth === 0) {\n                var _queue = ReactCurrentActQueue.current;\n                if (_queue !== null) {\n                  flushActQueue(_queue);\n                  ReactCurrentActQueue.current = null;\n                }\n                var _thenable = {\n                  then: function(resolve, reject) {\n                    if (ReactCurrentActQueue.current === null) {\n                      ReactCurrentActQueue.current = [];\n                      recursivelyFlushAsyncActWork(returnValue, resolve, reject);\n                    } else {\n                      resolve(returnValue);\n                    }\n                  }\n                };\n                return _thenable;\n              } else {\n                var _thenable2 = {\n                  then: function(resolve, reject) {\n                    resolve(returnValue);\n                  }\n                };\n                return _thenable2;\n              }\n            }\n          }\n        }\n        function popActScope(prevActScopeDepth) {\n          {\n            if (prevActScopeDepth !== actScopeDepth - 1) {\n              error(\"You seem to have overlapping act() calls, this is not supported. Be sure to await previous act() calls before making a new one. \");\n            }\n            actScopeDepth = prevActScopeDepth;\n          }\n        }\n        function recursivelyFlushAsyncActWork(returnValue, resolve, reject) {\n          {\n            var queue = ReactCurrentActQueue.current;\n            if (queue !== null) {\n              try {\n                flushActQueue(queue);\n                enqueueTask(function() {\n                  if (queue.length === 0) {\n                    ReactCurrentActQueue.current = null;\n                    resolve(returnValue);\n                  } else {\n                    recursivelyFlushAsyncActWork(returnValue, resolve, reject);\n                  }\n                });\n              } catch (error2) {\n                reject(error2);\n              }\n            } else {\n              resolve(returnValue);\n            }\n          }\n        }\n        var isFlushing = false;\n        function flushActQueue(queue) {\n          {\n            if (!isFlushing) {\n              isFlushing = true;\n              var i = 0;\n              try {\n                for (; i < queue.length; i++) {\n                  var callback = queue[i];\n                  do {\n                    callback = callback(true);\n                  } while (callback !== null);\n                }\n                queue.length = 0;\n              } catch (error2) {\n                queue = queue.slice(i + 1);\n                throw error2;\n              } finally {\n                isFlushing = false;\n              }\n            }\n          }\n        }\n        var createElement$1 = createElementWithValidation;\n        var cloneElement$1 = cloneElementWithValidation;\n        var createFactory = createFactoryWithValidation;\n        var Children = {\n          map: mapChildren,\n          forEach: forEachChildren,\n          count: countChildren,\n          toArray,\n          only: onlyChild\n        };\n        exports.Children = Children;\n        exports.Component = Component;\n        exports.Fragment = REACT_FRAGMENT_TYPE;\n        exports.Profiler = REACT_PROFILER_TYPE;\n        exports.PureComponent = PureComponent;\n        exports.StrictMode = REACT_STRICT_MODE_TYPE;\n        exports.Suspense = REACT_SUSPENSE_TYPE;\n        exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactSharedInternals;\n        exports.cloneElement = cloneElement$1;\n        exports.createContext = createContext;\n        exports.createElement = createElement$1;\n        exports.createFactory = createFactory;\n        exports.createRef = createRef;\n        exports.forwardRef = forwardRef;\n        exports.isValidElement = isValidElement;\n        exports.lazy = lazy;\n        exports.memo = memo;\n        exports.startTransition = startTransition;\n        exports.unstable_act = act;\n        exports.useCallback = useCallback;\n        exports.useContext = useContext;\n        exports.useDebugValue = useDebugValue;\n        exports.useDeferredValue = useDeferredValue;\n        exports.useEffect = useEffect;\n        exports.useId = useId;\n        exports.useImperativeHandle = useImperativeHandle;\n        exports.useInsertionEffect = useInsertionEffect;\n        exports.useLayoutEffect = useLayoutEffect;\n        exports.useMemo = useMemo;\n        exports.useReducer = useReducer;\n        exports.useRef = useRef;\n        exports.useState = useState;\n        exports.useSyncExternalStore = useSyncExternalStore;\n        exports.useTransition = useTransition;\n        exports.version = ReactVersion;\n        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== \"undefined\" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === \"function\") {\n          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());\n        }\n      })();\n    }\n  }\n});\n\n// ../../node_modules/.pnpm/react@18.2.0/node_modules/react/index.js\nvar require_react = __commonJS({\n  \"../../node_modules/.pnpm/react@18.2.0/node_modules/react/index.js\"(exports, module) {\n    if (false) {\n      module.exports = null;\n    } else {\n      module.exports = require_react_development();\n    }\n  }\n});\n\nexport {\n  require_react\n};\n/*! Bundled license information:\n\nreact/cjs/react.development.js:\n  (**\n   * @license React\n   * react.development.js\n   *\n   * Copyright (c) Facebook, Inc. and its affiliates.\n   *\n   * This source code is licensed under the MIT license found in the\n   * LICENSE file in the root directory of this source tree.\n   *)\n*/\n//# sourceMappingURL=chunk-R7U5S34U.js.map\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 77943,
            "count": 1
          }
        ]
      },
      {
        "functionName": "../../node_modules/.pnpm/react@18.2.0/node_modules/react/cjs/react.development.js",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 219,
            "endOffset": 77228,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 363,
            "endOffset": 77214,
            "count": 1
          },
          {
            "startOffset": 549,
            "endOffset": 643,
            "count": 0
          },
          {
            "startOffset": 10914,
            "endOffset": 11070,
            "count": 2
          },
          {
            "startOffset": 49781,
            "endOffset": 49786,
            "count": 0
          },
          {
            "startOffset": 77113,
            "endOffset": 77206,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getIteratorFn",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1623,
            "endOffset": 2040,
            "count": 0
          }
        ]
      },
      {
        "functionName": "setExtraStackFrame",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2753,
            "endOffset": 2867,
            "count": 0
          }
        ]
      },
      {
        "functionName": "ReactDebugCurrentFrame.setExtraStackFrame",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2932,
            "endOffset": 3035,
            "count": 0
          }
        ]
      },
      {
        "functionName": "ReactDebugCurrentFrame.getStackAddendum",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 3146,
            "endOffset": 3465,
            "count": 0
          }
        ]
      },
      {
        "functionName": "warn",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4007,
            "endOffset": 4332,
            "count": 0
          }
        ]
      },
      {
        "functionName": "error",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4341,
            "endOffset": 4677,
            "count": 0
          }
        ]
      },
      {
        "functionName": "printWarning",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4686,
            "endOffset": 5290,
            "count": 0
          }
        ]
      },
      {
        "functionName": "warnNoop",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 5357,
            "endOffset": 6147,
            "count": 0
          }
        ]
      },
      {
        "functionName": "isMounted",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 6493,
            "endOffset": 6557,
            "count": 0
          }
        ]
      },
      {
        "functionName": "enqueueForceUpdate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 7370,
            "endOffset": 7483,
            "count": 0
          }
        ]
      },
      {
        "functionName": "enqueueReplaceState",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 8213,
            "endOffset": 8342,
            "count": 0
          }
        ]
      },
      {
        "functionName": "enqueueSetState",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 9044,
            "endOffset": 9168,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Component",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 9312,
            "endOffset": 9524,
            "count": 1
          }
        ]
      },
      {
        "functionName": "Component.setState",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 9615,
            "endOffset": 10015,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Component.forceUpdate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10059,
            "endOffset": 10163,
            "count": 0
          }
        ]
      },
      {
        "functionName": "defineDeprecationWarning",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10560,
            "endOffset": 10867,
            "count": 2
          }
        ]
      },
      {
        "functionName": "get",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10677,
            "endOffset": 10839,
            "count": 0
          }
        ]
      },
      {
        "functionName": "ComponentDummy",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 11089,
            "endOffset": 11126,
            "count": 1
          }
        ]
      },
      {
        "functionName": "PureComponent",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11191,
            "endOffset": 11407,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createRef",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11682,
            "endOffset": 11869,
            "count": 0
          }
        ]
      },
      {
        "functionName": "isArray",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11919,
            "endOffset": 11983,
            "count": 0
          }
        ]
      },
      {
        "functionName": "typeName",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11992,
            "endOffset": 12268,
            "count": 0
          }
        ]
      },
      {
        "functionName": "willCoercionThrow",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12277,
            "endOffset": 12500,
            "count": 0
          }
        ]
      },
      {
        "functionName": "testStringCoercion",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12509,
            "endOffset": 12584,
            "count": 0
          }
        ]
      },
      {
        "functionName": "checkKeyStringCoercion",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12593,
            "endOffset": 12926,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getWrappedName",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12935,
            "endOffset": 13298,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getContextName",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13307,
            "endOffset": 13396,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getComponentNameFromType",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13405,
            "endOffset": 15568,
            "count": 0
          }
        ]
      },
      {
        "functionName": "hasValidRef",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15923,
            "endOffset": 16273,
            "count": 0
          }
        ]
      },
      {
        "functionName": "hasValidKey",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 16282,
            "endOffset": 16632,
            "count": 0
          }
        ]
      },
      {
        "functionName": "defineKeyPropWarningGetter",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 16641,
            "endOffset": 17377,
            "count": 0
          }
        ]
      },
      {
        "functionName": "defineRefPropWarningGetter",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 17386,
            "endOffset": 18122,
            "count": 0
          }
        ]
      },
      {
        "functionName": "warnIfStringRefCannotBeAutoConverted",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 18131,
            "endOffset": 19016,
            "count": 0
          }
        ]
      },
      {
        "functionName": "ReactElement",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 19044,
            "endOffset": 20314,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createElement",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 20324,
            "endOffset": 22591,
            "count": 0
          }
        ]
      },
      {
        "functionName": "cloneAndReplaceKey",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 22600,
            "endOffset": 22845,
            "count": 0
          }
        ]
      },
      {
        "functionName": "cloneElement",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 22854,
            "endOffset": 24760,
            "count": 0
          }
        ]
      },
      {
        "functionName": "isValidElement",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 24769,
            "endOffset": 24918,
            "count": 0
          }
        ]
      },
      {
        "functionName": "escape",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 24988,
            "endOffset": 25313,
            "count": 0
          }
        ]
      },
      {
        "functionName": "escapeUserProvidedKey",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 25409,
            "endOffset": 25523,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getElementKey",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 25532,
            "endOffset": 25843,
            "count": 0
          }
        ]
      },
      {
        "functionName": "mapIntoArray",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 25852,
            "endOffset": 30075,
            "count": 0
          }
        ]
      },
      {
        "functionName": "mapChildren",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 30084,
            "endOffset": 30429,
            "count": 0
          }
        ]
      },
      {
        "functionName": "countChildren",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 30438,
            "endOffset": 30599,
            "count": 0
          }
        ]
      },
      {
        "functionName": "forEachChildren",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 30608,
            "endOffset": 30806,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toArray",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 30815,
            "endOffset": 30956,
            "count": 0
          }
        ]
      },
      {
        "functionName": "onlyChild",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 30965,
            "endOffset": 31189,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createContext",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 31198,
            "endOffset": 35341,
            "count": 9
          }
        ]
      },
      {
        "functionName": "get",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 32773,
            "endOffset": 33175,
            "count": 0
          }
        ]
      },
      {
        "functionName": "set",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 33198,
            "endOffset": 33285,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 33355,
            "endOffset": 33433,
            "count": 0
          }
        ]
      },
      {
        "functionName": "set",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 33456,
            "endOffset": 33556,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 33627,
            "endOffset": 33706,
            "count": 0
          }
        ]
      },
      {
        "functionName": "set",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 33729,
            "endOffset": 33832,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 33901,
            "endOffset": 33978,
            "count": 0
          }
        ]
      },
      {
        "functionName": "set",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 34001,
            "endOffset": 34098,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 34163,
            "endOffset": 34577,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 34645,
            "endOffset": 34721,
            "count": 0
          }
        ]
      },
      {
        "functionName": "set",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 34744,
            "endOffset": 35105,
            "count": 0
          }
        ]
      },
      {
        "functionName": "lazyInitializer",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 35459,
            "endOffset": 37254,
            "count": 0
          }
        ]
      },
      {
        "functionName": "lazy",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 37263,
            "endOffset": 39008,
            "count": 0
          }
        ]
      },
      {
        "functionName": "forwardRef",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 39017,
            "endOffset": 40721,
            "count": 2
          },
          {
            "startOffset": 39130,
            "endOffset": 39301,
            "count": 0
          },
          {
            "startOffset": 39341,
            "endOffset": 39478,
            "count": 0
          },
          {
            "startOffset": 39548,
            "endOffset": 39782,
            "count": 0
          },
          {
            "startOffset": 39906,
            "endOffset": 40064,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 40386,
            "endOffset": 40446,
            "count": 0
          }
        ]
      },
      {
        "functionName": "set",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 40467,
            "endOffset": 40653,
            "count": 0
          }
        ]
      },
      {
        "functionName": "isValidElementType",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 40859,
            "endOffset": 42047,
            "count": 0
          }
        ]
      },
      {
        "functionName": "memo",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 42056,
            "endOffset": 42972,
            "count": 0
          }
        ]
      },
      {
        "functionName": "resolveDispatcher",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 42981,
            "endOffset": 43642,
            "count": 88
          },
          {
            "startOffset": 43120,
            "endOffset": 43591,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useContext",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 43651,
            "endOffset": 44379,
            "count": 4
          },
          {
            "startOffset": 43787,
            "endOffset": 44308,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useState",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 44388,
            "endOffset": 44531,
            "count": 14
          }
        ]
      },
      {
        "functionName": "useReducer",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 44540,
            "endOffset": 44713,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useRef",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 44722,
            "endOffset": 44861,
            "count": 44
          }
        ]
      },
      {
        "functionName": "useEffect",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 44870,
            "endOffset": 45015,
            "count": 18
          }
        ]
      },
      {
        "functionName": "useInsertionEffect",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 45024,
            "endOffset": 45187,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useLayoutEffect",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 45196,
            "endOffset": 45353,
            "count": 4
          }
        ]
      },
      {
        "functionName": "useCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 45362,
            "endOffset": 45515,
            "count": 4
          }
        ]
      },
      {
        "functionName": "useMemo",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 45524,
            "endOffset": 45665,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useImperativeHandle",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 45674,
            "endOffset": 45849,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useDebugValue",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 45858,
            "endOffset": 46051,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useTransition",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 46060,
            "endOffset": 46189,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useDeferredValue",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 46198,
            "endOffset": 46343,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useId",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 46352,
            "endOffset": 46465,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useSyncExternalStore",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 46474,
            "endOffset": 46699,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disabledLog",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 46908,
            "endOffset": 46942,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disableLogs",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 46998,
            "endOffset": 47907,
            "count": 0
          }
        ]
      },
      {
        "functionName": "reenableLogs",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 47916,
            "endOffset": 49123,
            "count": 0
          }
        ]
      },
      {
        "functionName": "describeBuiltInComponentFrame",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 49236,
            "endOffset": 49636,
            "count": 0
          }
        ]
      },
      {
        "functionName": "describeNativeComponentFrame",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 49861,
            "endOffset": 53451,
            "count": 0
          }
        ]
      },
      {
        "functionName": "describeFunctionComponentFrame",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 53460,
            "endOffset": 53616,
            "count": 0
          }
        ]
      },
      {
        "functionName": "shouldConstruct",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 53625,
            "endOffset": 53783,
            "count": 0
          }
        ]
      },
      {
        "functionName": "describeUnknownElementTypeFrameInDEV",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 53792,
            "endOffset": 55187,
            "count": 0
          }
        ]
      },
      {
        "functionName": "setCurrentlyValidatingElement",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 55317,
            "endOffset": 55757,
            "count": 0
          }
        ]
      },
      {
        "functionName": "checkPropTypes",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 55766,
            "endOffset": 57814,
            "count": 0
          }
        ]
      },
      {
        "functionName": "setCurrentlyValidatingElement$1",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 57823,
            "endOffset": 58215,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getDeclarationErrorAddendum",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 58336,
            "endOffset": 58652,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getSourceInfoErrorAddendum",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 58661,
            "endOffset": 58983,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getSourceInfoErrorAddendumForProps",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 58992,
            "endOffset": 59230,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getCurrentComponentErrorInfo",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 59279,
            "endOffset": 59700,
            "count": 0
          }
        ]
      },
      {
        "functionName": "validateExplicitKey",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 59709,
            "endOffset": 60735,
            "count": 0
          }
        ]
      },
      {
        "functionName": "validateChildKeys",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 60744,
            "endOffset": 61769,
            "count": 0
          }
        ]
      },
      {
        "functionName": "validatePropTypes",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 61778,
            "endOffset": 63252,
            "count": 0
          }
        ]
      },
      {
        "functionName": "validateFragmentProps",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 63261,
            "endOffset": 64077,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createElementWithValidation",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 64086,
            "endOffset": 65996,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createFactoryWithValidation",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 66062,
            "endOffset": 67001,
            "count": 0
          }
        ]
      },
      {
        "functionName": "cloneElementWithValidation",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 67010,
            "endOffset": 67346,
            "count": 0
          }
        ]
      },
      {
        "functionName": "startTransition",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 67355,
            "endOffset": 68397,
            "count": 0
          }
        ]
      },
      {
        "functionName": "enqueueTask",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 68490,
            "endOffset": 69638,
            "count": 0
          }
        ]
      },
      {
        "functionName": "act",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 69717,
            "endOffset": 73250,
            "count": 0
          }
        ]
      },
      {
        "functionName": "popActScope",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 73259,
            "endOffset": 73607,
            "count": 0
          }
        ]
      },
      {
        "functionName": "recursivelyFlushAsyncActWork",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 73616,
            "endOffset": 74348,
            "count": 0
          }
        ]
      },
      {
        "functionName": "flushActQueue",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 74389,
            "endOffset": 75022,
            "count": 0
          }
        ]
      },
      {
        "functionName": "../../node_modules/.pnpm/react@18.2.0/node_modules/react/index.js",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 77338,
            "endOffset": 77545,
            "count": 1
          },
          {
            "startOffset": 77440,
            "endOffset": 77476,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5173/node_modules/.vite/deps/chunk-LNEMQRCO.js?v=a50bb159",
    "scriptId": "25",
    "source": "var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __commonJS = (cb, mod) => function __require() {\n  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  // If the importer is in node compatibility mode or this is not an ESM\n  // file that has been converted to a CommonJS file using a Babel-\n  // compatible transform (i.e. \"__esModule\" has not been set), then set\n  // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n  mod\n));\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\n\nexport {\n  __commonJS,\n  __toESM,\n  __publicField\n};\n//# sourceMappingURL=chunk-LNEMQRCO.js.map\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 1713,
            "count": 1
          }
        ]
      },
      {
        "functionName": "__defNormalProp",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 293,
            "endOffset": 430,
            "count": 0
          }
        ]
      },
      {
        "functionName": "__commonJS",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 449,
            "endOffset": 588,
            "count": 10
          }
        ]
      },
      {
        "functionName": "__require",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 462,
            "endOffset": 588,
            "count": 68
          },
          {
            "startOffset": 498,
            "endOffset": 572,
            "count": 10
          }
        ]
      },
      {
        "functionName": "__copyProps",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 608,
            "endOffset": 954,
            "count": 56
          },
          {
            "startOffset": 677,
            "endOffset": 706,
            "count": 0
          },
          {
            "startOffset": 761,
            "endOffset": 935,
            "count": 1960
          }
        ]
      },
      {
        "functionName": "get",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 846,
            "endOffset": 861,
            "count": 19
          }
        ]
      },
      {
        "functionName": "__toESM",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 970,
            "endOffset": 1479,
            "count": 56
          },
          {
            "startOffset": 1051,
            "endOffset": 1055,
            "count": 0
          },
          {
            "startOffset": 1369,
            "endOffset": 1376,
            "count": 1
          },
          {
            "startOffset": 1377,
            "endOffset": 1395,
            "count": 1
          },
          {
            "startOffset": 1461,
            "endOffset": 1469,
            "count": 0
          }
        ]
      },
      {
        "functionName": "__publicField",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1501,
            "endOffset": 1614,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5173/node_modules/.vite/deps/gsap.js?v=a50bb159",
    "scriptId": "26",
    "source": "import {\n  Back,\n  Bounce,\n  CSSPlugin,\n  Circ,\n  Cubic,\n  Elastic,\n  Expo,\n  Linear,\n  Power0,\n  Power1,\n  Power2,\n  Power3,\n  Power4,\n  Quad,\n  Quart,\n  Quint,\n  Sine,\n  SteppedEase,\n  Strong,\n  Timeline,\n  Tween,\n  TweenMaxWithCSS,\n  gsapWithCSS\n} from \"/node_modules/.vite/deps/chunk-HJ66XTML.js?v=a50bb159\";\nimport \"/node_modules/.vite/deps/chunk-LNEMQRCO.js?v=a50bb159\";\nexport {\n  Back,\n  Bounce,\n  CSSPlugin,\n  Circ,\n  Cubic,\n  Elastic,\n  Expo,\n  Linear,\n  Power0,\n  Power1,\n  Power2,\n  Power3,\n  Power4,\n  Quad,\n  Quart,\n  Quint,\n  Sine,\n  SteppedEase,\n  Strong,\n  Timeline as TimelineLite,\n  Timeline as TimelineMax,\n  Tween as TweenLite,\n  TweenMaxWithCSS as TweenMax,\n  gsapWithCSS as default,\n  gsapWithCSS as gsap\n};\n//# sourceMappingURL=gsap.js.map\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 764,
            "count": 1
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5173/node_modules/.vite/deps/gsap_ScrollTrigger.js?v=a50bb159",
    "scriptId": "27",
    "source": "import {\n  Observer,\n  _getProxyProp,\n  _getScrollFunc,\n  _getTarget,\n  _getVelocityProp,\n  _horizontal,\n  _proxies,\n  _scrollers,\n  _vertical\n} from \"/node_modules/.vite/deps/chunk-JIUMHI3X.js?v=a50bb159\";\nimport \"/node_modules/.vite/deps/chunk-LNEMQRCO.js?v=a50bb159\";\n\n// ../../node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/ScrollTrigger.js\nvar gsap;\nvar _coreInitted;\nvar _win;\nvar _doc;\nvar _docEl;\nvar _body;\nvar _root;\nvar _resizeDelay;\nvar _toArray;\nvar _clamp;\nvar _time2;\nvar _syncInterval;\nvar _refreshing;\nvar _pointerIsDown;\nvar _transformProp;\nvar _i;\nvar _prevWidth;\nvar _prevHeight;\nvar _autoRefresh;\nvar _sort;\nvar _suppressOverwrites;\nvar _ignoreResize;\nvar _normalizer;\nvar _ignoreMobileResize;\nvar _baseScreenHeight;\nvar _baseScreenWidth;\nvar _fixIOSBug;\nvar _context;\nvar _scrollRestoration;\nvar _div100vh;\nvar _100vh;\nvar _isReverted;\nvar _clampingMax;\nvar _limitCallbacks;\nvar _startup = 1;\nvar _getTime = Date.now;\nvar _time1 = _getTime();\nvar _lastScrollTime = 0;\nvar _enabled = 0;\nvar _parseClamp = function _parseClamp2(value, type, self) {\n  var clamp = _isString(value) && (value.substr(0, 6) === \"clamp(\" || value.indexOf(\"max\") > -1);\n  self[\"_\" + type + \"Clamp\"] = clamp;\n  return clamp ? value.substr(6, value.length - 7) : value;\n};\nvar _keepClamp = function _keepClamp2(value, clamp) {\n  return clamp && (!_isString(value) || value.substr(0, 6) !== \"clamp(\") ? \"clamp(\" + value + \")\" : value;\n};\nvar _rafBugFix = function _rafBugFix2() {\n  return _enabled && requestAnimationFrame(_rafBugFix2);\n};\nvar _pointerDownHandler = function _pointerDownHandler2() {\n  return _pointerIsDown = 1;\n};\nvar _pointerUpHandler = function _pointerUpHandler2() {\n  return _pointerIsDown = 0;\n};\nvar _passThrough = function _passThrough2(v) {\n  return v;\n};\nvar _round = function _round2(value) {\n  return Math.round(value * 1e5) / 1e5 || 0;\n};\nvar _windowExists = function _windowExists2() {\n  return typeof window !== \"undefined\";\n};\nvar _getGSAP = function _getGSAP2() {\n  return gsap || _windowExists() && (gsap = window.gsap) && gsap.registerPlugin && gsap;\n};\nvar _isViewport = function _isViewport2(e) {\n  return !!~_root.indexOf(e);\n};\nvar _getViewportDimension = function _getViewportDimension2(dimensionProperty) {\n  return (dimensionProperty === \"Height\" ? _100vh : _win[\"inner\" + dimensionProperty]) || _docEl[\"client\" + dimensionProperty] || _body[\"client\" + dimensionProperty];\n};\nvar _getBoundsFunc = function _getBoundsFunc2(element) {\n  return _getProxyProp(element, \"getBoundingClientRect\") || (_isViewport(element) ? function() {\n    _winOffsets.width = _win.innerWidth;\n    _winOffsets.height = _100vh;\n    return _winOffsets;\n  } : function() {\n    return _getBounds(element);\n  });\n};\nvar _getSizeFunc = function _getSizeFunc2(scroller, isViewport, _ref) {\n  var d = _ref.d, d2 = _ref.d2, a = _ref.a;\n  return (a = _getProxyProp(scroller, \"getBoundingClientRect\")) ? function() {\n    return a()[d];\n  } : function() {\n    return (isViewport ? _getViewportDimension(d2) : scroller[\"client\" + d2]) || 0;\n  };\n};\nvar _getOffsetsFunc = function _getOffsetsFunc2(element, isViewport) {\n  return !isViewport || ~_proxies.indexOf(element) ? _getBoundsFunc(element) : function() {\n    return _winOffsets;\n  };\n};\nvar _maxScroll = function _maxScroll2(element, _ref2) {\n  var s = _ref2.s, d2 = _ref2.d2, d = _ref2.d, a = _ref2.a;\n  return Math.max(0, (s = \"scroll\" + d2) && (a = _getProxyProp(element, s)) ? a() - _getBoundsFunc(element)()[d] : _isViewport(element) ? (_docEl[s] || _body[s]) - _getViewportDimension(d2) : element[s] - element[\"offset\" + d2]);\n};\nvar _iterateAutoRefresh = function _iterateAutoRefresh2(func, events) {\n  for (var i = 0; i < _autoRefresh.length; i += 3) {\n    (!events || ~events.indexOf(_autoRefresh[i + 1])) && func(_autoRefresh[i], _autoRefresh[i + 1], _autoRefresh[i + 2]);\n  }\n};\nvar _isString = function _isString2(value) {\n  return typeof value === \"string\";\n};\nvar _isFunction = function _isFunction2(value) {\n  return typeof value === \"function\";\n};\nvar _isNumber = function _isNumber2(value) {\n  return typeof value === \"number\";\n};\nvar _isObject = function _isObject2(value) {\n  return typeof value === \"object\";\n};\nvar _endAnimation = function _endAnimation2(animation, reversed, pause) {\n  return animation && animation.progress(reversed ? 0 : 1) && pause && animation.pause();\n};\nvar _callback = function _callback2(self, func) {\n  if (self.enabled) {\n    var result = self._ctx ? self._ctx.add(function() {\n      return func(self);\n    }) : func(self);\n    result && result.totalTime && (self.callbackAnimation = result);\n  }\n};\nvar _abs = Math.abs;\nvar _left = \"left\";\nvar _top = \"top\";\nvar _right = \"right\";\nvar _bottom = \"bottom\";\nvar _width = \"width\";\nvar _height = \"height\";\nvar _Right = \"Right\";\nvar _Left = \"Left\";\nvar _Top = \"Top\";\nvar _Bottom = \"Bottom\";\nvar _padding = \"padding\";\nvar _margin = \"margin\";\nvar _Width = \"Width\";\nvar _Height = \"Height\";\nvar _px = \"px\";\nvar _getComputedStyle = function _getComputedStyle2(element) {\n  return _win.getComputedStyle(element);\n};\nvar _makePositionable = function _makePositionable2(element) {\n  var position = _getComputedStyle(element).position;\n  element.style.position = position === \"absolute\" || position === \"fixed\" ? position : \"relative\";\n};\nvar _setDefaults = function _setDefaults2(obj, defaults) {\n  for (var p in defaults) {\n    p in obj || (obj[p] = defaults[p]);\n  }\n  return obj;\n};\nvar _getBounds = function _getBounds2(element, withoutTransforms) {\n  var tween = withoutTransforms && _getComputedStyle(element)[_transformProp] !== \"matrix(1, 0, 0, 1, 0, 0)\" && gsap.to(element, {\n    x: 0,\n    y: 0,\n    xPercent: 0,\n    yPercent: 0,\n    rotation: 0,\n    rotationX: 0,\n    rotationY: 0,\n    scale: 1,\n    skewX: 0,\n    skewY: 0\n  }).progress(1), bounds = element.getBoundingClientRect();\n  tween && tween.progress(0).kill();\n  return bounds;\n};\nvar _getSize = function _getSize2(element, _ref3) {\n  var d2 = _ref3.d2;\n  return element[\"offset\" + d2] || element[\"client\" + d2] || 0;\n};\nvar _getLabelRatioArray = function _getLabelRatioArray2(timeline) {\n  var a = [], labels = timeline.labels, duration = timeline.duration(), p;\n  for (p in labels) {\n    a.push(labels[p] / duration);\n  }\n  return a;\n};\nvar _getClosestLabel = function _getClosestLabel2(animation) {\n  return function(value) {\n    return gsap.utils.snap(_getLabelRatioArray(animation), value);\n  };\n};\nvar _snapDirectional = function _snapDirectional2(snapIncrementOrArray) {\n  var snap = gsap.utils.snap(snapIncrementOrArray), a = Array.isArray(snapIncrementOrArray) && snapIncrementOrArray.slice(0).sort(function(a2, b) {\n    return a2 - b;\n  });\n  return a ? function(value, direction, threshold) {\n    if (threshold === void 0) {\n      threshold = 1e-3;\n    }\n    var i;\n    if (!direction) {\n      return snap(value);\n    }\n    if (direction > 0) {\n      value -= threshold;\n      for (i = 0; i < a.length; i++) {\n        if (a[i] >= value) {\n          return a[i];\n        }\n      }\n      return a[i - 1];\n    } else {\n      i = a.length;\n      value += threshold;\n      while (i--) {\n        if (a[i] <= value) {\n          return a[i];\n        }\n      }\n    }\n    return a[0];\n  } : function(value, direction, threshold) {\n    if (threshold === void 0) {\n      threshold = 1e-3;\n    }\n    var snapped = snap(value);\n    return !direction || Math.abs(snapped - value) < threshold || snapped - value < 0 === direction < 0 ? snapped : snap(direction < 0 ? value - snapIncrementOrArray : value + snapIncrementOrArray);\n  };\n};\nvar _getLabelAtDirection = function _getLabelAtDirection2(timeline) {\n  return function(value, st) {\n    return _snapDirectional(_getLabelRatioArray(timeline))(value, st.direction);\n  };\n};\nvar _multiListener = function _multiListener2(func, element, types, callback) {\n  return types.split(\",\").forEach(function(type) {\n    return func(element, type, callback);\n  });\n};\nvar _addListener = function _addListener2(element, type, func, nonPassive, capture) {\n  return element.addEventListener(type, func, {\n    passive: !nonPassive,\n    capture: !!capture\n  });\n};\nvar _removeListener = function _removeListener2(element, type, func, capture) {\n  return element.removeEventListener(type, func, !!capture);\n};\nvar _wheelListener = function _wheelListener2(func, el, scrollFunc) {\n  scrollFunc = scrollFunc && scrollFunc.wheelHandler;\n  if (scrollFunc) {\n    func(el, \"wheel\", scrollFunc);\n    func(el, \"touchmove\", scrollFunc);\n  }\n};\nvar _markerDefaults = {\n  startColor: \"green\",\n  endColor: \"red\",\n  indent: 0,\n  fontSize: \"16px\",\n  fontWeight: \"normal\"\n};\nvar _defaults = {\n  toggleActions: \"play\",\n  anticipatePin: 0\n};\nvar _keywords = {\n  top: 0,\n  left: 0,\n  center: 0.5,\n  bottom: 1,\n  right: 1\n};\nvar _offsetToPx = function _offsetToPx2(value, size) {\n  if (_isString(value)) {\n    var eqIndex = value.indexOf(\"=\"), relative = ~eqIndex ? +(value.charAt(eqIndex - 1) + 1) * parseFloat(value.substr(eqIndex + 1)) : 0;\n    if (~eqIndex) {\n      value.indexOf(\"%\") > eqIndex && (relative *= size / 100);\n      value = value.substr(0, eqIndex - 1);\n    }\n    value = relative + (value in _keywords ? _keywords[value] * size : ~value.indexOf(\"%\") ? parseFloat(value) * size / 100 : parseFloat(value) || 0);\n  }\n  return value;\n};\nvar _createMarker = function _createMarker2(type, name, container, direction, _ref4, offset, matchWidthEl, containerAnimation) {\n  var startColor = _ref4.startColor, endColor = _ref4.endColor, fontSize = _ref4.fontSize, indent = _ref4.indent, fontWeight = _ref4.fontWeight;\n  var e = _doc.createElement(\"div\"), useFixedPosition = _isViewport(container) || _getProxyProp(container, \"pinType\") === \"fixed\", isScroller = type.indexOf(\"scroller\") !== -1, parent = useFixedPosition ? _body : container, isStart = type.indexOf(\"start\") !== -1, color = isStart ? startColor : endColor, css = \"border-color:\" + color + \";font-size:\" + fontSize + \";color:\" + color + \";font-weight:\" + fontWeight + \";pointer-events:none;white-space:nowrap;font-family:sans-serif,Arial;z-index:1000;padding:4px 8px;border-width:0;border-style:solid;\";\n  css += \"position:\" + ((isScroller || containerAnimation) && useFixedPosition ? \"fixed;\" : \"absolute;\");\n  (isScroller || containerAnimation || !useFixedPosition) && (css += (direction === _vertical ? _right : _bottom) + \":\" + (offset + parseFloat(indent)) + \"px;\");\n  matchWidthEl && (css += \"box-sizing:border-box;text-align:left;width:\" + matchWidthEl.offsetWidth + \"px;\");\n  e._isStart = isStart;\n  e.setAttribute(\"class\", \"gsap-marker-\" + type + (name ? \" marker-\" + name : \"\"));\n  e.style.cssText = css;\n  e.innerText = name || name === 0 ? type + \"-\" + name : type;\n  parent.children[0] ? parent.insertBefore(e, parent.children[0]) : parent.appendChild(e);\n  e._offset = e[\"offset\" + direction.op.d2];\n  _positionMarker(e, 0, direction, isStart);\n  return e;\n};\nvar _positionMarker = function _positionMarker2(marker, start, direction, flipped) {\n  var vars = {\n    display: \"block\"\n  }, side = direction[flipped ? \"os2\" : \"p2\"], oppositeSide = direction[flipped ? \"p2\" : \"os2\"];\n  marker._isFlipped = flipped;\n  vars[direction.a + \"Percent\"] = flipped ? -100 : 0;\n  vars[direction.a] = flipped ? \"1px\" : 0;\n  vars[\"border\" + side + _Width] = 1;\n  vars[\"border\" + oppositeSide + _Width] = 0;\n  vars[direction.p] = start + \"px\";\n  gsap.set(marker, vars);\n};\nvar _triggers = [];\nvar _ids = {};\nvar _rafID;\nvar _sync = function _sync2() {\n  return _getTime() - _lastScrollTime > 34 && (_rafID || (_rafID = requestAnimationFrame(_updateAll)));\n};\nvar _onScroll = function _onScroll2() {\n  if (!_normalizer || !_normalizer.isPressed || _normalizer.startX > _body.clientWidth) {\n    _scrollers.cache++;\n    if (_normalizer) {\n      _rafID || (_rafID = requestAnimationFrame(_updateAll));\n    } else {\n      _updateAll();\n    }\n    _lastScrollTime || _dispatch(\"scrollStart\");\n    _lastScrollTime = _getTime();\n  }\n};\nvar _setBaseDimensions = function _setBaseDimensions2() {\n  _baseScreenWidth = _win.innerWidth;\n  _baseScreenHeight = _win.innerHeight;\n};\nvar _onResize = function _onResize2() {\n  _scrollers.cache++;\n  !_refreshing && !_ignoreResize && !_doc.fullscreenElement && !_doc.webkitFullscreenElement && (!_ignoreMobileResize || _baseScreenWidth !== _win.innerWidth || Math.abs(_win.innerHeight - _baseScreenHeight) > _win.innerHeight * 0.25) && _resizeDelay.restart(true);\n};\nvar _listeners = {};\nvar _emptyArray = [];\nvar _softRefresh = function _softRefresh2() {\n  return _removeListener(ScrollTrigger, \"scrollEnd\", _softRefresh2) || _refreshAll(true);\n};\nvar _dispatch = function _dispatch2(type) {\n  return _listeners[type] && _listeners[type].map(function(f) {\n    return f();\n  }) || _emptyArray;\n};\nvar _savedStyles = [];\nvar _revertRecorded = function _revertRecorded2(media) {\n  for (var i = 0; i < _savedStyles.length; i += 5) {\n    if (!media || _savedStyles[i + 4] && _savedStyles[i + 4].query === media) {\n      _savedStyles[i].style.cssText = _savedStyles[i + 1];\n      _savedStyles[i].getBBox && _savedStyles[i].setAttribute(\"transform\", _savedStyles[i + 2] || \"\");\n      _savedStyles[i + 3].uncache = 1;\n    }\n  }\n};\nvar _revertAll = function _revertAll2(kill, media) {\n  var trigger;\n  for (_i = 0; _i < _triggers.length; _i++) {\n    trigger = _triggers[_i];\n    if (trigger && (!media || trigger._ctx === media)) {\n      if (kill) {\n        trigger.kill(1);\n      } else {\n        trigger.revert(true, true);\n      }\n    }\n  }\n  _isReverted = true;\n  media && _revertRecorded(media);\n  media || _dispatch(\"revert\");\n};\nvar _clearScrollMemory = function _clearScrollMemory2(scrollRestoration, force) {\n  _scrollers.cache++;\n  (force || !_refreshingAll) && _scrollers.forEach(function(obj) {\n    return _isFunction(obj) && obj.cacheID++ && (obj.rec = 0);\n  });\n  _isString(scrollRestoration) && (_win.history.scrollRestoration = _scrollRestoration = scrollRestoration);\n};\nvar _refreshingAll;\nvar _refreshID = 0;\nvar _queueRefreshID;\nvar _queueRefreshAll = function _queueRefreshAll2() {\n  if (_queueRefreshID !== _refreshID) {\n    var id = _queueRefreshID = _refreshID;\n    requestAnimationFrame(function() {\n      return id === _refreshID && _refreshAll(true);\n    });\n  }\n};\nvar _refresh100vh = function _refresh100vh2() {\n  _body.appendChild(_div100vh);\n  _100vh = !_normalizer && _div100vh.offsetHeight || _win.innerHeight;\n  _body.removeChild(_div100vh);\n};\nvar _hideAllMarkers = function _hideAllMarkers2(hide) {\n  return _toArray(\".gsap-marker-start, .gsap-marker-end, .gsap-marker-scroller-start, .gsap-marker-scroller-end\").forEach(function(el) {\n    return el.style.display = hide ? \"none\" : \"block\";\n  });\n};\nvar _refreshAll = function _refreshAll2(force, skipRevert) {\n  if (_lastScrollTime && !force && !_isReverted) {\n    _addListener(ScrollTrigger, \"scrollEnd\", _softRefresh);\n    return;\n  }\n  _refresh100vh();\n  _refreshingAll = ScrollTrigger.isRefreshing = true;\n  _scrollers.forEach(function(obj) {\n    return _isFunction(obj) && ++obj.cacheID && (obj.rec = obj());\n  });\n  var refreshInits = _dispatch(\"refreshInit\");\n  _sort && ScrollTrigger.sort();\n  skipRevert || _revertAll();\n  _scrollers.forEach(function(obj) {\n    if (_isFunction(obj)) {\n      obj.smooth && (obj.target.style.scrollBehavior = \"auto\");\n      obj(0);\n    }\n  });\n  _triggers.slice(0).forEach(function(t) {\n    return t.refresh();\n  });\n  _isReverted = false;\n  _triggers.forEach(function(t) {\n    if (t._subPinOffset && t.pin) {\n      var prop = t.vars.horizontal ? \"offsetWidth\" : \"offsetHeight\", original = t.pin[prop];\n      t.revert(true, 1);\n      t.adjustPinSpacing(t.pin[prop] - original);\n      t.refresh();\n    }\n  });\n  _clampingMax = 1;\n  _hideAllMarkers(true);\n  _triggers.forEach(function(t) {\n    var max = _maxScroll(t.scroller, t._dir), endClamp = t.vars.end === \"max\" || t._endClamp && t.end > max, startClamp = t._startClamp && t.start >= max;\n    (endClamp || startClamp) && t.setPositions(startClamp ? max - 1 : t.start, endClamp ? Math.max(startClamp ? max : t.start + 1, max) : t.end, true);\n  });\n  _hideAllMarkers(false);\n  _clampingMax = 0;\n  refreshInits.forEach(function(result) {\n    return result && result.render && result.render(-1);\n  });\n  _scrollers.forEach(function(obj) {\n    if (_isFunction(obj)) {\n      obj.smooth && requestAnimationFrame(function() {\n        return obj.target.style.scrollBehavior = \"smooth\";\n      });\n      obj.rec && obj(obj.rec);\n    }\n  });\n  _clearScrollMemory(_scrollRestoration, 1);\n  _resizeDelay.pause();\n  _refreshID++;\n  _refreshingAll = 2;\n  _updateAll(2);\n  _triggers.forEach(function(t) {\n    return _isFunction(t.vars.onRefresh) && t.vars.onRefresh(t);\n  });\n  _refreshingAll = ScrollTrigger.isRefreshing = false;\n  _dispatch(\"refresh\");\n};\nvar _lastScroll = 0;\nvar _direction = 1;\nvar _primary;\nvar _updateAll = function _updateAll2(force) {\n  if (force === 2 || !_refreshingAll && !_isReverted) {\n    ScrollTrigger.isUpdating = true;\n    _primary && _primary.update(0);\n    var l = _triggers.length, time = _getTime(), recordVelocity = time - _time1 >= 50, scroll = l && _triggers[0].scroll();\n    _direction = _lastScroll > scroll ? -1 : 1;\n    _refreshingAll || (_lastScroll = scroll);\n    if (recordVelocity) {\n      if (_lastScrollTime && !_pointerIsDown && time - _lastScrollTime > 200) {\n        _lastScrollTime = 0;\n        _dispatch(\"scrollEnd\");\n      }\n      _time2 = _time1;\n      _time1 = time;\n    }\n    if (_direction < 0) {\n      _i = l;\n      while (_i-- > 0) {\n        _triggers[_i] && _triggers[_i].update(0, recordVelocity);\n      }\n      _direction = 1;\n    } else {\n      for (_i = 0; _i < l; _i++) {\n        _triggers[_i] && _triggers[_i].update(0, recordVelocity);\n      }\n    }\n    ScrollTrigger.isUpdating = false;\n  }\n  _rafID = 0;\n};\nvar _propNamesToCopy = [_left, _top, _bottom, _right, _margin + _Bottom, _margin + _Right, _margin + _Top, _margin + _Left, \"display\", \"flexShrink\", \"float\", \"zIndex\", \"gridColumnStart\", \"gridColumnEnd\", \"gridRowStart\", \"gridRowEnd\", \"gridArea\", \"justifySelf\", \"alignSelf\", \"placeSelf\", \"order\"];\nvar _stateProps = _propNamesToCopy.concat([_width, _height, \"boxSizing\", \"max\" + _Width, \"max\" + _Height, \"position\", _margin, _padding, _padding + _Top, _padding + _Right, _padding + _Bottom, _padding + _Left]);\nvar _swapPinOut = function _swapPinOut2(pin, spacer, state) {\n  _setState(state);\n  var cache = pin._gsap;\n  if (cache.spacerIsNative) {\n    _setState(cache.spacerState);\n  } else if (pin._gsap.swappedIn) {\n    var parent = spacer.parentNode;\n    if (parent) {\n      parent.insertBefore(pin, spacer);\n      parent.removeChild(spacer);\n    }\n  }\n  pin._gsap.swappedIn = false;\n};\nvar _swapPinIn = function _swapPinIn2(pin, spacer, cs, spacerState) {\n  if (!pin._gsap.swappedIn) {\n    var i = _propNamesToCopy.length, spacerStyle = spacer.style, pinStyle = pin.style, p;\n    while (i--) {\n      p = _propNamesToCopy[i];\n      spacerStyle[p] = cs[p];\n    }\n    spacerStyle.position = cs.position === \"absolute\" ? \"absolute\" : \"relative\";\n    cs.display === \"inline\" && (spacerStyle.display = \"inline-block\");\n    pinStyle[_bottom] = pinStyle[_right] = \"auto\";\n    spacerStyle.flexBasis = cs.flexBasis || \"auto\";\n    spacerStyle.overflow = \"visible\";\n    spacerStyle.boxSizing = \"border-box\";\n    spacerStyle[_width] = _getSize(pin, _horizontal) + _px;\n    spacerStyle[_height] = _getSize(pin, _vertical) + _px;\n    spacerStyle[_padding] = pinStyle[_margin] = pinStyle[_top] = pinStyle[_left] = \"0\";\n    _setState(spacerState);\n    pinStyle[_width] = pinStyle[\"max\" + _Width] = cs[_width];\n    pinStyle[_height] = pinStyle[\"max\" + _Height] = cs[_height];\n    pinStyle[_padding] = cs[_padding];\n    if (pin.parentNode !== spacer) {\n      pin.parentNode.insertBefore(spacer, pin);\n      spacer.appendChild(pin);\n    }\n    pin._gsap.swappedIn = true;\n  }\n};\nvar _capsExp = /([A-Z])/g;\nvar _setState = function _setState2(state) {\n  if (state) {\n    var style = state.t.style, l = state.length, i = 0, p, value;\n    (state.t._gsap || gsap.core.getCache(state.t)).uncache = 1;\n    for (; i < l; i += 2) {\n      value = state[i + 1];\n      p = state[i];\n      if (value) {\n        style[p] = value;\n      } else if (style[p]) {\n        style.removeProperty(p.replace(_capsExp, \"-$1\").toLowerCase());\n      }\n    }\n  }\n};\nvar _getState = function _getState2(element) {\n  var l = _stateProps.length, style = element.style, state = [], i = 0;\n  for (; i < l; i++) {\n    state.push(_stateProps[i], style[_stateProps[i]]);\n  }\n  state.t = element;\n  return state;\n};\nvar _copyState = function _copyState2(state, override, omitOffsets) {\n  var result = [], l = state.length, i = omitOffsets ? 8 : 0, p;\n  for (; i < l; i += 2) {\n    p = state[i];\n    result.push(p, p in override ? override[p] : state[i + 1]);\n  }\n  result.t = state.t;\n  return result;\n};\nvar _winOffsets = {\n  left: 0,\n  top: 0\n};\nvar _parsePosition = function _parsePosition2(value, trigger, scrollerSize, direction, scroll, marker, markerScroller, self, scrollerBounds, borderWidth, useFixedPosition, scrollerMax, containerAnimation, clampZeroProp) {\n  _isFunction(value) && (value = value(self));\n  if (_isString(value) && value.substr(0, 3) === \"max\") {\n    value = scrollerMax + (value.charAt(4) === \"=\" ? _offsetToPx(\"0\" + value.substr(3), scrollerSize) : 0);\n  }\n  var time = containerAnimation ? containerAnimation.time() : 0, p1, p2, element;\n  containerAnimation && containerAnimation.seek(0);\n  isNaN(value) || (value = +value);\n  if (!_isNumber(value)) {\n    _isFunction(trigger) && (trigger = trigger(self));\n    var offsets = (value || \"0\").split(\" \"), bounds, localOffset, globalOffset, display;\n    element = _getTarget(trigger, self) || _body;\n    bounds = _getBounds(element) || {};\n    if ((!bounds || !bounds.left && !bounds.top) && _getComputedStyle(element).display === \"none\") {\n      display = element.style.display;\n      element.style.display = \"block\";\n      bounds = _getBounds(element);\n      display ? element.style.display = display : element.style.removeProperty(\"display\");\n    }\n    localOffset = _offsetToPx(offsets[0], bounds[direction.d]);\n    globalOffset = _offsetToPx(offsets[1] || \"0\", scrollerSize);\n    value = bounds[direction.p] - scrollerBounds[direction.p] - borderWidth + localOffset + scroll - globalOffset;\n    markerScroller && _positionMarker(markerScroller, globalOffset, direction, scrollerSize - globalOffset < 20 || markerScroller._isStart && globalOffset > 20);\n    scrollerSize -= scrollerSize - globalOffset;\n  } else {\n    containerAnimation && (value = gsap.utils.mapRange(containerAnimation.scrollTrigger.start, containerAnimation.scrollTrigger.end, 0, scrollerMax, value));\n    markerScroller && _positionMarker(markerScroller, scrollerSize, direction, true);\n  }\n  if (clampZeroProp) {\n    self[clampZeroProp] = value || -1e-3;\n    value < 0 && (value = 0);\n  }\n  if (marker) {\n    var position = value + scrollerSize, isStart = marker._isStart;\n    p1 = \"scroll\" + direction.d2;\n    _positionMarker(marker, position, direction, isStart && position > 20 || !isStart && (useFixedPosition ? Math.max(_body[p1], _docEl[p1]) : marker.parentNode[p1]) <= position + 1);\n    if (useFixedPosition) {\n      scrollerBounds = _getBounds(markerScroller);\n      useFixedPosition && (marker.style[direction.op.p] = scrollerBounds[direction.op.p] - direction.op.m - marker._offset + _px);\n    }\n  }\n  if (containerAnimation && element) {\n    p1 = _getBounds(element);\n    containerAnimation.seek(scrollerMax);\n    p2 = _getBounds(element);\n    containerAnimation._caScrollDist = p1[direction.p] - p2[direction.p];\n    value = value / containerAnimation._caScrollDist * scrollerMax;\n  }\n  containerAnimation && containerAnimation.seek(time);\n  return containerAnimation ? value : Math.round(value);\n};\nvar _prefixExp = /(webkit|moz|length|cssText|inset)/i;\nvar _reparent = function _reparent2(element, parent, top, left) {\n  if (element.parentNode !== parent) {\n    var style = element.style, p, cs;\n    if (parent === _body) {\n      element._stOrig = style.cssText;\n      cs = _getComputedStyle(element);\n      for (p in cs) {\n        if (!+p && !_prefixExp.test(p) && cs[p] && typeof style[p] === \"string\" && p !== \"0\") {\n          style[p] = cs[p];\n        }\n      }\n      style.top = top;\n      style.left = left;\n    } else {\n      style.cssText = element._stOrig;\n    }\n    gsap.core.getCache(element).uncache = 1;\n    parent.appendChild(element);\n  }\n};\nvar _interruptionTracker = function _interruptionTracker2(getValueFunc, initialValue, onInterrupt) {\n  var last1 = initialValue, last2 = last1;\n  return function(value) {\n    var current = Math.round(getValueFunc());\n    if (current !== last1 && current !== last2 && Math.abs(current - last1) > 3 && Math.abs(current - last2) > 3) {\n      value = current;\n      onInterrupt && onInterrupt();\n    }\n    last2 = last1;\n    last1 = value;\n    return value;\n  };\n};\nvar _shiftMarker = function _shiftMarker2(marker, direction, value) {\n  var vars = {};\n  vars[direction.p] = \"+=\" + value;\n  gsap.set(marker, vars);\n};\nvar _getTweenCreator = function _getTweenCreator2(scroller, direction) {\n  var getScroll = _getScrollFunc(scroller, direction), prop = \"_scroll\" + direction.p2, getTween = function getTween2(scrollTo, vars, initialValue, change1, change2) {\n    var tween = getTween2.tween, onComplete = vars.onComplete, modifiers = {};\n    initialValue = initialValue || getScroll();\n    var checkForInterruption = _interruptionTracker(getScroll, initialValue, function() {\n      tween.kill();\n      getTween2.tween = 0;\n    });\n    change2 = change1 && change2 || 0;\n    change1 = change1 || scrollTo - initialValue;\n    tween && tween.kill();\n    vars[prop] = scrollTo;\n    vars.inherit = false;\n    vars.modifiers = modifiers;\n    modifiers[prop] = function() {\n      return checkForInterruption(initialValue + change1 * tween.ratio + change2 * tween.ratio * tween.ratio);\n    };\n    vars.onUpdate = function() {\n      _scrollers.cache++;\n      getTween2.tween && _updateAll();\n    };\n    vars.onComplete = function() {\n      getTween2.tween = 0;\n      onComplete && onComplete.call(tween);\n    };\n    tween = getTween2.tween = gsap.to(scroller, vars);\n    return tween;\n  };\n  scroller[prop] = getScroll;\n  getScroll.wheelHandler = function() {\n    return getTween.tween && getTween.tween.kill() && (getTween.tween = 0);\n  };\n  _addListener(scroller, \"wheel\", getScroll.wheelHandler);\n  ScrollTrigger.isTouch && _addListener(scroller, \"touchmove\", getScroll.wheelHandler);\n  return getTween;\n};\nvar ScrollTrigger = function() {\n  function ScrollTrigger2(vars, animation) {\n    _coreInitted || ScrollTrigger2.register(gsap) || console.warn(\"Please gsap.registerPlugin(ScrollTrigger)\");\n    _context(this);\n    this.init(vars, animation);\n  }\n  var _proto = ScrollTrigger2.prototype;\n  _proto.init = function init(vars, animation) {\n    this.progress = this.start = 0;\n    this.vars && this.kill(true, true);\n    if (!_enabled) {\n      this.update = this.refresh = this.kill = _passThrough;\n      return;\n    }\n    vars = _setDefaults(_isString(vars) || _isNumber(vars) || vars.nodeType ? {\n      trigger: vars\n    } : vars, _defaults);\n    var _vars = vars, onUpdate = _vars.onUpdate, toggleClass = _vars.toggleClass, id = _vars.id, onToggle = _vars.onToggle, onRefresh = _vars.onRefresh, scrub = _vars.scrub, trigger = _vars.trigger, pin = _vars.pin, pinSpacing = _vars.pinSpacing, invalidateOnRefresh = _vars.invalidateOnRefresh, anticipatePin = _vars.anticipatePin, onScrubComplete = _vars.onScrubComplete, onSnapComplete = _vars.onSnapComplete, once = _vars.once, snap = _vars.snap, pinReparent = _vars.pinReparent, pinSpacer = _vars.pinSpacer, containerAnimation = _vars.containerAnimation, fastScrollEnd = _vars.fastScrollEnd, preventOverlaps = _vars.preventOverlaps, direction = vars.horizontal || vars.containerAnimation && vars.horizontal !== false ? _horizontal : _vertical, isToggle = !scrub && scrub !== 0, scroller = _getTarget(vars.scroller || _win), scrollerCache = gsap.core.getCache(scroller), isViewport = _isViewport(scroller), useFixedPosition = (\"pinType\" in vars ? vars.pinType : _getProxyProp(scroller, \"pinType\") || isViewport && \"fixed\") === \"fixed\", callbacks = [vars.onEnter, vars.onLeave, vars.onEnterBack, vars.onLeaveBack], toggleActions = isToggle && vars.toggleActions.split(\" \"), markers = \"markers\" in vars ? vars.markers : _defaults.markers, borderWidth = isViewport ? 0 : parseFloat(_getComputedStyle(scroller)[\"border\" + direction.p2 + _Width]) || 0, self = this, onRefreshInit = vars.onRefreshInit && function() {\n      return vars.onRefreshInit(self);\n    }, getScrollerSize = _getSizeFunc(scroller, isViewport, direction), getScrollerOffsets = _getOffsetsFunc(scroller, isViewport), lastSnap = 0, lastRefresh = 0, prevProgress = 0, scrollFunc = _getScrollFunc(scroller, direction), tweenTo, pinCache, snapFunc, scroll1, scroll2, start, end, markerStart, markerEnd, markerStartTrigger, markerEndTrigger, markerVars, executingOnRefresh, change, pinOriginalState, pinActiveState, pinState, spacer, offset, pinGetter, pinSetter, pinStart, pinChange, spacingStart, spacerState, markerStartSetter, pinMoves, markerEndSetter, cs, snap1, snap2, scrubTween, scrubSmooth, snapDurClamp, snapDelayedCall, prevScroll, prevAnimProgress, caMarkerSetter, customRevertReturn;\n    self._startClamp = self._endClamp = false;\n    self._dir = direction;\n    anticipatePin *= 45;\n    self.scroller = scroller;\n    self.scroll = containerAnimation ? containerAnimation.time.bind(containerAnimation) : scrollFunc;\n    scroll1 = scrollFunc();\n    self.vars = vars;\n    animation = animation || vars.animation;\n    if (\"refreshPriority\" in vars) {\n      _sort = 1;\n      vars.refreshPriority === -9999 && (_primary = self);\n    }\n    scrollerCache.tweenScroll = scrollerCache.tweenScroll || {\n      top: _getTweenCreator(scroller, _vertical),\n      left: _getTweenCreator(scroller, _horizontal)\n    };\n    self.tweenTo = tweenTo = scrollerCache.tweenScroll[direction.p];\n    self.scrubDuration = function(value) {\n      scrubSmooth = _isNumber(value) && value;\n      if (!scrubSmooth) {\n        scrubTween && scrubTween.progress(1).kill();\n        scrubTween = 0;\n      } else {\n        scrubTween ? scrubTween.duration(value) : scrubTween = gsap.to(animation, {\n          ease: \"expo\",\n          totalProgress: \"+=0\",\n          inherit: false,\n          duration: scrubSmooth,\n          paused: true,\n          onComplete: function onComplete() {\n            return onScrubComplete && onScrubComplete(self);\n          }\n        });\n      }\n    };\n    if (animation) {\n      animation.vars.lazy = false;\n      animation._initted && !self.isReverted || animation.vars.immediateRender !== false && vars.immediateRender !== false && animation.duration() && animation.render(0, true, true);\n      self.animation = animation.pause();\n      animation.scrollTrigger = self;\n      self.scrubDuration(scrub);\n      snap1 = 0;\n      id || (id = animation.vars.id);\n    }\n    if (snap) {\n      if (!_isObject(snap) || snap.push) {\n        snap = {\n          snapTo: snap\n        };\n      }\n      \"scrollBehavior\" in _body.style && gsap.set(isViewport ? [_body, _docEl] : scroller, {\n        scrollBehavior: \"auto\"\n      });\n      _scrollers.forEach(function(o) {\n        return _isFunction(o) && o.target === (isViewport ? _doc.scrollingElement || _docEl : scroller) && (o.smooth = false);\n      });\n      snapFunc = _isFunction(snap.snapTo) ? snap.snapTo : snap.snapTo === \"labels\" ? _getClosestLabel(animation) : snap.snapTo === \"labelsDirectional\" ? _getLabelAtDirection(animation) : snap.directional !== false ? function(value, st) {\n        return _snapDirectional(snap.snapTo)(value, _getTime() - lastRefresh < 500 ? 0 : st.direction);\n      } : gsap.utils.snap(snap.snapTo);\n      snapDurClamp = snap.duration || {\n        min: 0.1,\n        max: 2\n      };\n      snapDurClamp = _isObject(snapDurClamp) ? _clamp(snapDurClamp.min, snapDurClamp.max) : _clamp(snapDurClamp, snapDurClamp);\n      snapDelayedCall = gsap.delayedCall(snap.delay || scrubSmooth / 2 || 0.1, function() {\n        var scroll = scrollFunc(), refreshedRecently = _getTime() - lastRefresh < 500, tween = tweenTo.tween;\n        if ((refreshedRecently || Math.abs(self.getVelocity()) < 10) && !tween && !_pointerIsDown && lastSnap !== scroll) {\n          var progress = (scroll - start) / change, totalProgress = animation && !isToggle ? animation.totalProgress() : progress, velocity = refreshedRecently ? 0 : (totalProgress - snap2) / (_getTime() - _time2) * 1e3 || 0, change1 = gsap.utils.clamp(-progress, 1 - progress, _abs(velocity / 2) * velocity / 0.185), naturalEnd = progress + (snap.inertia === false ? 0 : change1), endValue, endScroll, _snap = snap, onStart = _snap.onStart, _onInterrupt = _snap.onInterrupt, _onComplete = _snap.onComplete;\n          endValue = snapFunc(naturalEnd, self);\n          _isNumber(endValue) || (endValue = naturalEnd);\n          endScroll = Math.round(start + endValue * change);\n          if (scroll <= end && scroll >= start && endScroll !== scroll) {\n            if (tween && !tween._initted && tween.data <= _abs(endScroll - scroll)) {\n              return;\n            }\n            if (snap.inertia === false) {\n              change1 = endValue - progress;\n            }\n            tweenTo(endScroll, {\n              duration: snapDurClamp(_abs(Math.max(_abs(naturalEnd - totalProgress), _abs(endValue - totalProgress)) * 0.185 / velocity / 0.05 || 0)),\n              ease: snap.ease || \"power3\",\n              data: _abs(endScroll - scroll),\n              // record the distance so that if another snap tween occurs (conflict) we can prioritize the closest snap.\n              onInterrupt: function onInterrupt() {\n                return snapDelayedCall.restart(true) && _onInterrupt && _onInterrupt(self);\n              },\n              onComplete: function onComplete() {\n                self.update();\n                lastSnap = scrollFunc();\n                if (animation) {\n                  scrubTween ? scrubTween.resetTo(\"totalProgress\", endValue, animation._tTime / animation._tDur) : animation.progress(endValue);\n                }\n                snap1 = snap2 = animation && !isToggle ? animation.totalProgress() : self.progress;\n                onSnapComplete && onSnapComplete(self);\n                _onComplete && _onComplete(self);\n              }\n            }, scroll, change1 * change, endScroll - scroll - change1 * change);\n            onStart && onStart(self, tweenTo.tween);\n          }\n        } else if (self.isActive && lastSnap !== scroll) {\n          snapDelayedCall.restart(true);\n        }\n      }).pause();\n    }\n    id && (_ids[id] = self);\n    trigger = self.trigger = _getTarget(trigger || pin !== true && pin);\n    customRevertReturn = trigger && trigger._gsap && trigger._gsap.stRevert;\n    customRevertReturn && (customRevertReturn = customRevertReturn(self));\n    pin = pin === true ? trigger : _getTarget(pin);\n    _isString(toggleClass) && (toggleClass = {\n      targets: trigger,\n      className: toggleClass\n    });\n    if (pin) {\n      pinSpacing === false || pinSpacing === _margin || (pinSpacing = !pinSpacing && pin.parentNode && pin.parentNode.style && _getComputedStyle(pin.parentNode).display === \"flex\" ? false : _padding);\n      self.pin = pin;\n      pinCache = gsap.core.getCache(pin);\n      if (!pinCache.spacer) {\n        if (pinSpacer) {\n          pinSpacer = _getTarget(pinSpacer);\n          pinSpacer && !pinSpacer.nodeType && (pinSpacer = pinSpacer.current || pinSpacer.nativeElement);\n          pinCache.spacerIsNative = !!pinSpacer;\n          pinSpacer && (pinCache.spacerState = _getState(pinSpacer));\n        }\n        pinCache.spacer = spacer = pinSpacer || _doc.createElement(\"div\");\n        spacer.classList.add(\"pin-spacer\");\n        id && spacer.classList.add(\"pin-spacer-\" + id);\n        pinCache.pinState = pinOriginalState = _getState(pin);\n      } else {\n        pinOriginalState = pinCache.pinState;\n      }\n      vars.force3D !== false && gsap.set(pin, {\n        force3D: true\n      });\n      self.spacer = spacer = pinCache.spacer;\n      cs = _getComputedStyle(pin);\n      spacingStart = cs[pinSpacing + direction.os2];\n      pinGetter = gsap.getProperty(pin);\n      pinSetter = gsap.quickSetter(pin, direction.a, _px);\n      _swapPinIn(pin, spacer, cs);\n      pinState = _getState(pin);\n    }\n    if (markers) {\n      markerVars = _isObject(markers) ? _setDefaults(markers, _markerDefaults) : _markerDefaults;\n      markerStartTrigger = _createMarker(\"scroller-start\", id, scroller, direction, markerVars, 0);\n      markerEndTrigger = _createMarker(\"scroller-end\", id, scroller, direction, markerVars, 0, markerStartTrigger);\n      offset = markerStartTrigger[\"offset\" + direction.op.d2];\n      var content = _getTarget(_getProxyProp(scroller, \"content\") || scroller);\n      markerStart = this.markerStart = _createMarker(\"start\", id, content, direction, markerVars, offset, 0, containerAnimation);\n      markerEnd = this.markerEnd = _createMarker(\"end\", id, content, direction, markerVars, offset, 0, containerAnimation);\n      containerAnimation && (caMarkerSetter = gsap.quickSetter([markerStart, markerEnd], direction.a, _px));\n      if (!useFixedPosition && !(_proxies.length && _getProxyProp(scroller, \"fixedMarkers\") === true)) {\n        _makePositionable(isViewport ? _body : scroller);\n        gsap.set([markerStartTrigger, markerEndTrigger], {\n          force3D: true\n        });\n        markerStartSetter = gsap.quickSetter(markerStartTrigger, direction.a, _px);\n        markerEndSetter = gsap.quickSetter(markerEndTrigger, direction.a, _px);\n      }\n    }\n    if (containerAnimation) {\n      var oldOnUpdate = containerAnimation.vars.onUpdate, oldParams = containerAnimation.vars.onUpdateParams;\n      containerAnimation.eventCallback(\"onUpdate\", function() {\n        self.update(0, 0, 1);\n        oldOnUpdate && oldOnUpdate.apply(containerAnimation, oldParams || []);\n      });\n    }\n    self.previous = function() {\n      return _triggers[_triggers.indexOf(self) - 1];\n    };\n    self.next = function() {\n      return _triggers[_triggers.indexOf(self) + 1];\n    };\n    self.revert = function(revert, temp) {\n      if (!temp) {\n        return self.kill(true);\n      }\n      var r = revert !== false || !self.enabled, prevRefreshing = _refreshing;\n      if (r !== self.isReverted) {\n        if (r) {\n          prevScroll = Math.max(scrollFunc(), self.scroll.rec || 0);\n          prevProgress = self.progress;\n          prevAnimProgress = animation && animation.progress();\n        }\n        markerStart && [markerStart, markerEnd, markerStartTrigger, markerEndTrigger].forEach(function(m) {\n          return m.style.display = r ? \"none\" : \"block\";\n        });\n        if (r) {\n          _refreshing = self;\n          self.update(r);\n        }\n        if (pin && (!pinReparent || !self.isActive)) {\n          if (r) {\n            _swapPinOut(pin, spacer, pinOriginalState);\n          } else {\n            _swapPinIn(pin, spacer, _getComputedStyle(pin), spacerState);\n          }\n        }\n        r || self.update(r);\n        _refreshing = prevRefreshing;\n        self.isReverted = r;\n      }\n    };\n    self.refresh = function(soft, force, position, pinOffset) {\n      if ((_refreshing || !self.enabled) && !force) {\n        return;\n      }\n      if (pin && soft && _lastScrollTime) {\n        _addListener(ScrollTrigger2, \"scrollEnd\", _softRefresh);\n        return;\n      }\n      !_refreshingAll && onRefreshInit && onRefreshInit(self);\n      _refreshing = self;\n      if (tweenTo.tween && !position) {\n        tweenTo.tween.kill();\n        tweenTo.tween = 0;\n      }\n      scrubTween && scrubTween.pause();\n      invalidateOnRefresh && animation && animation.revert({\n        kill: false\n      }).invalidate();\n      self.isReverted || self.revert(true, true);\n      self._subPinOffset = false;\n      var size = getScrollerSize(), scrollerBounds = getScrollerOffsets(), max = containerAnimation ? containerAnimation.duration() : _maxScroll(scroller, direction), isFirstRefresh = change <= 0.01, offset2 = 0, otherPinOffset = pinOffset || 0, parsedEnd = _isObject(position) ? position.end : vars.end, parsedEndTrigger = vars.endTrigger || trigger, parsedStart = _isObject(position) ? position.start : vars.start || (vars.start === 0 || !trigger ? 0 : pin ? \"0 0\" : \"0 100%\"), pinnedContainer = self.pinnedContainer = vars.pinnedContainer && _getTarget(vars.pinnedContainer, self), triggerIndex = trigger && Math.max(0, _triggers.indexOf(self)) || 0, i = triggerIndex, cs2, bounds, scroll, isVertical, override, curTrigger, curPin, oppositeScroll, initted, revertedPins, forcedOverflow, markerStartOffset, markerEndOffset;\n      if (markers && _isObject(position)) {\n        markerStartOffset = gsap.getProperty(markerStartTrigger, direction.p);\n        markerEndOffset = gsap.getProperty(markerEndTrigger, direction.p);\n      }\n      while (i--) {\n        curTrigger = _triggers[i];\n        curTrigger.end || curTrigger.refresh(0, 1) || (_refreshing = self);\n        curPin = curTrigger.pin;\n        if (curPin && (curPin === trigger || curPin === pin || curPin === pinnedContainer) && !curTrigger.isReverted) {\n          revertedPins || (revertedPins = []);\n          revertedPins.unshift(curTrigger);\n          curTrigger.revert(true, true);\n        }\n        if (curTrigger !== _triggers[i]) {\n          triggerIndex--;\n          i--;\n        }\n      }\n      _isFunction(parsedStart) && (parsedStart = parsedStart(self));\n      parsedStart = _parseClamp(parsedStart, \"start\", self);\n      start = _parsePosition(parsedStart, trigger, size, direction, scrollFunc(), markerStart, markerStartTrigger, self, scrollerBounds, borderWidth, useFixedPosition, max, containerAnimation, self._startClamp && \"_startClamp\") || (pin ? -1e-3 : 0);\n      _isFunction(parsedEnd) && (parsedEnd = parsedEnd(self));\n      if (_isString(parsedEnd) && !parsedEnd.indexOf(\"+=\")) {\n        if (~parsedEnd.indexOf(\" \")) {\n          parsedEnd = (_isString(parsedStart) ? parsedStart.split(\" \")[0] : \"\") + parsedEnd;\n        } else {\n          offset2 = _offsetToPx(parsedEnd.substr(2), size);\n          parsedEnd = _isString(parsedStart) ? parsedStart : (containerAnimation ? gsap.utils.mapRange(0, containerAnimation.duration(), containerAnimation.scrollTrigger.start, containerAnimation.scrollTrigger.end, start) : start) + offset2;\n          parsedEndTrigger = trigger;\n        }\n      }\n      parsedEnd = _parseClamp(parsedEnd, \"end\", self);\n      end = Math.max(start, _parsePosition(parsedEnd || (parsedEndTrigger ? \"100% 0\" : max), parsedEndTrigger, size, direction, scrollFunc() + offset2, markerEnd, markerEndTrigger, self, scrollerBounds, borderWidth, useFixedPosition, max, containerAnimation, self._endClamp && \"_endClamp\")) || -1e-3;\n      offset2 = 0;\n      i = triggerIndex;\n      while (i--) {\n        curTrigger = _triggers[i];\n        curPin = curTrigger.pin;\n        if (curPin && curTrigger.start - curTrigger._pinPush <= start && !containerAnimation && curTrigger.end > 0) {\n          cs2 = curTrigger.end - (self._startClamp ? Math.max(0, curTrigger.start) : curTrigger.start);\n          if ((curPin === trigger && curTrigger.start - curTrigger._pinPush < start || curPin === pinnedContainer) && isNaN(parsedStart)) {\n            offset2 += cs2 * (1 - curTrigger.progress);\n          }\n          curPin === pin && (otherPinOffset += cs2);\n        }\n      }\n      start += offset2;\n      end += offset2;\n      self._startClamp && (self._startClamp += offset2);\n      if (self._endClamp && !_refreshingAll) {\n        self._endClamp = end || -1e-3;\n        end = Math.min(end, _maxScroll(scroller, direction));\n      }\n      change = end - start || (start -= 0.01) && 1e-3;\n      if (isFirstRefresh) {\n        prevProgress = gsap.utils.clamp(0, 1, gsap.utils.normalize(start, end, prevScroll));\n      }\n      self._pinPush = otherPinOffset;\n      if (markerStart && offset2) {\n        cs2 = {};\n        cs2[direction.a] = \"+=\" + offset2;\n        pinnedContainer && (cs2[direction.p] = \"-=\" + scrollFunc());\n        gsap.set([markerStart, markerEnd], cs2);\n      }\n      if (pin && !(_clampingMax && self.end >= _maxScroll(scroller, direction))) {\n        cs2 = _getComputedStyle(pin);\n        isVertical = direction === _vertical;\n        scroll = scrollFunc();\n        pinStart = parseFloat(pinGetter(direction.a)) + otherPinOffset;\n        if (!max && end > 1) {\n          forcedOverflow = (isViewport ? _doc.scrollingElement || _docEl : scroller).style;\n          forcedOverflow = {\n            style: forcedOverflow,\n            value: forcedOverflow[\"overflow\" + direction.a.toUpperCase()]\n          };\n          if (isViewport && _getComputedStyle(_body)[\"overflow\" + direction.a.toUpperCase()] !== \"scroll\") {\n            forcedOverflow.style[\"overflow\" + direction.a.toUpperCase()] = \"scroll\";\n          }\n        }\n        _swapPinIn(pin, spacer, cs2);\n        pinState = _getState(pin);\n        bounds = _getBounds(pin, true);\n        oppositeScroll = useFixedPosition && _getScrollFunc(scroller, isVertical ? _horizontal : _vertical)();\n        if (pinSpacing) {\n          spacerState = [pinSpacing + direction.os2, change + otherPinOffset + _px];\n          spacerState.t = spacer;\n          i = pinSpacing === _padding ? _getSize(pin, direction) + change + otherPinOffset : 0;\n          if (i) {\n            spacerState.push(direction.d, i + _px);\n            spacer.style.flexBasis !== \"auto\" && (spacer.style.flexBasis = i + _px);\n          }\n          _setState(spacerState);\n          if (pinnedContainer) {\n            _triggers.forEach(function(t) {\n              if (t.pin === pinnedContainer && t.vars.pinSpacing !== false) {\n                t._subPinOffset = true;\n              }\n            });\n          }\n          useFixedPosition && scrollFunc(prevScroll);\n        } else {\n          i = _getSize(pin, direction);\n          i && spacer.style.flexBasis !== \"auto\" && (spacer.style.flexBasis = i + _px);\n        }\n        if (useFixedPosition) {\n          override = {\n            top: bounds.top + (isVertical ? scroll - start : oppositeScroll) + _px,\n            left: bounds.left + (isVertical ? oppositeScroll : scroll - start) + _px,\n            boxSizing: \"border-box\",\n            position: \"fixed\"\n          };\n          override[_width] = override[\"max\" + _Width] = Math.ceil(bounds.width) + _px;\n          override[_height] = override[\"max\" + _Height] = Math.ceil(bounds.height) + _px;\n          override[_margin] = override[_margin + _Top] = override[_margin + _Right] = override[_margin + _Bottom] = override[_margin + _Left] = \"0\";\n          override[_padding] = cs2[_padding];\n          override[_padding + _Top] = cs2[_padding + _Top];\n          override[_padding + _Right] = cs2[_padding + _Right];\n          override[_padding + _Bottom] = cs2[_padding + _Bottom];\n          override[_padding + _Left] = cs2[_padding + _Left];\n          pinActiveState = _copyState(pinOriginalState, override, pinReparent);\n          _refreshingAll && scrollFunc(0);\n        }\n        if (animation) {\n          initted = animation._initted;\n          _suppressOverwrites(1);\n          animation.render(animation.duration(), true, true);\n          pinChange = pinGetter(direction.a) - pinStart + change + otherPinOffset;\n          pinMoves = Math.abs(change - pinChange) > 1;\n          useFixedPosition && pinMoves && pinActiveState.splice(pinActiveState.length - 2, 2);\n          animation.render(0, true, true);\n          initted || animation.invalidate(true);\n          animation.parent || animation.totalTime(animation.totalTime());\n          _suppressOverwrites(0);\n        } else {\n          pinChange = change;\n        }\n        forcedOverflow && (forcedOverflow.value ? forcedOverflow.style[\"overflow\" + direction.a.toUpperCase()] = forcedOverflow.value : forcedOverflow.style.removeProperty(\"overflow-\" + direction.a));\n      } else if (trigger && scrollFunc() && !containerAnimation) {\n        bounds = trigger.parentNode;\n        while (bounds && bounds !== _body) {\n          if (bounds._pinOffset) {\n            start -= bounds._pinOffset;\n            end -= bounds._pinOffset;\n          }\n          bounds = bounds.parentNode;\n        }\n      }\n      revertedPins && revertedPins.forEach(function(t) {\n        return t.revert(false, true);\n      });\n      self.start = start;\n      self.end = end;\n      scroll1 = scroll2 = _refreshingAll ? prevScroll : scrollFunc();\n      if (!containerAnimation && !_refreshingAll) {\n        scroll1 < prevScroll && scrollFunc(prevScroll);\n        self.scroll.rec = 0;\n      }\n      self.revert(false, true);\n      lastRefresh = _getTime();\n      if (snapDelayedCall) {\n        lastSnap = -1;\n        snapDelayedCall.restart(true);\n      }\n      _refreshing = 0;\n      animation && isToggle && (animation._initted || prevAnimProgress) && animation.progress() !== prevAnimProgress && animation.progress(prevAnimProgress || 0, true).render(animation.time(), true, true);\n      if (isFirstRefresh || prevProgress !== self.progress || containerAnimation || invalidateOnRefresh) {\n        animation && !isToggle && animation.totalProgress(containerAnimation && start < -1e-3 && !prevProgress ? gsap.utils.normalize(start, end, 0) : prevProgress, true);\n        self.progress = isFirstRefresh || (scroll1 - start) / change === prevProgress ? 0 : prevProgress;\n      }\n      pin && pinSpacing && (spacer._pinOffset = Math.round(self.progress * pinChange));\n      scrubTween && scrubTween.invalidate();\n      if (!isNaN(markerStartOffset)) {\n        markerStartOffset -= gsap.getProperty(markerStartTrigger, direction.p);\n        markerEndOffset -= gsap.getProperty(markerEndTrigger, direction.p);\n        _shiftMarker(markerStartTrigger, direction, markerStartOffset);\n        _shiftMarker(markerStart, direction, markerStartOffset - (pinOffset || 0));\n        _shiftMarker(markerEndTrigger, direction, markerEndOffset);\n        _shiftMarker(markerEnd, direction, markerEndOffset - (pinOffset || 0));\n      }\n      isFirstRefresh && !_refreshingAll && self.update();\n      if (onRefresh && !_refreshingAll && !executingOnRefresh) {\n        executingOnRefresh = true;\n        onRefresh(self);\n        executingOnRefresh = false;\n      }\n    };\n    self.getVelocity = function() {\n      return (scrollFunc() - scroll2) / (_getTime() - _time2) * 1e3 || 0;\n    };\n    self.endAnimation = function() {\n      _endAnimation(self.callbackAnimation);\n      if (animation) {\n        scrubTween ? scrubTween.progress(1) : !animation.paused() ? _endAnimation(animation, animation.reversed()) : isToggle || _endAnimation(animation, self.direction < 0, 1);\n      }\n    };\n    self.labelToScroll = function(label) {\n      return animation && animation.labels && (start || self.refresh() || start) + animation.labels[label] / animation.duration() * change || 0;\n    };\n    self.getTrailing = function(name) {\n      var i = _triggers.indexOf(self), a = self.direction > 0 ? _triggers.slice(0, i).reverse() : _triggers.slice(i + 1);\n      return (_isString(name) ? a.filter(function(t) {\n        return t.vars.preventOverlaps === name;\n      }) : a).filter(function(t) {\n        return self.direction > 0 ? t.end <= start : t.start >= end;\n      });\n    };\n    self.update = function(reset, recordVelocity, forceFake) {\n      if (containerAnimation && !forceFake && !reset) {\n        return;\n      }\n      var scroll = _refreshingAll === true ? prevScroll : self.scroll(), p = reset ? 0 : (scroll - start) / change, clipped = p < 0 ? 0 : p > 1 ? 1 : p || 0, prevProgress2 = self.progress, isActive, wasActive, toggleState, action, stateChanged, toggled, isAtMax, isTakingAction;\n      if (recordVelocity) {\n        scroll2 = scroll1;\n        scroll1 = containerAnimation ? scrollFunc() : scroll;\n        if (snap) {\n          snap2 = snap1;\n          snap1 = animation && !isToggle ? animation.totalProgress() : clipped;\n        }\n      }\n      if (anticipatePin && pin && !_refreshing && !_startup && _lastScrollTime) {\n        if (!clipped && start < scroll + (scroll - scroll2) / (_getTime() - _time2) * anticipatePin) {\n          clipped = 1e-4;\n        } else if (clipped === 1 && end > scroll + (scroll - scroll2) / (_getTime() - _time2) * anticipatePin) {\n          clipped = 0.9999;\n        }\n      }\n      if (clipped !== prevProgress2 && self.enabled) {\n        isActive = self.isActive = !!clipped && clipped < 1;\n        wasActive = !!prevProgress2 && prevProgress2 < 1;\n        toggled = isActive !== wasActive;\n        stateChanged = toggled || !!clipped !== !!prevProgress2;\n        self.direction = clipped > prevProgress2 ? 1 : -1;\n        self.progress = clipped;\n        if (stateChanged && !_refreshing) {\n          toggleState = clipped && !prevProgress2 ? 0 : clipped === 1 ? 1 : prevProgress2 === 1 ? 2 : 3;\n          if (isToggle) {\n            action = !toggled && toggleActions[toggleState + 1] !== \"none\" && toggleActions[toggleState + 1] || toggleActions[toggleState];\n            isTakingAction = animation && (action === \"complete\" || action === \"reset\" || action in animation);\n          }\n        }\n        preventOverlaps && (toggled || isTakingAction) && (isTakingAction || scrub || !animation) && (_isFunction(preventOverlaps) ? preventOverlaps(self) : self.getTrailing(preventOverlaps).forEach(function(t) {\n          return t.endAnimation();\n        }));\n        if (!isToggle) {\n          if (scrubTween && !_refreshing && !_startup) {\n            scrubTween._dp._time - scrubTween._start !== scrubTween._time && scrubTween.render(scrubTween._dp._time - scrubTween._start);\n            if (scrubTween.resetTo) {\n              scrubTween.resetTo(\"totalProgress\", clipped, animation._tTime / animation._tDur);\n            } else {\n              scrubTween.vars.totalProgress = clipped;\n              scrubTween.invalidate().restart();\n            }\n          } else if (animation) {\n            animation.totalProgress(clipped, !!(_refreshing && (lastRefresh || reset)));\n          }\n        }\n        if (pin) {\n          reset && pinSpacing && (spacer.style[pinSpacing + direction.os2] = spacingStart);\n          if (!useFixedPosition) {\n            pinSetter(_round(pinStart + pinChange * clipped));\n          } else if (stateChanged) {\n            isAtMax = !reset && clipped > prevProgress2 && end + 1 > scroll && scroll + 1 >= _maxScroll(scroller, direction);\n            if (pinReparent) {\n              if (!reset && (isActive || isAtMax)) {\n                var bounds = _getBounds(pin, true), _offset = scroll - start;\n                _reparent(pin, _body, bounds.top + (direction === _vertical ? _offset : 0) + _px, bounds.left + (direction === _vertical ? 0 : _offset) + _px);\n              } else {\n                _reparent(pin, spacer);\n              }\n            }\n            _setState(isActive || isAtMax ? pinActiveState : pinState);\n            pinMoves && clipped < 1 && isActive || pinSetter(pinStart + (clipped === 1 && !isAtMax ? pinChange : 0));\n          }\n        }\n        snap && !tweenTo.tween && !_refreshing && !_startup && snapDelayedCall.restart(true);\n        toggleClass && (toggled || once && clipped && (clipped < 1 || !_limitCallbacks)) && _toArray(toggleClass.targets).forEach(function(el) {\n          return el.classList[isActive || once ? \"add\" : \"remove\"](toggleClass.className);\n        });\n        onUpdate && !isToggle && !reset && onUpdate(self);\n        if (stateChanged && !_refreshing) {\n          if (isToggle) {\n            if (isTakingAction) {\n              if (action === \"complete\") {\n                animation.pause().totalProgress(1);\n              } else if (action === \"reset\") {\n                animation.restart(true).pause();\n              } else if (action === \"restart\") {\n                animation.restart(true);\n              } else {\n                animation[action]();\n              }\n            }\n            onUpdate && onUpdate(self);\n          }\n          if (toggled || !_limitCallbacks) {\n            onToggle && toggled && _callback(self, onToggle);\n            callbacks[toggleState] && _callback(self, callbacks[toggleState]);\n            once && (clipped === 1 ? self.kill(false, 1) : callbacks[toggleState] = 0);\n            if (!toggled) {\n              toggleState = clipped === 1 ? 1 : 3;\n              callbacks[toggleState] && _callback(self, callbacks[toggleState]);\n            }\n          }\n          if (fastScrollEnd && !isActive && Math.abs(self.getVelocity()) > (_isNumber(fastScrollEnd) ? fastScrollEnd : 2500)) {\n            _endAnimation(self.callbackAnimation);\n            scrubTween ? scrubTween.progress(1) : _endAnimation(animation, action === \"reverse\" ? 1 : !clipped, 1);\n          }\n        } else if (isToggle && onUpdate && !_refreshing) {\n          onUpdate(self);\n        }\n      }\n      if (markerEndSetter) {\n        var n = containerAnimation ? scroll / containerAnimation.duration() * (containerAnimation._caScrollDist || 0) : scroll;\n        markerStartSetter(n + (markerStartTrigger._isFlipped ? 1 : 0));\n        markerEndSetter(n);\n      }\n      caMarkerSetter && caMarkerSetter(-scroll / containerAnimation.duration() * (containerAnimation._caScrollDist || 0));\n    };\n    self.enable = function(reset, refresh) {\n      if (!self.enabled) {\n        self.enabled = true;\n        _addListener(scroller, \"resize\", _onResize);\n        isViewport || _addListener(scroller, \"scroll\", _onScroll);\n        onRefreshInit && _addListener(ScrollTrigger2, \"refreshInit\", onRefreshInit);\n        if (reset !== false) {\n          self.progress = prevProgress = 0;\n          scroll1 = scroll2 = lastSnap = scrollFunc();\n        }\n        refresh !== false && self.refresh();\n      }\n    };\n    self.getTween = function(snap3) {\n      return snap3 && tweenTo ? tweenTo.tween : scrubTween;\n    };\n    self.setPositions = function(newStart, newEnd, keepClamp, pinOffset) {\n      if (containerAnimation) {\n        var st = containerAnimation.scrollTrigger, duration = containerAnimation.duration(), _change = st.end - st.start;\n        newStart = st.start + _change * newStart / duration;\n        newEnd = st.start + _change * newEnd / duration;\n      }\n      self.refresh(false, false, {\n        start: _keepClamp(newStart, keepClamp && !!self._startClamp),\n        end: _keepClamp(newEnd, keepClamp && !!self._endClamp)\n      }, pinOffset);\n      self.update();\n    };\n    self.adjustPinSpacing = function(amount) {\n      if (spacerState && amount) {\n        var i = spacerState.indexOf(direction.d) + 1;\n        spacerState[i] = parseFloat(spacerState[i]) + amount + _px;\n        spacerState[1] = parseFloat(spacerState[1]) + amount + _px;\n        _setState(spacerState);\n      }\n    };\n    self.disable = function(reset, allowAnimation) {\n      if (self.enabled) {\n        reset !== false && self.revert(true, true);\n        self.enabled = self.isActive = false;\n        allowAnimation || scrubTween && scrubTween.pause();\n        prevScroll = 0;\n        pinCache && (pinCache.uncache = 1);\n        onRefreshInit && _removeListener(ScrollTrigger2, \"refreshInit\", onRefreshInit);\n        if (snapDelayedCall) {\n          snapDelayedCall.pause();\n          tweenTo.tween && tweenTo.tween.kill() && (tweenTo.tween = 0);\n        }\n        if (!isViewport) {\n          var i = _triggers.length;\n          while (i--) {\n            if (_triggers[i].scroller === scroller && _triggers[i] !== self) {\n              return;\n            }\n          }\n          _removeListener(scroller, \"resize\", _onResize);\n          isViewport || _removeListener(scroller, \"scroll\", _onScroll);\n        }\n      }\n    };\n    self.kill = function(revert, allowAnimation) {\n      self.disable(revert, allowAnimation);\n      scrubTween && !allowAnimation && scrubTween.kill();\n      id && delete _ids[id];\n      var i = _triggers.indexOf(self);\n      i >= 0 && _triggers.splice(i, 1);\n      i === _i && _direction > 0 && _i--;\n      i = 0;\n      _triggers.forEach(function(t) {\n        return t.scroller === self.scroller && (i = 1);\n      });\n      i || _refreshingAll || (self.scroll.rec = 0);\n      if (animation) {\n        animation.scrollTrigger = null;\n        revert && animation.revert({\n          kill: false\n        });\n        allowAnimation || animation.kill();\n      }\n      markerStart && [markerStart, markerEnd, markerStartTrigger, markerEndTrigger].forEach(function(m) {\n        return m.parentNode && m.parentNode.removeChild(m);\n      });\n      _primary === self && (_primary = 0);\n      if (pin) {\n        pinCache && (pinCache.uncache = 1);\n        i = 0;\n        _triggers.forEach(function(t) {\n          return t.pin === pin && i++;\n        });\n        i || (pinCache.spacer = 0);\n      }\n      vars.onKill && vars.onKill(self);\n    };\n    _triggers.push(self);\n    self.enable(false, false);\n    customRevertReturn && customRevertReturn(self);\n    if (animation && animation.add && !change) {\n      var updateFunc = self.update;\n      self.update = function() {\n        self.update = updateFunc;\n        start || end || self.refresh();\n      };\n      gsap.delayedCall(0.01, self.update);\n      change = 0.01;\n      start = end = 0;\n    } else {\n      self.refresh();\n    }\n    pin && _queueRefreshAll();\n  };\n  ScrollTrigger2.register = function register(core) {\n    if (!_coreInitted) {\n      gsap = core || _getGSAP();\n      _windowExists() && window.document && ScrollTrigger2.enable();\n      _coreInitted = _enabled;\n    }\n    return _coreInitted;\n  };\n  ScrollTrigger2.defaults = function defaults(config) {\n    if (config) {\n      for (var p in config) {\n        _defaults[p] = config[p];\n      }\n    }\n    return _defaults;\n  };\n  ScrollTrigger2.disable = function disable(reset, kill) {\n    _enabled = 0;\n    _triggers.forEach(function(trigger) {\n      return trigger[kill ? \"kill\" : \"disable\"](reset);\n    });\n    _removeListener(_win, \"wheel\", _onScroll);\n    _removeListener(_doc, \"scroll\", _onScroll);\n    clearInterval(_syncInterval);\n    _removeListener(_doc, \"touchcancel\", _passThrough);\n    _removeListener(_body, \"touchstart\", _passThrough);\n    _multiListener(_removeListener, _doc, \"pointerdown,touchstart,mousedown\", _pointerDownHandler);\n    _multiListener(_removeListener, _doc, \"pointerup,touchend,mouseup\", _pointerUpHandler);\n    _resizeDelay.kill();\n    _iterateAutoRefresh(_removeListener);\n    for (var i = 0; i < _scrollers.length; i += 3) {\n      _wheelListener(_removeListener, _scrollers[i], _scrollers[i + 1]);\n      _wheelListener(_removeListener, _scrollers[i], _scrollers[i + 2]);\n    }\n  };\n  ScrollTrigger2.enable = function enable() {\n    _win = window;\n    _doc = document;\n    _docEl = _doc.documentElement;\n    _body = _doc.body;\n    if (gsap) {\n      _toArray = gsap.utils.toArray;\n      _clamp = gsap.utils.clamp;\n      _context = gsap.core.context || _passThrough;\n      _suppressOverwrites = gsap.core.suppressOverwrites || _passThrough;\n      _scrollRestoration = _win.history.scrollRestoration || \"auto\";\n      _lastScroll = _win.pageYOffset;\n      gsap.core.globals(\"ScrollTrigger\", ScrollTrigger2);\n      if (_body) {\n        _enabled = 1;\n        _div100vh = document.createElement(\"div\");\n        _div100vh.style.height = \"100vh\";\n        _div100vh.style.position = \"absolute\";\n        _refresh100vh();\n        _rafBugFix();\n        Observer.register(gsap);\n        ScrollTrigger2.isTouch = Observer.isTouch;\n        _fixIOSBug = Observer.isTouch && /(iPad|iPhone|iPod|Mac)/g.test(navigator.userAgent);\n        _ignoreMobileResize = Observer.isTouch === 1;\n        _addListener(_win, \"wheel\", _onScroll);\n        _root = [_win, _doc, _docEl, _body];\n        if (gsap.matchMedia) {\n          ScrollTrigger2.matchMedia = function(vars) {\n            var mm = gsap.matchMedia(), p;\n            for (p in vars) {\n              mm.add(p, vars[p]);\n            }\n            return mm;\n          };\n          gsap.addEventListener(\"matchMediaInit\", function() {\n            return _revertAll();\n          });\n          gsap.addEventListener(\"matchMediaRevert\", function() {\n            return _revertRecorded();\n          });\n          gsap.addEventListener(\"matchMedia\", function() {\n            _refreshAll(0, 1);\n            _dispatch(\"matchMedia\");\n          });\n          gsap.matchMedia(\"(orientation: portrait)\", function() {\n            _setBaseDimensions();\n            return _setBaseDimensions;\n          });\n        } else {\n          console.warn(\"Requires GSAP 3.11.0 or later\");\n        }\n        _setBaseDimensions();\n        _addListener(_doc, \"scroll\", _onScroll);\n        var bodyStyle = _body.style, border = bodyStyle.borderTopStyle, AnimationProto = gsap.core.Animation.prototype, bounds, i;\n        AnimationProto.revert || Object.defineProperty(AnimationProto, \"revert\", {\n          value: function value() {\n            return this.time(-0.01, true);\n          }\n        });\n        bodyStyle.borderTopStyle = \"solid\";\n        bounds = _getBounds(_body);\n        _vertical.m = Math.round(bounds.top + _vertical.sc()) || 0;\n        _horizontal.m = Math.round(bounds.left + _horizontal.sc()) || 0;\n        border ? bodyStyle.borderTopStyle = border : bodyStyle.removeProperty(\"border-top-style\");\n        _syncInterval = setInterval(_sync, 250);\n        gsap.delayedCall(0.5, function() {\n          return _startup = 0;\n        });\n        _addListener(_doc, \"touchcancel\", _passThrough);\n        _addListener(_body, \"touchstart\", _passThrough);\n        _multiListener(_addListener, _doc, \"pointerdown,touchstart,mousedown\", _pointerDownHandler);\n        _multiListener(_addListener, _doc, \"pointerup,touchend,mouseup\", _pointerUpHandler);\n        _transformProp = gsap.utils.checkPrefix(\"transform\");\n        _stateProps.push(_transformProp);\n        _coreInitted = _getTime();\n        _resizeDelay = gsap.delayedCall(0.2, _refreshAll).pause();\n        _autoRefresh = [_doc, \"visibilitychange\", function() {\n          var w = _win.innerWidth, h = _win.innerHeight;\n          if (_doc.hidden) {\n            _prevWidth = w;\n            _prevHeight = h;\n          } else if (_prevWidth !== w || _prevHeight !== h) {\n            _onResize();\n          }\n        }, _doc, \"DOMContentLoaded\", _refreshAll, _win, \"load\", _refreshAll, _win, \"resize\", _onResize];\n        _iterateAutoRefresh(_addListener);\n        _triggers.forEach(function(trigger) {\n          return trigger.enable(0, 1);\n        });\n        for (i = 0; i < _scrollers.length; i += 3) {\n          _wheelListener(_removeListener, _scrollers[i], _scrollers[i + 1]);\n          _wheelListener(_removeListener, _scrollers[i], _scrollers[i + 2]);\n        }\n      }\n    }\n  };\n  ScrollTrigger2.config = function config(vars) {\n    \"limitCallbacks\" in vars && (_limitCallbacks = !!vars.limitCallbacks);\n    var ms = vars.syncInterval;\n    ms && clearInterval(_syncInterval) || (_syncInterval = ms) && setInterval(_sync, ms);\n    \"ignoreMobileResize\" in vars && (_ignoreMobileResize = ScrollTrigger2.isTouch === 1 && vars.ignoreMobileResize);\n    if (\"autoRefreshEvents\" in vars) {\n      _iterateAutoRefresh(_removeListener) || _iterateAutoRefresh(_addListener, vars.autoRefreshEvents || \"none\");\n      _ignoreResize = (vars.autoRefreshEvents + \"\").indexOf(\"resize\") === -1;\n    }\n  };\n  ScrollTrigger2.scrollerProxy = function scrollerProxy(target, vars) {\n    var t = _getTarget(target), i = _scrollers.indexOf(t), isViewport = _isViewport(t);\n    if (~i) {\n      _scrollers.splice(i, isViewport ? 6 : 2);\n    }\n    if (vars) {\n      isViewport ? _proxies.unshift(_win, vars, _body, vars, _docEl, vars) : _proxies.unshift(t, vars);\n    }\n  };\n  ScrollTrigger2.clearMatchMedia = function clearMatchMedia(query) {\n    _triggers.forEach(function(t) {\n      return t._ctx && t._ctx.query === query && t._ctx.kill(true, true);\n    });\n  };\n  ScrollTrigger2.isInViewport = function isInViewport(element, ratio, horizontal) {\n    var bounds = (_isString(element) ? _getTarget(element) : element).getBoundingClientRect(), offset = bounds[horizontal ? _width : _height] * ratio || 0;\n    return horizontal ? bounds.right - offset > 0 && bounds.left + offset < _win.innerWidth : bounds.bottom - offset > 0 && bounds.top + offset < _win.innerHeight;\n  };\n  ScrollTrigger2.positionInViewport = function positionInViewport(element, referencePoint, horizontal) {\n    _isString(element) && (element = _getTarget(element));\n    var bounds = element.getBoundingClientRect(), size = bounds[horizontal ? _width : _height], offset = referencePoint == null ? size / 2 : referencePoint in _keywords ? _keywords[referencePoint] * size : ~referencePoint.indexOf(\"%\") ? parseFloat(referencePoint) * size / 100 : parseFloat(referencePoint) || 0;\n    return horizontal ? (bounds.left + offset) / _win.innerWidth : (bounds.top + offset) / _win.innerHeight;\n  };\n  ScrollTrigger2.killAll = function killAll(allowListeners) {\n    _triggers.slice(0).forEach(function(t) {\n      return t.vars.id !== \"ScrollSmoother\" && t.kill();\n    });\n    if (allowListeners !== true) {\n      var listeners = _listeners.killAll || [];\n      _listeners = {};\n      listeners.forEach(function(f) {\n        return f();\n      });\n    }\n  };\n  return ScrollTrigger2;\n}();\nScrollTrigger.version = \"3.12.5\";\nScrollTrigger.saveStyles = function(targets) {\n  return targets ? _toArray(targets).forEach(function(target) {\n    if (target && target.style) {\n      var i = _savedStyles.indexOf(target);\n      i >= 0 && _savedStyles.splice(i, 5);\n      _savedStyles.push(target, target.style.cssText, target.getBBox && target.getAttribute(\"transform\"), gsap.core.getCache(target), _context());\n    }\n  }) : _savedStyles;\n};\nScrollTrigger.revert = function(soft, media) {\n  return _revertAll(!soft, media);\n};\nScrollTrigger.create = function(vars, animation) {\n  return new ScrollTrigger(vars, animation);\n};\nScrollTrigger.refresh = function(safe) {\n  return safe ? _onResize() : (_coreInitted || ScrollTrigger.register()) && _refreshAll(true);\n};\nScrollTrigger.update = function(force) {\n  return ++_scrollers.cache && _updateAll(force === true ? 2 : 0);\n};\nScrollTrigger.clearScrollMemory = _clearScrollMemory;\nScrollTrigger.maxScroll = function(element, horizontal) {\n  return _maxScroll(element, horizontal ? _horizontal : _vertical);\n};\nScrollTrigger.getScrollFunc = function(element, horizontal) {\n  return _getScrollFunc(_getTarget(element), horizontal ? _horizontal : _vertical);\n};\nScrollTrigger.getById = function(id) {\n  return _ids[id];\n};\nScrollTrigger.getAll = function() {\n  return _triggers.filter(function(t) {\n    return t.vars.id !== \"ScrollSmoother\";\n  });\n};\nScrollTrigger.isScrolling = function() {\n  return !!_lastScrollTime;\n};\nScrollTrigger.snapDirectional = _snapDirectional;\nScrollTrigger.addEventListener = function(type, callback) {\n  var a = _listeners[type] || (_listeners[type] = []);\n  ~a.indexOf(callback) || a.push(callback);\n};\nScrollTrigger.removeEventListener = function(type, callback) {\n  var a = _listeners[type], i = a && a.indexOf(callback);\n  i >= 0 && a.splice(i, 1);\n};\nScrollTrigger.batch = function(targets, vars) {\n  var result = [], varsCopy = {}, interval = vars.interval || 0.016, batchMax = vars.batchMax || 1e9, proxyCallback = function proxyCallback2(type, callback) {\n    var elements = [], triggers = [], delay = gsap.delayedCall(interval, function() {\n      callback(elements, triggers);\n      elements = [];\n      triggers = [];\n    }).pause();\n    return function(self) {\n      elements.length || delay.restart(true);\n      elements.push(self.trigger);\n      triggers.push(self);\n      batchMax <= elements.length && delay.progress(1);\n    };\n  }, p;\n  for (p in vars) {\n    varsCopy[p] = p.substr(0, 2) === \"on\" && _isFunction(vars[p]) && p !== \"onRefreshInit\" ? proxyCallback(p, vars[p]) : vars[p];\n  }\n  if (_isFunction(batchMax)) {\n    batchMax = batchMax();\n    _addListener(ScrollTrigger, \"refresh\", function() {\n      return batchMax = vars.batchMax();\n    });\n  }\n  _toArray(targets).forEach(function(target) {\n    var config = {};\n    for (p in varsCopy) {\n      config[p] = varsCopy[p];\n    }\n    config.trigger = target;\n    result.push(ScrollTrigger.create(config));\n  });\n  return result;\n};\nvar _clampScrollAndGetDurationMultiplier = function _clampScrollAndGetDurationMultiplier2(scrollFunc, current, end, max) {\n  current > max ? scrollFunc(max) : current < 0 && scrollFunc(0);\n  return end > max ? (max - current) / (end - current) : end < 0 ? current / (current - end) : 1;\n};\nvar _allowNativePanning = function _allowNativePanning2(target, direction) {\n  if (direction === true) {\n    target.style.removeProperty(\"touch-action\");\n  } else {\n    target.style.touchAction = direction === true ? \"auto\" : direction ? \"pan-\" + direction + (Observer.isTouch ? \" pinch-zoom\" : \"\") : \"none\";\n  }\n  target === _docEl && _allowNativePanning2(_body, direction);\n};\nvar _overflow = {\n  auto: 1,\n  scroll: 1\n};\nvar _nestedScroll = function _nestedScroll2(_ref5) {\n  var event = _ref5.event, target = _ref5.target, axis = _ref5.axis;\n  var node = (event.changedTouches ? event.changedTouches[0] : event).target, cache = node._gsap || gsap.core.getCache(node), time = _getTime(), cs;\n  if (!cache._isScrollT || time - cache._isScrollT > 2e3) {\n    while (node && node !== _body && (node.scrollHeight <= node.clientHeight && node.scrollWidth <= node.clientWidth || !(_overflow[(cs = _getComputedStyle(node)).overflowY] || _overflow[cs.overflowX]))) {\n      node = node.parentNode;\n    }\n    cache._isScroll = node && node !== target && !_isViewport(node) && (_overflow[(cs = _getComputedStyle(node)).overflowY] || _overflow[cs.overflowX]);\n    cache._isScrollT = time;\n  }\n  if (cache._isScroll || axis === \"x\") {\n    event.stopPropagation();\n    event._gsapAllow = true;\n  }\n};\nvar _inputObserver = function _inputObserver2(target, type, inputs, nested) {\n  return Observer.create({\n    target,\n    capture: true,\n    debounce: false,\n    lockAxis: true,\n    type,\n    onWheel: nested = nested && _nestedScroll,\n    onPress: nested,\n    onDrag: nested,\n    onScroll: nested,\n    onEnable: function onEnable() {\n      return inputs && _addListener(_doc, Observer.eventTypes[0], _captureInputs, false, true);\n    },\n    onDisable: function onDisable() {\n      return _removeListener(_doc, Observer.eventTypes[0], _captureInputs, true);\n    }\n  });\n};\nvar _inputExp = /(input|label|select|textarea)/i;\nvar _inputIsFocused;\nvar _captureInputs = function _captureInputs2(e) {\n  var isInput = _inputExp.test(e.target.tagName);\n  if (isInput || _inputIsFocused) {\n    e._gsapAllow = true;\n    _inputIsFocused = isInput;\n  }\n};\nvar _getScrollNormalizer = function _getScrollNormalizer2(vars) {\n  _isObject(vars) || (vars = {});\n  vars.preventDefault = vars.isNormalizer = vars.allowClicks = true;\n  vars.type || (vars.type = \"wheel,touch\");\n  vars.debounce = !!vars.debounce;\n  vars.id = vars.id || \"normalizer\";\n  var _vars2 = vars, normalizeScrollX = _vars2.normalizeScrollX, momentum = _vars2.momentum, allowNestedScroll = _vars2.allowNestedScroll, onRelease = _vars2.onRelease, self, maxY, target = _getTarget(vars.target) || _docEl, smoother = gsap.core.globals().ScrollSmoother, smootherInstance = smoother && smoother.get(), content = _fixIOSBug && (vars.content && _getTarget(vars.content) || smootherInstance && vars.content !== false && !smootherInstance.smooth() && smootherInstance.content()), scrollFuncY = _getScrollFunc(target, _vertical), scrollFuncX = _getScrollFunc(target, _horizontal), scale = 1, initialScale = (Observer.isTouch && _win.visualViewport ? _win.visualViewport.scale * _win.visualViewport.width : _win.outerWidth) / _win.innerWidth, wheelRefresh = 0, resolveMomentumDuration = _isFunction(momentum) ? function() {\n    return momentum(self);\n  } : function() {\n    return momentum || 2.8;\n  }, lastRefreshID, skipTouchMove, inputObserver = _inputObserver(target, vars.type, true, allowNestedScroll), resumeTouchMove = function resumeTouchMove2() {\n    return skipTouchMove = false;\n  }, scrollClampX = _passThrough, scrollClampY = _passThrough, updateClamps = function updateClamps2() {\n    maxY = _maxScroll(target, _vertical);\n    scrollClampY = _clamp(_fixIOSBug ? 1 : 0, maxY);\n    normalizeScrollX && (scrollClampX = _clamp(0, _maxScroll(target, _horizontal)));\n    lastRefreshID = _refreshID;\n  }, removeContentOffset = function removeContentOffset2() {\n    content._gsap.y = _round(parseFloat(content._gsap.y) + scrollFuncY.offset) + \"px\";\n    content.style.transform = \"matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, \" + parseFloat(content._gsap.y) + \", 0, 1)\";\n    scrollFuncY.offset = scrollFuncY.cacheID = 0;\n  }, ignoreDrag = function ignoreDrag2() {\n    if (skipTouchMove) {\n      requestAnimationFrame(resumeTouchMove);\n      var offset = _round(self.deltaY / 2), scroll = scrollClampY(scrollFuncY.v - offset);\n      if (content && scroll !== scrollFuncY.v + scrollFuncY.offset) {\n        scrollFuncY.offset = scroll - scrollFuncY.v;\n        var y = _round((parseFloat(content && content._gsap.y) || 0) - scrollFuncY.offset);\n        content.style.transform = \"matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, \" + y + \", 0, 1)\";\n        content._gsap.y = y + \"px\";\n        scrollFuncY.cacheID = _scrollers.cache;\n        _updateAll();\n      }\n      return true;\n    }\n    scrollFuncY.offset && removeContentOffset();\n    skipTouchMove = true;\n  }, tween, startScrollX, startScrollY, onStopDelayedCall, onResize = function onResize2() {\n    updateClamps();\n    if (tween.isActive() && tween.vars.scrollY > maxY) {\n      scrollFuncY() > maxY ? tween.progress(1) && scrollFuncY(maxY) : tween.resetTo(\"scrollY\", maxY);\n    }\n  };\n  content && gsap.set(content, {\n    y: \"+=0\"\n  });\n  vars.ignoreCheck = function(e) {\n    return _fixIOSBug && e.type === \"touchmove\" && ignoreDrag(e) || scale > 1.05 && e.type !== \"touchstart\" || self.isGesturing || e.touches && e.touches.length > 1;\n  };\n  vars.onPress = function() {\n    skipTouchMove = false;\n    var prevScale = scale;\n    scale = _round((_win.visualViewport && _win.visualViewport.scale || 1) / initialScale);\n    tween.pause();\n    prevScale !== scale && _allowNativePanning(target, scale > 1.01 ? true : normalizeScrollX ? false : \"x\");\n    startScrollX = scrollFuncX();\n    startScrollY = scrollFuncY();\n    updateClamps();\n    lastRefreshID = _refreshID;\n  };\n  vars.onRelease = vars.onGestureStart = function(self2, wasDragging) {\n    scrollFuncY.offset && removeContentOffset();\n    if (!wasDragging) {\n      onStopDelayedCall.restart(true);\n    } else {\n      _scrollers.cache++;\n      var dur = resolveMomentumDuration(), currentScroll, endScroll;\n      if (normalizeScrollX) {\n        currentScroll = scrollFuncX();\n        endScroll = currentScroll + dur * 0.05 * -self2.velocityX / 0.227;\n        dur *= _clampScrollAndGetDurationMultiplier(scrollFuncX, currentScroll, endScroll, _maxScroll(target, _horizontal));\n        tween.vars.scrollX = scrollClampX(endScroll);\n      }\n      currentScroll = scrollFuncY();\n      endScroll = currentScroll + dur * 0.05 * -self2.velocityY / 0.227;\n      dur *= _clampScrollAndGetDurationMultiplier(scrollFuncY, currentScroll, endScroll, _maxScroll(target, _vertical));\n      tween.vars.scrollY = scrollClampY(endScroll);\n      tween.invalidate().duration(dur).play(0.01);\n      if (_fixIOSBug && tween.vars.scrollY >= maxY || currentScroll >= maxY - 1) {\n        gsap.to({}, {\n          onUpdate: onResize,\n          duration: dur\n        });\n      }\n    }\n    onRelease && onRelease(self2);\n  };\n  vars.onWheel = function() {\n    tween._ts && tween.pause();\n    if (_getTime() - wheelRefresh > 1e3) {\n      lastRefreshID = 0;\n      wheelRefresh = _getTime();\n    }\n  };\n  vars.onChange = function(self2, dx, dy, xArray, yArray) {\n    _refreshID !== lastRefreshID && updateClamps();\n    dx && normalizeScrollX && scrollFuncX(scrollClampX(xArray[2] === dx ? startScrollX + (self2.startX - self2.x) : scrollFuncX() + dx - xArray[1]));\n    if (dy) {\n      scrollFuncY.offset && removeContentOffset();\n      var isTouch = yArray[2] === dy, y = isTouch ? startScrollY + self2.startY - self2.y : scrollFuncY() + dy - yArray[1], yClamped = scrollClampY(y);\n      isTouch && y !== yClamped && (startScrollY += yClamped - y);\n      scrollFuncY(yClamped);\n    }\n    (dy || dx) && _updateAll();\n  };\n  vars.onEnable = function() {\n    _allowNativePanning(target, normalizeScrollX ? false : \"x\");\n    ScrollTrigger.addEventListener(\"refresh\", onResize);\n    _addListener(_win, \"resize\", onResize);\n    if (scrollFuncY.smooth) {\n      scrollFuncY.target.style.scrollBehavior = \"auto\";\n      scrollFuncY.smooth = scrollFuncX.smooth = false;\n    }\n    inputObserver.enable();\n  };\n  vars.onDisable = function() {\n    _allowNativePanning(target, true);\n    _removeListener(_win, \"resize\", onResize);\n    ScrollTrigger.removeEventListener(\"refresh\", onResize);\n    inputObserver.kill();\n  };\n  vars.lockAxis = vars.lockAxis !== false;\n  self = new Observer(vars);\n  self.iOS = _fixIOSBug;\n  _fixIOSBug && !scrollFuncY() && scrollFuncY(1);\n  _fixIOSBug && gsap.ticker.add(_passThrough);\n  onStopDelayedCall = self._dc;\n  tween = gsap.to(self, {\n    ease: \"power4\",\n    paused: true,\n    inherit: false,\n    scrollX: normalizeScrollX ? \"+=0.1\" : \"+=0\",\n    scrollY: \"+=0.1\",\n    modifiers: {\n      scrollY: _interruptionTracker(scrollFuncY, scrollFuncY(), function() {\n        return tween.pause();\n      })\n    },\n    onUpdate: _updateAll,\n    onComplete: onStopDelayedCall.vars.onComplete\n  });\n  return self;\n};\nScrollTrigger.sort = function(func) {\n  return _triggers.sort(func || function(a, b) {\n    return (a.vars.refreshPriority || 0) * -1e6 + a.start - (b.start + (b.vars.refreshPriority || 0) * -1e6);\n  });\n};\nScrollTrigger.observe = function(vars) {\n  return new Observer(vars);\n};\nScrollTrigger.normalizeScroll = function(vars) {\n  if (typeof vars === \"undefined\") {\n    return _normalizer;\n  }\n  if (vars === true && _normalizer) {\n    return _normalizer.enable();\n  }\n  if (vars === false) {\n    _normalizer && _normalizer.kill();\n    _normalizer = vars;\n    return;\n  }\n  var normalizer = vars instanceof Observer ? vars : _getScrollNormalizer(vars);\n  _normalizer && _normalizer.target === normalizer.target && _normalizer.kill();\n  _isViewport(normalizer.target) && (_normalizer = normalizer);\n  return normalizer;\n};\nScrollTrigger.core = {\n  // smaller file size way to leverage in ScrollSmoother and Observer\n  _getVelocityProp,\n  _inputObserver,\n  _scrollers,\n  _proxies,\n  bridge: {\n    // when normalizeScroll sets the scroll position (ss = setScroll)\n    ss: function ss() {\n      _lastScrollTime || _dispatch(\"scrollStart\");\n      _lastScrollTime = _getTime();\n    },\n    // a way to get the _refreshing value in Observer\n    ref: function ref() {\n      return _refreshing;\n    }\n  }\n};\n_getGSAP() && gsap.registerPlugin(ScrollTrigger);\nexport {\n  ScrollTrigger,\n  ScrollTrigger as default\n};\n/*! Bundled license information:\n\ngsap/ScrollTrigger.js:\n  (*!\n   * ScrollTrigger 3.12.5\n   * https://gsap.com\n   *\n   * @license Copyright 2008-2024, GreenSock. All rights reserved.\n   * Subject to the terms at https://gsap.com/standard-license or for\n   * Club GSAP members, the agreement issued with that membership.\n   * @author: Jack Doyle, jack@greensock.com\n  *)\n*/\n//# sourceMappingURL=gsap_ScrollTrigger.js.map\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 83411,
            "count": 1
          },
          {
            "startOffset": 82896,
            "endOffset": 82933,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_parseClamp2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1028,
            "endOffset": 1268,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_keepClamp2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1287,
            "endOffset": 1432,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_rafBugFix2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1451,
            "endOffset": 1534,
            "count": 245
          }
        ]
      },
      {
        "functionName": "_pointerDownHandler2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1562,
            "endOffset": 1626,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_pointerUpHandler2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1652,
            "endOffset": 1714,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_passThrough2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1735,
            "endOffset": 1776,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_round2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1791,
            "endOffset": 1863,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_windowExists2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1885,
            "endOffset": 1954,
            "count": 2
          }
        ]
      },
      {
        "functionName": "_getGSAP2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1971,
            "endOffset": 2084,
            "count": 1
          },
          {
            "startOffset": 2051,
            "endOffset": 2073,
            "count": 0
          },
          {
            "startOffset": 2074,
            "endOffset": 2081,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_isViewport2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2104,
            "endOffset": 2162,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_getViewportDimension2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2192,
            "endOffset": 2413,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_getBoundsFunc2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2436,
            "endOffset": 2725,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_getSizeFunc2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2746,
            "endOffset": 3050,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_getOffsetsFunc2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 3074,
            "endOffset": 3245,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_maxScroll2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 3264,
            "endOffset": 3594,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_iterateAutoRefresh2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 3622,
            "endOffset": 3848,
            "count": 1
          },
          {
            "startOffset": 3719,
            "endOffset": 3846,
            "count": 4
          },
          {
            "startOffset": 3734,
            "endOffset": 3773,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_isString2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 3866,
            "endOffset": 3932,
            "count": 2
          }
        ]
      },
      {
        "functionName": "_isFunction2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 3952,
            "endOffset": 4022,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_isNumber2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4040,
            "endOffset": 4106,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_isObject2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4124,
            "endOffset": 4190,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_endAnimation2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4212,
            "endOffset": 4357,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_callback2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4375,
            "endOffset": 4607,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_getComputedStyle2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4980,
            "endOffset": 5061,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_makePositionable2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 5087,
            "endOffset": 5281,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_setDefaults2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 5302,
            "endOffset": 5429,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_getBounds2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5448,
            "endOffset": 5893,
            "count": 1
          },
          {
            "startOffset": 5531,
            "endOffset": 5607,
            "count": 0
          },
          {
            "startOffset": 5608,
            "endOffset": 5794,
            "count": 0
          },
          {
            "startOffset": 5846,
            "endOffset": 5873,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_getSize2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 5910,
            "endOffset": 6033,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_getLabelRatioArray2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 6061,
            "endOffset": 6251,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_getClosestLabel2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 6276,
            "endOffset": 6416,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_snapDirectional2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 6441,
            "endOffset": 7544,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_getLabelAtDirection2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 7573,
            "endOffset": 7734,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_multiListener2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7757,
            "endOffset": 7916,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7850,
            "endOffset": 7912,
            "count": 6
          }
        ]
      },
      {
        "functionName": "_addListener2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7937,
            "endOffset": 8108,
            "count": 14
          }
        ]
      },
      {
        "functionName": "_removeListener2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 8132,
            "endOffset": 8252,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_wheelListener2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 8275,
            "endOffset": 8477,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_offsetToPx2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 8768,
            "endOffset": 9275,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_createMarker2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 9297,
            "endOffset": 10870,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_positionMarker2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10894,
            "endOffset": 11365,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_sync2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 11426,
            "endOffset": 11551,
            "count": 16
          }
        ]
      },
      {
        "functionName": "_onScroll2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11569,
            "endOffset": 11919,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_setBaseDimensions2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 11946,
            "endOffset": 12058,
            "count": 1
          }
        ]
      },
      {
        "functionName": "_onResize2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12076,
            "endOffset": 12389,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_softRefresh2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12453,
            "endOffset": 12571,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_dispatch2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 12589,
            "endOffset": 12719,
            "count": 6
          },
          {
            "startOffset": 12643,
            "endOffset": 12701,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12667,
            "endOffset": 12700,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_revertRecorded2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12766,
            "endOffset": 13146,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_revertAll2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13165,
            "endOffset": 13550,
            "count": 2
          },
          {
            "startOffset": 13260,
            "endOffset": 13459,
            "count": 0
          },
          {
            "startOffset": 13490,
            "endOffset": 13515,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_clearScrollMemory2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13577,
            "endOffset": 13902,
            "count": 2
          },
          {
            "startOffset": 13665,
            "endOffset": 13683,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13707,
            "endOffset": 13789,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_queueRefreshAll2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13988,
            "endOffset": 14207,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_refresh100vh2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14229,
            "endOffset": 14393,
            "count": 3
          },
          {
            "startOffset": 14339,
            "endOffset": 14358,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_hideAllMarkers2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14417,
            "endOffset": 14650,
            "count": 4
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14573,
            "endOffset": 14646,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_refreshAll2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14670,
            "endOffset": 16737,
            "count": 2
          },
          {
            "startOffset": 14735,
            "endOffset": 14744,
            "count": 0
          },
          {
            "startOffset": 14745,
            "endOffset": 14760,
            "count": 0
          },
          {
            "startOffset": 14762,
            "endOffset": 14839,
            "count": 0
          },
          {
            "startOffset": 15078,
            "endOffset": 15101,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14934,
            "endOffset": 15020,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15154,
            "endOffset": 15285,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15317,
            "endOffset": 15358,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15404,
            "endOffset": 15650,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15718,
            "endOffset": 16042,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 16114,
            "endOffset": 16193,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 16217,
            "endOffset": 16425,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 16572,
            "endOffset": 16654,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_updateAll2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 16811,
            "endOffset": 17759,
            "count": 22
          },
          {
            "startOffset": 16859,
            "endOffset": 16893,
            "count": 20
          },
          {
            "startOffset": 16947,
            "endOffset": 16968,
            "count": 0
          },
          {
            "startOffset": 17068,
            "endOffset": 17092,
            "count": 0
          },
          {
            "startOffset": 17132,
            "endOffset": 17136,
            "count": 0
          },
          {
            "startOffset": 17161,
            "endOffset": 17186,
            "count": 20
          },
          {
            "startOffset": 17212,
            "endOffset": 17412,
            "count": 17
          },
          {
            "startOffset": 17240,
            "endOffset": 17258,
            "count": 0
          },
          {
            "startOffset": 17259,
            "endOffset": 17290,
            "count": 0
          },
          {
            "startOffset": 17292,
            "endOffset": 17362,
            "count": 0
          },
          {
            "startOffset": 17437,
            "endOffset": 17579,
            "count": 0
          },
          {
            "startOffset": 17620,
            "endOffset": 17695,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_swapPinOut2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 18289,
            "endOffset": 18648,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_swapPinIn2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 18667,
            "endOffset": 19820,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_setState2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 19865,
            "endOffset": 20280,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_getState2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 20298,
            "endOffset": 20521,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_copyState2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 20540,
            "endOffset": 20810,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_parsePosition2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 20876,
            "endOffset": 23772,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_reparent2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 23845,
            "endOffset": 24431,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_interruptionTracker2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 24460,
            "endOffset": 24893,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_shiftMarker2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 24914,
            "endOffset": 25045,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_getTweenCreator2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 25070,
            "endOffset": 26528,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 26550,
            "endOffset": 69267,
            "count": 1
          }
        ]
      },
      {
        "functionName": "ScrollTrigger2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 26565,
            "endOffset": 26775,
            "count": 0
          }
        ]
      },
      {
        "functionName": "init",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 26833,
            "endOffset": 61332,
            "count": 0
          }
        ]
      },
      {
        "functionName": "register",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 61362,
            "endOffset": 61580,
            "count": 2
          },
          {
            "startOffset": 61411,
            "endOffset": 61551,
            "count": 1
          },
          {
            "startOffset": 61431,
            "endOffset": 61444,
            "count": 0
          }
        ]
      },
      {
        "functionName": "defaults",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 61610,
            "endOffset": 61759,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disable",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 61788,
            "endOffset": 62652,
            "count": 0
          }
        ]
      },
      {
        "functionName": "enable",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 62680,
            "endOffset": 66725,
            "count": 1
          },
          {
            "startOffset": 62919,
            "endOffset": 62934,
            "count": 0
          },
          {
            "startOffset": 62993,
            "endOffset": 63008,
            "count": 0
          },
          {
            "startOffset": 63068,
            "endOffset": 63077,
            "count": 0
          },
          {
            "startOffset": 63525,
            "endOffset": 63579,
            "count": 0
          },
          {
            "startOffset": 64501,
            "endOffset": 64575,
            "count": 0
          },
          {
            "startOffset": 64816,
            "endOffset": 64970,
            "count": 0
          },
          {
            "startOffset": 65114,
            "endOffset": 65118,
            "count": 0
          },
          {
            "startOffset": 65187,
            "endOffset": 65191,
            "count": 0
          },
          {
            "startOffset": 65208,
            "endOffset": 65243,
            "count": 0
          },
          {
            "startOffset": 66542,
            "endOffset": 66707,
            "count": 0
          }
        ]
      },
      {
        "functionName": "ScrollTrigger2.matchMedia",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 63797,
            "endOffset": 63969,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 64021,
            "endOffset": 64078,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 64133,
            "endOffset": 64195,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 64244,
            "endOffset": 64336,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 64392,
            "endOffset": 64489,
            "count": 0
          }
        ]
      },
      {
        "functionName": "value",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 64886,
            "endOffset": 64959,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 65371,
            "endOffset": 65424,
            "count": 1
          }
        ]
      },
      {
        "functionName": "_autoRefresh",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 65991,
            "endOffset": 66255,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 66420,
            "endOffset": 66488,
            "count": 0
          }
        ]
      },
      {
        "functionName": "config",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 66753,
            "endOffset": 67332,
            "count": 0
          }
        ]
      },
      {
        "functionName": "scrollerProxy",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 67367,
            "endOffset": 67691,
            "count": 0
          }
        ]
      },
      {
        "functionName": "clearMatchMedia",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 67728,
            "endOffset": 67883,
            "count": 0
          }
        ]
      },
      {
        "functionName": "isInViewport",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 67917,
            "endOffset": 68292,
            "count": 0
          }
        ]
      },
      {
        "functionName": "positionInViewport",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 68332,
            "endOffset": 68882,
            "count": 0
          }
        ]
      },
      {
        "functionName": "killAll",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 68911,
            "endOffset": 69239,
            "count": 0
          }
        ]
      },
      {
        "functionName": "ScrollTrigger.saveStyles",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 69332,
            "endOffset": 69712,
            "count": 0
          }
        ]
      },
      {
        "functionName": "ScrollTrigger.revert",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 69737,
            "endOffset": 69797,
            "count": 0
          }
        ]
      },
      {
        "functionName": "ScrollTrigger.create",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 69822,
            "endOffset": 69896,
            "count": 0
          }
        ]
      },
      {
        "functionName": "ScrollTrigger.refresh",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 69922,
            "endOffset": 70035,
            "count": 0
          }
        ]
      },
      {
        "functionName": "ScrollTrigger.update",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 70060,
            "endOffset": 70146,
            "count": 4
          },
          {
            "startOffset": 70135,
            "endOffset": 70138,
            "count": 0
          }
        ]
      },
      {
        "functionName": "ScrollTrigger.maxScroll",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 70228,
            "endOffset": 70329,
            "count": 0
          }
        ]
      },
      {
        "functionName": "ScrollTrigger.getScrollFunc",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 70361,
            "endOffset": 70478,
            "count": 0
          }
        ]
      },
      {
        "functionName": "ScrollTrigger.getById",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 70504,
            "endOffset": 70539,
            "count": 0
          }
        ]
      },
      {
        "functionName": "ScrollTrigger.getAll",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 70564,
            "endOffset": 70667,
            "count": 0
          }
        ]
      },
      {
        "functionName": "ScrollTrigger.isScrolling",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 70697,
            "endOffset": 70739,
            "count": 0
          }
        ]
      },
      {
        "functionName": "ScrollTrigger.addEventListener",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 70824,
            "endOffset": 70951,
            "count": 0
          }
        ]
      },
      {
        "functionName": "ScrollTrigger.removeEventListener",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 70989,
            "endOffset": 71103,
            "count": 0
          }
        ]
      },
      {
        "functionName": "ScrollTrigger.batch",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 71127,
            "endOffset": 72252,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_clampScrollAndGetDurationMultiplier2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 72297,
            "endOffset": 72542,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_allowNativePanning2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 72570,
            "endOffset": 72921,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_nestedScroll2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 72987,
            "endOffset": 73830,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_inputObserver2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 73853,
            "endOffset": 74401,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_captureInputs2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 74495,
            "endOffset": 74672,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_getScrollNormalizer2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 74701,
            "endOffset": 81586,
            "count": 0
          }
        ]
      },
      {
        "functionName": "ScrollTrigger.sort",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 81609,
            "endOffset": 81792,
            "count": 0
          }
        ]
      },
      {
        "functionName": "ScrollTrigger.observe",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 81818,
            "endOffset": 81865,
            "count": 0
          }
        ]
      },
      {
        "functionName": "ScrollTrigger.normalizeScroll",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 81899,
            "endOffset": 82407,
            "count": 0
          }
        ]
      },
      {
        "functionName": "ss",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 82656,
            "endOffset": 82764,
            "count": 0
          }
        ]
      },
      {
        "functionName": "ref",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 82829,
            "endOffset": 82877,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5173/@fs/home/will/local_dev/portfolio/packages/motion-system/src/index.ts?t=1750724128976",
    "scriptId": "29",
    "source": "export { MotionProvider, useMotion } from \"/@fs/home/will/local_dev/portfolio/packages/motion-system/src/providers/MotionProvider.tsx?t=1750724128976\";\nexport { HeroToContactHeaderOrchestrator } from \"/@fs/home/will/local_dev/portfolio/packages/motion-system/src/orchestrators/HeroToContactHeaderOrchestrator.tsx?t=1750724128976\";\nexport { useScrollStateMachine } from \"/@fs/home/will/local_dev/portfolio/packages/motion-system/src/hooks/useScrollStateMachine.ts?t=1750724128976\";\nexport { KineticText } from \"/@fs/home/will/local_dev/portfolio/packages/motion-system/src/components/KineticText.tsx?t=1750724128976\";\nexport { ContactHeader } from \"/@fs/home/will/local_dev/portfolio/packages/motion-system/src/components/ContactHeader.tsx?t=1750724128976\";\nexport * from \"/@fs/home/will/local_dev/portfolio/packages/motion-system/src/types/index.ts\";\n\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImluZGV4LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFByb3ZpZGVyc1xuZXhwb3J0IHsgTW90aW9uUHJvdmlkZXIsIHVzZU1vdGlvbiB9IGZyb20gJy4vcHJvdmlkZXJzL01vdGlvblByb3ZpZGVyJ1xuXG4vLyBPcmNoZXN0cmF0b3JzXG5leHBvcnQgeyBIZXJvVG9Db250YWN0SGVhZGVyT3JjaGVzdHJhdG9yIH0gZnJvbSAnLi9vcmNoZXN0cmF0b3JzL0hlcm9Ub0NvbnRhY3RIZWFkZXJPcmNoZXN0cmF0b3InXG5cbi8vIEhvb2tzXG5leHBvcnQgeyB1c2VTY3JvbGxTdGF0ZU1hY2hpbmUgfSBmcm9tICcuL2hvb2tzL3VzZVNjcm9sbFN0YXRlTWFjaGluZSdcbmV4cG9ydCB0eXBlIHsgU2Nyb2xsU3RhdGUgfSBmcm9tICcuL2hvb2tzL3VzZVNjcm9sbFN0YXRlTWFjaGluZSdcblxuLy8gQ29tcG9uZW50c1xuZXhwb3J0IHsgS2luZXRpY1RleHQgfSBmcm9tICcuL2NvbXBvbmVudHMvS2luZXRpY1RleHQnXG5leHBvcnQgeyBDb250YWN0SGVhZGVyIH0gZnJvbSAnLi9jb21wb25lbnRzL0NvbnRhY3RIZWFkZXInXG5cbi8vIFR5cGVzXG5leHBvcnQgKiBmcm9tICcuL3R5cGVzJ1xuIl0sIm1hcHBpbmdzIjoiQUFDQSxTQUFTLGdCQUFnQixpQkFBaUI7QUFHMUMsU0FBUyx1Q0FBdUM7QUFHaEQsU0FBUyw2QkFBNkI7QUFJdEMsU0FBUyxtQkFBbUI7QUFDNUIsU0FBUyxxQkFBcUI7QUFHOUIsY0FBYzsiLCJuYW1lcyI6W119",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 1854,
            "count": 1
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5173/src/components/Hero/HeroSectionWebGL.tsx?t=1750726948502",
    "scriptId": "30",
    "source": "import { createHotContext as __vite__createHotContext } from \"/@vite/client\";import.meta.hot = __vite__createHotContext(\"/src/components/Hero/HeroSectionWebGL.tsx\");import __vite__cjsImport0_react_jsxDevRuntime from \"/node_modules/.vite/deps/react_jsx-dev-runtime.js?v=a50bb159\"; const jsxDEV = __vite__cjsImport0_react_jsxDevRuntime[\"jsxDEV\"];\nimport RefreshRuntime from \"/@react-refresh\";\nconst inWebWorker = typeof WorkerGlobalScope !== \"undefined\" && self instanceof WorkerGlobalScope;\nlet prevRefreshReg;\nlet prevRefreshSig;\nif (import.meta.hot && !inWebWorker) {\n  if (!window.__vite_plugin_react_preamble_installed__) {\n    throw new Error(\"@vitejs/plugin-react can't detect preamble. Something is wrong. See https://github.com/vitejs/vite-plugin-react/pull/11#discussion_r430879201\");\n  }\n  prevRefreshReg = window.$RefreshReg$;\n  prevRefreshSig = window.$RefreshSig$;\n  window.$RefreshReg$ = (type, id) => {\n    RefreshRuntime.register(type, \"/home/will/local_dev/portfolio/apps/robin-noguier/src/components/Hero/HeroSectionWebGL.tsx \" + id);\n  };\n  window.$RefreshSig$ = RefreshRuntime.createSignatureFunctionForTransform;\n}\nvar _s = $RefreshSig$();\nimport __vite__cjsImport3_react from \"/node_modules/.vite/deps/react.js?v=a50bb159\"; const useEffect = __vite__cjsImport3_react[\"useEffect\"]; const useRef = __vite__cjsImport3_react[\"useRef\"];\nimport { gsap } from \"/node_modules/.vite/deps/gsap.js?v=a50bb159\";\nimport { KineticPhone } from \"/src/components/KineticPhone/index.ts\";\nimport { useMotion } from \"/@fs/home/will/local_dev/portfolio/packages/motion-system/src/index.ts?t=1750724128976\";\nimport { config } from \"/src/config/index.ts?t=1750726948502\";\nimport styles from \"/src/components/Hero/HeroSection.module.css?t=1750724128430\";\nconst HeroSectionWebGL = () => {\n  _s();\n  const containerRef = useRef(null);\n  const { registerElement } = useMotion();\n  const titleRef = useRef(null);\n  const subtitleRef = useRef(null);\n  const institutionRef = useRef(null);\n  const emailRef = useRef(null);\n  const contactRef = useRef(null);\n  useEffect(() => {\n    if (titleRef.current)\n      registerElement(\"hero-name\", titleRef);\n    if (subtitleRef.current)\n      registerElement(\"hero-title\", subtitleRef);\n    if (institutionRef.current)\n      registerElement(\"hero-institution\", institutionRef);\n    if (emailRef.current)\n      registerElement(\"hero-email\", emailRef);\n    if (contactRef.current)\n      registerElement(\"hero-contact\", contactRef);\n  }, [registerElement]);\n  useEffect(() => {\n    if (!containerRef.current)\n      return;\n    const ctx = gsap.context(() => {\n      const magneticElements = containerRef.current.querySelectorAll(\"[data-magnetic]\");\n      magneticElements.forEach((el) => {\n        const element = el;\n        const handleMouseMove = (e) => {\n          const rect = element.getBoundingClientRect();\n          const x = e.clientX - rect.left - rect.width / 2;\n          const y = e.clientY - rect.top - rect.height / 2;\n          gsap.to(element, {\n            x: x * 0.3,\n            y: y * 0.3,\n            duration: 0.3,\n            ease: \"power2.out\"\n          });\n        };\n        const handleMouseLeave = () => {\n          gsap.to(element, {\n            x: 0,\n            y: 0,\n            duration: 0.3,\n            ease: \"power2.out\"\n          });\n        };\n        element.addEventListener(\"mousemove\", handleMouseMove);\n        element.addEventListener(\"mouseleave\", handleMouseLeave);\n        return () => {\n          element.removeEventListener(\"mousemove\", handleMouseMove);\n          element.removeEventListener(\"mouseleave\", handleMouseLeave);\n        };\n      });\n      gsap.from(\".heroTitle\", {\n        y: 50,\n        opacity: 0,\n        duration: 1,\n        ease: \"power3.out\",\n        delay: 0.2\n      });\n      gsap.from(\".heroSubtitle, .heroInstitution\", {\n        y: 30,\n        opacity: 0,\n        duration: 1,\n        stagger: 0.1,\n        ease: \"power3.out\",\n        delay: 0.4\n      });\n      gsap.from(\".heroContact\", {\n        y: 20,\n        opacity: 0,\n        duration: 1,\n        ease: \"power3.out\",\n        delay: 0.7\n      });\n      gsap.to(\".scrollLine\", {\n        scaleY: 0,\n        transformOrigin: \"top\",\n        duration: 2,\n        ease: \"power2.inOut\",\n        repeat: -1,\n        yoyo: true\n      });\n    }, containerRef);\n    return () => ctx.revert();\n  }, []);\n  return /* @__PURE__ */ jsxDEV(\"div\", { ref: containerRef, className: styles.heroContainer, children: [\n    /* @__PURE__ */ jsxDEV(\"div\", { className: styles.overlayContent, children: [\n      /* @__PURE__ */ jsxDEV(\"h1\", { ref: titleRef, className: `${styles.heroTitle} heroTitle`, children: config.hero.name }, void 0, false, {\n        fileName: \"/home/will/local_dev/portfolio/apps/robin-noguier/src/components/Hero/HeroSectionWebGL.tsx\",\n        lineNumber: 112,\n        columnNumber: 9\n      }, this),\n      /* @__PURE__ */ jsxDEV(\"p\", { ref: subtitleRef, className: `${styles.heroSubtitle} heroSubtitle`, children: config.hero.title }, void 0, false, {\n        fileName: \"/home/will/local_dev/portfolio/apps/robin-noguier/src/components/Hero/HeroSectionWebGL.tsx\",\n        lineNumber: 113,\n        columnNumber: 9\n      }, this),\n      /* @__PURE__ */ jsxDEV(\"p\", { ref: institutionRef, className: `${styles.heroInstitution} heroInstitution`, children: config.hero.institution }, void 0, false, {\n        fileName: \"/home/will/local_dev/portfolio/apps/robin-noguier/src/components/Hero/HeroSectionWebGL.tsx\",\n        lineNumber: 116,\n        columnNumber: 9\n      }, this),\n      /* @__PURE__ */ jsxDEV(\"div\", { ref: contactRef, className: `${styles.heroContact} heroContact`, children: [\n        /* @__PURE__ */ jsxDEV(KineticPhone, { className: styles.contactPhone }, void 0, false, {\n          fileName: \"/home/will/local_dev/portfolio/apps/robin-noguier/src/components/Hero/HeroSectionWebGL.tsx\",\n          lineNumber: 120,\n          columnNumber: 11\n        }, this),\n        /* @__PURE__ */ jsxDEV(\"span\", { className: styles.contactDivider, children: \"|\" }, void 0, false, {\n          fileName: \"/home/will/local_dev/portfolio/apps/robin-noguier/src/components/Hero/HeroSectionWebGL.tsx\",\n          lineNumber: 121,\n          columnNumber: 11\n        }, this),\n        /* @__PURE__ */ jsxDEV(\n          \"a\",\n          {\n            ref: emailRef,\n            href: `mailto:${config.hero.email}`,\n            className: styles.contactLink,\n            \"data-magnetic\": true,\n            children: config.hero.email\n          },\n          void 0,\n          false,\n          {\n            fileName: \"/home/will/local_dev/portfolio/apps/robin-noguier/src/components/Hero/HeroSectionWebGL.tsx\",\n            lineNumber: 122,\n            columnNumber: 11\n          },\n          this\n        )\n      ] }, void 0, true, {\n        fileName: \"/home/will/local_dev/portfolio/apps/robin-noguier/src/components/Hero/HeroSectionWebGL.tsx\",\n        lineNumber: 119,\n        columnNumber: 9\n      }, this)\n    ] }, void 0, true, {\n      fileName: \"/home/will/local_dev/portfolio/apps/robin-noguier/src/components/Hero/HeroSectionWebGL.tsx\",\n      lineNumber: 111,\n      columnNumber: 7\n    }, this),\n    /* @__PURE__ */ jsxDEV(\"div\", { className: styles.scrollIndicator, children: [\n      /* @__PURE__ */ jsxDEV(\"span\", { className: styles.scrollTextDesktop, children: \"Scroll / Drag to explore\" }, void 0, false, {\n        fileName: \"/home/will/local_dev/portfolio/apps/robin-noguier/src/components/Hero/HeroSectionWebGL.tsx\",\n        lineNumber: 134,\n        columnNumber: 9\n      }, this),\n      /* @__PURE__ */ jsxDEV(\"span\", { className: styles.scrollTextMobile, children: \"Swipe to explore\" }, void 0, false, {\n        fileName: \"/home/will/local_dev/portfolio/apps/robin-noguier/src/components/Hero/HeroSectionWebGL.tsx\",\n        lineNumber: 135,\n        columnNumber: 9\n      }, this),\n      /* @__PURE__ */ jsxDEV(\"div\", { className: `${styles.scrollLine} scrollLine` }, void 0, false, {\n        fileName: \"/home/will/local_dev/portfolio/apps/robin-noguier/src/components/Hero/HeroSectionWebGL.tsx\",\n        lineNumber: 136,\n        columnNumber: 9\n      }, this)\n    ] }, void 0, true, {\n      fileName: \"/home/will/local_dev/portfolio/apps/robin-noguier/src/components/Hero/HeroSectionWebGL.tsx\",\n      lineNumber: 133,\n      columnNumber: 7\n    }, this)\n  ] }, void 0, true, {\n    fileName: \"/home/will/local_dev/portfolio/apps/robin-noguier/src/components/Hero/HeroSectionWebGL.tsx\",\n    lineNumber: 110,\n    columnNumber: 5\n  }, this);\n};\n_s(HeroSectionWebGL, \"qT27js4xT2PhXCZRxo7+/MxT0Yc=\", false, function() {\n  return [useMotion];\n});\n_c = HeroSectionWebGL;\nexport default HeroSectionWebGL;\nvar _c;\n$RefreshReg$(_c, \"HeroSectionWebGL\");\nif (import.meta.hot && !inWebWorker) {\n  window.$RefreshReg$ = prevRefreshReg;\n  window.$RefreshSig$ = prevRefreshSig;\n  RefreshRuntime.__hmr_import(import.meta.url).then((currentExports) => {\n    RefreshRuntime.registerExportsForReactRefresh(\"/home/will/local_dev/portfolio/apps/robin-noguier/src/components/Hero/HeroSectionWebGL.tsx\", currentExports);\n    import.meta.hot.accept((nextExports) => {\n      if (!nextExports)\n        return;\n      const invalidateMessage = RefreshRuntime.validateRefreshBoundaryAndEnqueueUpdate(currentExports, nextExports);\n      if (invalidateMessage)\n        import.meta.hot.invalidate(invalidateMessage);\n    });\n  });\n}\n\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJtYXBwaW5ncyI6IkFBK0dROzJCQS9HUjtBQUFnQkEsTUFBV0MsY0FBYyxPQUFPO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ2hELFNBQVNDLFlBQVk7QUFDckIsU0FBU0Msb0JBQW9CO0FBQzdCLFNBQVNDLGlCQUFpQjtBQUMxQixTQUFTQyxjQUFjO0FBQ3ZCLE9BQU9DLFlBQVk7QUFFbkIsTUFBTUMsbUJBQW1CQSxNQUFNO0FBQUFDLEtBQUE7QUFDN0IsUUFBTUMsZUFBZVIsT0FBdUIsSUFBSTtBQUNoRCxRQUFNLEVBQUVTLGdCQUFnQixJQUFJTixVQUFVO0FBQ3RDLFFBQU1PLFdBQVdWLE9BQTJCLElBQUk7QUFDaEQsUUFBTVcsY0FBY1gsT0FBNkIsSUFBSTtBQUNyRCxRQUFNWSxpQkFBaUJaLE9BQTZCLElBQUk7QUFDeEQsUUFBTWEsV0FBV2IsT0FBMEIsSUFBSTtBQUMvQyxRQUFNYyxhQUFhZCxPQUF1QixJQUFJO0FBRzlDRCxZQUFVLE1BQU07QUFDZCxRQUFJVyxTQUFTSztBQUFTTixzQkFBZ0IsYUFBYUMsUUFBUTtBQUMzRCxRQUFJQyxZQUFZSTtBQUFTTixzQkFBZ0IsY0FBY0UsV0FBVztBQUNsRSxRQUFJQyxlQUFlRztBQUFTTixzQkFBZ0Isb0JBQW9CRyxjQUFjO0FBQzlFLFFBQUlDLFNBQVNFO0FBQVNOLHNCQUFnQixjQUFjSSxRQUFRO0FBQzVELFFBQUlDLFdBQVdDO0FBQVNOLHNCQUFnQixnQkFBZ0JLLFVBQVU7QUFBQSxFQUNwRSxHQUFHLENBQUNMLGVBQWUsQ0FBQztBQUVwQlYsWUFBVSxNQUFNO0FBQ2QsUUFBSSxDQUFDUyxhQUFhTztBQUFTO0FBRTNCLFVBQU1DLE1BQU1mLEtBQUtnQixRQUFRLE1BQU07QUFFN0IsWUFBTUMsbUJBQ0pWLGFBQWFPLFFBQVNJLGlCQUFpQixpQkFBaUI7QUFFMURELHVCQUFpQkUsUUFBUSxDQUFDQyxPQUFPO0FBQy9CLGNBQU1DLFVBQVVEO0FBRWhCLGNBQU1FLGtCQUFrQkEsQ0FBQ0MsTUFBa0I7QUFDekMsZ0JBQU1DLE9BQU9ILFFBQVFJLHNCQUFzQjtBQUMzQyxnQkFBTUMsSUFBSUgsRUFBRUksVUFBVUgsS0FBS0ksT0FBT0osS0FBS0ssUUFBUTtBQUMvQyxnQkFBTUMsSUFBSVAsRUFBRVEsVUFBVVAsS0FBS1EsTUFBTVIsS0FBS1MsU0FBUztBQUUvQ2pDLGVBQUtrQyxHQUFHYixTQUFTO0FBQUEsWUFDZkssR0FBR0EsSUFBSTtBQUFBLFlBQ1BJLEdBQUdBLElBQUk7QUFBQSxZQUNQSyxVQUFVO0FBQUEsWUFDVkMsTUFBTTtBQUFBLFVBQ1IsQ0FBQztBQUFBLFFBQ0g7QUFFQSxjQUFNQyxtQkFBbUJBLE1BQU07QUFDN0JyQyxlQUFLa0MsR0FBR2IsU0FBUztBQUFBLFlBQ2ZLLEdBQUc7QUFBQSxZQUNISSxHQUFHO0FBQUEsWUFDSEssVUFBVTtBQUFBLFlBQ1ZDLE1BQU07QUFBQSxVQUNSLENBQUM7QUFBQSxRQUNIO0FBRUFmLGdCQUFRaUIsaUJBQWlCLGFBQWFoQixlQUFlO0FBQ3JERCxnQkFBUWlCLGlCQUFpQixjQUFjRCxnQkFBZ0I7QUFHdkQsZUFBTyxNQUFNO0FBQ1hoQixrQkFBUWtCLG9CQUFvQixhQUFhakIsZUFBZTtBQUN4REQsa0JBQVFrQixvQkFBb0IsY0FBY0YsZ0JBQWdCO0FBQUEsUUFDNUQ7QUFBQSxNQUNGLENBQUM7QUFHRHJDLFdBQUt3QyxLQUFLLGNBQWM7QUFBQSxRQUN0QlYsR0FBRztBQUFBLFFBQ0hXLFNBQVM7QUFBQSxRQUNUTixVQUFVO0FBQUEsUUFDVkMsTUFBTTtBQUFBLFFBQ05NLE9BQU87QUFBQSxNQUNULENBQUM7QUFFRDFDLFdBQUt3QyxLQUFLLG1DQUFtQztBQUFBLFFBQzNDVixHQUFHO0FBQUEsUUFDSFcsU0FBUztBQUFBLFFBQ1ROLFVBQVU7QUFBQSxRQUNWUSxTQUFTO0FBQUEsUUFDVFAsTUFBTTtBQUFBLFFBQ05NLE9BQU87QUFBQSxNQUNULENBQUM7QUFFRDFDLFdBQUt3QyxLQUFLLGdCQUFnQjtBQUFBLFFBQ3hCVixHQUFHO0FBQUEsUUFDSFcsU0FBUztBQUFBLFFBQ1ROLFVBQVU7QUFBQSxRQUNWQyxNQUFNO0FBQUEsUUFDTk0sT0FBTztBQUFBLE1BQ1QsQ0FBQztBQUdEMUMsV0FBS2tDLEdBQUcsZUFBZTtBQUFBLFFBQ3JCVSxRQUFRO0FBQUEsUUFDUkMsaUJBQWlCO0FBQUEsUUFDakJWLFVBQVU7QUFBQSxRQUNWQyxNQUFNO0FBQUEsUUFDTlUsUUFBUTtBQUFBLFFBQ1JDLE1BQU07QUFBQSxNQUNSLENBQUM7QUFBQSxJQUNILEdBQUd4QyxZQUFZO0FBRWYsV0FBTyxNQUFNUSxJQUFJaUMsT0FBTztBQUFBLEVBQzFCLEdBQUcsRUFBRTtBQUVMLFNBQ0UsdUJBQUMsU0FBSSxLQUFLekMsY0FBYyxXQUFXSCxPQUFPNkMsZUFDeEM7QUFBQSwyQkFBQyxTQUFJLFdBQVc3QyxPQUFPOEMsZ0JBQ3JCO0FBQUEsNkJBQUMsUUFBRyxLQUFLekMsVUFBVSxXQUFXLEdBQUdMLE9BQU8rQyxTQUFTLGNBQWVoRCxpQkFBT2lELEtBQUtDLFFBQTVFO0FBQUE7QUFBQTtBQUFBO0FBQUEsYUFBaUY7QUFBQSxNQUNqRix1QkFBQyxPQUFFLEtBQUszQyxhQUFhLFdBQVcsR0FBR04sT0FBT2tELFlBQVksaUJBQ25EbkQsaUJBQU9pRCxLQUFLRyxTQURmO0FBQUE7QUFBQTtBQUFBO0FBQUEsYUFFQTtBQUFBLE1BQ0EsdUJBQUMsT0FBRSxLQUFLNUMsZ0JBQWdCLFdBQVcsR0FBR1AsT0FBT29ELGVBQWUsb0JBQ3pEckQsaUJBQU9pRCxLQUFLSyxlQURmO0FBQUE7QUFBQTtBQUFBO0FBQUEsYUFFQTtBQUFBLE1BQ0EsdUJBQUMsU0FBSSxLQUFLNUMsWUFBWSxXQUFXLEdBQUdULE9BQU9zRCxXQUFXLGdCQUNwRDtBQUFBLCtCQUFDLGdCQUFhLFdBQVd0RCxPQUFPdUQsZ0JBQWhDO0FBQUE7QUFBQTtBQUFBO0FBQUEsZUFBNkM7QUFBQSxRQUM3Qyx1QkFBQyxVQUFLLFdBQVd2RCxPQUFPd0QsZ0JBQWdCLGlCQUF4QztBQUFBO0FBQUE7QUFBQTtBQUFBLGVBQXlDO0FBQUEsUUFDekM7QUFBQSxVQUFDO0FBQUE7QUFBQSxZQUNDLEtBQUtoRDtBQUFBQSxZQUNMLE1BQU0sVUFBVVQsT0FBT2lELEtBQUtTLEtBQUs7QUFBQSxZQUNqQyxXQUFXekQsT0FBTzBEO0FBQUFBLFlBQ2xCLGlCQUFhO0FBQUEsWUFFWjNELGlCQUFPaUQsS0FBS1M7QUFBQUE7QUFBQUEsVUFOZjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsUUFPQTtBQUFBLFdBVkY7QUFBQTtBQUFBO0FBQUE7QUFBQSxhQVdBO0FBQUEsU0FuQkY7QUFBQTtBQUFBO0FBQUE7QUFBQSxXQW9CQTtBQUFBLElBRUEsdUJBQUMsU0FBSSxXQUFXekQsT0FBTzJELGlCQUNyQjtBQUFBLDZCQUFDLFVBQUssV0FBVzNELE9BQU80RCxtQkFBbUIsd0NBQTNDO0FBQUE7QUFBQTtBQUFBO0FBQUEsYUFBbUU7QUFBQSxNQUNuRSx1QkFBQyxVQUFLLFdBQVc1RCxPQUFPNkQsa0JBQWtCLGdDQUExQztBQUFBO0FBQUE7QUFBQTtBQUFBLGFBQTBEO0FBQUEsTUFDMUQsdUJBQUMsU0FBSSxXQUFXLEdBQUc3RCxPQUFPOEQsVUFBVSxpQkFBcEM7QUFBQTtBQUFBO0FBQUE7QUFBQSxhQUFtRDtBQUFBLFNBSHJEO0FBQUE7QUFBQTtBQUFBO0FBQUEsV0FJQTtBQUFBLE9BM0JGO0FBQUE7QUFBQTtBQUFBO0FBQUEsU0E0QkE7QUFFSjtBQUFDNUQsR0FwSUtELGtCQUFnQjtBQUFBLFVBRVFILFNBQVM7QUFBQTtBQUFBaUUsS0FGakM5RDtBQXNJTixlQUFlQTtBQUFnQixJQUFBOEQ7QUFBQUMsYUFBQUQsSUFBQSIsIm5hbWVzIjpbInVzZUVmZmVjdCIsInVzZVJlZiIsImdzYXAiLCJLaW5ldGljUGhvbmUiLCJ1c2VNb3Rpb24iLCJjb25maWciLCJzdHlsZXMiLCJIZXJvU2VjdGlvbldlYkdMIiwiX3MiLCJjb250YWluZXJSZWYiLCJyZWdpc3RlckVsZW1lbnQiLCJ0aXRsZVJlZiIsInN1YnRpdGxlUmVmIiwiaW5zdGl0dXRpb25SZWYiLCJlbWFpbFJlZiIsImNvbnRhY3RSZWYiLCJjdXJyZW50IiwiY3R4IiwiY29udGV4dCIsIm1hZ25ldGljRWxlbWVudHMiLCJxdWVyeVNlbGVjdG9yQWxsIiwiZm9yRWFjaCIsImVsIiwiZWxlbWVudCIsImhhbmRsZU1vdXNlTW92ZSIsImUiLCJyZWN0IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwieCIsImNsaWVudFgiLCJsZWZ0Iiwid2lkdGgiLCJ5IiwiY2xpZW50WSIsInRvcCIsImhlaWdodCIsInRvIiwiZHVyYXRpb24iLCJlYXNlIiwiaGFuZGxlTW91c2VMZWF2ZSIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiZnJvbSIsIm9wYWNpdHkiLCJkZWxheSIsInN0YWdnZXIiLCJzY2FsZVkiLCJ0cmFuc2Zvcm1PcmlnaW4iLCJyZXBlYXQiLCJ5b3lvIiwicmV2ZXJ0IiwiaGVyb0NvbnRhaW5lciIsIm92ZXJsYXlDb250ZW50IiwiaGVyb1RpdGxlIiwiaGVybyIsIm5hbWUiLCJoZXJvU3VidGl0bGUiLCJ0aXRsZSIsImhlcm9JbnN0aXR1dGlvbiIsImluc3RpdHV0aW9uIiwiaGVyb0NvbnRhY3QiLCJjb250YWN0UGhvbmUiLCJjb250YWN0RGl2aWRlciIsImVtYWlsIiwiY29udGFjdExpbmsiLCJzY3JvbGxJbmRpY2F0b3IiLCJzY3JvbGxUZXh0RGVza3RvcCIsInNjcm9sbFRleHRNb2JpbGUiLCJzY3JvbGxMaW5lIiwiX2MiLCIkUmVmcmVzaFJlZyQiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZXMiOlsiSGVyb1NlY3Rpb25XZWJHTC50c3giXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0LCB7IHVzZUVmZmVjdCwgdXNlUmVmIH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgeyBnc2FwIH0gZnJvbSAnZ3NhcCdcbmltcG9ydCB7IEtpbmV0aWNQaG9uZSB9IGZyb20gJy4uL0tpbmV0aWNQaG9uZSdcbmltcG9ydCB7IHVzZU1vdGlvbiB9IGZyb20gJ0ByeWxlZWJyYXNzZXVyL21vdGlvbi1zeXN0ZW0nXG5pbXBvcnQgeyBjb25maWcgfSBmcm9tICcuLi8uLi9jb25maWcnXG5pbXBvcnQgc3R5bGVzIGZyb20gJy4vSGVyb1NlY3Rpb24ubW9kdWxlLmNzcydcblxuY29uc3QgSGVyb1NlY3Rpb25XZWJHTCA9ICgpID0+IHtcbiAgY29uc3QgY29udGFpbmVyUmVmID0gdXNlUmVmPEhUTUxEaXZFbGVtZW50PihudWxsKVxuICBjb25zdCB7IHJlZ2lzdGVyRWxlbWVudCB9ID0gdXNlTW90aW9uKClcbiAgY29uc3QgdGl0bGVSZWYgPSB1c2VSZWY8SFRNTEhlYWRpbmdFbGVtZW50PihudWxsKVxuICBjb25zdCBzdWJ0aXRsZVJlZiA9IHVzZVJlZjxIVE1MUGFyYWdyYXBoRWxlbWVudD4obnVsbClcbiAgY29uc3QgaW5zdGl0dXRpb25SZWYgPSB1c2VSZWY8SFRNTFBhcmFncmFwaEVsZW1lbnQ+KG51bGwpXG4gIGNvbnN0IGVtYWlsUmVmID0gdXNlUmVmPEhUTUxBbmNob3JFbGVtZW50PihudWxsKVxuICBjb25zdCBjb250YWN0UmVmID0gdXNlUmVmPEhUTUxEaXZFbGVtZW50PihudWxsKVxuXG4gIC8vIFJlZ2lzdGVyIGVsZW1lbnRzIHdpdGggbW90aW9uIHN5c3RlbVxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICh0aXRsZVJlZi5jdXJyZW50KSByZWdpc3RlckVsZW1lbnQoJ2hlcm8tbmFtZScsIHRpdGxlUmVmKVxuICAgIGlmIChzdWJ0aXRsZVJlZi5jdXJyZW50KSByZWdpc3RlckVsZW1lbnQoJ2hlcm8tdGl0bGUnLCBzdWJ0aXRsZVJlZilcbiAgICBpZiAoaW5zdGl0dXRpb25SZWYuY3VycmVudCkgcmVnaXN0ZXJFbGVtZW50KCdoZXJvLWluc3RpdHV0aW9uJywgaW5zdGl0dXRpb25SZWYpXG4gICAgaWYgKGVtYWlsUmVmLmN1cnJlbnQpIHJlZ2lzdGVyRWxlbWVudCgnaGVyby1lbWFpbCcsIGVtYWlsUmVmKVxuICAgIGlmIChjb250YWN0UmVmLmN1cnJlbnQpIHJlZ2lzdGVyRWxlbWVudCgnaGVyby1jb250YWN0JywgY29udGFjdFJlZilcbiAgfSwgW3JlZ2lzdGVyRWxlbWVudF0pXG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWNvbnRhaW5lclJlZi5jdXJyZW50KSByZXR1cm5cblxuICAgIGNvbnN0IGN0eCA9IGdzYXAuY29udGV4dCgoKSA9PiB7XG4gICAgICAvLyBNYWduZXRpYyBob3ZlciBlZmZlY3QgZm9yIGVtYWlsIGxpbmtcbiAgICAgIGNvbnN0IG1hZ25ldGljRWxlbWVudHMgPVxuICAgICAgICBjb250YWluZXJSZWYuY3VycmVudCEucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtbWFnbmV0aWNdJylcblxuICAgICAgbWFnbmV0aWNFbGVtZW50cy5mb3JFYWNoKChlbCkgPT4ge1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gZWwgYXMgSFRNTEVsZW1lbnRcblxuICAgICAgICBjb25zdCBoYW5kbGVNb3VzZU1vdmUgPSAoZTogTW91c2VFdmVudCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gICAgICAgICAgY29uc3QgeCA9IGUuY2xpZW50WCAtIHJlY3QubGVmdCAtIHJlY3Qud2lkdGggLyAyXG4gICAgICAgICAgY29uc3QgeSA9IGUuY2xpZW50WSAtIHJlY3QudG9wIC0gcmVjdC5oZWlnaHQgLyAyXG5cbiAgICAgICAgICBnc2FwLnRvKGVsZW1lbnQsIHtcbiAgICAgICAgICAgIHg6IHggKiAwLjMsXG4gICAgICAgICAgICB5OiB5ICogMC4zLFxuICAgICAgICAgICAgZHVyYXRpb246IDAuMyxcbiAgICAgICAgICAgIGVhc2U6ICdwb3dlcjIub3V0JyxcbiAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgaGFuZGxlTW91c2VMZWF2ZSA9ICgpID0+IHtcbiAgICAgICAgICBnc2FwLnRvKGVsZW1lbnQsIHtcbiAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICB5OiAwLFxuICAgICAgICAgICAgZHVyYXRpb246IDAuMyxcbiAgICAgICAgICAgIGVhc2U6ICdwb3dlcjIub3V0JyxcbiAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBoYW5kbGVNb3VzZU1vdmUpXG4gICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIGhhbmRsZU1vdXNlTGVhdmUpXG5cbiAgICAgICAgLy8gQ2xlYW51cFxuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgaGFuZGxlTW91c2VNb3ZlKVxuICAgICAgICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIGhhbmRsZU1vdXNlTGVhdmUpXG4gICAgICAgIH1cbiAgICAgIH0pXG5cbiAgICAgIC8vIEFuaW1hdGUgaGVybyBjb250ZW50IG9uIGxvYWRcbiAgICAgIGdzYXAuZnJvbSgnLmhlcm9UaXRsZScsIHtcbiAgICAgICAgeTogNTAsXG4gICAgICAgIG9wYWNpdHk6IDAsXG4gICAgICAgIGR1cmF0aW9uOiAxLFxuICAgICAgICBlYXNlOiAncG93ZXIzLm91dCcsXG4gICAgICAgIGRlbGF5OiAwLjIsXG4gICAgICB9KVxuXG4gICAgICBnc2FwLmZyb20oJy5oZXJvU3VidGl0bGUsIC5oZXJvSW5zdGl0dXRpb24nLCB7XG4gICAgICAgIHk6IDMwLFxuICAgICAgICBvcGFjaXR5OiAwLFxuICAgICAgICBkdXJhdGlvbjogMSxcbiAgICAgICAgc3RhZ2dlcjogMC4xLFxuICAgICAgICBlYXNlOiAncG93ZXIzLm91dCcsXG4gICAgICAgIGRlbGF5OiAwLjQsXG4gICAgICB9KVxuXG4gICAgICBnc2FwLmZyb20oJy5oZXJvQ29udGFjdCcsIHtcbiAgICAgICAgeTogMjAsXG4gICAgICAgIG9wYWNpdHk6IDAsXG4gICAgICAgIGR1cmF0aW9uOiAxLFxuICAgICAgICBlYXNlOiAncG93ZXIzLm91dCcsXG4gICAgICAgIGRlbGF5OiAwLjcsXG4gICAgICB9KVxuXG4gICAgICAvLyBBbmltYXRlIHNjcm9sbCBpbmRpY2F0b3JcbiAgICAgIGdzYXAudG8oJy5zY3JvbGxMaW5lJywge1xuICAgICAgICBzY2FsZVk6IDAsXG4gICAgICAgIHRyYW5zZm9ybU9yaWdpbjogJ3RvcCcsXG4gICAgICAgIGR1cmF0aW9uOiAyLFxuICAgICAgICBlYXNlOiAncG93ZXIyLmluT3V0JyxcbiAgICAgICAgcmVwZWF0OiAtMSxcbiAgICAgICAgeW95bzogdHJ1ZSxcbiAgICAgIH0pXG4gICAgfSwgY29udGFpbmVyUmVmKVxuXG4gICAgcmV0dXJuICgpID0+IGN0eC5yZXZlcnQoKVxuICB9LCBbXSlcblxuICByZXR1cm4gKFxuICAgIDxkaXYgcmVmPXtjb250YWluZXJSZWZ9IGNsYXNzTmFtZT17c3R5bGVzLmhlcm9Db250YWluZXJ9PlxuICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5vdmVybGF5Q29udGVudH0+XG4gICAgICAgIDxoMSByZWY9e3RpdGxlUmVmfSBjbGFzc05hbWU9e2Ake3N0eWxlcy5oZXJvVGl0bGV9IGhlcm9UaXRsZWB9Pntjb25maWcuaGVyby5uYW1lfTwvaDE+XG4gICAgICAgIDxwIHJlZj17c3VidGl0bGVSZWZ9IGNsYXNzTmFtZT17YCR7c3R5bGVzLmhlcm9TdWJ0aXRsZX0gaGVyb1N1YnRpdGxlYH0+XG4gICAgICAgICAge2NvbmZpZy5oZXJvLnRpdGxlfVxuICAgICAgICA8L3A+XG4gICAgICAgIDxwIHJlZj17aW5zdGl0dXRpb25SZWZ9IGNsYXNzTmFtZT17YCR7c3R5bGVzLmhlcm9JbnN0aXR1dGlvbn0gaGVyb0luc3RpdHV0aW9uYH0+XG4gICAgICAgICAge2NvbmZpZy5oZXJvLmluc3RpdHV0aW9ufVxuICAgICAgICA8L3A+XG4gICAgICAgIDxkaXYgcmVmPXtjb250YWN0UmVmfSBjbGFzc05hbWU9e2Ake3N0eWxlcy5oZXJvQ29udGFjdH0gaGVyb0NvbnRhY3RgfT5cbiAgICAgICAgICA8S2luZXRpY1Bob25lIGNsYXNzTmFtZT17c3R5bGVzLmNvbnRhY3RQaG9uZX0gLz5cbiAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9e3N0eWxlcy5jb250YWN0RGl2aWRlcn0+fDwvc3Bhbj5cbiAgICAgICAgICA8YVxuICAgICAgICAgICAgcmVmPXtlbWFpbFJlZn1cbiAgICAgICAgICAgIGhyZWY9e2BtYWlsdG86JHtjb25maWcuaGVyby5lbWFpbH1gfVxuICAgICAgICAgICAgY2xhc3NOYW1lPXtzdHlsZXMuY29udGFjdExpbmt9XG4gICAgICAgICAgICBkYXRhLW1hZ25ldGljXG4gICAgICAgICAgPlxuICAgICAgICAgICAge2NvbmZpZy5oZXJvLmVtYWlsfVxuICAgICAgICAgIDwvYT5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cblxuICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5zY3JvbGxJbmRpY2F0b3J9PlxuICAgICAgICA8c3BhbiBjbGFzc05hbWU9e3N0eWxlcy5zY3JvbGxUZXh0RGVza3RvcH0+U2Nyb2xsIC8gRHJhZyB0byBleHBsb3JlPC9zcGFuPlxuICAgICAgICA8c3BhbiBjbGFzc05hbWU9e3N0eWxlcy5zY3JvbGxUZXh0TW9iaWxlfT5Td2lwZSB0byBleHBsb3JlPC9zcGFuPlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT17YCR7c3R5bGVzLnNjcm9sbExpbmV9IHNjcm9sbExpbmVgfT48L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICApXG59XG5cbmV4cG9ydCBkZWZhdWx0IEhlcm9TZWN0aW9uV2ViR0xcbiJdLCJmaWxlIjoiL2hvbWUvd2lsbC9sb2NhbF9kZXYvcG9ydGZvbGlvL2FwcHMvcm9iaW4tbm9ndWllci9zcmMvY29tcG9uZW50cy9IZXJvL0hlcm9TZWN0aW9uV2ViR0wudHN4In0=",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 21431,
            "count": 1
          },
          {
            "startOffset": 452,
            "endOffset": 488,
            "count": 0
          },
          {
            "startOffset": 625,
            "endOffset": 796,
            "count": 0
          }
        ]
      },
      {
        "functionName": "window.$RefreshReg$",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 901,
            "endOffset": 1055,
            "count": 1
          }
        ]
      },
      {
        "functionName": "HeroSectionWebGL",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1777,
            "endOffset": 8500,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 2061,
            "endOffset": 2466,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 2500,
            "endOffset": 4346,
            "count": 2
          },
          {
            "startOffset": 2545,
            "endOffset": 2552,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 2582,
            "endOffset": 4295,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 2710,
            "endOffset": 3625,
            "count": 2
          }
        ]
      },
      {
        "functionName": "handleMouseMove",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2780,
            "endOffset": 3123,
            "count": 0
          }
        ]
      },
      {
        "functionName": "handleMouseLeave",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 3158,
            "endOffset": 3312,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 3459,
            "endOffset": 3616,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 4323,
            "endOffset": 4341,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 8562,
            "endOffset": 8598,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 8874,
            "endOffset": 9355,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 9084,
            "endOffset": 9349,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5173/src/components/CustomCursor/CustomCursor.tsx",
    "scriptId": "31",
    "source": "import { createHotContext as __vite__createHotContext } from \"/@vite/client\";import.meta.hot = __vite__createHotContext(\"/src/components/CustomCursor/CustomCursor.tsx\");import __vite__cjsImport0_react_jsxDevRuntime from \"/node_modules/.vite/deps/react_jsx-dev-runtime.js?v=a50bb159\"; const Fragment = __vite__cjsImport0_react_jsxDevRuntime[\"Fragment\"]; const jsxDEV = __vite__cjsImport0_react_jsxDevRuntime[\"jsxDEV\"];\nimport RefreshRuntime from \"/@react-refresh\";\nconst inWebWorker = typeof WorkerGlobalScope !== \"undefined\" && self instanceof WorkerGlobalScope;\nlet prevRefreshReg;\nlet prevRefreshSig;\nif (import.meta.hot && !inWebWorker) {\n  if (!window.__vite_plugin_react_preamble_installed__) {\n    throw new Error(\"@vitejs/plugin-react can't detect preamble. Something is wrong. See https://github.com/vitejs/vite-plugin-react/pull/11#discussion_r430879201\");\n  }\n  prevRefreshReg = window.$RefreshReg$;\n  prevRefreshSig = window.$RefreshSig$;\n  window.$RefreshReg$ = (type, id) => {\n    RefreshRuntime.register(type, \"/home/will/local_dev/portfolio/apps/robin-noguier/src/components/CustomCursor/CustomCursor.tsx \" + id);\n  };\n  window.$RefreshSig$ = RefreshRuntime.createSignatureFunctionForTransform;\n}\nvar _s = $RefreshSig$();\nimport __vite__cjsImport3_react from \"/node_modules/.vite/deps/react.js?v=a50bb159\"; const useEffect = __vite__cjsImport3_react[\"useEffect\"]; const useRef = __vite__cjsImport3_react[\"useRef\"]; const useState = __vite__cjsImport3_react[\"useState\"];\nimport styles from \"/src/components/CustomCursor/CustomCursor.module.css\";\nconst CustomCursor = () => {\n  _s();\n  const cursorRef = useRef(null);\n  const cursorDotRef = useRef(null);\n  const [isHovering, setIsHovering] = useState(false);\n  const [isClicking, setIsClicking] = useState(false);\n  const position = useRef({ x: 0, y: 0 });\n  const magnetTargets = useRef(null);\n  useEffect(() => {\n    const cursor = cursorRef.current;\n    const cursorDot = cursorDotRef.current;\n    if (!cursor || !cursorDot)\n      return;\n    document.body.style.cursor = \"none\";\n    magnetTargets.current = document.querySelectorAll(\"[data-magnetic]\");\n    let rafId;\n    const updateCursor = () => {\n      cursor.style.transform = `translate3d(${position.current.x}px, ${position.current.y}px, 0) translate(-50%, -50%)`;\n      cursorDot.style.transform = `translate3d(${position.current.x}px, ${position.current.y}px, 0) translate(-50%, -50%)`;\n    };\n    const onMouseMove = (e) => {\n      position.current = { x: e.clientX, y: e.clientY };\n      updateCursor();\n    };\n    const onMouseEnter = (e) => {\n      const target = e.target;\n      if (target && target.matches && target.matches(\"a, button, [data-hover]\")) {\n        setIsHovering(true);\n      }\n    };\n    const onMouseLeave = (e) => {\n      const target = e.target;\n      if (target && target.matches && target.matches(\"a, button, [data-hover]\")) {\n        setIsHovering(false);\n      }\n    };\n    const onMouseDown = () => setIsClicking(true);\n    const onMouseUp = () => setIsClicking(false);\n    const onMouseEnterWindow = () => {\n      cursor.style.opacity = \"0.8\";\n      cursorDot.style.opacity = \"0.9\";\n    };\n    const onMouseLeaveWindow = () => {\n      cursor.style.opacity = \"0\";\n      cursorDot.style.opacity = \"0\";\n    };\n    document.addEventListener(\"mousemove\", onMouseMove);\n    document.addEventListener(\"mouseenter\", onMouseEnter, true);\n    document.addEventListener(\"mouseleave\", onMouseLeave, true);\n    document.addEventListener(\"mousedown\", onMouseDown);\n    document.addEventListener(\"mouseup\", onMouseUp);\n    document.addEventListener(\"mouseenter\", onMouseEnterWindow);\n    document.addEventListener(\"mouseleave\", onMouseLeaveWindow);\n    cursor.style.opacity = \"0\";\n    cursorDot.style.opacity = \"0\";\n    return () => {\n      document.body.style.cursor = \"auto\";\n      document.removeEventListener(\"mousemove\", onMouseMove);\n      document.removeEventListener(\"mouseenter\", onMouseEnter, true);\n      document.removeEventListener(\"mouseleave\", onMouseLeave, true);\n      document.removeEventListener(\"mousedown\", onMouseDown);\n      document.removeEventListener(\"mouseup\", onMouseUp);\n      document.removeEventListener(\"mouseenter\", onMouseEnterWindow);\n      document.removeEventListener(\"mouseleave\", onMouseLeaveWindow);\n      if (rafId)\n        cancelAnimationFrame(rafId);\n    };\n  }, []);\n  const prefersReducedMotion = window.matchMedia(\n    \"(prefers-reduced-motion: reduce)\"\n  ).matches;\n  if (prefersReducedMotion)\n    return null;\n  return /* @__PURE__ */ jsxDEV(Fragment, { children: [\n    /* @__PURE__ */ jsxDEV(\n      \"div\",\n      {\n        ref: cursorRef,\n        className: `${styles.cursor} ${isHovering ? styles.hovering : \"\"} ${isClicking ? styles.clicking : \"\"}`,\n        \"aria-hidden\": \"true\"\n      },\n      void 0,\n      false,\n      {\n        fileName: \"/home/will/local_dev/portfolio/apps/robin-noguier/src/components/CustomCursor/CustomCursor.tsx\",\n        lineNumber: 112,\n        columnNumber: 7\n      },\n      this\n    ),\n    /* @__PURE__ */ jsxDEV(\"div\", { ref: cursorDotRef, className: styles.cursorDot, \"aria-hidden\": \"true\" }, void 0, false, {\n      fileName: \"/home/will/local_dev/portfolio/apps/robin-noguier/src/components/CustomCursor/CustomCursor.tsx\",\n      lineNumber: 117,\n      columnNumber: 7\n    }, this)\n  ] }, void 0, true, {\n    fileName: \"/home/will/local_dev/portfolio/apps/robin-noguier/src/components/CustomCursor/CustomCursor.tsx\",\n    lineNumber: 111,\n    columnNumber: 5\n  }, this);\n};\n_s(CustomCursor, \"P9ndQXpOtvrW6Z5EtgaaEyqPaU0=\");\n_c = CustomCursor;\nexport default CustomCursor;\nvar _c;\n$RefreshReg$(_c, \"CustomCursor\");\nif (import.meta.hot && !inWebWorker) {\n  window.$RefreshReg$ = prevRefreshReg;\n  window.$RefreshSig$ = prevRefreshSig;\n  RefreshRuntime.__hmr_import(import.meta.url).then((currentExports) => {\n    RefreshRuntime.registerExportsForReactRefresh(\"/home/will/local_dev/portfolio/apps/robin-noguier/src/components/CustomCursor/CustomCursor.tsx\", currentExports);\n    import.meta.hot.accept((nextExports) => {\n      if (!nextExports)\n        return;\n      const invalidateMessage = RefreshRuntime.validateRefreshBoundaryAndEnqueueUpdate(currentExports, nextExports);\n      if (invalidateMessage)\n        import.meta.hot.invalidate(invalidateMessage);\n    });\n  });\n}\n\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJtYXBwaW5ncyI6IkFBOEdJLG1CQUNFLGNBREY7MkJBOUdKO0FBQWdCQSxNQUFXQyxjQUFRQyxPQUFRLHNCQUFlO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQzFELE9BQU9DLFlBQVk7QUFPbkIsTUFBTUMsZUFBeUJBLE1BQU07QUFBQUMsS0FBQTtBQUNuQyxRQUFNQyxZQUFZTCxPQUF1QixJQUFJO0FBQzdDLFFBQU1NLGVBQWVOLE9BQXVCLElBQUk7QUFDaEQsUUFBTSxDQUFDTyxZQUFZQyxhQUFhLElBQUlQLFNBQVMsS0FBSztBQUNsRCxRQUFNLENBQUNRLFlBQVlDLGFBQWEsSUFBSVQsU0FBUyxLQUFLO0FBQ2xELFFBQU1VLFdBQVdYLE9BQWlCLEVBQUVZLEdBQUcsR0FBR0MsR0FBRyxFQUFFLENBQUM7QUFDaEQsUUFBTUMsZ0JBQWdCZCxPQUFtQyxJQUFJO0FBRTdERCxZQUFVLE1BQU07QUFDZCxVQUFNZ0IsU0FBU1YsVUFBVVc7QUFDekIsVUFBTUMsWUFBWVgsYUFBYVU7QUFDL0IsUUFBSSxDQUFDRCxVQUFVLENBQUNFO0FBQVc7QUFHM0JDLGFBQVNDLEtBQUtDLE1BQU1MLFNBQVM7QUFHN0JELGtCQUFjRSxVQUFVRSxTQUFTRyxpQkFBaUIsaUJBQWlCO0FBRW5FLFFBQUlDO0FBRUosVUFBTUMsZUFBZUEsTUFBTTtBQUV6QlIsYUFBT0ssTUFBTUksWUFBWSxlQUFlYixTQUFTSyxRQUFRSixDQUFDLE9BQU9ELFNBQVNLLFFBQVFILENBQUM7QUFDbkZJLGdCQUFVRyxNQUFNSSxZQUFZLGVBQWViLFNBQVNLLFFBQVFKLENBQUMsT0FBT0QsU0FBU0ssUUFBUUgsQ0FBQztBQUFBLElBQ3hGO0FBRUEsVUFBTVksY0FBY0EsQ0FBQ0MsTUFBa0I7QUFDckNmLGVBQVNLLFVBQVUsRUFBRUosR0FBR2MsRUFBRUMsU0FBU2QsR0FBR2EsRUFBRUUsUUFBUTtBQUdoREwsbUJBQWE7QUFBQSxJQUNmO0FBRUEsVUFBTU0sZUFBZUEsQ0FBQ0gsTUFBa0I7QUFDdEMsWUFBTUksU0FBU0osRUFBRUk7QUFDakIsVUFDRUEsVUFDQUEsT0FBT0MsV0FDUEQsT0FBT0MsUUFBUSx5QkFBeUIsR0FDeEM7QUFDQXZCLHNCQUFjLElBQUk7QUFBQSxNQUNwQjtBQUFBLElBQ0Y7QUFFQSxVQUFNd0IsZUFBZUEsQ0FBQ04sTUFBa0I7QUFDdEMsWUFBTUksU0FBU0osRUFBRUk7QUFDakIsVUFDRUEsVUFDQUEsT0FBT0MsV0FDUEQsT0FBT0MsUUFBUSx5QkFBeUIsR0FDeEM7QUFDQXZCLHNCQUFjLEtBQUs7QUFBQSxNQUNyQjtBQUFBLElBQ0Y7QUFFQSxVQUFNeUIsY0FBY0EsTUFBTXZCLGNBQWMsSUFBSTtBQUM1QyxVQUFNd0IsWUFBWUEsTUFBTXhCLGNBQWMsS0FBSztBQUUzQyxVQUFNeUIscUJBQXFCQSxNQUFNO0FBQy9CcEIsYUFBT0ssTUFBTWdCLFVBQVU7QUFDdkJuQixnQkFBVUcsTUFBTWdCLFVBQVU7QUFBQSxJQUM1QjtBQUVBLFVBQU1DLHFCQUFxQkEsTUFBTTtBQUMvQnRCLGFBQU9LLE1BQU1nQixVQUFVO0FBQ3ZCbkIsZ0JBQVVHLE1BQU1nQixVQUFVO0FBQUEsSUFDNUI7QUFHQWxCLGFBQVNvQixpQkFBaUIsYUFBYWIsV0FBVztBQUNsRFAsYUFBU29CLGlCQUFpQixjQUFjVCxjQUFjLElBQUk7QUFDMURYLGFBQVNvQixpQkFBaUIsY0FBY04sY0FBYyxJQUFJO0FBQzFEZCxhQUFTb0IsaUJBQWlCLGFBQWFMLFdBQVc7QUFDbERmLGFBQVNvQixpQkFBaUIsV0FBV0osU0FBUztBQUM5Q2hCLGFBQVNvQixpQkFBaUIsY0FBY0gsa0JBQWtCO0FBQzFEakIsYUFBU29CLGlCQUFpQixjQUFjRCxrQkFBa0I7QUFHMUR0QixXQUFPSyxNQUFNZ0IsVUFBVTtBQUN2Qm5CLGNBQVVHLE1BQU1nQixVQUFVO0FBRTFCLFdBQU8sTUFBTTtBQUNYbEIsZUFBU0MsS0FBS0MsTUFBTUwsU0FBUztBQUM3QkcsZUFBU3FCLG9CQUFvQixhQUFhZCxXQUFXO0FBQ3JEUCxlQUFTcUIsb0JBQW9CLGNBQWNWLGNBQWMsSUFBSTtBQUM3RFgsZUFBU3FCLG9CQUFvQixjQUFjUCxjQUFjLElBQUk7QUFDN0RkLGVBQVNxQixvQkFBb0IsYUFBYU4sV0FBVztBQUNyRGYsZUFBU3FCLG9CQUFvQixXQUFXTCxTQUFTO0FBQ2pEaEIsZUFBU3FCLG9CQUFvQixjQUFjSixrQkFBa0I7QUFDN0RqQixlQUFTcUIsb0JBQW9CLGNBQWNGLGtCQUFrQjtBQUM3RCxVQUFJZjtBQUFPa0IsNkJBQXFCbEIsS0FBSztBQUFBLElBQ3ZDO0FBQUEsRUFDRixHQUFHLEVBQUU7QUFHTCxRQUFNbUIsdUJBQXVCQyxPQUFPQztBQUFBQSxJQUNsQztBQUFBLEVBQ0YsRUFBRVo7QUFDRixNQUFJVTtBQUFzQixXQUFPO0FBRWpDLFNBQ0UsbUNBQ0U7QUFBQTtBQUFBLE1BQUM7QUFBQTtBQUFBLFFBQ0MsS0FBS3BDO0FBQUFBLFFBQ0wsV0FBVyxHQUFHSCxPQUFPYSxNQUFNLElBQUlSLGFBQWFMLE9BQU8wQyxXQUFXLEVBQUUsSUFBSW5DLGFBQWFQLE9BQU8yQyxXQUFXLEVBQUU7QUFBQSxRQUNyRyxlQUFZO0FBQUE7QUFBQSxNQUhkO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUdvQjtBQUFBLElBRXBCLHVCQUFDLFNBQUksS0FBS3ZDLGNBQWMsV0FBV0osT0FBT2UsV0FBVyxlQUFZLFVBQWpFO0FBQUE7QUFBQTtBQUFBO0FBQUEsV0FBdUU7QUFBQSxPQU56RTtBQUFBO0FBQUE7QUFBQTtBQUFBLFNBT0E7QUFFSjtBQUFDYixHQS9HS0QsY0FBc0I7QUFBQTJDLEtBQXRCM0M7QUFpSE4sZUFBZUE7QUFBWSxJQUFBMkM7QUFBQUMsYUFBQUQsSUFBQSIsIm5hbWVzIjpbInVzZUVmZmVjdCIsInVzZVJlZiIsInVzZVN0YXRlIiwic3R5bGVzIiwiQ3VzdG9tQ3Vyc29yIiwiX3MiLCJjdXJzb3JSZWYiLCJjdXJzb3JEb3RSZWYiLCJpc0hvdmVyaW5nIiwic2V0SXNIb3ZlcmluZyIsImlzQ2xpY2tpbmciLCJzZXRJc0NsaWNraW5nIiwicG9zaXRpb24iLCJ4IiwieSIsIm1hZ25ldFRhcmdldHMiLCJjdXJzb3IiLCJjdXJyZW50IiwiY3Vyc29yRG90IiwiZG9jdW1lbnQiLCJib2R5Iiwic3R5bGUiLCJxdWVyeVNlbGVjdG9yQWxsIiwicmFmSWQiLCJ1cGRhdGVDdXJzb3IiLCJ0cmFuc2Zvcm0iLCJvbk1vdXNlTW92ZSIsImUiLCJjbGllbnRYIiwiY2xpZW50WSIsIm9uTW91c2VFbnRlciIsInRhcmdldCIsIm1hdGNoZXMiLCJvbk1vdXNlTGVhdmUiLCJvbk1vdXNlRG93biIsIm9uTW91c2VVcCIsIm9uTW91c2VFbnRlcldpbmRvdyIsIm9wYWNpdHkiLCJvbk1vdXNlTGVhdmVXaW5kb3ciLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwicHJlZmVyc1JlZHVjZWRNb3Rpb24iLCJ3aW5kb3ciLCJtYXRjaE1lZGlhIiwiaG92ZXJpbmciLCJjbGlja2luZyIsIl9jIiwiJFJlZnJlc2hSZWckIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VzIjpbIkN1c3RvbUN1cnNvci50c3giXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0LCB7IHVzZUVmZmVjdCwgdXNlUmVmLCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHN0eWxlcyBmcm9tICcuL0N1c3RvbUN1cnNvci5tb2R1bGUuY3NzJ1xuXG5pbnRlcmZhY2UgUG9zaXRpb24ge1xuICB4OiBudW1iZXJcbiAgeTogbnVtYmVyXG59XG5cbmNvbnN0IEN1c3RvbUN1cnNvcjogUmVhY3QuRkMgPSAoKSA9PiB7XG4gIGNvbnN0IGN1cnNvclJlZiA9IHVzZVJlZjxIVE1MRGl2RWxlbWVudD4obnVsbClcbiAgY29uc3QgY3Vyc29yRG90UmVmID0gdXNlUmVmPEhUTUxEaXZFbGVtZW50PihudWxsKVxuICBjb25zdCBbaXNIb3ZlcmluZywgc2V0SXNIb3ZlcmluZ10gPSB1c2VTdGF0ZShmYWxzZSlcbiAgY29uc3QgW2lzQ2xpY2tpbmcsIHNldElzQ2xpY2tpbmddID0gdXNlU3RhdGUoZmFsc2UpXG4gIGNvbnN0IHBvc2l0aW9uID0gdXNlUmVmPFBvc2l0aW9uPih7IHg6IDAsIHk6IDAgfSlcbiAgY29uc3QgbWFnbmV0VGFyZ2V0cyA9IHVzZVJlZjxOb2RlTGlzdE9mPEVsZW1lbnQ+IHwgbnVsbD4obnVsbClcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGN1cnNvciA9IGN1cnNvclJlZi5jdXJyZW50XG4gICAgY29uc3QgY3Vyc29yRG90ID0gY3Vyc29yRG90UmVmLmN1cnJlbnRcbiAgICBpZiAoIWN1cnNvciB8fCAhY3Vyc29yRG90KSByZXR1cm5cblxuICAgIC8vIEhpZGUgZGVmYXVsdCBjdXJzb3JcbiAgICBkb2N1bWVudC5ib2R5LnN0eWxlLmN1cnNvciA9ICdub25lJ1xuXG4gICAgLy8gSW5pdGlhbGl6ZSBtYWduZXRpYyB0YXJnZXRzXG4gICAgbWFnbmV0VGFyZ2V0cy5jdXJyZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtbWFnbmV0aWNdJylcblxuICAgIGxldCByYWZJZDogbnVtYmVyXG5cbiAgICBjb25zdCB1cGRhdGVDdXJzb3IgPSAoKSA9PiB7XG4gICAgICAvLyBVc2UgdHJhbnNmb3JtIGZvciBiZXR0ZXIgcGVyZm9ybWFuY2VcbiAgICAgIGN1cnNvci5zdHlsZS50cmFuc2Zvcm0gPSBgdHJhbnNsYXRlM2QoJHtwb3NpdGlvbi5jdXJyZW50Lnh9cHgsICR7cG9zaXRpb24uY3VycmVudC55fXB4LCAwKSB0cmFuc2xhdGUoLTUwJSwgLTUwJSlgXG4gICAgICBjdXJzb3JEb3Quc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZTNkKCR7cG9zaXRpb24uY3VycmVudC54fXB4LCAke3Bvc2l0aW9uLmN1cnJlbnQueX1weCwgMCkgdHJhbnNsYXRlKC01MCUsIC01MCUpYFxuICAgIH1cblxuICAgIGNvbnN0IG9uTW91c2VNb3ZlID0gKGU6IE1vdXNlRXZlbnQpID0+IHtcbiAgICAgIHBvc2l0aW9uLmN1cnJlbnQgPSB7IHg6IGUuY2xpZW50WCwgeTogZS5jbGllbnRZIH1cblxuICAgICAgLy8gRGlyZWN0IHVwZGF0ZSBmb3IgaW5zdGFudCByZXNwb25zZVxuICAgICAgdXBkYXRlQ3Vyc29yKClcbiAgICB9XG5cbiAgICBjb25zdCBvbk1vdXNlRW50ZXIgPSAoZTogTW91c2VFdmVudCkgPT4ge1xuICAgICAgY29uc3QgdGFyZ2V0ID0gZS50YXJnZXQgYXMgRWxlbWVudFxuICAgICAgaWYgKFxuICAgICAgICB0YXJnZXQgJiZcbiAgICAgICAgdGFyZ2V0Lm1hdGNoZXMgJiZcbiAgICAgICAgdGFyZ2V0Lm1hdGNoZXMoJ2EsIGJ1dHRvbiwgW2RhdGEtaG92ZXJdJylcbiAgICAgICkge1xuICAgICAgICBzZXRJc0hvdmVyaW5nKHRydWUpXG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3Qgb25Nb3VzZUxlYXZlID0gKGU6IE1vdXNlRXZlbnQpID0+IHtcbiAgICAgIGNvbnN0IHRhcmdldCA9IGUudGFyZ2V0IGFzIEVsZW1lbnRcbiAgICAgIGlmIChcbiAgICAgICAgdGFyZ2V0ICYmXG4gICAgICAgIHRhcmdldC5tYXRjaGVzICYmXG4gICAgICAgIHRhcmdldC5tYXRjaGVzKCdhLCBidXR0b24sIFtkYXRhLWhvdmVyXScpXG4gICAgICApIHtcbiAgICAgICAgc2V0SXNIb3ZlcmluZyhmYWxzZSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBvbk1vdXNlRG93biA9ICgpID0+IHNldElzQ2xpY2tpbmcodHJ1ZSlcbiAgICBjb25zdCBvbk1vdXNlVXAgPSAoKSA9PiBzZXRJc0NsaWNraW5nKGZhbHNlKVxuXG4gICAgY29uc3Qgb25Nb3VzZUVudGVyV2luZG93ID0gKCkgPT4ge1xuICAgICAgY3Vyc29yLnN0eWxlLm9wYWNpdHkgPSAnMC44J1xuICAgICAgY3Vyc29yRG90LnN0eWxlLm9wYWNpdHkgPSAnMC45J1xuICAgIH1cblxuICAgIGNvbnN0IG9uTW91c2VMZWF2ZVdpbmRvdyA9ICgpID0+IHtcbiAgICAgIGN1cnNvci5zdHlsZS5vcGFjaXR5ID0gJzAnXG4gICAgICBjdXJzb3JEb3Quc3R5bGUub3BhY2l0eSA9ICcwJ1xuICAgIH1cblxuICAgIC8vIEV2ZW50IGxpc3RlbmVyc1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIG9uTW91c2VNb3ZlKVxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZW50ZXInLCBvbk1vdXNlRW50ZXIsIHRydWUpXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIG9uTW91c2VMZWF2ZSwgdHJ1ZSlcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBvbk1vdXNlRG93bilcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgb25Nb3VzZVVwKVxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZW50ZXInLCBvbk1vdXNlRW50ZXJXaW5kb3cpXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIG9uTW91c2VMZWF2ZVdpbmRvdylcblxuICAgIC8vIEluaXRpYWwgc2V0dXBcbiAgICBjdXJzb3Iuc3R5bGUub3BhY2l0eSA9ICcwJ1xuICAgIGN1cnNvckRvdC5zdHlsZS5vcGFjaXR5ID0gJzAnXG5cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgZG9jdW1lbnQuYm9keS5zdHlsZS5jdXJzb3IgPSAnYXV0bydcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIG9uTW91c2VNb3ZlKVxuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VlbnRlcicsIG9uTW91c2VFbnRlciwgdHJ1ZSlcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCBvbk1vdXNlTGVhdmUsIHRydWUpXG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBvbk1vdXNlRG93bilcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBvbk1vdXNlVXApXG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWVudGVyJywgb25Nb3VzZUVudGVyV2luZG93KVxuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIG9uTW91c2VMZWF2ZVdpbmRvdylcbiAgICAgIGlmIChyYWZJZCkgY2FuY2VsQW5pbWF0aW9uRnJhbWUocmFmSWQpXG4gICAgfVxuICB9LCBbXSlcblxuICAvLyBDaGVjayBmb3IgcmVkdWNlZCBtb3Rpb24gcHJlZmVyZW5jZVxuICBjb25zdCBwcmVmZXJzUmVkdWNlZE1vdGlvbiA9IHdpbmRvdy5tYXRjaE1lZGlhKFxuICAgICcocHJlZmVycy1yZWR1Y2VkLW1vdGlvbjogcmVkdWNlKSdcbiAgKS5tYXRjaGVzXG4gIGlmIChwcmVmZXJzUmVkdWNlZE1vdGlvbikgcmV0dXJuIG51bGxcblxuICByZXR1cm4gKFxuICAgIDw+XG4gICAgICA8ZGl2XG4gICAgICAgIHJlZj17Y3Vyc29yUmVmfVxuICAgICAgICBjbGFzc05hbWU9e2Ake3N0eWxlcy5jdXJzb3J9ICR7aXNIb3ZlcmluZyA/IHN0eWxlcy5ob3ZlcmluZyA6ICcnfSAke2lzQ2xpY2tpbmcgPyBzdHlsZXMuY2xpY2tpbmcgOiAnJ31gfVxuICAgICAgICBhcmlhLWhpZGRlbj1cInRydWVcIlxuICAgICAgLz5cbiAgICAgIDxkaXYgcmVmPXtjdXJzb3JEb3RSZWZ9IGNsYXNzTmFtZT17c3R5bGVzLmN1cnNvckRvdH0gYXJpYS1oaWRkZW49XCJ0cnVlXCIgLz5cbiAgICA8Lz5cbiAgKVxufVxuXG5leHBvcnQgZGVmYXVsdCBDdXN0b21DdXJzb3JcbiJdLCJmaWxlIjoiL2hvbWUvd2lsbC9sb2NhbF9kZXYvcG9ydGZvbGlvL2FwcHMvcm9iaW4tbm9ndWllci9zcmMvY29tcG9uZW50cy9DdXN0b21DdXJzb3IvQ3VzdG9tQ3Vyc29yLnRzeCJ9",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 16101,
            "count": 1
          },
          {
            "startOffset": 525,
            "endOffset": 561,
            "count": 0
          },
          {
            "startOffset": 698,
            "endOffset": 869,
            "count": 0
          }
        ]
      },
      {
        "functionName": "window.$RefreshReg$",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 974,
            "endOffset": 1132,
            "count": 1
          }
        ]
      },
      {
        "functionName": "CustomCursor",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1581,
            "endOffset": 5495,
            "count": 2
          },
          {
            "startOffset": 4487,
            "endOffset": 4499,
            "count": 0
          },
          {
            "startOffset": 4679,
            "endOffset": 4696,
            "count": 0
          },
          {
            "startOffset": 4716,
            "endOffset": 4733,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1871,
            "endOffset": 4346,
            "count": 2
          },
          {
            "startOffset": 1998,
            "endOffset": 2005,
            "count": 0
          }
        ]
      },
      {
        "functionName": "updateCursor",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2161,
            "endOffset": 2419,
            "count": 0
          }
        ]
      },
      {
        "functionName": "onMouseMove",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2445,
            "endOffset": 2538,
            "count": 0
          }
        ]
      },
      {
        "functionName": "onMouseEnter",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2565,
            "endOffset": 2730,
            "count": 0
          }
        ]
      },
      {
        "functionName": "onMouseLeave",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2757,
            "endOffset": 2923,
            "count": 0
          }
        ]
      },
      {
        "functionName": "onMouseDown",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2949,
            "endOffset": 2974,
            "count": 0
          }
        ]
      },
      {
        "functionName": "onMouseUp",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2998,
            "endOffset": 3024,
            "count": 0
          }
        ]
      },
      {
        "functionName": "onMouseEnterWindow",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 3057,
            "endOffset": 3145,
            "count": 0
          }
        ]
      },
      {
        "functionName": "onMouseLeaveWindow",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 3178,
            "endOffset": 3262,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 3769,
            "endOffset": 4341,
            "count": 1
          },
          {
            "startOffset": 4307,
            "endOffset": 4335,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5808,
            "endOffset": 6293,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 6022,
            "endOffset": 6287,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5173/node_modules/.vite/deps/gsap_ScrollToPlugin.js?v=a50bb159",
    "scriptId": "28",
    "source": "import \"/node_modules/.vite/deps/chunk-LNEMQRCO.js?v=a50bb159\";\n\n// ../../node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/ScrollToPlugin.js\nvar gsap;\nvar _coreInitted;\nvar _window;\nvar _docEl;\nvar _body;\nvar _toArray;\nvar _config;\nvar ScrollTrigger;\nvar _windowExists = function _windowExists2() {\n  return typeof window !== \"undefined\";\n};\nvar _getGSAP = function _getGSAP2() {\n  return gsap || _windowExists() && (gsap = window.gsap) && gsap.registerPlugin && gsap;\n};\nvar _isString = function _isString2(value) {\n  return typeof value === \"string\";\n};\nvar _isFunction = function _isFunction2(value) {\n  return typeof value === \"function\";\n};\nvar _max = function _max2(element, axis) {\n  var dim = axis === \"x\" ? \"Width\" : \"Height\", scroll = \"scroll\" + dim, client = \"client\" + dim;\n  return element === _window || element === _docEl || element === _body ? Math.max(_docEl[scroll], _body[scroll]) - (_window[\"inner\" + dim] || _docEl[client] || _body[client]) : element[scroll] - element[\"offset\" + dim];\n};\nvar _buildGetter = function _buildGetter2(e, axis) {\n  var p = \"scroll\" + (axis === \"x\" ? \"Left\" : \"Top\");\n  if (e === _window) {\n    if (e.pageXOffset != null) {\n      p = \"page\" + axis.toUpperCase() + \"Offset\";\n    } else {\n      e = _docEl[p] != null ? _docEl : _body;\n    }\n  }\n  return function() {\n    return e[p];\n  };\n};\nvar _clean = function _clean2(value, index, target, targets) {\n  _isFunction(value) && (value = value(index, target, targets));\n  if (typeof value !== \"object\") {\n    return _isString(value) && value !== \"max\" && value.charAt(1) !== \"=\" ? {\n      x: value,\n      y: value\n    } : {\n      y: value\n    };\n  } else if (value.nodeType) {\n    return {\n      y: value,\n      x: value\n    };\n  } else {\n    var result = {}, p;\n    for (p in value) {\n      result[p] = p !== \"onAutoKill\" && _isFunction(value[p]) ? value[p](index, target, targets) : value[p];\n    }\n    return result;\n  }\n};\nvar _getOffset = function _getOffset2(element, container) {\n  element = _toArray(element)[0];\n  if (!element || !element.getBoundingClientRect) {\n    return console.warn(\"scrollTo target doesn't exist. Using 0\") || {\n      x: 0,\n      y: 0\n    };\n  }\n  var rect = element.getBoundingClientRect(), isRoot = !container || container === _window || container === _body, cRect = isRoot ? {\n    top: _docEl.clientTop - (_window.pageYOffset || _docEl.scrollTop || _body.scrollTop || 0),\n    left: _docEl.clientLeft - (_window.pageXOffset || _docEl.scrollLeft || _body.scrollLeft || 0)\n  } : container.getBoundingClientRect(), offsets = {\n    x: rect.left - cRect.left,\n    y: rect.top - cRect.top\n  };\n  if (!isRoot && container) {\n    offsets.x += _buildGetter(container, \"x\")();\n    offsets.y += _buildGetter(container, \"y\")();\n  }\n  return offsets;\n};\nvar _parseVal = function _parseVal2(value, target, axis, currentVal, offset) {\n  return !isNaN(value) && typeof value !== \"object\" ? parseFloat(value) - offset : _isString(value) && value.charAt(1) === \"=\" ? parseFloat(value.substr(2)) * (value.charAt(0) === \"-\" ? -1 : 1) + currentVal - offset : value === \"max\" ? _max(target, axis) - offset : Math.min(_max(target, axis), _getOffset(value, target)[axis] - offset);\n};\nvar _initCore = function _initCore2() {\n  gsap = _getGSAP();\n  if (_windowExists() && gsap && typeof document !== \"undefined\" && document.body) {\n    _window = window;\n    _body = document.body;\n    _docEl = document.documentElement;\n    _toArray = gsap.utils.toArray;\n    gsap.config({\n      autoKillThreshold: 7\n    });\n    _config = gsap.config();\n    _coreInitted = 1;\n  }\n};\nvar ScrollToPlugin = {\n  version: \"3.12.5\",\n  name: \"scrollTo\",\n  rawVars: 1,\n  register: function register(core) {\n    gsap = core;\n    _initCore();\n  },\n  init: function init(target, value, tween, index, targets) {\n    _coreInitted || _initCore();\n    var data = this, snapType = gsap.getProperty(target, \"scrollSnapType\");\n    data.isWin = target === _window;\n    data.target = target;\n    data.tween = tween;\n    value = _clean(value, index, target, targets);\n    data.vars = value;\n    data.autoKill = !!value.autoKill;\n    data.getX = _buildGetter(target, \"x\");\n    data.getY = _buildGetter(target, \"y\");\n    data.x = data.xPrev = data.getX();\n    data.y = data.yPrev = data.getY();\n    ScrollTrigger || (ScrollTrigger = gsap.core.globals().ScrollTrigger);\n    gsap.getProperty(target, \"scrollBehavior\") === \"smooth\" && gsap.set(target, {\n      scrollBehavior: \"auto\"\n    });\n    if (snapType && snapType !== \"none\") {\n      data.snap = 1;\n      data.snapInline = target.style.scrollSnapType;\n      target.style.scrollSnapType = \"none\";\n    }\n    if (value.x != null) {\n      data.add(data, \"x\", data.x, _parseVal(value.x, target, \"x\", data.x, value.offsetX || 0), index, targets);\n      data._props.push(\"scrollTo_x\");\n    } else {\n      data.skipX = 1;\n    }\n    if (value.y != null) {\n      data.add(data, \"y\", data.y, _parseVal(value.y, target, \"y\", data.y, value.offsetY || 0), index, targets);\n      data._props.push(\"scrollTo_y\");\n    } else {\n      data.skipY = 1;\n    }\n  },\n  render: function render(ratio, data) {\n    var pt = data._pt, target = data.target, tween = data.tween, autoKill = data.autoKill, xPrev = data.xPrev, yPrev = data.yPrev, isWin = data.isWin, snap = data.snap, snapInline = data.snapInline, x, y, yDif, xDif, threshold;\n    while (pt) {\n      pt.r(ratio, pt.d);\n      pt = pt._next;\n    }\n    x = isWin || !data.skipX ? data.getX() : xPrev;\n    y = isWin || !data.skipY ? data.getY() : yPrev;\n    yDif = y - yPrev;\n    xDif = x - xPrev;\n    threshold = _config.autoKillThreshold;\n    if (data.x < 0) {\n      data.x = 0;\n    }\n    if (data.y < 0) {\n      data.y = 0;\n    }\n    if (autoKill) {\n      if (!data.skipX && (xDif > threshold || xDif < -threshold) && x < _max(target, \"x\")) {\n        data.skipX = 1;\n      }\n      if (!data.skipY && (yDif > threshold || yDif < -threshold) && y < _max(target, \"y\")) {\n        data.skipY = 1;\n      }\n      if (data.skipX && data.skipY) {\n        tween.kill();\n        data.vars.onAutoKill && data.vars.onAutoKill.apply(tween, data.vars.onAutoKillParams || []);\n      }\n    }\n    if (isWin) {\n      _window.scrollTo(!data.skipX ? data.x : x, !data.skipY ? data.y : y);\n    } else {\n      data.skipY || (target.scrollTop = data.y);\n      data.skipX || (target.scrollLeft = data.x);\n    }\n    if (snap && (ratio === 1 || ratio === 0)) {\n      y = target.scrollTop;\n      x = target.scrollLeft;\n      snapInline ? target.style.scrollSnapType = snapInline : target.style.removeProperty(\"scroll-snap-type\");\n      target.scrollTop = y + 1;\n      target.scrollLeft = x + 1;\n      target.scrollTop = y;\n      target.scrollLeft = x;\n    }\n    data.xPrev = data.x;\n    data.yPrev = data.y;\n    ScrollTrigger && ScrollTrigger.update();\n  },\n  kill: function kill(property) {\n    var both = property === \"scrollTo\", i = this._props.indexOf(property);\n    if (both || property === \"scrollTo_x\") {\n      this.skipX = 1;\n    }\n    if (both || property === \"scrollTo_y\") {\n      this.skipY = 1;\n    }\n    i > -1 && this._props.splice(i, 1);\n    return !this._props.length;\n  }\n};\nScrollToPlugin.max = _max;\nScrollToPlugin.getOffset = _getOffset;\nScrollToPlugin.buildGetter = _buildGetter;\n_getGSAP() && gsap.registerPlugin(ScrollToPlugin);\nexport {\n  ScrollToPlugin,\n  ScrollToPlugin as default\n};\n/*! Bundled license information:\n\ngsap/ScrollToPlugin.js:\n  (*!\n   * ScrollToPlugin 3.12.5\n   * https://gsap.com\n   *\n   * @license Copyright 2008-2024, GreenSock. All rights reserved.\n   * Subject to the terms at https://gsap.com/standard-license or for\n   * Club GSAP members, the agreement issued with that membership.\n   * @author: Jack Doyle, jack@greensock.com\n  *)\n*/\n//# sourceMappingURL=gsap_ScrollToPlugin.js.map\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 7758,
            "count": 1
          },
          {
            "startOffset": 7237,
            "endOffset": 7275,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_windowExists2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 271,
            "endOffset": 340,
            "count": 2
          }
        ]
      },
      {
        "functionName": "_getGSAP2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 357,
            "endOffset": 470,
            "count": 2
          },
          {
            "startOffset": 394,
            "endOffset": 467,
            "count": 1
          },
          {
            "startOffset": 437,
            "endOffset": 459,
            "count": 0
          },
          {
            "startOffset": 460,
            "endOffset": 467,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_isString2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 488,
            "endOffset": 554,
            "count": 2
          }
        ]
      },
      {
        "functionName": "_isFunction2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 574,
            "endOffset": 644,
            "count": 2
          }
        ]
      },
      {
        "functionName": "_max2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 657,
            "endOffset": 1008,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_buildGetter2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1029,
            "endOffset": 1337,
            "count": 4
          },
          {
            "startOffset": 1098,
            "endOffset": 1106,
            "count": 2
          },
          {
            "startOffset": 1107,
            "endOffset": 1114,
            "count": 2
          },
          {
            "startOffset": 1228,
            "endOffset": 1287,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1301,
            "endOffset": 1334,
            "count": 12
          }
        ]
      },
      {
        "functionName": "_clean2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1352,
            "endOffset": 1922,
            "count": 2
          },
          {
            "startOffset": 1423,
            "endOffset": 1465,
            "count": 0
          },
          {
            "startOffset": 1530,
            "endOffset": 1548,
            "count": 0
          },
          {
            "startOffset": 1549,
            "endOffset": 1575,
            "count": 0
          },
          {
            "startOffset": 1576,
            "endOffset": 1616,
            "count": 0
          },
          {
            "startOffset": 1646,
            "endOffset": 1920,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_getOffset2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1941,
            "endOffset": 2770,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_parseVal2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 2788,
            "endOffset": 3190,
            "count": 2
          },
          {
            "startOffset": 2932,
            "endOffset": 3187,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_initCore2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 3208,
            "endOffset": 3570,
            "count": 1
          }
        ]
      },
      {
        "functionName": "register",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 3662,
            "endOffset": 3725,
            "count": 1
          }
        ]
      },
      {
        "functionName": "init",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 3735,
            "endOffset": 5060,
            "count": 2
          },
          {
            "startOffset": 3806,
            "endOffset": 3820,
            "count": 0
          },
          {
            "startOffset": 4279,
            "endOffset": 4333,
            "count": 1
          },
          {
            "startOffset": 4395,
            "endOffset": 4452,
            "count": 0
          },
          {
            "startOffset": 4471,
            "endOffset": 4493,
            "count": 0
          },
          {
            "startOffset": 4495,
            "endOffset": 4620,
            "count": 0
          },
          {
            "startOffset": 4646,
            "endOffset": 4803,
            "count": 0
          },
          {
            "startOffset": 5021,
            "endOffset": 5056,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5072,
            "endOffset": 6781,
            "count": 4
          },
          {
            "startOffset": 5414,
            "endOffset": 5428,
            "count": 0
          },
          {
            "startOffset": 5443,
            "endOffset": 5450,
            "count": 0
          },
          {
            "startOffset": 5466,
            "endOffset": 5480,
            "count": 0
          },
          {
            "startOffset": 5495,
            "endOffset": 5502,
            "count": 0
          },
          {
            "startOffset": 5611,
            "endOffset": 5636,
            "count": 0
          },
          {
            "startOffset": 5657,
            "endOffset": 5682,
            "count": 0
          },
          {
            "startOffset": 5701,
            "endOffset": 6127,
            "count": 0
          },
          {
            "startOffset": 6180,
            "endOffset": 6188,
            "count": 0
          },
          {
            "startOffset": 6215,
            "endOffset": 6218,
            "count": 0
          },
          {
            "startOffset": 6226,
            "endOffset": 6338,
            "count": 0
          },
          {
            "startOffset": 6352,
            "endOffset": 6383,
            "count": 0
          },
          {
            "startOffset": 6385,
            "endOffset": 6682,
            "count": 0
          }
        ]
      },
      {
        "functionName": "kill",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 6791,
            "endOffset": 7113,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5173/node_modules/.vite/deps/react-dom_client.js?v=a50bb159",
    "scriptId": "21",
    "source": "import {\n  require_react\n} from \"/node_modules/.vite/deps/chunk-R7U5S34U.js?v=a50bb159\";\nimport {\n  __commonJS\n} from \"/node_modules/.vite/deps/chunk-LNEMQRCO.js?v=a50bb159\";\n\n// ../../node_modules/.pnpm/scheduler@0.23.2/node_modules/scheduler/cjs/scheduler.development.js\nvar require_scheduler_development = __commonJS({\n  \"../../node_modules/.pnpm/scheduler@0.23.2/node_modules/scheduler/cjs/scheduler.development.js\"(exports) {\n    \"use strict\";\n    if (true) {\n      (function() {\n        \"use strict\";\n        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== \"undefined\" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === \"function\") {\n          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());\n        }\n        var enableSchedulerDebugging = false;\n        var enableProfiling = false;\n        var frameYieldMs = 5;\n        function push(heap, node) {\n          var index = heap.length;\n          heap.push(node);\n          siftUp(heap, node, index);\n        }\n        function peek(heap) {\n          return heap.length === 0 ? null : heap[0];\n        }\n        function pop(heap) {\n          if (heap.length === 0) {\n            return null;\n          }\n          var first = heap[0];\n          var last = heap.pop();\n          if (last !== first) {\n            heap[0] = last;\n            siftDown(heap, last, 0);\n          }\n          return first;\n        }\n        function siftUp(heap, node, i) {\n          var index = i;\n          while (index > 0) {\n            var parentIndex = index - 1 >>> 1;\n            var parent = heap[parentIndex];\n            if (compare(parent, node) > 0) {\n              heap[parentIndex] = node;\n              heap[index] = parent;\n              index = parentIndex;\n            } else {\n              return;\n            }\n          }\n        }\n        function siftDown(heap, node, i) {\n          var index = i;\n          var length = heap.length;\n          var halfLength = length >>> 1;\n          while (index < halfLength) {\n            var leftIndex = (index + 1) * 2 - 1;\n            var left = heap[leftIndex];\n            var rightIndex = leftIndex + 1;\n            var right = heap[rightIndex];\n            if (compare(left, node) < 0) {\n              if (rightIndex < length && compare(right, left) < 0) {\n                heap[index] = right;\n                heap[rightIndex] = node;\n                index = rightIndex;\n              } else {\n                heap[index] = left;\n                heap[leftIndex] = node;\n                index = leftIndex;\n              }\n            } else if (rightIndex < length && compare(right, node) < 0) {\n              heap[index] = right;\n              heap[rightIndex] = node;\n              index = rightIndex;\n            } else {\n              return;\n            }\n          }\n        }\n        function compare(a, b) {\n          var diff = a.sortIndex - b.sortIndex;\n          return diff !== 0 ? diff : a.id - b.id;\n        }\n        var ImmediatePriority = 1;\n        var UserBlockingPriority = 2;\n        var NormalPriority = 3;\n        var LowPriority = 4;\n        var IdlePriority = 5;\n        function markTaskErrored(task, ms) {\n        }\n        var hasPerformanceNow = typeof performance === \"object\" && typeof performance.now === \"function\";\n        if (hasPerformanceNow) {\n          var localPerformance = performance;\n          exports.unstable_now = function() {\n            return localPerformance.now();\n          };\n        } else {\n          var localDate = Date;\n          var initialTime = localDate.now();\n          exports.unstable_now = function() {\n            return localDate.now() - initialTime;\n          };\n        }\n        var maxSigned31BitInt = 1073741823;\n        var IMMEDIATE_PRIORITY_TIMEOUT = -1;\n        var USER_BLOCKING_PRIORITY_TIMEOUT = 250;\n        var NORMAL_PRIORITY_TIMEOUT = 5e3;\n        var LOW_PRIORITY_TIMEOUT = 1e4;\n        var IDLE_PRIORITY_TIMEOUT = maxSigned31BitInt;\n        var taskQueue = [];\n        var timerQueue = [];\n        var taskIdCounter = 1;\n        var currentTask = null;\n        var currentPriorityLevel = NormalPriority;\n        var isPerformingWork = false;\n        var isHostCallbackScheduled = false;\n        var isHostTimeoutScheduled = false;\n        var localSetTimeout = typeof setTimeout === \"function\" ? setTimeout : null;\n        var localClearTimeout = typeof clearTimeout === \"function\" ? clearTimeout : null;\n        var localSetImmediate = typeof setImmediate !== \"undefined\" ? setImmediate : null;\n        var isInputPending = typeof navigator !== \"undefined\" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 ? navigator.scheduling.isInputPending.bind(navigator.scheduling) : null;\n        function advanceTimers(currentTime) {\n          var timer = peek(timerQueue);\n          while (timer !== null) {\n            if (timer.callback === null) {\n              pop(timerQueue);\n            } else if (timer.startTime <= currentTime) {\n              pop(timerQueue);\n              timer.sortIndex = timer.expirationTime;\n              push(taskQueue, timer);\n            } else {\n              return;\n            }\n            timer = peek(timerQueue);\n          }\n        }\n        function handleTimeout(currentTime) {\n          isHostTimeoutScheduled = false;\n          advanceTimers(currentTime);\n          if (!isHostCallbackScheduled) {\n            if (peek(taskQueue) !== null) {\n              isHostCallbackScheduled = true;\n              requestHostCallback(flushWork);\n            } else {\n              var firstTimer = peek(timerQueue);\n              if (firstTimer !== null) {\n                requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);\n              }\n            }\n          }\n        }\n        function flushWork(hasTimeRemaining, initialTime2) {\n          isHostCallbackScheduled = false;\n          if (isHostTimeoutScheduled) {\n            isHostTimeoutScheduled = false;\n            cancelHostTimeout();\n          }\n          isPerformingWork = true;\n          var previousPriorityLevel = currentPriorityLevel;\n          try {\n            if (enableProfiling) {\n              try {\n                return workLoop(hasTimeRemaining, initialTime2);\n              } catch (error) {\n                if (currentTask !== null) {\n                  var currentTime = exports.unstable_now();\n                  markTaskErrored(currentTask, currentTime);\n                  currentTask.isQueued = false;\n                }\n                throw error;\n              }\n            } else {\n              return workLoop(hasTimeRemaining, initialTime2);\n            }\n          } finally {\n            currentTask = null;\n            currentPriorityLevel = previousPriorityLevel;\n            isPerformingWork = false;\n          }\n        }\n        function workLoop(hasTimeRemaining, initialTime2) {\n          var currentTime = initialTime2;\n          advanceTimers(currentTime);\n          currentTask = peek(taskQueue);\n          while (currentTask !== null && !enableSchedulerDebugging) {\n            if (currentTask.expirationTime > currentTime && (!hasTimeRemaining || shouldYieldToHost())) {\n              break;\n            }\n            var callback = currentTask.callback;\n            if (typeof callback === \"function\") {\n              currentTask.callback = null;\n              currentPriorityLevel = currentTask.priorityLevel;\n              var didUserCallbackTimeout = currentTask.expirationTime <= currentTime;\n              var continuationCallback = callback(didUserCallbackTimeout);\n              currentTime = exports.unstable_now();\n              if (typeof continuationCallback === \"function\") {\n                currentTask.callback = continuationCallback;\n              } else {\n                if (currentTask === peek(taskQueue)) {\n                  pop(taskQueue);\n                }\n              }\n              advanceTimers(currentTime);\n            } else {\n              pop(taskQueue);\n            }\n            currentTask = peek(taskQueue);\n          }\n          if (currentTask !== null) {\n            return true;\n          } else {\n            var firstTimer = peek(timerQueue);\n            if (firstTimer !== null) {\n              requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);\n            }\n            return false;\n          }\n        }\n        function unstable_runWithPriority(priorityLevel, eventHandler) {\n          switch (priorityLevel) {\n            case ImmediatePriority:\n            case UserBlockingPriority:\n            case NormalPriority:\n            case LowPriority:\n            case IdlePriority:\n              break;\n            default:\n              priorityLevel = NormalPriority;\n          }\n          var previousPriorityLevel = currentPriorityLevel;\n          currentPriorityLevel = priorityLevel;\n          try {\n            return eventHandler();\n          } finally {\n            currentPriorityLevel = previousPriorityLevel;\n          }\n        }\n        function unstable_next(eventHandler) {\n          var priorityLevel;\n          switch (currentPriorityLevel) {\n            case ImmediatePriority:\n            case UserBlockingPriority:\n            case NormalPriority:\n              priorityLevel = NormalPriority;\n              break;\n            default:\n              priorityLevel = currentPriorityLevel;\n              break;\n          }\n          var previousPriorityLevel = currentPriorityLevel;\n          currentPriorityLevel = priorityLevel;\n          try {\n            return eventHandler();\n          } finally {\n            currentPriorityLevel = previousPriorityLevel;\n          }\n        }\n        function unstable_wrapCallback(callback) {\n          var parentPriorityLevel = currentPriorityLevel;\n          return function() {\n            var previousPriorityLevel = currentPriorityLevel;\n            currentPriorityLevel = parentPriorityLevel;\n            try {\n              return callback.apply(this, arguments);\n            } finally {\n              currentPriorityLevel = previousPriorityLevel;\n            }\n          };\n        }\n        function unstable_scheduleCallback(priorityLevel, callback, options) {\n          var currentTime = exports.unstable_now();\n          var startTime2;\n          if (typeof options === \"object\" && options !== null) {\n            var delay = options.delay;\n            if (typeof delay === \"number\" && delay > 0) {\n              startTime2 = currentTime + delay;\n            } else {\n              startTime2 = currentTime;\n            }\n          } else {\n            startTime2 = currentTime;\n          }\n          var timeout;\n          switch (priorityLevel) {\n            case ImmediatePriority:\n              timeout = IMMEDIATE_PRIORITY_TIMEOUT;\n              break;\n            case UserBlockingPriority:\n              timeout = USER_BLOCKING_PRIORITY_TIMEOUT;\n              break;\n            case IdlePriority:\n              timeout = IDLE_PRIORITY_TIMEOUT;\n              break;\n            case LowPriority:\n              timeout = LOW_PRIORITY_TIMEOUT;\n              break;\n            case NormalPriority:\n            default:\n              timeout = NORMAL_PRIORITY_TIMEOUT;\n              break;\n          }\n          var expirationTime = startTime2 + timeout;\n          var newTask = {\n            id: taskIdCounter++,\n            callback,\n            priorityLevel,\n            startTime: startTime2,\n            expirationTime,\n            sortIndex: -1\n          };\n          if (startTime2 > currentTime) {\n            newTask.sortIndex = startTime2;\n            push(timerQueue, newTask);\n            if (peek(taskQueue) === null && newTask === peek(timerQueue)) {\n              if (isHostTimeoutScheduled) {\n                cancelHostTimeout();\n              } else {\n                isHostTimeoutScheduled = true;\n              }\n              requestHostTimeout(handleTimeout, startTime2 - currentTime);\n            }\n          } else {\n            newTask.sortIndex = expirationTime;\n            push(taskQueue, newTask);\n            if (!isHostCallbackScheduled && !isPerformingWork) {\n              isHostCallbackScheduled = true;\n              requestHostCallback(flushWork);\n            }\n          }\n          return newTask;\n        }\n        function unstable_pauseExecution() {\n        }\n        function unstable_continueExecution() {\n          if (!isHostCallbackScheduled && !isPerformingWork) {\n            isHostCallbackScheduled = true;\n            requestHostCallback(flushWork);\n          }\n        }\n        function unstable_getFirstCallbackNode() {\n          return peek(taskQueue);\n        }\n        function unstable_cancelCallback(task) {\n          task.callback = null;\n        }\n        function unstable_getCurrentPriorityLevel() {\n          return currentPriorityLevel;\n        }\n        var isMessageLoopRunning = false;\n        var scheduledHostCallback = null;\n        var taskTimeoutID = -1;\n        var frameInterval = frameYieldMs;\n        var startTime = -1;\n        function shouldYieldToHost() {\n          var timeElapsed = exports.unstable_now() - startTime;\n          if (timeElapsed < frameInterval) {\n            return false;\n          }\n          return true;\n        }\n        function requestPaint() {\n        }\n        function forceFrameRate(fps) {\n          if (fps < 0 || fps > 125) {\n            console[\"error\"](\"forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported\");\n            return;\n          }\n          if (fps > 0) {\n            frameInterval = Math.floor(1e3 / fps);\n          } else {\n            frameInterval = frameYieldMs;\n          }\n        }\n        var performWorkUntilDeadline = function() {\n          if (scheduledHostCallback !== null) {\n            var currentTime = exports.unstable_now();\n            startTime = currentTime;\n            var hasTimeRemaining = true;\n            var hasMoreWork = true;\n            try {\n              hasMoreWork = scheduledHostCallback(hasTimeRemaining, currentTime);\n            } finally {\n              if (hasMoreWork) {\n                schedulePerformWorkUntilDeadline();\n              } else {\n                isMessageLoopRunning = false;\n                scheduledHostCallback = null;\n              }\n            }\n          } else {\n            isMessageLoopRunning = false;\n          }\n        };\n        var schedulePerformWorkUntilDeadline;\n        if (typeof localSetImmediate === \"function\") {\n          schedulePerformWorkUntilDeadline = function() {\n            localSetImmediate(performWorkUntilDeadline);\n          };\n        } else if (typeof MessageChannel !== \"undefined\") {\n          var channel = new MessageChannel();\n          var port = channel.port2;\n          channel.port1.onmessage = performWorkUntilDeadline;\n          schedulePerformWorkUntilDeadline = function() {\n            port.postMessage(null);\n          };\n        } else {\n          schedulePerformWorkUntilDeadline = function() {\n            localSetTimeout(performWorkUntilDeadline, 0);\n          };\n        }\n        function requestHostCallback(callback) {\n          scheduledHostCallback = callback;\n          if (!isMessageLoopRunning) {\n            isMessageLoopRunning = true;\n            schedulePerformWorkUntilDeadline();\n          }\n        }\n        function requestHostTimeout(callback, ms) {\n          taskTimeoutID = localSetTimeout(function() {\n            callback(exports.unstable_now());\n          }, ms);\n        }\n        function cancelHostTimeout() {\n          localClearTimeout(taskTimeoutID);\n          taskTimeoutID = -1;\n        }\n        var unstable_requestPaint = requestPaint;\n        var unstable_Profiling = null;\n        exports.unstable_IdlePriority = IdlePriority;\n        exports.unstable_ImmediatePriority = ImmediatePriority;\n        exports.unstable_LowPriority = LowPriority;\n        exports.unstable_NormalPriority = NormalPriority;\n        exports.unstable_Profiling = unstable_Profiling;\n        exports.unstable_UserBlockingPriority = UserBlockingPriority;\n        exports.unstable_cancelCallback = unstable_cancelCallback;\n        exports.unstable_continueExecution = unstable_continueExecution;\n        exports.unstable_forceFrameRate = forceFrameRate;\n        exports.unstable_getCurrentPriorityLevel = unstable_getCurrentPriorityLevel;\n        exports.unstable_getFirstCallbackNode = unstable_getFirstCallbackNode;\n        exports.unstable_next = unstable_next;\n        exports.unstable_pauseExecution = unstable_pauseExecution;\n        exports.unstable_requestPaint = unstable_requestPaint;\n        exports.unstable_runWithPriority = unstable_runWithPriority;\n        exports.unstable_scheduleCallback = unstable_scheduleCallback;\n        exports.unstable_shouldYield = shouldYieldToHost;\n        exports.unstable_wrapCallback = unstable_wrapCallback;\n        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== \"undefined\" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === \"function\") {\n          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());\n        }\n      })();\n    }\n  }\n});\n\n// ../../node_modules/.pnpm/scheduler@0.23.2/node_modules/scheduler/index.js\nvar require_scheduler = __commonJS({\n  \"../../node_modules/.pnpm/scheduler@0.23.2/node_modules/scheduler/index.js\"(exports, module) {\n    \"use strict\";\n    if (false) {\n      module.exports = null;\n    } else {\n      module.exports = require_scheduler_development();\n    }\n  }\n});\n\n// ../../node_modules/.pnpm/react-dom@18.2.0_react@18.2.0/node_modules/react-dom/cjs/react-dom.development.js\nvar require_react_dom_development = __commonJS({\n  \"../../node_modules/.pnpm/react-dom@18.2.0_react@18.2.0/node_modules/react-dom/cjs/react-dom.development.js\"(exports) {\n    \"use strict\";\n    if (true) {\n      (function() {\n        \"use strict\";\n        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== \"undefined\" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === \"function\") {\n          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());\n        }\n        var React = require_react();\n        var Scheduler = require_scheduler();\n        var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n        var suppressWarning = false;\n        function setSuppressWarning(newSuppressWarning) {\n          {\n            suppressWarning = newSuppressWarning;\n          }\n        }\n        function warn(format) {\n          {\n            if (!suppressWarning) {\n              for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n                args[_key - 1] = arguments[_key];\n              }\n              printWarning(\"warn\", format, args);\n            }\n          }\n        }\n        function error(format) {\n          {\n            if (!suppressWarning) {\n              for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n                args[_key2 - 1] = arguments[_key2];\n              }\n              printWarning(\"error\", format, args);\n            }\n          }\n        }\n        function printWarning(level, format, args) {\n          {\n            var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;\n            var stack = ReactDebugCurrentFrame2.getStackAddendum();\n            if (stack !== \"\") {\n              format += \"%s\";\n              args = args.concat([stack]);\n            }\n            var argsWithFormat = args.map(function(item) {\n              return String(item);\n            });\n            argsWithFormat.unshift(\"Warning: \" + format);\n            Function.prototype.apply.call(console[level], console, argsWithFormat);\n          }\n        }\n        var FunctionComponent = 0;\n        var ClassComponent = 1;\n        var IndeterminateComponent = 2;\n        var HostRoot = 3;\n        var HostPortal = 4;\n        var HostComponent = 5;\n        var HostText = 6;\n        var Fragment = 7;\n        var Mode = 8;\n        var ContextConsumer = 9;\n        var ContextProvider = 10;\n        var ForwardRef = 11;\n        var Profiler = 12;\n        var SuspenseComponent = 13;\n        var MemoComponent = 14;\n        var SimpleMemoComponent = 15;\n        var LazyComponent = 16;\n        var IncompleteClassComponent = 17;\n        var DehydratedFragment = 18;\n        var SuspenseListComponent = 19;\n        var ScopeComponent = 21;\n        var OffscreenComponent = 22;\n        var LegacyHiddenComponent = 23;\n        var CacheComponent = 24;\n        var TracingMarkerComponent = 25;\n        var enableClientRenderFallbackOnTextMismatch = true;\n        var enableNewReconciler = false;\n        var enableLazyContextPropagation = false;\n        var enableLegacyHidden = false;\n        var enableSuspenseAvoidThisFallback = false;\n        var disableCommentsAsDOMContainers = true;\n        var enableCustomElementPropertySupport = false;\n        var warnAboutStringRefs = false;\n        var enableSchedulingProfiler = true;\n        var enableProfilerTimer = true;\n        var enableProfilerCommitHooks = true;\n        var allNativeEvents = /* @__PURE__ */ new Set();\n        var registrationNameDependencies = {};\n        var possibleRegistrationNames = {};\n        function registerTwoPhaseEvent(registrationName, dependencies) {\n          registerDirectEvent(registrationName, dependencies);\n          registerDirectEvent(registrationName + \"Capture\", dependencies);\n        }\n        function registerDirectEvent(registrationName, dependencies) {\n          {\n            if (registrationNameDependencies[registrationName]) {\n              error(\"EventRegistry: More than one plugin attempted to publish the same registration name, `%s`.\", registrationName);\n            }\n          }\n          registrationNameDependencies[registrationName] = dependencies;\n          {\n            var lowerCasedName = registrationName.toLowerCase();\n            possibleRegistrationNames[lowerCasedName] = registrationName;\n            if (registrationName === \"onDoubleClick\") {\n              possibleRegistrationNames.ondblclick = registrationName;\n            }\n          }\n          for (var i = 0; i < dependencies.length; i++) {\n            allNativeEvents.add(dependencies[i]);\n          }\n        }\n        var canUseDOM = !!(typeof window !== \"undefined\" && typeof window.document !== \"undefined\" && typeof window.document.createElement !== \"undefined\");\n        var hasOwnProperty = Object.prototype.hasOwnProperty;\n        function typeName(value) {\n          {\n            var hasToStringTag = typeof Symbol === \"function\" && Symbol.toStringTag;\n            var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || \"Object\";\n            return type;\n          }\n        }\n        function willCoercionThrow(value) {\n          {\n            try {\n              testStringCoercion(value);\n              return false;\n            } catch (e) {\n              return true;\n            }\n          }\n        }\n        function testStringCoercion(value) {\n          return \"\" + value;\n        }\n        function checkAttributeStringCoercion(value, attributeName) {\n          {\n            if (willCoercionThrow(value)) {\n              error(\"The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before before using it here.\", attributeName, typeName(value));\n              return testStringCoercion(value);\n            }\n          }\n        }\n        function checkKeyStringCoercion(value) {\n          {\n            if (willCoercionThrow(value)) {\n              error(\"The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.\", typeName(value));\n              return testStringCoercion(value);\n            }\n          }\n        }\n        function checkPropStringCoercion(value, propName) {\n          {\n            if (willCoercionThrow(value)) {\n              error(\"The provided `%s` prop is an unsupported type %s. This value must be coerced to a string before before using it here.\", propName, typeName(value));\n              return testStringCoercion(value);\n            }\n          }\n        }\n        function checkCSSPropertyStringCoercion(value, propName) {\n          {\n            if (willCoercionThrow(value)) {\n              error(\"The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before before using it here.\", propName, typeName(value));\n              return testStringCoercion(value);\n            }\n          }\n        }\n        function checkHtmlStringCoercion(value) {\n          {\n            if (willCoercionThrow(value)) {\n              error(\"The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before before using it here.\", typeName(value));\n              return testStringCoercion(value);\n            }\n          }\n        }\n        function checkFormFieldValueStringCoercion(value) {\n          {\n            if (willCoercionThrow(value)) {\n              error(\"Form field values (value, checked, defaultValue, or defaultChecked props) must be strings, not %s. This value must be coerced to a string before before using it here.\", typeName(value));\n              return testStringCoercion(value);\n            }\n          }\n        }\n        var RESERVED = 0;\n        var STRING = 1;\n        var BOOLEANISH_STRING = 2;\n        var BOOLEAN = 3;\n        var OVERLOADED_BOOLEAN = 4;\n        var NUMERIC = 5;\n        var POSITIVE_NUMERIC = 6;\n        var ATTRIBUTE_NAME_START_CHAR = \":A-Z_a-z\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD\";\n        var ATTRIBUTE_NAME_CHAR = ATTRIBUTE_NAME_START_CHAR + \"\\\\-.0-9\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040\";\n        var VALID_ATTRIBUTE_NAME_REGEX = new RegExp(\"^[\" + ATTRIBUTE_NAME_START_CHAR + \"][\" + ATTRIBUTE_NAME_CHAR + \"]*$\");\n        var illegalAttributeNameCache = {};\n        var validatedAttributeNameCache = {};\n        function isAttributeNameSafe(attributeName) {\n          if (hasOwnProperty.call(validatedAttributeNameCache, attributeName)) {\n            return true;\n          }\n          if (hasOwnProperty.call(illegalAttributeNameCache, attributeName)) {\n            return false;\n          }\n          if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {\n            validatedAttributeNameCache[attributeName] = true;\n            return true;\n          }\n          illegalAttributeNameCache[attributeName] = true;\n          {\n            error(\"Invalid attribute name: `%s`\", attributeName);\n          }\n          return false;\n        }\n        function shouldIgnoreAttribute(name, propertyInfo, isCustomComponentTag) {\n          if (propertyInfo !== null) {\n            return propertyInfo.type === RESERVED;\n          }\n          if (isCustomComponentTag) {\n            return false;\n          }\n          if (name.length > 2 && (name[0] === \"o\" || name[0] === \"O\") && (name[1] === \"n\" || name[1] === \"N\")) {\n            return true;\n          }\n          return false;\n        }\n        function shouldRemoveAttributeWithWarning(name, value, propertyInfo, isCustomComponentTag) {\n          if (propertyInfo !== null && propertyInfo.type === RESERVED) {\n            return false;\n          }\n          switch (typeof value) {\n            case \"function\":\n            case \"symbol\":\n              return true;\n            case \"boolean\": {\n              if (isCustomComponentTag) {\n                return false;\n              }\n              if (propertyInfo !== null) {\n                return !propertyInfo.acceptsBooleans;\n              } else {\n                var prefix2 = name.toLowerCase().slice(0, 5);\n                return prefix2 !== \"data-\" && prefix2 !== \"aria-\";\n              }\n            }\n            default:\n              return false;\n          }\n        }\n        function shouldRemoveAttribute(name, value, propertyInfo, isCustomComponentTag) {\n          if (value === null || typeof value === \"undefined\") {\n            return true;\n          }\n          if (shouldRemoveAttributeWithWarning(name, value, propertyInfo, isCustomComponentTag)) {\n            return true;\n          }\n          if (isCustomComponentTag) {\n            return false;\n          }\n          if (propertyInfo !== null) {\n            switch (propertyInfo.type) {\n              case BOOLEAN:\n                return !value;\n              case OVERLOADED_BOOLEAN:\n                return value === false;\n              case NUMERIC:\n                return isNaN(value);\n              case POSITIVE_NUMERIC:\n                return isNaN(value) || value < 1;\n            }\n          }\n          return false;\n        }\n        function getPropertyInfo(name) {\n          return properties.hasOwnProperty(name) ? properties[name] : null;\n        }\n        function PropertyInfoRecord(name, type, mustUseProperty, attributeName, attributeNamespace, sanitizeURL2, removeEmptyString) {\n          this.acceptsBooleans = type === BOOLEANISH_STRING || type === BOOLEAN || type === OVERLOADED_BOOLEAN;\n          this.attributeName = attributeName;\n          this.attributeNamespace = attributeNamespace;\n          this.mustUseProperty = mustUseProperty;\n          this.propertyName = name;\n          this.type = type;\n          this.sanitizeURL = sanitizeURL2;\n          this.removeEmptyString = removeEmptyString;\n        }\n        var properties = {};\n        var reservedProps = [\n          \"children\",\n          \"dangerouslySetInnerHTML\",\n          // TODO: This prevents the assignment of defaultValue to regular\n          // elements (not just inputs). Now that ReactDOMInput assigns to the\n          // defaultValue property -- do we need this?\n          \"defaultValue\",\n          \"defaultChecked\",\n          \"innerHTML\",\n          \"suppressContentEditableWarning\",\n          \"suppressHydrationWarning\",\n          \"style\"\n        ];\n        reservedProps.forEach(function(name) {\n          properties[name] = new PropertyInfoRecord(\n            name,\n            RESERVED,\n            false,\n            // mustUseProperty\n            name,\n            // attributeName\n            null,\n            // attributeNamespace\n            false,\n            // sanitizeURL\n            false\n          );\n        });\n        [[\"acceptCharset\", \"accept-charset\"], [\"className\", \"class\"], [\"htmlFor\", \"for\"], [\"httpEquiv\", \"http-equiv\"]].forEach(function(_ref) {\n          var name = _ref[0], attributeName = _ref[1];\n          properties[name] = new PropertyInfoRecord(\n            name,\n            STRING,\n            false,\n            // mustUseProperty\n            attributeName,\n            // attributeName\n            null,\n            // attributeNamespace\n            false,\n            // sanitizeURL\n            false\n          );\n        });\n        [\"contentEditable\", \"draggable\", \"spellCheck\", \"value\"].forEach(function(name) {\n          properties[name] = new PropertyInfoRecord(\n            name,\n            BOOLEANISH_STRING,\n            false,\n            // mustUseProperty\n            name.toLowerCase(),\n            // attributeName\n            null,\n            // attributeNamespace\n            false,\n            // sanitizeURL\n            false\n          );\n        });\n        [\"autoReverse\", \"externalResourcesRequired\", \"focusable\", \"preserveAlpha\"].forEach(function(name) {\n          properties[name] = new PropertyInfoRecord(\n            name,\n            BOOLEANISH_STRING,\n            false,\n            // mustUseProperty\n            name,\n            // attributeName\n            null,\n            // attributeNamespace\n            false,\n            // sanitizeURL\n            false\n          );\n        });\n        [\n          \"allowFullScreen\",\n          \"async\",\n          // Note: there is a special case that prevents it from being written to the DOM\n          // on the client side because the browsers are inconsistent. Instead we call focus().\n          \"autoFocus\",\n          \"autoPlay\",\n          \"controls\",\n          \"default\",\n          \"defer\",\n          \"disabled\",\n          \"disablePictureInPicture\",\n          \"disableRemotePlayback\",\n          \"formNoValidate\",\n          \"hidden\",\n          \"loop\",\n          \"noModule\",\n          \"noValidate\",\n          \"open\",\n          \"playsInline\",\n          \"readOnly\",\n          \"required\",\n          \"reversed\",\n          \"scoped\",\n          \"seamless\",\n          // Microdata\n          \"itemScope\"\n        ].forEach(function(name) {\n          properties[name] = new PropertyInfoRecord(\n            name,\n            BOOLEAN,\n            false,\n            // mustUseProperty\n            name.toLowerCase(),\n            // attributeName\n            null,\n            // attributeNamespace\n            false,\n            // sanitizeURL\n            false\n          );\n        });\n        [\n          \"checked\",\n          // Note: `option.selected` is not updated if `select.multiple` is\n          // disabled with `removeAttribute`. We have special logic for handling this.\n          \"multiple\",\n          \"muted\",\n          \"selected\"\n          // NOTE: if you add a camelCased prop to this list,\n          // you'll need to set attributeName to name.toLowerCase()\n          // instead in the assignment below.\n        ].forEach(function(name) {\n          properties[name] = new PropertyInfoRecord(\n            name,\n            BOOLEAN,\n            true,\n            // mustUseProperty\n            name,\n            // attributeName\n            null,\n            // attributeNamespace\n            false,\n            // sanitizeURL\n            false\n          );\n        });\n        [\n          \"capture\",\n          \"download\"\n          // NOTE: if you add a camelCased prop to this list,\n          // you'll need to set attributeName to name.toLowerCase()\n          // instead in the assignment below.\n        ].forEach(function(name) {\n          properties[name] = new PropertyInfoRecord(\n            name,\n            OVERLOADED_BOOLEAN,\n            false,\n            // mustUseProperty\n            name,\n            // attributeName\n            null,\n            // attributeNamespace\n            false,\n            // sanitizeURL\n            false\n          );\n        });\n        [\n          \"cols\",\n          \"rows\",\n          \"size\",\n          \"span\"\n          // NOTE: if you add a camelCased prop to this list,\n          // you'll need to set attributeName to name.toLowerCase()\n          // instead in the assignment below.\n        ].forEach(function(name) {\n          properties[name] = new PropertyInfoRecord(\n            name,\n            POSITIVE_NUMERIC,\n            false,\n            // mustUseProperty\n            name,\n            // attributeName\n            null,\n            // attributeNamespace\n            false,\n            // sanitizeURL\n            false\n          );\n        });\n        [\"rowSpan\", \"start\"].forEach(function(name) {\n          properties[name] = new PropertyInfoRecord(\n            name,\n            NUMERIC,\n            false,\n            // mustUseProperty\n            name.toLowerCase(),\n            // attributeName\n            null,\n            // attributeNamespace\n            false,\n            // sanitizeURL\n            false\n          );\n        });\n        var CAMELIZE = /[\\-\\:]([a-z])/g;\n        var capitalize = function(token) {\n          return token[1].toUpperCase();\n        };\n        [\n          \"accent-height\",\n          \"alignment-baseline\",\n          \"arabic-form\",\n          \"baseline-shift\",\n          \"cap-height\",\n          \"clip-path\",\n          \"clip-rule\",\n          \"color-interpolation\",\n          \"color-interpolation-filters\",\n          \"color-profile\",\n          \"color-rendering\",\n          \"dominant-baseline\",\n          \"enable-background\",\n          \"fill-opacity\",\n          \"fill-rule\",\n          \"flood-color\",\n          \"flood-opacity\",\n          \"font-family\",\n          \"font-size\",\n          \"font-size-adjust\",\n          \"font-stretch\",\n          \"font-style\",\n          \"font-variant\",\n          \"font-weight\",\n          \"glyph-name\",\n          \"glyph-orientation-horizontal\",\n          \"glyph-orientation-vertical\",\n          \"horiz-adv-x\",\n          \"horiz-origin-x\",\n          \"image-rendering\",\n          \"letter-spacing\",\n          \"lighting-color\",\n          \"marker-end\",\n          \"marker-mid\",\n          \"marker-start\",\n          \"overline-position\",\n          \"overline-thickness\",\n          \"paint-order\",\n          \"panose-1\",\n          \"pointer-events\",\n          \"rendering-intent\",\n          \"shape-rendering\",\n          \"stop-color\",\n          \"stop-opacity\",\n          \"strikethrough-position\",\n          \"strikethrough-thickness\",\n          \"stroke-dasharray\",\n          \"stroke-dashoffset\",\n          \"stroke-linecap\",\n          \"stroke-linejoin\",\n          \"stroke-miterlimit\",\n          \"stroke-opacity\",\n          \"stroke-width\",\n          \"text-anchor\",\n          \"text-decoration\",\n          \"text-rendering\",\n          \"underline-position\",\n          \"underline-thickness\",\n          \"unicode-bidi\",\n          \"unicode-range\",\n          \"units-per-em\",\n          \"v-alphabetic\",\n          \"v-hanging\",\n          \"v-ideographic\",\n          \"v-mathematical\",\n          \"vector-effect\",\n          \"vert-adv-y\",\n          \"vert-origin-x\",\n          \"vert-origin-y\",\n          \"word-spacing\",\n          \"writing-mode\",\n          \"xmlns:xlink\",\n          \"x-height\"\n          // NOTE: if you add a camelCased prop to this list,\n          // you'll need to set attributeName to name.toLowerCase()\n          // instead in the assignment below.\n        ].forEach(function(attributeName) {\n          var name = attributeName.replace(CAMELIZE, capitalize);\n          properties[name] = new PropertyInfoRecord(\n            name,\n            STRING,\n            false,\n            // mustUseProperty\n            attributeName,\n            null,\n            // attributeNamespace\n            false,\n            // sanitizeURL\n            false\n          );\n        });\n        [\n          \"xlink:actuate\",\n          \"xlink:arcrole\",\n          \"xlink:role\",\n          \"xlink:show\",\n          \"xlink:title\",\n          \"xlink:type\"\n          // NOTE: if you add a camelCased prop to this list,\n          // you'll need to set attributeName to name.toLowerCase()\n          // instead in the assignment below.\n        ].forEach(function(attributeName) {\n          var name = attributeName.replace(CAMELIZE, capitalize);\n          properties[name] = new PropertyInfoRecord(\n            name,\n            STRING,\n            false,\n            // mustUseProperty\n            attributeName,\n            \"http://www.w3.org/1999/xlink\",\n            false,\n            // sanitizeURL\n            false\n          );\n        });\n        [\n          \"xml:base\",\n          \"xml:lang\",\n          \"xml:space\"\n          // NOTE: if you add a camelCased prop to this list,\n          // you'll need to set attributeName to name.toLowerCase()\n          // instead in the assignment below.\n        ].forEach(function(attributeName) {\n          var name = attributeName.replace(CAMELIZE, capitalize);\n          properties[name] = new PropertyInfoRecord(\n            name,\n            STRING,\n            false,\n            // mustUseProperty\n            attributeName,\n            \"http://www.w3.org/XML/1998/namespace\",\n            false,\n            // sanitizeURL\n            false\n          );\n        });\n        [\"tabIndex\", \"crossOrigin\"].forEach(function(attributeName) {\n          properties[attributeName] = new PropertyInfoRecord(\n            attributeName,\n            STRING,\n            false,\n            // mustUseProperty\n            attributeName.toLowerCase(),\n            // attributeName\n            null,\n            // attributeNamespace\n            false,\n            // sanitizeURL\n            false\n          );\n        });\n        var xlinkHref = \"xlinkHref\";\n        properties[xlinkHref] = new PropertyInfoRecord(\n          \"xlinkHref\",\n          STRING,\n          false,\n          // mustUseProperty\n          \"xlink:href\",\n          \"http://www.w3.org/1999/xlink\",\n          true,\n          // sanitizeURL\n          false\n        );\n        [\"src\", \"href\", \"action\", \"formAction\"].forEach(function(attributeName) {\n          properties[attributeName] = new PropertyInfoRecord(\n            attributeName,\n            STRING,\n            false,\n            // mustUseProperty\n            attributeName.toLowerCase(),\n            // attributeName\n            null,\n            // attributeNamespace\n            true,\n            // sanitizeURL\n            true\n          );\n        });\n        var isJavaScriptProtocol = /^[\\u0000-\\u001F ]*j[\\r\\n\\t]*a[\\r\\n\\t]*v[\\r\\n\\t]*a[\\r\\n\\t]*s[\\r\\n\\t]*c[\\r\\n\\t]*r[\\r\\n\\t]*i[\\r\\n\\t]*p[\\r\\n\\t]*t[\\r\\n\\t]*\\:/i;\n        var didWarn = false;\n        function sanitizeURL(url) {\n          {\n            if (!didWarn && isJavaScriptProtocol.test(url)) {\n              didWarn = true;\n              error(\"A future version of React will block javascript: URLs as a security precaution. Use event handlers instead if you can. If you need to generate unsafe HTML try using dangerouslySetInnerHTML instead. React was passed %s.\", JSON.stringify(url));\n            }\n          }\n        }\n        function getValueForProperty(node, name, expected, propertyInfo) {\n          {\n            if (propertyInfo.mustUseProperty) {\n              var propertyName = propertyInfo.propertyName;\n              return node[propertyName];\n            } else {\n              {\n                checkAttributeStringCoercion(expected, name);\n              }\n              if (propertyInfo.sanitizeURL) {\n                sanitizeURL(\"\" + expected);\n              }\n              var attributeName = propertyInfo.attributeName;\n              var stringValue = null;\n              if (propertyInfo.type === OVERLOADED_BOOLEAN) {\n                if (node.hasAttribute(attributeName)) {\n                  var value = node.getAttribute(attributeName);\n                  if (value === \"\") {\n                    return true;\n                  }\n                  if (shouldRemoveAttribute(name, expected, propertyInfo, false)) {\n                    return value;\n                  }\n                  if (value === \"\" + expected) {\n                    return expected;\n                  }\n                  return value;\n                }\n              } else if (node.hasAttribute(attributeName)) {\n                if (shouldRemoveAttribute(name, expected, propertyInfo, false)) {\n                  return node.getAttribute(attributeName);\n                }\n                if (propertyInfo.type === BOOLEAN) {\n                  return expected;\n                }\n                stringValue = node.getAttribute(attributeName);\n              }\n              if (shouldRemoveAttribute(name, expected, propertyInfo, false)) {\n                return stringValue === null ? expected : stringValue;\n              } else if (stringValue === \"\" + expected) {\n                return expected;\n              } else {\n                return stringValue;\n              }\n            }\n          }\n        }\n        function getValueForAttribute(node, name, expected, isCustomComponentTag) {\n          {\n            if (!isAttributeNameSafe(name)) {\n              return;\n            }\n            if (!node.hasAttribute(name)) {\n              return expected === void 0 ? void 0 : null;\n            }\n            var value = node.getAttribute(name);\n            {\n              checkAttributeStringCoercion(expected, name);\n            }\n            if (value === \"\" + expected) {\n              return expected;\n            }\n            return value;\n          }\n        }\n        function setValueForProperty(node, name, value, isCustomComponentTag) {\n          var propertyInfo = getPropertyInfo(name);\n          if (shouldIgnoreAttribute(name, propertyInfo, isCustomComponentTag)) {\n            return;\n          }\n          if (shouldRemoveAttribute(name, value, propertyInfo, isCustomComponentTag)) {\n            value = null;\n          }\n          if (isCustomComponentTag || propertyInfo === null) {\n            if (isAttributeNameSafe(name)) {\n              var _attributeName = name;\n              if (value === null) {\n                node.removeAttribute(_attributeName);\n              } else {\n                {\n                  checkAttributeStringCoercion(value, name);\n                }\n                node.setAttribute(_attributeName, \"\" + value);\n              }\n            }\n            return;\n          }\n          var mustUseProperty = propertyInfo.mustUseProperty;\n          if (mustUseProperty) {\n            var propertyName = propertyInfo.propertyName;\n            if (value === null) {\n              var type = propertyInfo.type;\n              node[propertyName] = type === BOOLEAN ? false : \"\";\n            } else {\n              node[propertyName] = value;\n            }\n            return;\n          }\n          var attributeName = propertyInfo.attributeName, attributeNamespace = propertyInfo.attributeNamespace;\n          if (value === null) {\n            node.removeAttribute(attributeName);\n          } else {\n            var _type = propertyInfo.type;\n            var attributeValue;\n            if (_type === BOOLEAN || _type === OVERLOADED_BOOLEAN && value === true) {\n              attributeValue = \"\";\n            } else {\n              {\n                {\n                  checkAttributeStringCoercion(value, attributeName);\n                }\n                attributeValue = \"\" + value;\n              }\n              if (propertyInfo.sanitizeURL) {\n                sanitizeURL(attributeValue.toString());\n              }\n            }\n            if (attributeNamespace) {\n              node.setAttributeNS(attributeNamespace, attributeName, attributeValue);\n            } else {\n              node.setAttribute(attributeName, attributeValue);\n            }\n          }\n        }\n        var REACT_ELEMENT_TYPE = Symbol.for(\"react.element\");\n        var REACT_PORTAL_TYPE = Symbol.for(\"react.portal\");\n        var REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\");\n        var REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\");\n        var REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\");\n        var REACT_PROVIDER_TYPE = Symbol.for(\"react.provider\");\n        var REACT_CONTEXT_TYPE = Symbol.for(\"react.context\");\n        var REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\");\n        var REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\");\n        var REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\");\n        var REACT_MEMO_TYPE = Symbol.for(\"react.memo\");\n        var REACT_LAZY_TYPE = Symbol.for(\"react.lazy\");\n        var REACT_SCOPE_TYPE = Symbol.for(\"react.scope\");\n        var REACT_DEBUG_TRACING_MODE_TYPE = Symbol.for(\"react.debug_trace_mode\");\n        var REACT_OFFSCREEN_TYPE = Symbol.for(\"react.offscreen\");\n        var REACT_LEGACY_HIDDEN_TYPE = Symbol.for(\"react.legacy_hidden\");\n        var REACT_CACHE_TYPE = Symbol.for(\"react.cache\");\n        var REACT_TRACING_MARKER_TYPE = Symbol.for(\"react.tracing_marker\");\n        var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\n        var FAUX_ITERATOR_SYMBOL = \"@@iterator\";\n        function getIteratorFn(maybeIterable) {\n          if (maybeIterable === null || typeof maybeIterable !== \"object\") {\n            return null;\n          }\n          var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n          if (typeof maybeIterator === \"function\") {\n            return maybeIterator;\n          }\n          return null;\n        }\n        var assign = Object.assign;\n        var disabledDepth = 0;\n        var prevLog;\n        var prevInfo;\n        var prevWarn;\n        var prevError;\n        var prevGroup;\n        var prevGroupCollapsed;\n        var prevGroupEnd;\n        function disabledLog() {\n        }\n        disabledLog.__reactDisabledLog = true;\n        function disableLogs() {\n          {\n            if (disabledDepth === 0) {\n              prevLog = console.log;\n              prevInfo = console.info;\n              prevWarn = console.warn;\n              prevError = console.error;\n              prevGroup = console.group;\n              prevGroupCollapsed = console.groupCollapsed;\n              prevGroupEnd = console.groupEnd;\n              var props = {\n                configurable: true,\n                enumerable: true,\n                value: disabledLog,\n                writable: true\n              };\n              Object.defineProperties(console, {\n                info: props,\n                log: props,\n                warn: props,\n                error: props,\n                group: props,\n                groupCollapsed: props,\n                groupEnd: props\n              });\n            }\n            disabledDepth++;\n          }\n        }\n        function reenableLogs() {\n          {\n            disabledDepth--;\n            if (disabledDepth === 0) {\n              var props = {\n                configurable: true,\n                enumerable: true,\n                writable: true\n              };\n              Object.defineProperties(console, {\n                log: assign({}, props, {\n                  value: prevLog\n                }),\n                info: assign({}, props, {\n                  value: prevInfo\n                }),\n                warn: assign({}, props, {\n                  value: prevWarn\n                }),\n                error: assign({}, props, {\n                  value: prevError\n                }),\n                group: assign({}, props, {\n                  value: prevGroup\n                }),\n                groupCollapsed: assign({}, props, {\n                  value: prevGroupCollapsed\n                }),\n                groupEnd: assign({}, props, {\n                  value: prevGroupEnd\n                })\n              });\n            }\n            if (disabledDepth < 0) {\n              error(\"disabledDepth fell below zero. This is a bug in React. Please file an issue.\");\n            }\n          }\n        }\n        var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\n        var prefix;\n        function describeBuiltInComponentFrame(name, source, ownerFn) {\n          {\n            if (prefix === void 0) {\n              try {\n                throw Error();\n              } catch (x) {\n                var match = x.stack.trim().match(/\\n( *(at )?)/);\n                prefix = match && match[1] || \"\";\n              }\n            }\n            return \"\\n\" + prefix + name;\n          }\n        }\n        var reentry = false;\n        var componentFrameCache;\n        {\n          var PossiblyWeakMap = typeof WeakMap === \"function\" ? WeakMap : Map;\n          componentFrameCache = new PossiblyWeakMap();\n        }\n        function describeNativeComponentFrame(fn, construct) {\n          if (!fn || reentry) {\n            return \"\";\n          }\n          {\n            var frame = componentFrameCache.get(fn);\n            if (frame !== void 0) {\n              return frame;\n            }\n          }\n          var control;\n          reentry = true;\n          var previousPrepareStackTrace = Error.prepareStackTrace;\n          Error.prepareStackTrace = void 0;\n          var previousDispatcher;\n          {\n            previousDispatcher = ReactCurrentDispatcher.current;\n            ReactCurrentDispatcher.current = null;\n            disableLogs();\n          }\n          try {\n            if (construct) {\n              var Fake = function() {\n                throw Error();\n              };\n              Object.defineProperty(Fake.prototype, \"props\", {\n                set: function() {\n                  throw Error();\n                }\n              });\n              if (typeof Reflect === \"object\" && Reflect.construct) {\n                try {\n                  Reflect.construct(Fake, []);\n                } catch (x) {\n                  control = x;\n                }\n                Reflect.construct(fn, [], Fake);\n              } else {\n                try {\n                  Fake.call();\n                } catch (x) {\n                  control = x;\n                }\n                fn.call(Fake.prototype);\n              }\n            } else {\n              try {\n                throw Error();\n              } catch (x) {\n                control = x;\n              }\n              fn();\n            }\n          } catch (sample) {\n            if (sample && control && typeof sample.stack === \"string\") {\n              var sampleLines = sample.stack.split(\"\\n\");\n              var controlLines = control.stack.split(\"\\n\");\n              var s = sampleLines.length - 1;\n              var c = controlLines.length - 1;\n              while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {\n                c--;\n              }\n              for (; s >= 1 && c >= 0; s--, c--) {\n                if (sampleLines[s] !== controlLines[c]) {\n                  if (s !== 1 || c !== 1) {\n                    do {\n                      s--;\n                      c--;\n                      if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                        var _frame = \"\\n\" + sampleLines[s].replace(\" at new \", \" at \");\n                        if (fn.displayName && _frame.includes(\"<anonymous>\")) {\n                          _frame = _frame.replace(\"<anonymous>\", fn.displayName);\n                        }\n                        {\n                          if (typeof fn === \"function\") {\n                            componentFrameCache.set(fn, _frame);\n                          }\n                        }\n                        return _frame;\n                      }\n                    } while (s >= 1 && c >= 0);\n                  }\n                  break;\n                }\n              }\n            }\n          } finally {\n            reentry = false;\n            {\n              ReactCurrentDispatcher.current = previousDispatcher;\n              reenableLogs();\n            }\n            Error.prepareStackTrace = previousPrepareStackTrace;\n          }\n          var name = fn ? fn.displayName || fn.name : \"\";\n          var syntheticFrame = name ? describeBuiltInComponentFrame(name) : \"\";\n          {\n            if (typeof fn === \"function\") {\n              componentFrameCache.set(fn, syntheticFrame);\n            }\n          }\n          return syntheticFrame;\n        }\n        function describeClassComponentFrame(ctor, source, ownerFn) {\n          {\n            return describeNativeComponentFrame(ctor, true);\n          }\n        }\n        function describeFunctionComponentFrame(fn, source, ownerFn) {\n          {\n            return describeNativeComponentFrame(fn, false);\n          }\n        }\n        function shouldConstruct(Component) {\n          var prototype = Component.prototype;\n          return !!(prototype && prototype.isReactComponent);\n        }\n        function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {\n          if (type == null) {\n            return \"\";\n          }\n          if (typeof type === \"function\") {\n            {\n              return describeNativeComponentFrame(type, shouldConstruct(type));\n            }\n          }\n          if (typeof type === \"string\") {\n            return describeBuiltInComponentFrame(type);\n          }\n          switch (type) {\n            case REACT_SUSPENSE_TYPE:\n              return describeBuiltInComponentFrame(\"Suspense\");\n            case REACT_SUSPENSE_LIST_TYPE:\n              return describeBuiltInComponentFrame(\"SuspenseList\");\n          }\n          if (typeof type === \"object\") {\n            switch (type.$$typeof) {\n              case REACT_FORWARD_REF_TYPE:\n                return describeFunctionComponentFrame(type.render);\n              case REACT_MEMO_TYPE:\n                return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);\n              case REACT_LAZY_TYPE: {\n                var lazyComponent = type;\n                var payload = lazyComponent._payload;\n                var init = lazyComponent._init;\n                try {\n                  return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);\n                } catch (x) {\n                }\n              }\n            }\n          }\n          return \"\";\n        }\n        function describeFiber(fiber) {\n          var owner = fiber._debugOwner ? fiber._debugOwner.type : null;\n          var source = fiber._debugSource;\n          switch (fiber.tag) {\n            case HostComponent:\n              return describeBuiltInComponentFrame(fiber.type);\n            case LazyComponent:\n              return describeBuiltInComponentFrame(\"Lazy\");\n            case SuspenseComponent:\n              return describeBuiltInComponentFrame(\"Suspense\");\n            case SuspenseListComponent:\n              return describeBuiltInComponentFrame(\"SuspenseList\");\n            case FunctionComponent:\n            case IndeterminateComponent:\n            case SimpleMemoComponent:\n              return describeFunctionComponentFrame(fiber.type);\n            case ForwardRef:\n              return describeFunctionComponentFrame(fiber.type.render);\n            case ClassComponent:\n              return describeClassComponentFrame(fiber.type);\n            default:\n              return \"\";\n          }\n        }\n        function getStackByFiberInDevAndProd(workInProgress2) {\n          try {\n            var info = \"\";\n            var node = workInProgress2;\n            do {\n              info += describeFiber(node);\n              node = node.return;\n            } while (node);\n            return info;\n          } catch (x) {\n            return \"\\nError generating stack: \" + x.message + \"\\n\" + x.stack;\n          }\n        }\n        function getWrappedName(outerType, innerType, wrapperName) {\n          var displayName = outerType.displayName;\n          if (displayName) {\n            return displayName;\n          }\n          var functionName = innerType.displayName || innerType.name || \"\";\n          return functionName !== \"\" ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n        }\n        function getContextName(type) {\n          return type.displayName || \"Context\";\n        }\n        function getComponentNameFromType(type) {\n          if (type == null) {\n            return null;\n          }\n          {\n            if (typeof type.tag === \"number\") {\n              error(\"Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.\");\n            }\n          }\n          if (typeof type === \"function\") {\n            return type.displayName || type.name || null;\n          }\n          if (typeof type === \"string\") {\n            return type;\n          }\n          switch (type) {\n            case REACT_FRAGMENT_TYPE:\n              return \"Fragment\";\n            case REACT_PORTAL_TYPE:\n              return \"Portal\";\n            case REACT_PROFILER_TYPE:\n              return \"Profiler\";\n            case REACT_STRICT_MODE_TYPE:\n              return \"StrictMode\";\n            case REACT_SUSPENSE_TYPE:\n              return \"Suspense\";\n            case REACT_SUSPENSE_LIST_TYPE:\n              return \"SuspenseList\";\n          }\n          if (typeof type === \"object\") {\n            switch (type.$$typeof) {\n              case REACT_CONTEXT_TYPE:\n                var context = type;\n                return getContextName(context) + \".Consumer\";\n              case REACT_PROVIDER_TYPE:\n                var provider = type;\n                return getContextName(provider._context) + \".Provider\";\n              case REACT_FORWARD_REF_TYPE:\n                return getWrappedName(type, type.render, \"ForwardRef\");\n              case REACT_MEMO_TYPE:\n                var outerName = type.displayName || null;\n                if (outerName !== null) {\n                  return outerName;\n                }\n                return getComponentNameFromType(type.type) || \"Memo\";\n              case REACT_LAZY_TYPE: {\n                var lazyComponent = type;\n                var payload = lazyComponent._payload;\n                var init = lazyComponent._init;\n                try {\n                  return getComponentNameFromType(init(payload));\n                } catch (x) {\n                  return null;\n                }\n              }\n            }\n          }\n          return null;\n        }\n        function getWrappedName$1(outerType, innerType, wrapperName) {\n          var functionName = innerType.displayName || innerType.name || \"\";\n          return outerType.displayName || (functionName !== \"\" ? wrapperName + \"(\" + functionName + \")\" : wrapperName);\n        }\n        function getContextName$1(type) {\n          return type.displayName || \"Context\";\n        }\n        function getComponentNameFromFiber(fiber) {\n          var tag = fiber.tag, type = fiber.type;\n          switch (tag) {\n            case CacheComponent:\n              return \"Cache\";\n            case ContextConsumer:\n              var context = type;\n              return getContextName$1(context) + \".Consumer\";\n            case ContextProvider:\n              var provider = type;\n              return getContextName$1(provider._context) + \".Provider\";\n            case DehydratedFragment:\n              return \"DehydratedFragment\";\n            case ForwardRef:\n              return getWrappedName$1(type, type.render, \"ForwardRef\");\n            case Fragment:\n              return \"Fragment\";\n            case HostComponent:\n              return type;\n            case HostPortal:\n              return \"Portal\";\n            case HostRoot:\n              return \"Root\";\n            case HostText:\n              return \"Text\";\n            case LazyComponent:\n              return getComponentNameFromType(type);\n            case Mode:\n              if (type === REACT_STRICT_MODE_TYPE) {\n                return \"StrictMode\";\n              }\n              return \"Mode\";\n            case OffscreenComponent:\n              return \"Offscreen\";\n            case Profiler:\n              return \"Profiler\";\n            case ScopeComponent:\n              return \"Scope\";\n            case SuspenseComponent:\n              return \"Suspense\";\n            case SuspenseListComponent:\n              return \"SuspenseList\";\n            case TracingMarkerComponent:\n              return \"TracingMarker\";\n            case ClassComponent:\n            case FunctionComponent:\n            case IncompleteClassComponent:\n            case IndeterminateComponent:\n            case MemoComponent:\n            case SimpleMemoComponent:\n              if (typeof type === \"function\") {\n                return type.displayName || type.name || null;\n              }\n              if (typeof type === \"string\") {\n                return type;\n              }\n              break;\n          }\n          return null;\n        }\n        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n        var current = null;\n        var isRendering = false;\n        function getCurrentFiberOwnerNameInDevOrNull() {\n          {\n            if (current === null) {\n              return null;\n            }\n            var owner = current._debugOwner;\n            if (owner !== null && typeof owner !== \"undefined\") {\n              return getComponentNameFromFiber(owner);\n            }\n          }\n          return null;\n        }\n        function getCurrentFiberStackInDev() {\n          {\n            if (current === null) {\n              return \"\";\n            }\n            return getStackByFiberInDevAndProd(current);\n          }\n        }\n        function resetCurrentFiber() {\n          {\n            ReactDebugCurrentFrame.getCurrentStack = null;\n            current = null;\n            isRendering = false;\n          }\n        }\n        function setCurrentFiber(fiber) {\n          {\n            ReactDebugCurrentFrame.getCurrentStack = fiber === null ? null : getCurrentFiberStackInDev;\n            current = fiber;\n            isRendering = false;\n          }\n        }\n        function getCurrentFiber() {\n          {\n            return current;\n          }\n        }\n        function setIsRendering(rendering) {\n          {\n            isRendering = rendering;\n          }\n        }\n        function toString(value) {\n          return \"\" + value;\n        }\n        function getToStringValue(value) {\n          switch (typeof value) {\n            case \"boolean\":\n            case \"number\":\n            case \"string\":\n            case \"undefined\":\n              return value;\n            case \"object\":\n              {\n                checkFormFieldValueStringCoercion(value);\n              }\n              return value;\n            default:\n              return \"\";\n          }\n        }\n        var hasReadOnlyValue = {\n          button: true,\n          checkbox: true,\n          image: true,\n          hidden: true,\n          radio: true,\n          reset: true,\n          submit: true\n        };\n        function checkControlledValueProps(tagName, props) {\n          {\n            if (!(hasReadOnlyValue[props.type] || props.onChange || props.onInput || props.readOnly || props.disabled || props.value == null)) {\n              error(\"You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`.\");\n            }\n            if (!(props.onChange || props.readOnly || props.disabled || props.checked == null)) {\n              error(\"You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.\");\n            }\n          }\n        }\n        function isCheckable(elem) {\n          var type = elem.type;\n          var nodeName = elem.nodeName;\n          return nodeName && nodeName.toLowerCase() === \"input\" && (type === \"checkbox\" || type === \"radio\");\n        }\n        function getTracker(node) {\n          return node._valueTracker;\n        }\n        function detachTracker(node) {\n          node._valueTracker = null;\n        }\n        function getValueFromNode(node) {\n          var value = \"\";\n          if (!node) {\n            return value;\n          }\n          if (isCheckable(node)) {\n            value = node.checked ? \"true\" : \"false\";\n          } else {\n            value = node.value;\n          }\n          return value;\n        }\n        function trackValueOnNode(node) {\n          var valueField = isCheckable(node) ? \"checked\" : \"value\";\n          var descriptor = Object.getOwnPropertyDescriptor(node.constructor.prototype, valueField);\n          {\n            checkFormFieldValueStringCoercion(node[valueField]);\n          }\n          var currentValue = \"\" + node[valueField];\n          if (node.hasOwnProperty(valueField) || typeof descriptor === \"undefined\" || typeof descriptor.get !== \"function\" || typeof descriptor.set !== \"function\") {\n            return;\n          }\n          var get2 = descriptor.get, set2 = descriptor.set;\n          Object.defineProperty(node, valueField, {\n            configurable: true,\n            get: function() {\n              return get2.call(this);\n            },\n            set: function(value) {\n              {\n                checkFormFieldValueStringCoercion(value);\n              }\n              currentValue = \"\" + value;\n              set2.call(this, value);\n            }\n          });\n          Object.defineProperty(node, valueField, {\n            enumerable: descriptor.enumerable\n          });\n          var tracker = {\n            getValue: function() {\n              return currentValue;\n            },\n            setValue: function(value) {\n              {\n                checkFormFieldValueStringCoercion(value);\n              }\n              currentValue = \"\" + value;\n            },\n            stopTracking: function() {\n              detachTracker(node);\n              delete node[valueField];\n            }\n          };\n          return tracker;\n        }\n        function track(node) {\n          if (getTracker(node)) {\n            return;\n          }\n          node._valueTracker = trackValueOnNode(node);\n        }\n        function updateValueIfChanged(node) {\n          if (!node) {\n            return false;\n          }\n          var tracker = getTracker(node);\n          if (!tracker) {\n            return true;\n          }\n          var lastValue = tracker.getValue();\n          var nextValue = getValueFromNode(node);\n          if (nextValue !== lastValue) {\n            tracker.setValue(nextValue);\n            return true;\n          }\n          return false;\n        }\n        function getActiveElement(doc) {\n          doc = doc || (typeof document !== \"undefined\" ? document : void 0);\n          if (typeof doc === \"undefined\") {\n            return null;\n          }\n          try {\n            return doc.activeElement || doc.body;\n          } catch (e) {\n            return doc.body;\n          }\n        }\n        var didWarnValueDefaultValue = false;\n        var didWarnCheckedDefaultChecked = false;\n        var didWarnControlledToUncontrolled = false;\n        var didWarnUncontrolledToControlled = false;\n        function isControlled(props) {\n          var usesChecked = props.type === \"checkbox\" || props.type === \"radio\";\n          return usesChecked ? props.checked != null : props.value != null;\n        }\n        function getHostProps(element, props) {\n          var node = element;\n          var checked = props.checked;\n          var hostProps = assign({}, props, {\n            defaultChecked: void 0,\n            defaultValue: void 0,\n            value: void 0,\n            checked: checked != null ? checked : node._wrapperState.initialChecked\n          });\n          return hostProps;\n        }\n        function initWrapperState(element, props) {\n          {\n            checkControlledValueProps(\"input\", props);\n            if (props.checked !== void 0 && props.defaultChecked !== void 0 && !didWarnCheckedDefaultChecked) {\n              error(\"%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components\", getCurrentFiberOwnerNameInDevOrNull() || \"A component\", props.type);\n              didWarnCheckedDefaultChecked = true;\n            }\n            if (props.value !== void 0 && props.defaultValue !== void 0 && !didWarnValueDefaultValue) {\n              error(\"%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components\", getCurrentFiberOwnerNameInDevOrNull() || \"A component\", props.type);\n              didWarnValueDefaultValue = true;\n            }\n          }\n          var node = element;\n          var defaultValue = props.defaultValue == null ? \"\" : props.defaultValue;\n          node._wrapperState = {\n            initialChecked: props.checked != null ? props.checked : props.defaultChecked,\n            initialValue: getToStringValue(props.value != null ? props.value : defaultValue),\n            controlled: isControlled(props)\n          };\n        }\n        function updateChecked(element, props) {\n          var node = element;\n          var checked = props.checked;\n          if (checked != null) {\n            setValueForProperty(node, \"checked\", checked, false);\n          }\n        }\n        function updateWrapper(element, props) {\n          var node = element;\n          {\n            var controlled = isControlled(props);\n            if (!node._wrapperState.controlled && controlled && !didWarnUncontrolledToControlled) {\n              error(\"A component is changing an uncontrolled input to be controlled. This is likely caused by the value changing from undefined to a defined value, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components\");\n              didWarnUncontrolledToControlled = true;\n            }\n            if (node._wrapperState.controlled && !controlled && !didWarnControlledToUncontrolled) {\n              error(\"A component is changing a controlled input to be uncontrolled. This is likely caused by the value changing from a defined to undefined, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components\");\n              didWarnControlledToUncontrolled = true;\n            }\n          }\n          updateChecked(element, props);\n          var value = getToStringValue(props.value);\n          var type = props.type;\n          if (value != null) {\n            if (type === \"number\") {\n              if (value === 0 && node.value === \"\" || // We explicitly want to coerce to number here if possible.\n              // eslint-disable-next-line\n              node.value != value) {\n                node.value = toString(value);\n              }\n            } else if (node.value !== toString(value)) {\n              node.value = toString(value);\n            }\n          } else if (type === \"submit\" || type === \"reset\") {\n            node.removeAttribute(\"value\");\n            return;\n          }\n          {\n            if (props.hasOwnProperty(\"value\")) {\n              setDefaultValue(node, props.type, value);\n            } else if (props.hasOwnProperty(\"defaultValue\")) {\n              setDefaultValue(node, props.type, getToStringValue(props.defaultValue));\n            }\n          }\n          {\n            if (props.checked == null && props.defaultChecked != null) {\n              node.defaultChecked = !!props.defaultChecked;\n            }\n          }\n        }\n        function postMountWrapper(element, props, isHydrating2) {\n          var node = element;\n          if (props.hasOwnProperty(\"value\") || props.hasOwnProperty(\"defaultValue\")) {\n            var type = props.type;\n            var isButton = type === \"submit\" || type === \"reset\";\n            if (isButton && (props.value === void 0 || props.value === null)) {\n              return;\n            }\n            var initialValue = toString(node._wrapperState.initialValue);\n            if (!isHydrating2) {\n              {\n                if (initialValue !== node.value) {\n                  node.value = initialValue;\n                }\n              }\n            }\n            {\n              node.defaultValue = initialValue;\n            }\n          }\n          var name = node.name;\n          if (name !== \"\") {\n            node.name = \"\";\n          }\n          {\n            node.defaultChecked = !node.defaultChecked;\n            node.defaultChecked = !!node._wrapperState.initialChecked;\n          }\n          if (name !== \"\") {\n            node.name = name;\n          }\n        }\n        function restoreControlledState(element, props) {\n          var node = element;\n          updateWrapper(node, props);\n          updateNamedCousins(node, props);\n        }\n        function updateNamedCousins(rootNode, props) {\n          var name = props.name;\n          if (props.type === \"radio\" && name != null) {\n            var queryRoot = rootNode;\n            while (queryRoot.parentNode) {\n              queryRoot = queryRoot.parentNode;\n            }\n            {\n              checkAttributeStringCoercion(name, \"name\");\n            }\n            var group = queryRoot.querySelectorAll(\"input[name=\" + JSON.stringify(\"\" + name) + '][type=\"radio\"]');\n            for (var i = 0; i < group.length; i++) {\n              var otherNode = group[i];\n              if (otherNode === rootNode || otherNode.form !== rootNode.form) {\n                continue;\n              }\n              var otherProps = getFiberCurrentPropsFromNode(otherNode);\n              if (!otherProps) {\n                throw new Error(\"ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.\");\n              }\n              updateValueIfChanged(otherNode);\n              updateWrapper(otherNode, otherProps);\n            }\n          }\n        }\n        function setDefaultValue(node, type, value) {\n          if (\n            // Focused number inputs synchronize on blur. See ChangeEventPlugin.js\n            type !== \"number\" || getActiveElement(node.ownerDocument) !== node\n          ) {\n            if (value == null) {\n              node.defaultValue = toString(node._wrapperState.initialValue);\n            } else if (node.defaultValue !== toString(value)) {\n              node.defaultValue = toString(value);\n            }\n          }\n        }\n        var didWarnSelectedSetOnOption = false;\n        var didWarnInvalidChild = false;\n        var didWarnInvalidInnerHTML = false;\n        function validateProps(element, props) {\n          {\n            if (props.value == null) {\n              if (typeof props.children === \"object\" && props.children !== null) {\n                React.Children.forEach(props.children, function(child) {\n                  if (child == null) {\n                    return;\n                  }\n                  if (typeof child === \"string\" || typeof child === \"number\") {\n                    return;\n                  }\n                  if (!didWarnInvalidChild) {\n                    didWarnInvalidChild = true;\n                    error(\"Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>.\");\n                  }\n                });\n              } else if (props.dangerouslySetInnerHTML != null) {\n                if (!didWarnInvalidInnerHTML) {\n                  didWarnInvalidInnerHTML = true;\n                  error(\"Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected.\");\n                }\n              }\n            }\n            if (props.selected != null && !didWarnSelectedSetOnOption) {\n              error(\"Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>.\");\n              didWarnSelectedSetOnOption = true;\n            }\n          }\n        }\n        function postMountWrapper$1(element, props) {\n          if (props.value != null) {\n            element.setAttribute(\"value\", toString(getToStringValue(props.value)));\n          }\n        }\n        var isArrayImpl = Array.isArray;\n        function isArray(a) {\n          return isArrayImpl(a);\n        }\n        var didWarnValueDefaultValue$1;\n        {\n          didWarnValueDefaultValue$1 = false;\n        }\n        function getDeclarationErrorAddendum() {\n          var ownerName = getCurrentFiberOwnerNameInDevOrNull();\n          if (ownerName) {\n            return \"\\n\\nCheck the render method of `\" + ownerName + \"`.\";\n          }\n          return \"\";\n        }\n        var valuePropNames = [\"value\", \"defaultValue\"];\n        function checkSelectPropTypes(props) {\n          {\n            checkControlledValueProps(\"select\", props);\n            for (var i = 0; i < valuePropNames.length; i++) {\n              var propName = valuePropNames[i];\n              if (props[propName] == null) {\n                continue;\n              }\n              var propNameIsArray = isArray(props[propName]);\n              if (props.multiple && !propNameIsArray) {\n                error(\"The `%s` prop supplied to <select> must be an array if `multiple` is true.%s\", propName, getDeclarationErrorAddendum());\n              } else if (!props.multiple && propNameIsArray) {\n                error(\"The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.%s\", propName, getDeclarationErrorAddendum());\n              }\n            }\n          }\n        }\n        function updateOptions(node, multiple, propValue, setDefaultSelected) {\n          var options2 = node.options;\n          if (multiple) {\n            var selectedValues = propValue;\n            var selectedValue = {};\n            for (var i = 0; i < selectedValues.length; i++) {\n              selectedValue[\"$\" + selectedValues[i]] = true;\n            }\n            for (var _i = 0; _i < options2.length; _i++) {\n              var selected = selectedValue.hasOwnProperty(\"$\" + options2[_i].value);\n              if (options2[_i].selected !== selected) {\n                options2[_i].selected = selected;\n              }\n              if (selected && setDefaultSelected) {\n                options2[_i].defaultSelected = true;\n              }\n            }\n          } else {\n            var _selectedValue = toString(getToStringValue(propValue));\n            var defaultSelected = null;\n            for (var _i2 = 0; _i2 < options2.length; _i2++) {\n              if (options2[_i2].value === _selectedValue) {\n                options2[_i2].selected = true;\n                if (setDefaultSelected) {\n                  options2[_i2].defaultSelected = true;\n                }\n                return;\n              }\n              if (defaultSelected === null && !options2[_i2].disabled) {\n                defaultSelected = options2[_i2];\n              }\n            }\n            if (defaultSelected !== null) {\n              defaultSelected.selected = true;\n            }\n          }\n        }\n        function getHostProps$1(element, props) {\n          return assign({}, props, {\n            value: void 0\n          });\n        }\n        function initWrapperState$1(element, props) {\n          var node = element;\n          {\n            checkSelectPropTypes(props);\n          }\n          node._wrapperState = {\n            wasMultiple: !!props.multiple\n          };\n          {\n            if (props.value !== void 0 && props.defaultValue !== void 0 && !didWarnValueDefaultValue$1) {\n              error(\"Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://reactjs.org/link/controlled-components\");\n              didWarnValueDefaultValue$1 = true;\n            }\n          }\n        }\n        function postMountWrapper$2(element, props) {\n          var node = element;\n          node.multiple = !!props.multiple;\n          var value = props.value;\n          if (value != null) {\n            updateOptions(node, !!props.multiple, value, false);\n          } else if (props.defaultValue != null) {\n            updateOptions(node, !!props.multiple, props.defaultValue, true);\n          }\n        }\n        function postUpdateWrapper(element, props) {\n          var node = element;\n          var wasMultiple = node._wrapperState.wasMultiple;\n          node._wrapperState.wasMultiple = !!props.multiple;\n          var value = props.value;\n          if (value != null) {\n            updateOptions(node, !!props.multiple, value, false);\n          } else if (wasMultiple !== !!props.multiple) {\n            if (props.defaultValue != null) {\n              updateOptions(node, !!props.multiple, props.defaultValue, true);\n            } else {\n              updateOptions(node, !!props.multiple, props.multiple ? [] : \"\", false);\n            }\n          }\n        }\n        function restoreControlledState$1(element, props) {\n          var node = element;\n          var value = props.value;\n          if (value != null) {\n            updateOptions(node, !!props.multiple, value, false);\n          }\n        }\n        var didWarnValDefaultVal = false;\n        function getHostProps$2(element, props) {\n          var node = element;\n          if (props.dangerouslySetInnerHTML != null) {\n            throw new Error(\"`dangerouslySetInnerHTML` does not make sense on <textarea>.\");\n          }\n          var hostProps = assign({}, props, {\n            value: void 0,\n            defaultValue: void 0,\n            children: toString(node._wrapperState.initialValue)\n          });\n          return hostProps;\n        }\n        function initWrapperState$2(element, props) {\n          var node = element;\n          {\n            checkControlledValueProps(\"textarea\", props);\n            if (props.value !== void 0 && props.defaultValue !== void 0 && !didWarnValDefaultVal) {\n              error(\"%s contains a textarea with both value and defaultValue props. Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://reactjs.org/link/controlled-components\", getCurrentFiberOwnerNameInDevOrNull() || \"A component\");\n              didWarnValDefaultVal = true;\n            }\n          }\n          var initialValue = props.value;\n          if (initialValue == null) {\n            var children = props.children, defaultValue = props.defaultValue;\n            if (children != null) {\n              {\n                error(\"Use the `defaultValue` or `value` props instead of setting children on <textarea>.\");\n              }\n              {\n                if (defaultValue != null) {\n                  throw new Error(\"If you supply `defaultValue` on a <textarea>, do not pass children.\");\n                }\n                if (isArray(children)) {\n                  if (children.length > 1) {\n                    throw new Error(\"<textarea> can only have at most one child.\");\n                  }\n                  children = children[0];\n                }\n                defaultValue = children;\n              }\n            }\n            if (defaultValue == null) {\n              defaultValue = \"\";\n            }\n            initialValue = defaultValue;\n          }\n          node._wrapperState = {\n            initialValue: getToStringValue(initialValue)\n          };\n        }\n        function updateWrapper$1(element, props) {\n          var node = element;\n          var value = getToStringValue(props.value);\n          var defaultValue = getToStringValue(props.defaultValue);\n          if (value != null) {\n            var newValue = toString(value);\n            if (newValue !== node.value) {\n              node.value = newValue;\n            }\n            if (props.defaultValue == null && node.defaultValue !== newValue) {\n              node.defaultValue = newValue;\n            }\n          }\n          if (defaultValue != null) {\n            node.defaultValue = toString(defaultValue);\n          }\n        }\n        function postMountWrapper$3(element, props) {\n          var node = element;\n          var textContent = node.textContent;\n          if (textContent === node._wrapperState.initialValue) {\n            if (textContent !== \"\" && textContent !== null) {\n              node.value = textContent;\n            }\n          }\n        }\n        function restoreControlledState$2(element, props) {\n          updateWrapper$1(element, props);\n        }\n        var HTML_NAMESPACE = \"http://www.w3.org/1999/xhtml\";\n        var MATH_NAMESPACE = \"http://www.w3.org/1998/Math/MathML\";\n        var SVG_NAMESPACE = \"http://www.w3.org/2000/svg\";\n        function getIntrinsicNamespace(type) {\n          switch (type) {\n            case \"svg\":\n              return SVG_NAMESPACE;\n            case \"math\":\n              return MATH_NAMESPACE;\n            default:\n              return HTML_NAMESPACE;\n          }\n        }\n        function getChildNamespace(parentNamespace, type) {\n          if (parentNamespace == null || parentNamespace === HTML_NAMESPACE) {\n            return getIntrinsicNamespace(type);\n          }\n          if (parentNamespace === SVG_NAMESPACE && type === \"foreignObject\") {\n            return HTML_NAMESPACE;\n          }\n          return parentNamespace;\n        }\n        var createMicrosoftUnsafeLocalFunction = function(func) {\n          if (typeof MSApp !== \"undefined\" && MSApp.execUnsafeLocalFunction) {\n            return function(arg0, arg1, arg2, arg3) {\n              MSApp.execUnsafeLocalFunction(function() {\n                return func(arg0, arg1, arg2, arg3);\n              });\n            };\n          } else {\n            return func;\n          }\n        };\n        var reusableSVGContainer;\n        var setInnerHTML = createMicrosoftUnsafeLocalFunction(function(node, html) {\n          if (node.namespaceURI === SVG_NAMESPACE) {\n            if (!(\"innerHTML\" in node)) {\n              reusableSVGContainer = reusableSVGContainer || document.createElement(\"div\");\n              reusableSVGContainer.innerHTML = \"<svg>\" + html.valueOf().toString() + \"</svg>\";\n              var svgNode = reusableSVGContainer.firstChild;\n              while (node.firstChild) {\n                node.removeChild(node.firstChild);\n              }\n              while (svgNode.firstChild) {\n                node.appendChild(svgNode.firstChild);\n              }\n              return;\n            }\n          }\n          node.innerHTML = html;\n        });\n        var ELEMENT_NODE = 1;\n        var TEXT_NODE = 3;\n        var COMMENT_NODE = 8;\n        var DOCUMENT_NODE = 9;\n        var DOCUMENT_FRAGMENT_NODE = 11;\n        var setTextContent = function(node, text) {\n          if (text) {\n            var firstChild = node.firstChild;\n            if (firstChild && firstChild === node.lastChild && firstChild.nodeType === TEXT_NODE) {\n              firstChild.nodeValue = text;\n              return;\n            }\n          }\n          node.textContent = text;\n        };\n        var shorthandToLonghand = {\n          animation: [\"animationDelay\", \"animationDirection\", \"animationDuration\", \"animationFillMode\", \"animationIterationCount\", \"animationName\", \"animationPlayState\", \"animationTimingFunction\"],\n          background: [\"backgroundAttachment\", \"backgroundClip\", \"backgroundColor\", \"backgroundImage\", \"backgroundOrigin\", \"backgroundPositionX\", \"backgroundPositionY\", \"backgroundRepeat\", \"backgroundSize\"],\n          backgroundPosition: [\"backgroundPositionX\", \"backgroundPositionY\"],\n          border: [\"borderBottomColor\", \"borderBottomStyle\", \"borderBottomWidth\", \"borderImageOutset\", \"borderImageRepeat\", \"borderImageSlice\", \"borderImageSource\", \"borderImageWidth\", \"borderLeftColor\", \"borderLeftStyle\", \"borderLeftWidth\", \"borderRightColor\", \"borderRightStyle\", \"borderRightWidth\", \"borderTopColor\", \"borderTopStyle\", \"borderTopWidth\"],\n          borderBlockEnd: [\"borderBlockEndColor\", \"borderBlockEndStyle\", \"borderBlockEndWidth\"],\n          borderBlockStart: [\"borderBlockStartColor\", \"borderBlockStartStyle\", \"borderBlockStartWidth\"],\n          borderBottom: [\"borderBottomColor\", \"borderBottomStyle\", \"borderBottomWidth\"],\n          borderColor: [\"borderBottomColor\", \"borderLeftColor\", \"borderRightColor\", \"borderTopColor\"],\n          borderImage: [\"borderImageOutset\", \"borderImageRepeat\", \"borderImageSlice\", \"borderImageSource\", \"borderImageWidth\"],\n          borderInlineEnd: [\"borderInlineEndColor\", \"borderInlineEndStyle\", \"borderInlineEndWidth\"],\n          borderInlineStart: [\"borderInlineStartColor\", \"borderInlineStartStyle\", \"borderInlineStartWidth\"],\n          borderLeft: [\"borderLeftColor\", \"borderLeftStyle\", \"borderLeftWidth\"],\n          borderRadius: [\"borderBottomLeftRadius\", \"borderBottomRightRadius\", \"borderTopLeftRadius\", \"borderTopRightRadius\"],\n          borderRight: [\"borderRightColor\", \"borderRightStyle\", \"borderRightWidth\"],\n          borderStyle: [\"borderBottomStyle\", \"borderLeftStyle\", \"borderRightStyle\", \"borderTopStyle\"],\n          borderTop: [\"borderTopColor\", \"borderTopStyle\", \"borderTopWidth\"],\n          borderWidth: [\"borderBottomWidth\", \"borderLeftWidth\", \"borderRightWidth\", \"borderTopWidth\"],\n          columnRule: [\"columnRuleColor\", \"columnRuleStyle\", \"columnRuleWidth\"],\n          columns: [\"columnCount\", \"columnWidth\"],\n          flex: [\"flexBasis\", \"flexGrow\", \"flexShrink\"],\n          flexFlow: [\"flexDirection\", \"flexWrap\"],\n          font: [\"fontFamily\", \"fontFeatureSettings\", \"fontKerning\", \"fontLanguageOverride\", \"fontSize\", \"fontSizeAdjust\", \"fontStretch\", \"fontStyle\", \"fontVariant\", \"fontVariantAlternates\", \"fontVariantCaps\", \"fontVariantEastAsian\", \"fontVariantLigatures\", \"fontVariantNumeric\", \"fontVariantPosition\", \"fontWeight\", \"lineHeight\"],\n          fontVariant: [\"fontVariantAlternates\", \"fontVariantCaps\", \"fontVariantEastAsian\", \"fontVariantLigatures\", \"fontVariantNumeric\", \"fontVariantPosition\"],\n          gap: [\"columnGap\", \"rowGap\"],\n          grid: [\"gridAutoColumns\", \"gridAutoFlow\", \"gridAutoRows\", \"gridTemplateAreas\", \"gridTemplateColumns\", \"gridTemplateRows\"],\n          gridArea: [\"gridColumnEnd\", \"gridColumnStart\", \"gridRowEnd\", \"gridRowStart\"],\n          gridColumn: [\"gridColumnEnd\", \"gridColumnStart\"],\n          gridColumnGap: [\"columnGap\"],\n          gridGap: [\"columnGap\", \"rowGap\"],\n          gridRow: [\"gridRowEnd\", \"gridRowStart\"],\n          gridRowGap: [\"rowGap\"],\n          gridTemplate: [\"gridTemplateAreas\", \"gridTemplateColumns\", \"gridTemplateRows\"],\n          listStyle: [\"listStyleImage\", \"listStylePosition\", \"listStyleType\"],\n          margin: [\"marginBottom\", \"marginLeft\", \"marginRight\", \"marginTop\"],\n          marker: [\"markerEnd\", \"markerMid\", \"markerStart\"],\n          mask: [\"maskClip\", \"maskComposite\", \"maskImage\", \"maskMode\", \"maskOrigin\", \"maskPositionX\", \"maskPositionY\", \"maskRepeat\", \"maskSize\"],\n          maskPosition: [\"maskPositionX\", \"maskPositionY\"],\n          outline: [\"outlineColor\", \"outlineStyle\", \"outlineWidth\"],\n          overflow: [\"overflowX\", \"overflowY\"],\n          padding: [\"paddingBottom\", \"paddingLeft\", \"paddingRight\", \"paddingTop\"],\n          placeContent: [\"alignContent\", \"justifyContent\"],\n          placeItems: [\"alignItems\", \"justifyItems\"],\n          placeSelf: [\"alignSelf\", \"justifySelf\"],\n          textDecoration: [\"textDecorationColor\", \"textDecorationLine\", \"textDecorationStyle\"],\n          textEmphasis: [\"textEmphasisColor\", \"textEmphasisStyle\"],\n          transition: [\"transitionDelay\", \"transitionDuration\", \"transitionProperty\", \"transitionTimingFunction\"],\n          wordWrap: [\"overflowWrap\"]\n        };\n        var isUnitlessNumber = {\n          animationIterationCount: true,\n          aspectRatio: true,\n          borderImageOutset: true,\n          borderImageSlice: true,\n          borderImageWidth: true,\n          boxFlex: true,\n          boxFlexGroup: true,\n          boxOrdinalGroup: true,\n          columnCount: true,\n          columns: true,\n          flex: true,\n          flexGrow: true,\n          flexPositive: true,\n          flexShrink: true,\n          flexNegative: true,\n          flexOrder: true,\n          gridArea: true,\n          gridRow: true,\n          gridRowEnd: true,\n          gridRowSpan: true,\n          gridRowStart: true,\n          gridColumn: true,\n          gridColumnEnd: true,\n          gridColumnSpan: true,\n          gridColumnStart: true,\n          fontWeight: true,\n          lineClamp: true,\n          lineHeight: true,\n          opacity: true,\n          order: true,\n          orphans: true,\n          tabSize: true,\n          widows: true,\n          zIndex: true,\n          zoom: true,\n          // SVG-related properties\n          fillOpacity: true,\n          floodOpacity: true,\n          stopOpacity: true,\n          strokeDasharray: true,\n          strokeDashoffset: true,\n          strokeMiterlimit: true,\n          strokeOpacity: true,\n          strokeWidth: true\n        };\n        function prefixKey(prefix2, key) {\n          return prefix2 + key.charAt(0).toUpperCase() + key.substring(1);\n        }\n        var prefixes = [\"Webkit\", \"ms\", \"Moz\", \"O\"];\n        Object.keys(isUnitlessNumber).forEach(function(prop) {\n          prefixes.forEach(function(prefix2) {\n            isUnitlessNumber[prefixKey(prefix2, prop)] = isUnitlessNumber[prop];\n          });\n        });\n        function dangerousStyleValue(name, value, isCustomProperty) {\n          var isEmpty = value == null || typeof value === \"boolean\" || value === \"\";\n          if (isEmpty) {\n            return \"\";\n          }\n          if (!isCustomProperty && typeof value === \"number\" && value !== 0 && !(isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name])) {\n            return value + \"px\";\n          }\n          {\n            checkCSSPropertyStringCoercion(value, name);\n          }\n          return (\"\" + value).trim();\n        }\n        var uppercasePattern = /([A-Z])/g;\n        var msPattern = /^ms-/;\n        function hyphenateStyleName(name) {\n          return name.replace(uppercasePattern, \"-$1\").toLowerCase().replace(msPattern, \"-ms-\");\n        }\n        var warnValidStyle = function() {\n        };\n        {\n          var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;\n          var msPattern$1 = /^-ms-/;\n          var hyphenPattern = /-(.)/g;\n          var badStyleValueWithSemicolonPattern = /;\\s*$/;\n          var warnedStyleNames = {};\n          var warnedStyleValues = {};\n          var warnedForNaNValue = false;\n          var warnedForInfinityValue = false;\n          var camelize = function(string) {\n            return string.replace(hyphenPattern, function(_, character) {\n              return character.toUpperCase();\n            });\n          };\n          var warnHyphenatedStyleName = function(name) {\n            if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {\n              return;\n            }\n            warnedStyleNames[name] = true;\n            error(\n              \"Unsupported style property %s. Did you mean %s?\",\n              name,\n              // As Andi Smith suggests\n              // (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix\n              // is converted to lowercase `ms`.\n              camelize(name.replace(msPattern$1, \"ms-\"))\n            );\n          };\n          var warnBadVendoredStyleName = function(name) {\n            if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {\n              return;\n            }\n            warnedStyleNames[name] = true;\n            error(\"Unsupported vendor-prefixed style property %s. Did you mean %s?\", name, name.charAt(0).toUpperCase() + name.slice(1));\n          };\n          var warnStyleValueWithSemicolon = function(name, value) {\n            if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {\n              return;\n            }\n            warnedStyleValues[value] = true;\n            error(`Style property values shouldn't contain a semicolon. Try \"%s: %s\" instead.`, name, value.replace(badStyleValueWithSemicolonPattern, \"\"));\n          };\n          var warnStyleValueIsNaN = function(name, value) {\n            if (warnedForNaNValue) {\n              return;\n            }\n            warnedForNaNValue = true;\n            error(\"`NaN` is an invalid value for the `%s` css style property.\", name);\n          };\n          var warnStyleValueIsInfinity = function(name, value) {\n            if (warnedForInfinityValue) {\n              return;\n            }\n            warnedForInfinityValue = true;\n            error(\"`Infinity` is an invalid value for the `%s` css style property.\", name);\n          };\n          warnValidStyle = function(name, value) {\n            if (name.indexOf(\"-\") > -1) {\n              warnHyphenatedStyleName(name);\n            } else if (badVendoredStyleNamePattern.test(name)) {\n              warnBadVendoredStyleName(name);\n            } else if (badStyleValueWithSemicolonPattern.test(value)) {\n              warnStyleValueWithSemicolon(name, value);\n            }\n            if (typeof value === \"number\") {\n              if (isNaN(value)) {\n                warnStyleValueIsNaN(name, value);\n              } else if (!isFinite(value)) {\n                warnStyleValueIsInfinity(name, value);\n              }\n            }\n          };\n        }\n        var warnValidStyle$1 = warnValidStyle;\n        function createDangerousStringForStyles(styles) {\n          {\n            var serialized = \"\";\n            var delimiter = \"\";\n            for (var styleName in styles) {\n              if (!styles.hasOwnProperty(styleName)) {\n                continue;\n              }\n              var styleValue = styles[styleName];\n              if (styleValue != null) {\n                var isCustomProperty = styleName.indexOf(\"--\") === 0;\n                serialized += delimiter + (isCustomProperty ? styleName : hyphenateStyleName(styleName)) + \":\";\n                serialized += dangerousStyleValue(styleName, styleValue, isCustomProperty);\n                delimiter = \";\";\n              }\n            }\n            return serialized || null;\n          }\n        }\n        function setValueForStyles(node, styles) {\n          var style2 = node.style;\n          for (var styleName in styles) {\n            if (!styles.hasOwnProperty(styleName)) {\n              continue;\n            }\n            var isCustomProperty = styleName.indexOf(\"--\") === 0;\n            {\n              if (!isCustomProperty) {\n                warnValidStyle$1(styleName, styles[styleName]);\n              }\n            }\n            var styleValue = dangerousStyleValue(styleName, styles[styleName], isCustomProperty);\n            if (styleName === \"float\") {\n              styleName = \"cssFloat\";\n            }\n            if (isCustomProperty) {\n              style2.setProperty(styleName, styleValue);\n            } else {\n              style2[styleName] = styleValue;\n            }\n          }\n        }\n        function isValueEmpty(value) {\n          return value == null || typeof value === \"boolean\" || value === \"\";\n        }\n        function expandShorthandMap(styles) {\n          var expanded = {};\n          for (var key in styles) {\n            var longhands = shorthandToLonghand[key] || [key];\n            for (var i = 0; i < longhands.length; i++) {\n              expanded[longhands[i]] = key;\n            }\n          }\n          return expanded;\n        }\n        function validateShorthandPropertyCollisionInDev(styleUpdates, nextStyles) {\n          {\n            if (!nextStyles) {\n              return;\n            }\n            var expandedUpdates = expandShorthandMap(styleUpdates);\n            var expandedStyles = expandShorthandMap(nextStyles);\n            var warnedAbout = {};\n            for (var key in expandedUpdates) {\n              var originalKey = expandedUpdates[key];\n              var correctOriginalKey = expandedStyles[key];\n              if (correctOriginalKey && originalKey !== correctOriginalKey) {\n                var warningKey = originalKey + \",\" + correctOriginalKey;\n                if (warnedAbout[warningKey]) {\n                  continue;\n                }\n                warnedAbout[warningKey] = true;\n                error(\"%s a style property during rerender (%s) when a conflicting property is set (%s) can lead to styling bugs. To avoid this, don't mix shorthand and non-shorthand properties for the same value; instead, replace the shorthand with separate values.\", isValueEmpty(styleUpdates[originalKey]) ? \"Removing\" : \"Updating\", originalKey, correctOriginalKey);\n              }\n            }\n          }\n        }\n        var omittedCloseTags = {\n          area: true,\n          base: true,\n          br: true,\n          col: true,\n          embed: true,\n          hr: true,\n          img: true,\n          input: true,\n          keygen: true,\n          link: true,\n          meta: true,\n          param: true,\n          source: true,\n          track: true,\n          wbr: true\n          // NOTE: menuitem's close tag should be omitted, but that causes problems.\n        };\n        var voidElementTags = assign({\n          menuitem: true\n        }, omittedCloseTags);\n        var HTML = \"__html\";\n        function assertValidProps(tag, props) {\n          if (!props) {\n            return;\n          }\n          if (voidElementTags[tag]) {\n            if (props.children != null || props.dangerouslySetInnerHTML != null) {\n              throw new Error(tag + \" is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.\");\n            }\n          }\n          if (props.dangerouslySetInnerHTML != null) {\n            if (props.children != null) {\n              throw new Error(\"Can only set one of `children` or `props.dangerouslySetInnerHTML`.\");\n            }\n            if (typeof props.dangerouslySetInnerHTML !== \"object\" || !(HTML in props.dangerouslySetInnerHTML)) {\n              throw new Error(\"`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.\");\n            }\n          }\n          {\n            if (!props.suppressContentEditableWarning && props.contentEditable && props.children != null) {\n              error(\"A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional.\");\n            }\n          }\n          if (props.style != null && typeof props.style !== \"object\") {\n            throw new Error(\"The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.\");\n          }\n        }\n        function isCustomComponent(tagName, props) {\n          if (tagName.indexOf(\"-\") === -1) {\n            return typeof props.is === \"string\";\n          }\n          switch (tagName) {\n            case \"annotation-xml\":\n            case \"color-profile\":\n            case \"font-face\":\n            case \"font-face-src\":\n            case \"font-face-uri\":\n            case \"font-face-format\":\n            case \"font-face-name\":\n            case \"missing-glyph\":\n              return false;\n            default:\n              return true;\n          }\n        }\n        var possibleStandardNames = {\n          // HTML\n          accept: \"accept\",\n          acceptcharset: \"acceptCharset\",\n          \"accept-charset\": \"acceptCharset\",\n          accesskey: \"accessKey\",\n          action: \"action\",\n          allowfullscreen: \"allowFullScreen\",\n          alt: \"alt\",\n          as: \"as\",\n          async: \"async\",\n          autocapitalize: \"autoCapitalize\",\n          autocomplete: \"autoComplete\",\n          autocorrect: \"autoCorrect\",\n          autofocus: \"autoFocus\",\n          autoplay: \"autoPlay\",\n          autosave: \"autoSave\",\n          capture: \"capture\",\n          cellpadding: \"cellPadding\",\n          cellspacing: \"cellSpacing\",\n          challenge: \"challenge\",\n          charset: \"charSet\",\n          checked: \"checked\",\n          children: \"children\",\n          cite: \"cite\",\n          class: \"className\",\n          classid: \"classID\",\n          classname: \"className\",\n          cols: \"cols\",\n          colspan: \"colSpan\",\n          content: \"content\",\n          contenteditable: \"contentEditable\",\n          contextmenu: \"contextMenu\",\n          controls: \"controls\",\n          controlslist: \"controlsList\",\n          coords: \"coords\",\n          crossorigin: \"crossOrigin\",\n          dangerouslysetinnerhtml: \"dangerouslySetInnerHTML\",\n          data: \"data\",\n          datetime: \"dateTime\",\n          default: \"default\",\n          defaultchecked: \"defaultChecked\",\n          defaultvalue: \"defaultValue\",\n          defer: \"defer\",\n          dir: \"dir\",\n          disabled: \"disabled\",\n          disablepictureinpicture: \"disablePictureInPicture\",\n          disableremoteplayback: \"disableRemotePlayback\",\n          download: \"download\",\n          draggable: \"draggable\",\n          enctype: \"encType\",\n          enterkeyhint: \"enterKeyHint\",\n          for: \"htmlFor\",\n          form: \"form\",\n          formmethod: \"formMethod\",\n          formaction: \"formAction\",\n          formenctype: \"formEncType\",\n          formnovalidate: \"formNoValidate\",\n          formtarget: \"formTarget\",\n          frameborder: \"frameBorder\",\n          headers: \"headers\",\n          height: \"height\",\n          hidden: \"hidden\",\n          high: \"high\",\n          href: \"href\",\n          hreflang: \"hrefLang\",\n          htmlfor: \"htmlFor\",\n          httpequiv: \"httpEquiv\",\n          \"http-equiv\": \"httpEquiv\",\n          icon: \"icon\",\n          id: \"id\",\n          imagesizes: \"imageSizes\",\n          imagesrcset: \"imageSrcSet\",\n          innerhtml: \"innerHTML\",\n          inputmode: \"inputMode\",\n          integrity: \"integrity\",\n          is: \"is\",\n          itemid: \"itemID\",\n          itemprop: \"itemProp\",\n          itemref: \"itemRef\",\n          itemscope: \"itemScope\",\n          itemtype: \"itemType\",\n          keyparams: \"keyParams\",\n          keytype: \"keyType\",\n          kind: \"kind\",\n          label: \"label\",\n          lang: \"lang\",\n          list: \"list\",\n          loop: \"loop\",\n          low: \"low\",\n          manifest: \"manifest\",\n          marginwidth: \"marginWidth\",\n          marginheight: \"marginHeight\",\n          max: \"max\",\n          maxlength: \"maxLength\",\n          media: \"media\",\n          mediagroup: \"mediaGroup\",\n          method: \"method\",\n          min: \"min\",\n          minlength: \"minLength\",\n          multiple: \"multiple\",\n          muted: \"muted\",\n          name: \"name\",\n          nomodule: \"noModule\",\n          nonce: \"nonce\",\n          novalidate: \"noValidate\",\n          open: \"open\",\n          optimum: \"optimum\",\n          pattern: \"pattern\",\n          placeholder: \"placeholder\",\n          playsinline: \"playsInline\",\n          poster: \"poster\",\n          preload: \"preload\",\n          profile: \"profile\",\n          radiogroup: \"radioGroup\",\n          readonly: \"readOnly\",\n          referrerpolicy: \"referrerPolicy\",\n          rel: \"rel\",\n          required: \"required\",\n          reversed: \"reversed\",\n          role: \"role\",\n          rows: \"rows\",\n          rowspan: \"rowSpan\",\n          sandbox: \"sandbox\",\n          scope: \"scope\",\n          scoped: \"scoped\",\n          scrolling: \"scrolling\",\n          seamless: \"seamless\",\n          selected: \"selected\",\n          shape: \"shape\",\n          size: \"size\",\n          sizes: \"sizes\",\n          span: \"span\",\n          spellcheck: \"spellCheck\",\n          src: \"src\",\n          srcdoc: \"srcDoc\",\n          srclang: \"srcLang\",\n          srcset: \"srcSet\",\n          start: \"start\",\n          step: \"step\",\n          style: \"style\",\n          summary: \"summary\",\n          tabindex: \"tabIndex\",\n          target: \"target\",\n          title: \"title\",\n          type: \"type\",\n          usemap: \"useMap\",\n          value: \"value\",\n          width: \"width\",\n          wmode: \"wmode\",\n          wrap: \"wrap\",\n          // SVG\n          about: \"about\",\n          accentheight: \"accentHeight\",\n          \"accent-height\": \"accentHeight\",\n          accumulate: \"accumulate\",\n          additive: \"additive\",\n          alignmentbaseline: \"alignmentBaseline\",\n          \"alignment-baseline\": \"alignmentBaseline\",\n          allowreorder: \"allowReorder\",\n          alphabetic: \"alphabetic\",\n          amplitude: \"amplitude\",\n          arabicform: \"arabicForm\",\n          \"arabic-form\": \"arabicForm\",\n          ascent: \"ascent\",\n          attributename: \"attributeName\",\n          attributetype: \"attributeType\",\n          autoreverse: \"autoReverse\",\n          azimuth: \"azimuth\",\n          basefrequency: \"baseFrequency\",\n          baselineshift: \"baselineShift\",\n          \"baseline-shift\": \"baselineShift\",\n          baseprofile: \"baseProfile\",\n          bbox: \"bbox\",\n          begin: \"begin\",\n          bias: \"bias\",\n          by: \"by\",\n          calcmode: \"calcMode\",\n          capheight: \"capHeight\",\n          \"cap-height\": \"capHeight\",\n          clip: \"clip\",\n          clippath: \"clipPath\",\n          \"clip-path\": \"clipPath\",\n          clippathunits: \"clipPathUnits\",\n          cliprule: \"clipRule\",\n          \"clip-rule\": \"clipRule\",\n          color: \"color\",\n          colorinterpolation: \"colorInterpolation\",\n          \"color-interpolation\": \"colorInterpolation\",\n          colorinterpolationfilters: \"colorInterpolationFilters\",\n          \"color-interpolation-filters\": \"colorInterpolationFilters\",\n          colorprofile: \"colorProfile\",\n          \"color-profile\": \"colorProfile\",\n          colorrendering: \"colorRendering\",\n          \"color-rendering\": \"colorRendering\",\n          contentscripttype: \"contentScriptType\",\n          contentstyletype: \"contentStyleType\",\n          cursor: \"cursor\",\n          cx: \"cx\",\n          cy: \"cy\",\n          d: \"d\",\n          datatype: \"datatype\",\n          decelerate: \"decelerate\",\n          descent: \"descent\",\n          diffuseconstant: \"diffuseConstant\",\n          direction: \"direction\",\n          display: \"display\",\n          divisor: \"divisor\",\n          dominantbaseline: \"dominantBaseline\",\n          \"dominant-baseline\": \"dominantBaseline\",\n          dur: \"dur\",\n          dx: \"dx\",\n          dy: \"dy\",\n          edgemode: \"edgeMode\",\n          elevation: \"elevation\",\n          enablebackground: \"enableBackground\",\n          \"enable-background\": \"enableBackground\",\n          end: \"end\",\n          exponent: \"exponent\",\n          externalresourcesrequired: \"externalResourcesRequired\",\n          fill: \"fill\",\n          fillopacity: \"fillOpacity\",\n          \"fill-opacity\": \"fillOpacity\",\n          fillrule: \"fillRule\",\n          \"fill-rule\": \"fillRule\",\n          filter: \"filter\",\n          filterres: \"filterRes\",\n          filterunits: \"filterUnits\",\n          floodopacity: \"floodOpacity\",\n          \"flood-opacity\": \"floodOpacity\",\n          floodcolor: \"floodColor\",\n          \"flood-color\": \"floodColor\",\n          focusable: \"focusable\",\n          fontfamily: \"fontFamily\",\n          \"font-family\": \"fontFamily\",\n          fontsize: \"fontSize\",\n          \"font-size\": \"fontSize\",\n          fontsizeadjust: \"fontSizeAdjust\",\n          \"font-size-adjust\": \"fontSizeAdjust\",\n          fontstretch: \"fontStretch\",\n          \"font-stretch\": \"fontStretch\",\n          fontstyle: \"fontStyle\",\n          \"font-style\": \"fontStyle\",\n          fontvariant: \"fontVariant\",\n          \"font-variant\": \"fontVariant\",\n          fontweight: \"fontWeight\",\n          \"font-weight\": \"fontWeight\",\n          format: \"format\",\n          from: \"from\",\n          fx: \"fx\",\n          fy: \"fy\",\n          g1: \"g1\",\n          g2: \"g2\",\n          glyphname: \"glyphName\",\n          \"glyph-name\": \"glyphName\",\n          glyphorientationhorizontal: \"glyphOrientationHorizontal\",\n          \"glyph-orientation-horizontal\": \"glyphOrientationHorizontal\",\n          glyphorientationvertical: \"glyphOrientationVertical\",\n          \"glyph-orientation-vertical\": \"glyphOrientationVertical\",\n          glyphref: \"glyphRef\",\n          gradienttransform: \"gradientTransform\",\n          gradientunits: \"gradientUnits\",\n          hanging: \"hanging\",\n          horizadvx: \"horizAdvX\",\n          \"horiz-adv-x\": \"horizAdvX\",\n          horizoriginx: \"horizOriginX\",\n          \"horiz-origin-x\": \"horizOriginX\",\n          ideographic: \"ideographic\",\n          imagerendering: \"imageRendering\",\n          \"image-rendering\": \"imageRendering\",\n          in2: \"in2\",\n          in: \"in\",\n          inlist: \"inlist\",\n          intercept: \"intercept\",\n          k1: \"k1\",\n          k2: \"k2\",\n          k3: \"k3\",\n          k4: \"k4\",\n          k: \"k\",\n          kernelmatrix: \"kernelMatrix\",\n          kernelunitlength: \"kernelUnitLength\",\n          kerning: \"kerning\",\n          keypoints: \"keyPoints\",\n          keysplines: \"keySplines\",\n          keytimes: \"keyTimes\",\n          lengthadjust: \"lengthAdjust\",\n          letterspacing: \"letterSpacing\",\n          \"letter-spacing\": \"letterSpacing\",\n          lightingcolor: \"lightingColor\",\n          \"lighting-color\": \"lightingColor\",\n          limitingconeangle: \"limitingConeAngle\",\n          local: \"local\",\n          markerend: \"markerEnd\",\n          \"marker-end\": \"markerEnd\",\n          markerheight: \"markerHeight\",\n          markermid: \"markerMid\",\n          \"marker-mid\": \"markerMid\",\n          markerstart: \"markerStart\",\n          \"marker-start\": \"markerStart\",\n          markerunits: \"markerUnits\",\n          markerwidth: \"markerWidth\",\n          mask: \"mask\",\n          maskcontentunits: \"maskContentUnits\",\n          maskunits: \"maskUnits\",\n          mathematical: \"mathematical\",\n          mode: \"mode\",\n          numoctaves: \"numOctaves\",\n          offset: \"offset\",\n          opacity: \"opacity\",\n          operator: \"operator\",\n          order: \"order\",\n          orient: \"orient\",\n          orientation: \"orientation\",\n          origin: \"origin\",\n          overflow: \"overflow\",\n          overlineposition: \"overlinePosition\",\n          \"overline-position\": \"overlinePosition\",\n          overlinethickness: \"overlineThickness\",\n          \"overline-thickness\": \"overlineThickness\",\n          paintorder: \"paintOrder\",\n          \"paint-order\": \"paintOrder\",\n          panose1: \"panose1\",\n          \"panose-1\": \"panose1\",\n          pathlength: \"pathLength\",\n          patterncontentunits: \"patternContentUnits\",\n          patterntransform: \"patternTransform\",\n          patternunits: \"patternUnits\",\n          pointerevents: \"pointerEvents\",\n          \"pointer-events\": \"pointerEvents\",\n          points: \"points\",\n          pointsatx: \"pointsAtX\",\n          pointsaty: \"pointsAtY\",\n          pointsatz: \"pointsAtZ\",\n          prefix: \"prefix\",\n          preservealpha: \"preserveAlpha\",\n          preserveaspectratio: \"preserveAspectRatio\",\n          primitiveunits: \"primitiveUnits\",\n          property: \"property\",\n          r: \"r\",\n          radius: \"radius\",\n          refx: \"refX\",\n          refy: \"refY\",\n          renderingintent: \"renderingIntent\",\n          \"rendering-intent\": \"renderingIntent\",\n          repeatcount: \"repeatCount\",\n          repeatdur: \"repeatDur\",\n          requiredextensions: \"requiredExtensions\",\n          requiredfeatures: \"requiredFeatures\",\n          resource: \"resource\",\n          restart: \"restart\",\n          result: \"result\",\n          results: \"results\",\n          rotate: \"rotate\",\n          rx: \"rx\",\n          ry: \"ry\",\n          scale: \"scale\",\n          security: \"security\",\n          seed: \"seed\",\n          shaperendering: \"shapeRendering\",\n          \"shape-rendering\": \"shapeRendering\",\n          slope: \"slope\",\n          spacing: \"spacing\",\n          specularconstant: \"specularConstant\",\n          specularexponent: \"specularExponent\",\n          speed: \"speed\",\n          spreadmethod: \"spreadMethod\",\n          startoffset: \"startOffset\",\n          stddeviation: \"stdDeviation\",\n          stemh: \"stemh\",\n          stemv: \"stemv\",\n          stitchtiles: \"stitchTiles\",\n          stopcolor: \"stopColor\",\n          \"stop-color\": \"stopColor\",\n          stopopacity: \"stopOpacity\",\n          \"stop-opacity\": \"stopOpacity\",\n          strikethroughposition: \"strikethroughPosition\",\n          \"strikethrough-position\": \"strikethroughPosition\",\n          strikethroughthickness: \"strikethroughThickness\",\n          \"strikethrough-thickness\": \"strikethroughThickness\",\n          string: \"string\",\n          stroke: \"stroke\",\n          strokedasharray: \"strokeDasharray\",\n          \"stroke-dasharray\": \"strokeDasharray\",\n          strokedashoffset: \"strokeDashoffset\",\n          \"stroke-dashoffset\": \"strokeDashoffset\",\n          strokelinecap: \"strokeLinecap\",\n          \"stroke-linecap\": \"strokeLinecap\",\n          strokelinejoin: \"strokeLinejoin\",\n          \"stroke-linejoin\": \"strokeLinejoin\",\n          strokemiterlimit: \"strokeMiterlimit\",\n          \"stroke-miterlimit\": \"strokeMiterlimit\",\n          strokewidth: \"strokeWidth\",\n          \"stroke-width\": \"strokeWidth\",\n          strokeopacity: \"strokeOpacity\",\n          \"stroke-opacity\": \"strokeOpacity\",\n          suppresscontenteditablewarning: \"suppressContentEditableWarning\",\n          suppresshydrationwarning: \"suppressHydrationWarning\",\n          surfacescale: \"surfaceScale\",\n          systemlanguage: \"systemLanguage\",\n          tablevalues: \"tableValues\",\n          targetx: \"targetX\",\n          targety: \"targetY\",\n          textanchor: \"textAnchor\",\n          \"text-anchor\": \"textAnchor\",\n          textdecoration: \"textDecoration\",\n          \"text-decoration\": \"textDecoration\",\n          textlength: \"textLength\",\n          textrendering: \"textRendering\",\n          \"text-rendering\": \"textRendering\",\n          to: \"to\",\n          transform: \"transform\",\n          typeof: \"typeof\",\n          u1: \"u1\",\n          u2: \"u2\",\n          underlineposition: \"underlinePosition\",\n          \"underline-position\": \"underlinePosition\",\n          underlinethickness: \"underlineThickness\",\n          \"underline-thickness\": \"underlineThickness\",\n          unicode: \"unicode\",\n          unicodebidi: \"unicodeBidi\",\n          \"unicode-bidi\": \"unicodeBidi\",\n          unicoderange: \"unicodeRange\",\n          \"unicode-range\": \"unicodeRange\",\n          unitsperem: \"unitsPerEm\",\n          \"units-per-em\": \"unitsPerEm\",\n          unselectable: \"unselectable\",\n          valphabetic: \"vAlphabetic\",\n          \"v-alphabetic\": \"vAlphabetic\",\n          values: \"values\",\n          vectoreffect: \"vectorEffect\",\n          \"vector-effect\": \"vectorEffect\",\n          version: \"version\",\n          vertadvy: \"vertAdvY\",\n          \"vert-adv-y\": \"vertAdvY\",\n          vertoriginx: \"vertOriginX\",\n          \"vert-origin-x\": \"vertOriginX\",\n          vertoriginy: \"vertOriginY\",\n          \"vert-origin-y\": \"vertOriginY\",\n          vhanging: \"vHanging\",\n          \"v-hanging\": \"vHanging\",\n          videographic: \"vIdeographic\",\n          \"v-ideographic\": \"vIdeographic\",\n          viewbox: \"viewBox\",\n          viewtarget: \"viewTarget\",\n          visibility: \"visibility\",\n          vmathematical: \"vMathematical\",\n          \"v-mathematical\": \"vMathematical\",\n          vocab: \"vocab\",\n          widths: \"widths\",\n          wordspacing: \"wordSpacing\",\n          \"word-spacing\": \"wordSpacing\",\n          writingmode: \"writingMode\",\n          \"writing-mode\": \"writingMode\",\n          x1: \"x1\",\n          x2: \"x2\",\n          x: \"x\",\n          xchannelselector: \"xChannelSelector\",\n          xheight: \"xHeight\",\n          \"x-height\": \"xHeight\",\n          xlinkactuate: \"xlinkActuate\",\n          \"xlink:actuate\": \"xlinkActuate\",\n          xlinkarcrole: \"xlinkArcrole\",\n          \"xlink:arcrole\": \"xlinkArcrole\",\n          xlinkhref: \"xlinkHref\",\n          \"xlink:href\": \"xlinkHref\",\n          xlinkrole: \"xlinkRole\",\n          \"xlink:role\": \"xlinkRole\",\n          xlinkshow: \"xlinkShow\",\n          \"xlink:show\": \"xlinkShow\",\n          xlinktitle: \"xlinkTitle\",\n          \"xlink:title\": \"xlinkTitle\",\n          xlinktype: \"xlinkType\",\n          \"xlink:type\": \"xlinkType\",\n          xmlbase: \"xmlBase\",\n          \"xml:base\": \"xmlBase\",\n          xmllang: \"xmlLang\",\n          \"xml:lang\": \"xmlLang\",\n          xmlns: \"xmlns\",\n          \"xml:space\": \"xmlSpace\",\n          xmlnsxlink: \"xmlnsXlink\",\n          \"xmlns:xlink\": \"xmlnsXlink\",\n          xmlspace: \"xmlSpace\",\n          y1: \"y1\",\n          y2: \"y2\",\n          y: \"y\",\n          ychannelselector: \"yChannelSelector\",\n          z: \"z\",\n          zoomandpan: \"zoomAndPan\"\n        };\n        var ariaProperties = {\n          \"aria-current\": 0,\n          // state\n          \"aria-description\": 0,\n          \"aria-details\": 0,\n          \"aria-disabled\": 0,\n          // state\n          \"aria-hidden\": 0,\n          // state\n          \"aria-invalid\": 0,\n          // state\n          \"aria-keyshortcuts\": 0,\n          \"aria-label\": 0,\n          \"aria-roledescription\": 0,\n          // Widget Attributes\n          \"aria-autocomplete\": 0,\n          \"aria-checked\": 0,\n          \"aria-expanded\": 0,\n          \"aria-haspopup\": 0,\n          \"aria-level\": 0,\n          \"aria-modal\": 0,\n          \"aria-multiline\": 0,\n          \"aria-multiselectable\": 0,\n          \"aria-orientation\": 0,\n          \"aria-placeholder\": 0,\n          \"aria-pressed\": 0,\n          \"aria-readonly\": 0,\n          \"aria-required\": 0,\n          \"aria-selected\": 0,\n          \"aria-sort\": 0,\n          \"aria-valuemax\": 0,\n          \"aria-valuemin\": 0,\n          \"aria-valuenow\": 0,\n          \"aria-valuetext\": 0,\n          // Live Region Attributes\n          \"aria-atomic\": 0,\n          \"aria-busy\": 0,\n          \"aria-live\": 0,\n          \"aria-relevant\": 0,\n          // Drag-and-Drop Attributes\n          \"aria-dropeffect\": 0,\n          \"aria-grabbed\": 0,\n          // Relationship Attributes\n          \"aria-activedescendant\": 0,\n          \"aria-colcount\": 0,\n          \"aria-colindex\": 0,\n          \"aria-colspan\": 0,\n          \"aria-controls\": 0,\n          \"aria-describedby\": 0,\n          \"aria-errormessage\": 0,\n          \"aria-flowto\": 0,\n          \"aria-labelledby\": 0,\n          \"aria-owns\": 0,\n          \"aria-posinset\": 0,\n          \"aria-rowcount\": 0,\n          \"aria-rowindex\": 0,\n          \"aria-rowspan\": 0,\n          \"aria-setsize\": 0\n        };\n        var warnedProperties = {};\n        var rARIA = new RegExp(\"^(aria)-[\" + ATTRIBUTE_NAME_CHAR + \"]*$\");\n        var rARIACamel = new RegExp(\"^(aria)[A-Z][\" + ATTRIBUTE_NAME_CHAR + \"]*$\");\n        function validateProperty(tagName, name) {\n          {\n            if (hasOwnProperty.call(warnedProperties, name) && warnedProperties[name]) {\n              return true;\n            }\n            if (rARIACamel.test(name)) {\n              var ariaName = \"aria-\" + name.slice(4).toLowerCase();\n              var correctName = ariaProperties.hasOwnProperty(ariaName) ? ariaName : null;\n              if (correctName == null) {\n                error(\"Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.\", name);\n                warnedProperties[name] = true;\n                return true;\n              }\n              if (name !== correctName) {\n                error(\"Invalid ARIA attribute `%s`. Did you mean `%s`?\", name, correctName);\n                warnedProperties[name] = true;\n                return true;\n              }\n            }\n            if (rARIA.test(name)) {\n              var lowerCasedName = name.toLowerCase();\n              var standardName = ariaProperties.hasOwnProperty(lowerCasedName) ? lowerCasedName : null;\n              if (standardName == null) {\n                warnedProperties[name] = true;\n                return false;\n              }\n              if (name !== standardName) {\n                error(\"Unknown ARIA attribute `%s`. Did you mean `%s`?\", name, standardName);\n                warnedProperties[name] = true;\n                return true;\n              }\n            }\n          }\n          return true;\n        }\n        function warnInvalidARIAProps(type, props) {\n          {\n            var invalidProps = [];\n            for (var key in props) {\n              var isValid = validateProperty(type, key);\n              if (!isValid) {\n                invalidProps.push(key);\n              }\n            }\n            var unknownPropString = invalidProps.map(function(prop) {\n              return \"`\" + prop + \"`\";\n            }).join(\", \");\n            if (invalidProps.length === 1) {\n              error(\"Invalid aria prop %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props\", unknownPropString, type);\n            } else if (invalidProps.length > 1) {\n              error(\"Invalid aria props %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props\", unknownPropString, type);\n            }\n          }\n        }\n        function validateProperties(type, props) {\n          if (isCustomComponent(type, props)) {\n            return;\n          }\n          warnInvalidARIAProps(type, props);\n        }\n        var didWarnValueNull = false;\n        function validateProperties$1(type, props) {\n          {\n            if (type !== \"input\" && type !== \"textarea\" && type !== \"select\") {\n              return;\n            }\n            if (props != null && props.value === null && !didWarnValueNull) {\n              didWarnValueNull = true;\n              if (type === \"select\" && props.multiple) {\n                error(\"`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.\", type);\n              } else {\n                error(\"`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.\", type);\n              }\n            }\n          }\n        }\n        var validateProperty$1 = function() {\n        };\n        {\n          var warnedProperties$1 = {};\n          var EVENT_NAME_REGEX = /^on./;\n          var INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/;\n          var rARIA$1 = new RegExp(\"^(aria)-[\" + ATTRIBUTE_NAME_CHAR + \"]*$\");\n          var rARIACamel$1 = new RegExp(\"^(aria)[A-Z][\" + ATTRIBUTE_NAME_CHAR + \"]*$\");\n          validateProperty$1 = function(tagName, name, value, eventRegistry) {\n            if (hasOwnProperty.call(warnedProperties$1, name) && warnedProperties$1[name]) {\n              return true;\n            }\n            var lowerCasedName = name.toLowerCase();\n            if (lowerCasedName === \"onfocusin\" || lowerCasedName === \"onfocusout\") {\n              error(\"React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React.\");\n              warnedProperties$1[name] = true;\n              return true;\n            }\n            if (eventRegistry != null) {\n              var registrationNameDependencies2 = eventRegistry.registrationNameDependencies, possibleRegistrationNames2 = eventRegistry.possibleRegistrationNames;\n              if (registrationNameDependencies2.hasOwnProperty(name)) {\n                return true;\n              }\n              var registrationName = possibleRegistrationNames2.hasOwnProperty(lowerCasedName) ? possibleRegistrationNames2[lowerCasedName] : null;\n              if (registrationName != null) {\n                error(\"Invalid event handler property `%s`. Did you mean `%s`?\", name, registrationName);\n                warnedProperties$1[name] = true;\n                return true;\n              }\n              if (EVENT_NAME_REGEX.test(name)) {\n                error(\"Unknown event handler property `%s`. It will be ignored.\", name);\n                warnedProperties$1[name] = true;\n                return true;\n              }\n            } else if (EVENT_NAME_REGEX.test(name)) {\n              if (INVALID_EVENT_NAME_REGEX.test(name)) {\n                error(\"Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.\", name);\n              }\n              warnedProperties$1[name] = true;\n              return true;\n            }\n            if (rARIA$1.test(name) || rARIACamel$1.test(name)) {\n              return true;\n            }\n            if (lowerCasedName === \"innerhtml\") {\n              error(\"Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`.\");\n              warnedProperties$1[name] = true;\n              return true;\n            }\n            if (lowerCasedName === \"aria\") {\n              error(\"The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead.\");\n              warnedProperties$1[name] = true;\n              return true;\n            }\n            if (lowerCasedName === \"is\" && value !== null && value !== void 0 && typeof value !== \"string\") {\n              error(\"Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.\", typeof value);\n              warnedProperties$1[name] = true;\n              return true;\n            }\n            if (typeof value === \"number\" && isNaN(value)) {\n              error(\"Received NaN for the `%s` attribute. If this is expected, cast the value to a string.\", name);\n              warnedProperties$1[name] = true;\n              return true;\n            }\n            var propertyInfo = getPropertyInfo(name);\n            var isReserved = propertyInfo !== null && propertyInfo.type === RESERVED;\n            if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {\n              var standardName = possibleStandardNames[lowerCasedName];\n              if (standardName !== name) {\n                error(\"Invalid DOM property `%s`. Did you mean `%s`?\", name, standardName);\n                warnedProperties$1[name] = true;\n                return true;\n              }\n            } else if (!isReserved && name !== lowerCasedName) {\n              error(\"React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.\", name, lowerCasedName);\n              warnedProperties$1[name] = true;\n              return true;\n            }\n            if (typeof value === \"boolean\" && shouldRemoveAttributeWithWarning(name, value, propertyInfo, false)) {\n              if (value) {\n                error('Received `%s` for a non-boolean attribute `%s`.\\n\\nIf you want to write it to the DOM, pass a string instead: %s=\"%s\" or %s={value.toString()}.', value, name, name, value, name);\n              } else {\n                error('Received `%s` for a non-boolean attribute `%s`.\\n\\nIf you want to write it to the DOM, pass a string instead: %s=\"%s\" or %s={value.toString()}.\\n\\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.', value, name, name, value, name, name, name);\n              }\n              warnedProperties$1[name] = true;\n              return true;\n            }\n            if (isReserved) {\n              return true;\n            }\n            if (shouldRemoveAttributeWithWarning(name, value, propertyInfo, false)) {\n              warnedProperties$1[name] = true;\n              return false;\n            }\n            if ((value === \"false\" || value === \"true\") && propertyInfo !== null && propertyInfo.type === BOOLEAN) {\n              error(\"Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?\", value, name, value === \"false\" ? \"The browser will interpret it as a truthy value.\" : 'Although this works, it will not work as expected if you pass the string \"false\".', name, value);\n              warnedProperties$1[name] = true;\n              return true;\n            }\n            return true;\n          };\n        }\n        var warnUnknownProperties = function(type, props, eventRegistry) {\n          {\n            var unknownProps = [];\n            for (var key in props) {\n              var isValid = validateProperty$1(type, key, props[key], eventRegistry);\n              if (!isValid) {\n                unknownProps.push(key);\n              }\n            }\n            var unknownPropString = unknownProps.map(function(prop) {\n              return \"`\" + prop + \"`\";\n            }).join(\", \");\n            if (unknownProps.length === 1) {\n              error(\"Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://reactjs.org/link/attribute-behavior \", unknownPropString, type);\n            } else if (unknownProps.length > 1) {\n              error(\"Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://reactjs.org/link/attribute-behavior \", unknownPropString, type);\n            }\n          }\n        };\n        function validateProperties$2(type, props, eventRegistry) {\n          if (isCustomComponent(type, props)) {\n            return;\n          }\n          warnUnknownProperties(type, props, eventRegistry);\n        }\n        var IS_EVENT_HANDLE_NON_MANAGED_NODE = 1;\n        var IS_NON_DELEGATED = 1 << 1;\n        var IS_CAPTURE_PHASE = 1 << 2;\n        var SHOULD_NOT_PROCESS_POLYFILL_EVENT_PLUGINS = IS_EVENT_HANDLE_NON_MANAGED_NODE | IS_NON_DELEGATED | IS_CAPTURE_PHASE;\n        var currentReplayingEvent = null;\n        function setReplayingEvent(event) {\n          {\n            if (currentReplayingEvent !== null) {\n              error(\"Expected currently replaying event to be null. This error is likely caused by a bug in React. Please file an issue.\");\n            }\n          }\n          currentReplayingEvent = event;\n        }\n        function resetReplayingEvent() {\n          {\n            if (currentReplayingEvent === null) {\n              error(\"Expected currently replaying event to not be null. This error is likely caused by a bug in React. Please file an issue.\");\n            }\n          }\n          currentReplayingEvent = null;\n        }\n        function isReplayingEvent(event) {\n          return event === currentReplayingEvent;\n        }\n        function getEventTarget(nativeEvent) {\n          var target = nativeEvent.target || nativeEvent.srcElement || window;\n          if (target.correspondingUseElement) {\n            target = target.correspondingUseElement;\n          }\n          return target.nodeType === TEXT_NODE ? target.parentNode : target;\n        }\n        var restoreImpl = null;\n        var restoreTarget = null;\n        var restoreQueue = null;\n        function restoreStateOfTarget(target) {\n          var internalInstance = getInstanceFromNode(target);\n          if (!internalInstance) {\n            return;\n          }\n          if (typeof restoreImpl !== \"function\") {\n            throw new Error(\"setRestoreImplementation() needs to be called to handle a target for controlled events. This error is likely caused by a bug in React. Please file an issue.\");\n          }\n          var stateNode = internalInstance.stateNode;\n          if (stateNode) {\n            var _props = getFiberCurrentPropsFromNode(stateNode);\n            restoreImpl(internalInstance.stateNode, internalInstance.type, _props);\n          }\n        }\n        function setRestoreImplementation(impl) {\n          restoreImpl = impl;\n        }\n        function enqueueStateRestore(target) {\n          if (restoreTarget) {\n            if (restoreQueue) {\n              restoreQueue.push(target);\n            } else {\n              restoreQueue = [target];\n            }\n          } else {\n            restoreTarget = target;\n          }\n        }\n        function needsStateRestore() {\n          return restoreTarget !== null || restoreQueue !== null;\n        }\n        function restoreStateIfNeeded() {\n          if (!restoreTarget) {\n            return;\n          }\n          var target = restoreTarget;\n          var queuedTargets = restoreQueue;\n          restoreTarget = null;\n          restoreQueue = null;\n          restoreStateOfTarget(target);\n          if (queuedTargets) {\n            for (var i = 0; i < queuedTargets.length; i++) {\n              restoreStateOfTarget(queuedTargets[i]);\n            }\n          }\n        }\n        var batchedUpdatesImpl = function(fn, bookkeeping) {\n          return fn(bookkeeping);\n        };\n        var flushSyncImpl = function() {\n        };\n        var isInsideEventHandler = false;\n        function finishEventHandler() {\n          var controlledComponentsHavePendingUpdates = needsStateRestore();\n          if (controlledComponentsHavePendingUpdates) {\n            flushSyncImpl();\n            restoreStateIfNeeded();\n          }\n        }\n        function batchedUpdates(fn, a, b) {\n          if (isInsideEventHandler) {\n            return fn(a, b);\n          }\n          isInsideEventHandler = true;\n          try {\n            return batchedUpdatesImpl(fn, a, b);\n          } finally {\n            isInsideEventHandler = false;\n            finishEventHandler();\n          }\n        }\n        function setBatchingImplementation(_batchedUpdatesImpl, _discreteUpdatesImpl, _flushSyncImpl) {\n          batchedUpdatesImpl = _batchedUpdatesImpl;\n          flushSyncImpl = _flushSyncImpl;\n        }\n        function isInteractive(tag) {\n          return tag === \"button\" || tag === \"input\" || tag === \"select\" || tag === \"textarea\";\n        }\n        function shouldPreventMouseEvent(name, type, props) {\n          switch (name) {\n            case \"onClick\":\n            case \"onClickCapture\":\n            case \"onDoubleClick\":\n            case \"onDoubleClickCapture\":\n            case \"onMouseDown\":\n            case \"onMouseDownCapture\":\n            case \"onMouseMove\":\n            case \"onMouseMoveCapture\":\n            case \"onMouseUp\":\n            case \"onMouseUpCapture\":\n            case \"onMouseEnter\":\n              return !!(props.disabled && isInteractive(type));\n            default:\n              return false;\n          }\n        }\n        function getListener(inst, registrationName) {\n          var stateNode = inst.stateNode;\n          if (stateNode === null) {\n            return null;\n          }\n          var props = getFiberCurrentPropsFromNode(stateNode);\n          if (props === null) {\n            return null;\n          }\n          var listener = props[registrationName];\n          if (shouldPreventMouseEvent(registrationName, inst.type, props)) {\n            return null;\n          }\n          if (listener && typeof listener !== \"function\") {\n            throw new Error(\"Expected `\" + registrationName + \"` listener to be a function, instead got a value of `\" + typeof listener + \"` type.\");\n          }\n          return listener;\n        }\n        var passiveBrowserEventsSupported = false;\n        if (canUseDOM) {\n          try {\n            var options = {};\n            Object.defineProperty(options, \"passive\", {\n              get: function() {\n                passiveBrowserEventsSupported = true;\n              }\n            });\n            window.addEventListener(\"test\", options, options);\n            window.removeEventListener(\"test\", options, options);\n          } catch (e) {\n            passiveBrowserEventsSupported = false;\n          }\n        }\n        function invokeGuardedCallbackProd(name, func, context, a, b, c, d, e, f) {\n          var funcArgs = Array.prototype.slice.call(arguments, 3);\n          try {\n            func.apply(context, funcArgs);\n          } catch (error2) {\n            this.onError(error2);\n          }\n        }\n        var invokeGuardedCallbackImpl = invokeGuardedCallbackProd;\n        {\n          if (typeof window !== \"undefined\" && typeof window.dispatchEvent === \"function\" && typeof document !== \"undefined\" && typeof document.createEvent === \"function\") {\n            var fakeNode = document.createElement(\"react\");\n            invokeGuardedCallbackImpl = function invokeGuardedCallbackDev(name, func, context, a, b, c, d, e, f) {\n              if (typeof document === \"undefined\" || document === null) {\n                throw new Error(\"The `document` global was defined when React was initialized, but is not defined anymore. This can happen in a test environment if a component schedules an update from an asynchronous callback, but the test has already finished running. To solve this, you can either unmount the component at the end of your test (and ensure that any asynchronous operations get canceled in `componentWillUnmount`), or you can change the test itself to be asynchronous.\");\n              }\n              var evt = document.createEvent(\"Event\");\n              var didCall = false;\n              var didError = true;\n              var windowEvent = window.event;\n              var windowEventDescriptor = Object.getOwnPropertyDescriptor(window, \"event\");\n              function restoreAfterDispatch() {\n                fakeNode.removeEventListener(evtType, callCallback2, false);\n                if (typeof window.event !== \"undefined\" && window.hasOwnProperty(\"event\")) {\n                  window.event = windowEvent;\n                }\n              }\n              var funcArgs = Array.prototype.slice.call(arguments, 3);\n              function callCallback2() {\n                didCall = true;\n                restoreAfterDispatch();\n                func.apply(context, funcArgs);\n                didError = false;\n              }\n              var error2;\n              var didSetError = false;\n              var isCrossOriginError = false;\n              function handleWindowError(event) {\n                error2 = event.error;\n                didSetError = true;\n                if (error2 === null && event.colno === 0 && event.lineno === 0) {\n                  isCrossOriginError = true;\n                }\n                if (event.defaultPrevented) {\n                  if (error2 != null && typeof error2 === \"object\") {\n                    try {\n                      error2._suppressLogging = true;\n                    } catch (inner) {\n                    }\n                  }\n                }\n              }\n              var evtType = \"react-\" + (name ? name : \"invokeguardedcallback\");\n              window.addEventListener(\"error\", handleWindowError);\n              fakeNode.addEventListener(evtType, callCallback2, false);\n              evt.initEvent(evtType, false, false);\n              fakeNode.dispatchEvent(evt);\n              if (windowEventDescriptor) {\n                Object.defineProperty(window, \"event\", windowEventDescriptor);\n              }\n              if (didCall && didError) {\n                if (!didSetError) {\n                  error2 = new Error(`An error was thrown inside one of your components, but React doesn't know what it was. This is likely due to browser flakiness. React does its best to preserve the \"Pause on exceptions\" behavior of the DevTools, which requires some DEV-mode only tricks. It's possible that these don't work in your browser. Try triggering the error in production mode, or switching to a modern browser. If you suspect that this is actually an issue with React, please file an issue.`);\n                } else if (isCrossOriginError) {\n                  error2 = new Error(\"A cross-origin error was thrown. React doesn't have access to the actual error object in development. See https://reactjs.org/link/crossorigin-error for more information.\");\n                }\n                this.onError(error2);\n              }\n              window.removeEventListener(\"error\", handleWindowError);\n              if (!didCall) {\n                restoreAfterDispatch();\n                return invokeGuardedCallbackProd.apply(this, arguments);\n              }\n            };\n          }\n        }\n        var invokeGuardedCallbackImpl$1 = invokeGuardedCallbackImpl;\n        var hasError = false;\n        var caughtError = null;\n        var hasRethrowError = false;\n        var rethrowError = null;\n        var reporter = {\n          onError: function(error2) {\n            hasError = true;\n            caughtError = error2;\n          }\n        };\n        function invokeGuardedCallback(name, func, context, a, b, c, d, e, f) {\n          hasError = false;\n          caughtError = null;\n          invokeGuardedCallbackImpl$1.apply(reporter, arguments);\n        }\n        function invokeGuardedCallbackAndCatchFirstError(name, func, context, a, b, c, d, e, f) {\n          invokeGuardedCallback.apply(this, arguments);\n          if (hasError) {\n            var error2 = clearCaughtError();\n            if (!hasRethrowError) {\n              hasRethrowError = true;\n              rethrowError = error2;\n            }\n          }\n        }\n        function rethrowCaughtError() {\n          if (hasRethrowError) {\n            var error2 = rethrowError;\n            hasRethrowError = false;\n            rethrowError = null;\n            throw error2;\n          }\n        }\n        function hasCaughtError() {\n          return hasError;\n        }\n        function clearCaughtError() {\n          if (hasError) {\n            var error2 = caughtError;\n            hasError = false;\n            caughtError = null;\n            return error2;\n          } else {\n            throw new Error(\"clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue.\");\n          }\n        }\n        function get(key) {\n          return key._reactInternals;\n        }\n        function has(key) {\n          return key._reactInternals !== void 0;\n        }\n        function set(key, value) {\n          key._reactInternals = value;\n        }\n        var NoFlags = (\n          /*                      */\n          0\n        );\n        var PerformedWork = (\n          /*                */\n          1\n        );\n        var Placement = (\n          /*                    */\n          2\n        );\n        var Update = (\n          /*                       */\n          4\n        );\n        var ChildDeletion = (\n          /*                */\n          16\n        );\n        var ContentReset = (\n          /*                 */\n          32\n        );\n        var Callback = (\n          /*                     */\n          64\n        );\n        var DidCapture = (\n          /*                   */\n          128\n        );\n        var ForceClientRender = (\n          /*            */\n          256\n        );\n        var Ref = (\n          /*                          */\n          512\n        );\n        var Snapshot = (\n          /*                     */\n          1024\n        );\n        var Passive = (\n          /*                      */\n          2048\n        );\n        var Hydrating = (\n          /*                    */\n          4096\n        );\n        var Visibility = (\n          /*                   */\n          8192\n        );\n        var StoreConsistency = (\n          /*             */\n          16384\n        );\n        var LifecycleEffectMask = Passive | Update | Callback | Ref | Snapshot | StoreConsistency;\n        var HostEffectMask = (\n          /*               */\n          32767\n        );\n        var Incomplete = (\n          /*                   */\n          32768\n        );\n        var ShouldCapture = (\n          /*                */\n          65536\n        );\n        var ForceUpdateForLegacySuspense = (\n          /* */\n          131072\n        );\n        var Forked = (\n          /*                       */\n          1048576\n        );\n        var RefStatic = (\n          /*                    */\n          2097152\n        );\n        var LayoutStatic = (\n          /*                 */\n          4194304\n        );\n        var PassiveStatic = (\n          /*                */\n          8388608\n        );\n        var MountLayoutDev = (\n          /*               */\n          16777216\n        );\n        var MountPassiveDev = (\n          /*              */\n          33554432\n        );\n        var BeforeMutationMask = (\n          // TODO: Remove Update flag from before mutation phase by re-landing Visibility\n          // flag logic (see #20043)\n          Update | Snapshot | 0\n        );\n        var MutationMask = Placement | Update | ChildDeletion | ContentReset | Ref | Hydrating | Visibility;\n        var LayoutMask = Update | Callback | Ref | Visibility;\n        var PassiveMask = Passive | ChildDeletion;\n        var StaticMask = LayoutStatic | PassiveStatic | RefStatic;\n        var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\n        function getNearestMountedFiber(fiber) {\n          var node = fiber;\n          var nearestMounted = fiber;\n          if (!fiber.alternate) {\n            var nextNode = node;\n            do {\n              node = nextNode;\n              if ((node.flags & (Placement | Hydrating)) !== NoFlags) {\n                nearestMounted = node.return;\n              }\n              nextNode = node.return;\n            } while (nextNode);\n          } else {\n            while (node.return) {\n              node = node.return;\n            }\n          }\n          if (node.tag === HostRoot) {\n            return nearestMounted;\n          }\n          return null;\n        }\n        function getSuspenseInstanceFromFiber(fiber) {\n          if (fiber.tag === SuspenseComponent) {\n            var suspenseState = fiber.memoizedState;\n            if (suspenseState === null) {\n              var current2 = fiber.alternate;\n              if (current2 !== null) {\n                suspenseState = current2.memoizedState;\n              }\n            }\n            if (suspenseState !== null) {\n              return suspenseState.dehydrated;\n            }\n          }\n          return null;\n        }\n        function getContainerFromFiber(fiber) {\n          return fiber.tag === HostRoot ? fiber.stateNode.containerInfo : null;\n        }\n        function isFiberMounted(fiber) {\n          return getNearestMountedFiber(fiber) === fiber;\n        }\n        function isMounted(component) {\n          {\n            var owner = ReactCurrentOwner.current;\n            if (owner !== null && owner.tag === ClassComponent) {\n              var ownerFiber = owner;\n              var instance = ownerFiber.stateNode;\n              if (!instance._warnedAboutRefsInRender) {\n                error(\"%s is accessing isMounted inside its render() function. render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.\", getComponentNameFromFiber(ownerFiber) || \"A component\");\n              }\n              instance._warnedAboutRefsInRender = true;\n            }\n          }\n          var fiber = get(component);\n          if (!fiber) {\n            return false;\n          }\n          return getNearestMountedFiber(fiber) === fiber;\n        }\n        function assertIsMounted(fiber) {\n          if (getNearestMountedFiber(fiber) !== fiber) {\n            throw new Error(\"Unable to find node on an unmounted component.\");\n          }\n        }\n        function findCurrentFiberUsingSlowPath(fiber) {\n          var alternate = fiber.alternate;\n          if (!alternate) {\n            var nearestMounted = getNearestMountedFiber(fiber);\n            if (nearestMounted === null) {\n              throw new Error(\"Unable to find node on an unmounted component.\");\n            }\n            if (nearestMounted !== fiber) {\n              return null;\n            }\n            return fiber;\n          }\n          var a = fiber;\n          var b = alternate;\n          while (true) {\n            var parentA = a.return;\n            if (parentA === null) {\n              break;\n            }\n            var parentB = parentA.alternate;\n            if (parentB === null) {\n              var nextParent = parentA.return;\n              if (nextParent !== null) {\n                a = b = nextParent;\n                continue;\n              }\n              break;\n            }\n            if (parentA.child === parentB.child) {\n              var child = parentA.child;\n              while (child) {\n                if (child === a) {\n                  assertIsMounted(parentA);\n                  return fiber;\n                }\n                if (child === b) {\n                  assertIsMounted(parentA);\n                  return alternate;\n                }\n                child = child.sibling;\n              }\n              throw new Error(\"Unable to find node on an unmounted component.\");\n            }\n            if (a.return !== b.return) {\n              a = parentA;\n              b = parentB;\n            } else {\n              var didFindChild = false;\n              var _child = parentA.child;\n              while (_child) {\n                if (_child === a) {\n                  didFindChild = true;\n                  a = parentA;\n                  b = parentB;\n                  break;\n                }\n                if (_child === b) {\n                  didFindChild = true;\n                  b = parentA;\n                  a = parentB;\n                  break;\n                }\n                _child = _child.sibling;\n              }\n              if (!didFindChild) {\n                _child = parentB.child;\n                while (_child) {\n                  if (_child === a) {\n                    didFindChild = true;\n                    a = parentB;\n                    b = parentA;\n                    break;\n                  }\n                  if (_child === b) {\n                    didFindChild = true;\n                    b = parentB;\n                    a = parentA;\n                    break;\n                  }\n                  _child = _child.sibling;\n                }\n                if (!didFindChild) {\n                  throw new Error(\"Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.\");\n                }\n              }\n            }\n            if (a.alternate !== b) {\n              throw new Error(\"Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue.\");\n            }\n          }\n          if (a.tag !== HostRoot) {\n            throw new Error(\"Unable to find node on an unmounted component.\");\n          }\n          if (a.stateNode.current === a) {\n            return fiber;\n          }\n          return alternate;\n        }\n        function findCurrentHostFiber(parent) {\n          var currentParent = findCurrentFiberUsingSlowPath(parent);\n          return currentParent !== null ? findCurrentHostFiberImpl(currentParent) : null;\n        }\n        function findCurrentHostFiberImpl(node) {\n          if (node.tag === HostComponent || node.tag === HostText) {\n            return node;\n          }\n          var child = node.child;\n          while (child !== null) {\n            var match = findCurrentHostFiberImpl(child);\n            if (match !== null) {\n              return match;\n            }\n            child = child.sibling;\n          }\n          return null;\n        }\n        function findCurrentHostFiberWithNoPortals(parent) {\n          var currentParent = findCurrentFiberUsingSlowPath(parent);\n          return currentParent !== null ? findCurrentHostFiberWithNoPortalsImpl(currentParent) : null;\n        }\n        function findCurrentHostFiberWithNoPortalsImpl(node) {\n          if (node.tag === HostComponent || node.tag === HostText) {\n            return node;\n          }\n          var child = node.child;\n          while (child !== null) {\n            if (child.tag !== HostPortal) {\n              var match = findCurrentHostFiberWithNoPortalsImpl(child);\n              if (match !== null) {\n                return match;\n              }\n            }\n            child = child.sibling;\n          }\n          return null;\n        }\n        var scheduleCallback = Scheduler.unstable_scheduleCallback;\n        var cancelCallback = Scheduler.unstable_cancelCallback;\n        var shouldYield = Scheduler.unstable_shouldYield;\n        var requestPaint = Scheduler.unstable_requestPaint;\n        var now = Scheduler.unstable_now;\n        var getCurrentPriorityLevel = Scheduler.unstable_getCurrentPriorityLevel;\n        var ImmediatePriority = Scheduler.unstable_ImmediatePriority;\n        var UserBlockingPriority = Scheduler.unstable_UserBlockingPriority;\n        var NormalPriority = Scheduler.unstable_NormalPriority;\n        var LowPriority = Scheduler.unstable_LowPriority;\n        var IdlePriority = Scheduler.unstable_IdlePriority;\n        var unstable_yieldValue = Scheduler.unstable_yieldValue;\n        var unstable_setDisableYieldValue = Scheduler.unstable_setDisableYieldValue;\n        var rendererID = null;\n        var injectedHook = null;\n        var injectedProfilingHooks = null;\n        var hasLoggedError = false;\n        var isDevToolsPresent = typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== \"undefined\";\n        function injectInternals(internals) {\n          if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === \"undefined\") {\n            return false;\n          }\n          var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;\n          if (hook.isDisabled) {\n            return true;\n          }\n          if (!hook.supportsFiber) {\n            {\n              error(\"The installed version of React DevTools is too old and will not work with the current version of React. Please update React DevTools. https://reactjs.org/link/react-devtools\");\n            }\n            return true;\n          }\n          try {\n            if (enableSchedulingProfiler) {\n              internals = assign({}, internals, {\n                getLaneLabelMap,\n                injectProfilingHooks\n              });\n            }\n            rendererID = hook.inject(internals);\n            injectedHook = hook;\n          } catch (err) {\n            {\n              error(\"React instrumentation encountered an error: %s.\", err);\n            }\n          }\n          if (hook.checkDCE) {\n            return true;\n          } else {\n            return false;\n          }\n        }\n        function onScheduleRoot(root2, children) {\n          {\n            if (injectedHook && typeof injectedHook.onScheduleFiberRoot === \"function\") {\n              try {\n                injectedHook.onScheduleFiberRoot(rendererID, root2, children);\n              } catch (err) {\n                if (!hasLoggedError) {\n                  hasLoggedError = true;\n                  error(\"React instrumentation encountered an error: %s\", err);\n                }\n              }\n            }\n          }\n        }\n        function onCommitRoot(root2, eventPriority) {\n          if (injectedHook && typeof injectedHook.onCommitFiberRoot === \"function\") {\n            try {\n              var didError = (root2.current.flags & DidCapture) === DidCapture;\n              if (enableProfilerTimer) {\n                var schedulerPriority;\n                switch (eventPriority) {\n                  case DiscreteEventPriority:\n                    schedulerPriority = ImmediatePriority;\n                    break;\n                  case ContinuousEventPriority:\n                    schedulerPriority = UserBlockingPriority;\n                    break;\n                  case DefaultEventPriority:\n                    schedulerPriority = NormalPriority;\n                    break;\n                  case IdleEventPriority:\n                    schedulerPriority = IdlePriority;\n                    break;\n                  default:\n                    schedulerPriority = NormalPriority;\n                    break;\n                }\n                injectedHook.onCommitFiberRoot(rendererID, root2, schedulerPriority, didError);\n              } else {\n                injectedHook.onCommitFiberRoot(rendererID, root2, void 0, didError);\n              }\n            } catch (err) {\n              {\n                if (!hasLoggedError) {\n                  hasLoggedError = true;\n                  error(\"React instrumentation encountered an error: %s\", err);\n                }\n              }\n            }\n          }\n        }\n        function onPostCommitRoot(root2) {\n          if (injectedHook && typeof injectedHook.onPostCommitFiberRoot === \"function\") {\n            try {\n              injectedHook.onPostCommitFiberRoot(rendererID, root2);\n            } catch (err) {\n              {\n                if (!hasLoggedError) {\n                  hasLoggedError = true;\n                  error(\"React instrumentation encountered an error: %s\", err);\n                }\n              }\n            }\n          }\n        }\n        function onCommitUnmount(fiber) {\n          if (injectedHook && typeof injectedHook.onCommitFiberUnmount === \"function\") {\n            try {\n              injectedHook.onCommitFiberUnmount(rendererID, fiber);\n            } catch (err) {\n              {\n                if (!hasLoggedError) {\n                  hasLoggedError = true;\n                  error(\"React instrumentation encountered an error: %s\", err);\n                }\n              }\n            }\n          }\n        }\n        function setIsStrictModeForDevtools(newIsStrictMode) {\n          {\n            if (typeof unstable_yieldValue === \"function\") {\n              unstable_setDisableYieldValue(newIsStrictMode);\n              setSuppressWarning(newIsStrictMode);\n            }\n            if (injectedHook && typeof injectedHook.setStrictMode === \"function\") {\n              try {\n                injectedHook.setStrictMode(rendererID, newIsStrictMode);\n              } catch (err) {\n                {\n                  if (!hasLoggedError) {\n                    hasLoggedError = true;\n                    error(\"React instrumentation encountered an error: %s\", err);\n                  }\n                }\n              }\n            }\n          }\n        }\n        function injectProfilingHooks(profilingHooks) {\n          injectedProfilingHooks = profilingHooks;\n        }\n        function getLaneLabelMap() {\n          {\n            var map = /* @__PURE__ */ new Map();\n            var lane = 1;\n            for (var index2 = 0; index2 < TotalLanes; index2++) {\n              var label = getLabelForLane(lane);\n              map.set(lane, label);\n              lane *= 2;\n            }\n            return map;\n          }\n        }\n        function markCommitStarted(lanes) {\n          {\n            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markCommitStarted === \"function\") {\n              injectedProfilingHooks.markCommitStarted(lanes);\n            }\n          }\n        }\n        function markCommitStopped() {\n          {\n            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markCommitStopped === \"function\") {\n              injectedProfilingHooks.markCommitStopped();\n            }\n          }\n        }\n        function markComponentRenderStarted(fiber) {\n          {\n            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentRenderStarted === \"function\") {\n              injectedProfilingHooks.markComponentRenderStarted(fiber);\n            }\n          }\n        }\n        function markComponentRenderStopped() {\n          {\n            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentRenderStopped === \"function\") {\n              injectedProfilingHooks.markComponentRenderStopped();\n            }\n          }\n        }\n        function markComponentPassiveEffectMountStarted(fiber) {\n          {\n            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectMountStarted === \"function\") {\n              injectedProfilingHooks.markComponentPassiveEffectMountStarted(fiber);\n            }\n          }\n        }\n        function markComponentPassiveEffectMountStopped() {\n          {\n            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectMountStopped === \"function\") {\n              injectedProfilingHooks.markComponentPassiveEffectMountStopped();\n            }\n          }\n        }\n        function markComponentPassiveEffectUnmountStarted(fiber) {\n          {\n            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStarted === \"function\") {\n              injectedProfilingHooks.markComponentPassiveEffectUnmountStarted(fiber);\n            }\n          }\n        }\n        function markComponentPassiveEffectUnmountStopped() {\n          {\n            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStopped === \"function\") {\n              injectedProfilingHooks.markComponentPassiveEffectUnmountStopped();\n            }\n          }\n        }\n        function markComponentLayoutEffectMountStarted(fiber) {\n          {\n            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectMountStarted === \"function\") {\n              injectedProfilingHooks.markComponentLayoutEffectMountStarted(fiber);\n            }\n          }\n        }\n        function markComponentLayoutEffectMountStopped() {\n          {\n            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectMountStopped === \"function\") {\n              injectedProfilingHooks.markComponentLayoutEffectMountStopped();\n            }\n          }\n        }\n        function markComponentLayoutEffectUnmountStarted(fiber) {\n          {\n            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStarted === \"function\") {\n              injectedProfilingHooks.markComponentLayoutEffectUnmountStarted(fiber);\n            }\n          }\n        }\n        function markComponentLayoutEffectUnmountStopped() {\n          {\n            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStopped === \"function\") {\n              injectedProfilingHooks.markComponentLayoutEffectUnmountStopped();\n            }\n          }\n        }\n        function markComponentErrored(fiber, thrownValue, lanes) {\n          {\n            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentErrored === \"function\") {\n              injectedProfilingHooks.markComponentErrored(fiber, thrownValue, lanes);\n            }\n          }\n        }\n        function markComponentSuspended(fiber, wakeable, lanes) {\n          {\n            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentSuspended === \"function\") {\n              injectedProfilingHooks.markComponentSuspended(fiber, wakeable, lanes);\n            }\n          }\n        }\n        function markLayoutEffectsStarted(lanes) {\n          {\n            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markLayoutEffectsStarted === \"function\") {\n              injectedProfilingHooks.markLayoutEffectsStarted(lanes);\n            }\n          }\n        }\n        function markLayoutEffectsStopped() {\n          {\n            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markLayoutEffectsStopped === \"function\") {\n              injectedProfilingHooks.markLayoutEffectsStopped();\n            }\n          }\n        }\n        function markPassiveEffectsStarted(lanes) {\n          {\n            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markPassiveEffectsStarted === \"function\") {\n              injectedProfilingHooks.markPassiveEffectsStarted(lanes);\n            }\n          }\n        }\n        function markPassiveEffectsStopped() {\n          {\n            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markPassiveEffectsStopped === \"function\") {\n              injectedProfilingHooks.markPassiveEffectsStopped();\n            }\n          }\n        }\n        function markRenderStarted(lanes) {\n          {\n            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderStarted === \"function\") {\n              injectedProfilingHooks.markRenderStarted(lanes);\n            }\n          }\n        }\n        function markRenderYielded() {\n          {\n            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderYielded === \"function\") {\n              injectedProfilingHooks.markRenderYielded();\n            }\n          }\n        }\n        function markRenderStopped() {\n          {\n            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderStopped === \"function\") {\n              injectedProfilingHooks.markRenderStopped();\n            }\n          }\n        }\n        function markRenderScheduled(lane) {\n          {\n            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderScheduled === \"function\") {\n              injectedProfilingHooks.markRenderScheduled(lane);\n            }\n          }\n        }\n        function markForceUpdateScheduled(fiber, lane) {\n          {\n            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markForceUpdateScheduled === \"function\") {\n              injectedProfilingHooks.markForceUpdateScheduled(fiber, lane);\n            }\n          }\n        }\n        function markStateUpdateScheduled(fiber, lane) {\n          {\n            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markStateUpdateScheduled === \"function\") {\n              injectedProfilingHooks.markStateUpdateScheduled(fiber, lane);\n            }\n          }\n        }\n        var NoMode = (\n          /*                         */\n          0\n        );\n        var ConcurrentMode = (\n          /*                 */\n          1\n        );\n        var ProfileMode = (\n          /*                    */\n          2\n        );\n        var StrictLegacyMode = (\n          /*               */\n          8\n        );\n        var StrictEffectsMode = (\n          /*              */\n          16\n        );\n        var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback;\n        var log = Math.log;\n        var LN2 = Math.LN2;\n        function clz32Fallback(x) {\n          var asUint = x >>> 0;\n          if (asUint === 0) {\n            return 32;\n          }\n          return 31 - (log(asUint) / LN2 | 0) | 0;\n        }\n        var TotalLanes = 31;\n        var NoLanes = (\n          /*                        */\n          0\n        );\n        var NoLane = (\n          /*                          */\n          0\n        );\n        var SyncLane = (\n          /*                        */\n          1\n        );\n        var InputContinuousHydrationLane = (\n          /*    */\n          2\n        );\n        var InputContinuousLane = (\n          /*             */\n          4\n        );\n        var DefaultHydrationLane = (\n          /*            */\n          8\n        );\n        var DefaultLane = (\n          /*                     */\n          16\n        );\n        var TransitionHydrationLane = (\n          /*                */\n          32\n        );\n        var TransitionLanes = (\n          /*                       */\n          4194240\n        );\n        var TransitionLane1 = (\n          /*                        */\n          64\n        );\n        var TransitionLane2 = (\n          /*                        */\n          128\n        );\n        var TransitionLane3 = (\n          /*                        */\n          256\n        );\n        var TransitionLane4 = (\n          /*                        */\n          512\n        );\n        var TransitionLane5 = (\n          /*                        */\n          1024\n        );\n        var TransitionLane6 = (\n          /*                        */\n          2048\n        );\n        var TransitionLane7 = (\n          /*                        */\n          4096\n        );\n        var TransitionLane8 = (\n          /*                        */\n          8192\n        );\n        var TransitionLane9 = (\n          /*                        */\n          16384\n        );\n        var TransitionLane10 = (\n          /*                       */\n          32768\n        );\n        var TransitionLane11 = (\n          /*                       */\n          65536\n        );\n        var TransitionLane12 = (\n          /*                       */\n          131072\n        );\n        var TransitionLane13 = (\n          /*                       */\n          262144\n        );\n        var TransitionLane14 = (\n          /*                       */\n          524288\n        );\n        var TransitionLane15 = (\n          /*                       */\n          1048576\n        );\n        var TransitionLane16 = (\n          /*                       */\n          2097152\n        );\n        var RetryLanes = (\n          /*                            */\n          130023424\n        );\n        var RetryLane1 = (\n          /*                             */\n          4194304\n        );\n        var RetryLane2 = (\n          /*                             */\n          8388608\n        );\n        var RetryLane3 = (\n          /*                             */\n          16777216\n        );\n        var RetryLane4 = (\n          /*                             */\n          33554432\n        );\n        var RetryLane5 = (\n          /*                             */\n          67108864\n        );\n        var SomeRetryLane = RetryLane1;\n        var SelectiveHydrationLane = (\n          /*          */\n          134217728\n        );\n        var NonIdleLanes = (\n          /*                          */\n          268435455\n        );\n        var IdleHydrationLane = (\n          /*               */\n          268435456\n        );\n        var IdleLane = (\n          /*                        */\n          536870912\n        );\n        var OffscreenLane = (\n          /*                   */\n          1073741824\n        );\n        function getLabelForLane(lane) {\n          {\n            if (lane & SyncLane) {\n              return \"Sync\";\n            }\n            if (lane & InputContinuousHydrationLane) {\n              return \"InputContinuousHydration\";\n            }\n            if (lane & InputContinuousLane) {\n              return \"InputContinuous\";\n            }\n            if (lane & DefaultHydrationLane) {\n              return \"DefaultHydration\";\n            }\n            if (lane & DefaultLane) {\n              return \"Default\";\n            }\n            if (lane & TransitionHydrationLane) {\n              return \"TransitionHydration\";\n            }\n            if (lane & TransitionLanes) {\n              return \"Transition\";\n            }\n            if (lane & RetryLanes) {\n              return \"Retry\";\n            }\n            if (lane & SelectiveHydrationLane) {\n              return \"SelectiveHydration\";\n            }\n            if (lane & IdleHydrationLane) {\n              return \"IdleHydration\";\n            }\n            if (lane & IdleLane) {\n              return \"Idle\";\n            }\n            if (lane & OffscreenLane) {\n              return \"Offscreen\";\n            }\n          }\n        }\n        var NoTimestamp = -1;\n        var nextTransitionLane = TransitionLane1;\n        var nextRetryLane = RetryLane1;\n        function getHighestPriorityLanes(lanes) {\n          switch (getHighestPriorityLane(lanes)) {\n            case SyncLane:\n              return SyncLane;\n            case InputContinuousHydrationLane:\n              return InputContinuousHydrationLane;\n            case InputContinuousLane:\n              return InputContinuousLane;\n            case DefaultHydrationLane:\n              return DefaultHydrationLane;\n            case DefaultLane:\n              return DefaultLane;\n            case TransitionHydrationLane:\n              return TransitionHydrationLane;\n            case TransitionLane1:\n            case TransitionLane2:\n            case TransitionLane3:\n            case TransitionLane4:\n            case TransitionLane5:\n            case TransitionLane6:\n            case TransitionLane7:\n            case TransitionLane8:\n            case TransitionLane9:\n            case TransitionLane10:\n            case TransitionLane11:\n            case TransitionLane12:\n            case TransitionLane13:\n            case TransitionLane14:\n            case TransitionLane15:\n            case TransitionLane16:\n              return lanes & TransitionLanes;\n            case RetryLane1:\n            case RetryLane2:\n            case RetryLane3:\n            case RetryLane4:\n            case RetryLane5:\n              return lanes & RetryLanes;\n            case SelectiveHydrationLane:\n              return SelectiveHydrationLane;\n            case IdleHydrationLane:\n              return IdleHydrationLane;\n            case IdleLane:\n              return IdleLane;\n            case OffscreenLane:\n              return OffscreenLane;\n            default:\n              {\n                error(\"Should have found matching lanes. This is a bug in React.\");\n              }\n              return lanes;\n          }\n        }\n        function getNextLanes(root2, wipLanes) {\n          var pendingLanes = root2.pendingLanes;\n          if (pendingLanes === NoLanes) {\n            return NoLanes;\n          }\n          var nextLanes = NoLanes;\n          var suspendedLanes = root2.suspendedLanes;\n          var pingedLanes = root2.pingedLanes;\n          var nonIdlePendingLanes = pendingLanes & NonIdleLanes;\n          if (nonIdlePendingLanes !== NoLanes) {\n            var nonIdleUnblockedLanes = nonIdlePendingLanes & ~suspendedLanes;\n            if (nonIdleUnblockedLanes !== NoLanes) {\n              nextLanes = getHighestPriorityLanes(nonIdleUnblockedLanes);\n            } else {\n              var nonIdlePingedLanes = nonIdlePendingLanes & pingedLanes;\n              if (nonIdlePingedLanes !== NoLanes) {\n                nextLanes = getHighestPriorityLanes(nonIdlePingedLanes);\n              }\n            }\n          } else {\n            var unblockedLanes = pendingLanes & ~suspendedLanes;\n            if (unblockedLanes !== NoLanes) {\n              nextLanes = getHighestPriorityLanes(unblockedLanes);\n            } else {\n              if (pingedLanes !== NoLanes) {\n                nextLanes = getHighestPriorityLanes(pingedLanes);\n              }\n            }\n          }\n          if (nextLanes === NoLanes) {\n            return NoLanes;\n          }\n          if (wipLanes !== NoLanes && wipLanes !== nextLanes && // If we already suspended with a delay, then interrupting is fine. Don't\n          // bother waiting until the root is complete.\n          (wipLanes & suspendedLanes) === NoLanes) {\n            var nextLane = getHighestPriorityLane(nextLanes);\n            var wipLane = getHighestPriorityLane(wipLanes);\n            if (\n              // Tests whether the next lane is equal or lower priority than the wip\n              // one. This works because the bits decrease in priority as you go left.\n              nextLane >= wipLane || // Default priority updates should not interrupt transition updates. The\n              // only difference between default updates and transition updates is that\n              // default updates do not support refresh transitions.\n              nextLane === DefaultLane && (wipLane & TransitionLanes) !== NoLanes\n            ) {\n              return wipLanes;\n            }\n          }\n          if ((nextLanes & InputContinuousLane) !== NoLanes) {\n            nextLanes |= pendingLanes & DefaultLane;\n          }\n          var entangledLanes = root2.entangledLanes;\n          if (entangledLanes !== NoLanes) {\n            var entanglements = root2.entanglements;\n            var lanes = nextLanes & entangledLanes;\n            while (lanes > 0) {\n              var index2 = pickArbitraryLaneIndex(lanes);\n              var lane = 1 << index2;\n              nextLanes |= entanglements[index2];\n              lanes &= ~lane;\n            }\n          }\n          return nextLanes;\n        }\n        function getMostRecentEventTime(root2, lanes) {\n          var eventTimes = root2.eventTimes;\n          var mostRecentEventTime = NoTimestamp;\n          while (lanes > 0) {\n            var index2 = pickArbitraryLaneIndex(lanes);\n            var lane = 1 << index2;\n            var eventTime = eventTimes[index2];\n            if (eventTime > mostRecentEventTime) {\n              mostRecentEventTime = eventTime;\n            }\n            lanes &= ~lane;\n          }\n          return mostRecentEventTime;\n        }\n        function computeExpirationTime(lane, currentTime) {\n          switch (lane) {\n            case SyncLane:\n            case InputContinuousHydrationLane:\n            case InputContinuousLane:\n              return currentTime + 250;\n            case DefaultHydrationLane:\n            case DefaultLane:\n            case TransitionHydrationLane:\n            case TransitionLane1:\n            case TransitionLane2:\n            case TransitionLane3:\n            case TransitionLane4:\n            case TransitionLane5:\n            case TransitionLane6:\n            case TransitionLane7:\n            case TransitionLane8:\n            case TransitionLane9:\n            case TransitionLane10:\n            case TransitionLane11:\n            case TransitionLane12:\n            case TransitionLane13:\n            case TransitionLane14:\n            case TransitionLane15:\n            case TransitionLane16:\n              return currentTime + 5e3;\n            case RetryLane1:\n            case RetryLane2:\n            case RetryLane3:\n            case RetryLane4:\n            case RetryLane5:\n              return NoTimestamp;\n            case SelectiveHydrationLane:\n            case IdleHydrationLane:\n            case IdleLane:\n            case OffscreenLane:\n              return NoTimestamp;\n            default:\n              {\n                error(\"Should have found matching lanes. This is a bug in React.\");\n              }\n              return NoTimestamp;\n          }\n        }\n        function markStarvedLanesAsExpired(root2, currentTime) {\n          var pendingLanes = root2.pendingLanes;\n          var suspendedLanes = root2.suspendedLanes;\n          var pingedLanes = root2.pingedLanes;\n          var expirationTimes = root2.expirationTimes;\n          var lanes = pendingLanes;\n          while (lanes > 0) {\n            var index2 = pickArbitraryLaneIndex(lanes);\n            var lane = 1 << index2;\n            var expirationTime = expirationTimes[index2];\n            if (expirationTime === NoTimestamp) {\n              if ((lane & suspendedLanes) === NoLanes || (lane & pingedLanes) !== NoLanes) {\n                expirationTimes[index2] = computeExpirationTime(lane, currentTime);\n              }\n            } else if (expirationTime <= currentTime) {\n              root2.expiredLanes |= lane;\n            }\n            lanes &= ~lane;\n          }\n        }\n        function getHighestPriorityPendingLanes(root2) {\n          return getHighestPriorityLanes(root2.pendingLanes);\n        }\n        function getLanesToRetrySynchronouslyOnError(root2) {\n          var everythingButOffscreen = root2.pendingLanes & ~OffscreenLane;\n          if (everythingButOffscreen !== NoLanes) {\n            return everythingButOffscreen;\n          }\n          if (everythingButOffscreen & OffscreenLane) {\n            return OffscreenLane;\n          }\n          return NoLanes;\n        }\n        function includesSyncLane(lanes) {\n          return (lanes & SyncLane) !== NoLanes;\n        }\n        function includesNonIdleWork(lanes) {\n          return (lanes & NonIdleLanes) !== NoLanes;\n        }\n        function includesOnlyRetries(lanes) {\n          return (lanes & RetryLanes) === lanes;\n        }\n        function includesOnlyNonUrgentLanes(lanes) {\n          var UrgentLanes = SyncLane | InputContinuousLane | DefaultLane;\n          return (lanes & UrgentLanes) === NoLanes;\n        }\n        function includesOnlyTransitions(lanes) {\n          return (lanes & TransitionLanes) === lanes;\n        }\n        function includesBlockingLane(root2, lanes) {\n          var SyncDefaultLanes = InputContinuousHydrationLane | InputContinuousLane | DefaultHydrationLane | DefaultLane;\n          return (lanes & SyncDefaultLanes) !== NoLanes;\n        }\n        function includesExpiredLane(root2, lanes) {\n          return (lanes & root2.expiredLanes) !== NoLanes;\n        }\n        function isTransitionLane(lane) {\n          return (lane & TransitionLanes) !== NoLanes;\n        }\n        function claimNextTransitionLane() {\n          var lane = nextTransitionLane;\n          nextTransitionLane <<= 1;\n          if ((nextTransitionLane & TransitionLanes) === NoLanes) {\n            nextTransitionLane = TransitionLane1;\n          }\n          return lane;\n        }\n        function claimNextRetryLane() {\n          var lane = nextRetryLane;\n          nextRetryLane <<= 1;\n          if ((nextRetryLane & RetryLanes) === NoLanes) {\n            nextRetryLane = RetryLane1;\n          }\n          return lane;\n        }\n        function getHighestPriorityLane(lanes) {\n          return lanes & -lanes;\n        }\n        function pickArbitraryLane(lanes) {\n          return getHighestPriorityLane(lanes);\n        }\n        function pickArbitraryLaneIndex(lanes) {\n          return 31 - clz32(lanes);\n        }\n        function laneToIndex(lane) {\n          return pickArbitraryLaneIndex(lane);\n        }\n        function includesSomeLane(a, b) {\n          return (a & b) !== NoLanes;\n        }\n        function isSubsetOfLanes(set2, subset) {\n          return (set2 & subset) === subset;\n        }\n        function mergeLanes(a, b) {\n          return a | b;\n        }\n        function removeLanes(set2, subset) {\n          return set2 & ~subset;\n        }\n        function intersectLanes(a, b) {\n          return a & b;\n        }\n        function laneToLanes(lane) {\n          return lane;\n        }\n        function higherPriorityLane(a, b) {\n          return a !== NoLane && a < b ? a : b;\n        }\n        function createLaneMap(initial) {\n          var laneMap = [];\n          for (var i = 0; i < TotalLanes; i++) {\n            laneMap.push(initial);\n          }\n          return laneMap;\n        }\n        function markRootUpdated(root2, updateLane, eventTime) {\n          root2.pendingLanes |= updateLane;\n          if (updateLane !== IdleLane) {\n            root2.suspendedLanes = NoLanes;\n            root2.pingedLanes = NoLanes;\n          }\n          var eventTimes = root2.eventTimes;\n          var index2 = laneToIndex(updateLane);\n          eventTimes[index2] = eventTime;\n        }\n        function markRootSuspended(root2, suspendedLanes) {\n          root2.suspendedLanes |= suspendedLanes;\n          root2.pingedLanes &= ~suspendedLanes;\n          var expirationTimes = root2.expirationTimes;\n          var lanes = suspendedLanes;\n          while (lanes > 0) {\n            var index2 = pickArbitraryLaneIndex(lanes);\n            var lane = 1 << index2;\n            expirationTimes[index2] = NoTimestamp;\n            lanes &= ~lane;\n          }\n        }\n        function markRootPinged(root2, pingedLanes, eventTime) {\n          root2.pingedLanes |= root2.suspendedLanes & pingedLanes;\n        }\n        function markRootFinished(root2, remainingLanes) {\n          var noLongerPendingLanes = root2.pendingLanes & ~remainingLanes;\n          root2.pendingLanes = remainingLanes;\n          root2.suspendedLanes = NoLanes;\n          root2.pingedLanes = NoLanes;\n          root2.expiredLanes &= remainingLanes;\n          root2.mutableReadLanes &= remainingLanes;\n          root2.entangledLanes &= remainingLanes;\n          var entanglements = root2.entanglements;\n          var eventTimes = root2.eventTimes;\n          var expirationTimes = root2.expirationTimes;\n          var lanes = noLongerPendingLanes;\n          while (lanes > 0) {\n            var index2 = pickArbitraryLaneIndex(lanes);\n            var lane = 1 << index2;\n            entanglements[index2] = NoLanes;\n            eventTimes[index2] = NoTimestamp;\n            expirationTimes[index2] = NoTimestamp;\n            lanes &= ~lane;\n          }\n        }\n        function markRootEntangled(root2, entangledLanes) {\n          var rootEntangledLanes = root2.entangledLanes |= entangledLanes;\n          var entanglements = root2.entanglements;\n          var lanes = rootEntangledLanes;\n          while (lanes) {\n            var index2 = pickArbitraryLaneIndex(lanes);\n            var lane = 1 << index2;\n            if (\n              // Is this one of the newly entangled lanes?\n              lane & entangledLanes | // Is this lane transitively entangled with the newly entangled lanes?\n              entanglements[index2] & entangledLanes\n            ) {\n              entanglements[index2] |= entangledLanes;\n            }\n            lanes &= ~lane;\n          }\n        }\n        function getBumpedLaneForHydration(root2, renderLanes2) {\n          var renderLane = getHighestPriorityLane(renderLanes2);\n          var lane;\n          switch (renderLane) {\n            case InputContinuousLane:\n              lane = InputContinuousHydrationLane;\n              break;\n            case DefaultLane:\n              lane = DefaultHydrationLane;\n              break;\n            case TransitionLane1:\n            case TransitionLane2:\n            case TransitionLane3:\n            case TransitionLane4:\n            case TransitionLane5:\n            case TransitionLane6:\n            case TransitionLane7:\n            case TransitionLane8:\n            case TransitionLane9:\n            case TransitionLane10:\n            case TransitionLane11:\n            case TransitionLane12:\n            case TransitionLane13:\n            case TransitionLane14:\n            case TransitionLane15:\n            case TransitionLane16:\n            case RetryLane1:\n            case RetryLane2:\n            case RetryLane3:\n            case RetryLane4:\n            case RetryLane5:\n              lane = TransitionHydrationLane;\n              break;\n            case IdleLane:\n              lane = IdleHydrationLane;\n              break;\n            default:\n              lane = NoLane;\n              break;\n          }\n          if ((lane & (root2.suspendedLanes | renderLanes2)) !== NoLane) {\n            return NoLane;\n          }\n          return lane;\n        }\n        function addFiberToLanesMap(root2, fiber, lanes) {\n          if (!isDevToolsPresent) {\n            return;\n          }\n          var pendingUpdatersLaneMap = root2.pendingUpdatersLaneMap;\n          while (lanes > 0) {\n            var index2 = laneToIndex(lanes);\n            var lane = 1 << index2;\n            var updaters = pendingUpdatersLaneMap[index2];\n            updaters.add(fiber);\n            lanes &= ~lane;\n          }\n        }\n        function movePendingFibersToMemoized(root2, lanes) {\n          if (!isDevToolsPresent) {\n            return;\n          }\n          var pendingUpdatersLaneMap = root2.pendingUpdatersLaneMap;\n          var memoizedUpdaters = root2.memoizedUpdaters;\n          while (lanes > 0) {\n            var index2 = laneToIndex(lanes);\n            var lane = 1 << index2;\n            var updaters = pendingUpdatersLaneMap[index2];\n            if (updaters.size > 0) {\n              updaters.forEach(function(fiber) {\n                var alternate = fiber.alternate;\n                if (alternate === null || !memoizedUpdaters.has(alternate)) {\n                  memoizedUpdaters.add(fiber);\n                }\n              });\n              updaters.clear();\n            }\n            lanes &= ~lane;\n          }\n        }\n        function getTransitionsForLanes(root2, lanes) {\n          {\n            return null;\n          }\n        }\n        var DiscreteEventPriority = SyncLane;\n        var ContinuousEventPriority = InputContinuousLane;\n        var DefaultEventPriority = DefaultLane;\n        var IdleEventPriority = IdleLane;\n        var currentUpdatePriority = NoLane;\n        function getCurrentUpdatePriority() {\n          return currentUpdatePriority;\n        }\n        function setCurrentUpdatePriority(newPriority) {\n          currentUpdatePriority = newPriority;\n        }\n        function runWithPriority(priority, fn) {\n          var previousPriority = currentUpdatePriority;\n          try {\n            currentUpdatePriority = priority;\n            return fn();\n          } finally {\n            currentUpdatePriority = previousPriority;\n          }\n        }\n        function higherEventPriority(a, b) {\n          return a !== 0 && a < b ? a : b;\n        }\n        function lowerEventPriority(a, b) {\n          return a === 0 || a > b ? a : b;\n        }\n        function isHigherEventPriority(a, b) {\n          return a !== 0 && a < b;\n        }\n        function lanesToEventPriority(lanes) {\n          var lane = getHighestPriorityLane(lanes);\n          if (!isHigherEventPriority(DiscreteEventPriority, lane)) {\n            return DiscreteEventPriority;\n          }\n          if (!isHigherEventPriority(ContinuousEventPriority, lane)) {\n            return ContinuousEventPriority;\n          }\n          if (includesNonIdleWork(lane)) {\n            return DefaultEventPriority;\n          }\n          return IdleEventPriority;\n        }\n        function isRootDehydrated(root2) {\n          var currentState = root2.current.memoizedState;\n          return currentState.isDehydrated;\n        }\n        var _attemptSynchronousHydration;\n        function setAttemptSynchronousHydration(fn) {\n          _attemptSynchronousHydration = fn;\n        }\n        function attemptSynchronousHydration(fiber) {\n          _attemptSynchronousHydration(fiber);\n        }\n        var attemptContinuousHydration;\n        function setAttemptContinuousHydration(fn) {\n          attemptContinuousHydration = fn;\n        }\n        var attemptHydrationAtCurrentPriority;\n        function setAttemptHydrationAtCurrentPriority(fn) {\n          attemptHydrationAtCurrentPriority = fn;\n        }\n        var getCurrentUpdatePriority$1;\n        function setGetCurrentUpdatePriority(fn) {\n          getCurrentUpdatePriority$1 = fn;\n        }\n        var attemptHydrationAtPriority;\n        function setAttemptHydrationAtPriority(fn) {\n          attemptHydrationAtPriority = fn;\n        }\n        var hasScheduledReplayAttempt = false;\n        var queuedDiscreteEvents = [];\n        var queuedFocus = null;\n        var queuedDrag = null;\n        var queuedMouse = null;\n        var queuedPointers = /* @__PURE__ */ new Map();\n        var queuedPointerCaptures = /* @__PURE__ */ new Map();\n        var queuedExplicitHydrationTargets = [];\n        var discreteReplayableEvents = [\n          \"mousedown\",\n          \"mouseup\",\n          \"touchcancel\",\n          \"touchend\",\n          \"touchstart\",\n          \"auxclick\",\n          \"dblclick\",\n          \"pointercancel\",\n          \"pointerdown\",\n          \"pointerup\",\n          \"dragend\",\n          \"dragstart\",\n          \"drop\",\n          \"compositionend\",\n          \"compositionstart\",\n          \"keydown\",\n          \"keypress\",\n          \"keyup\",\n          \"input\",\n          \"textInput\",\n          // Intentionally camelCase\n          \"copy\",\n          \"cut\",\n          \"paste\",\n          \"click\",\n          \"change\",\n          \"contextmenu\",\n          \"reset\",\n          \"submit\"\n        ];\n        function isDiscreteEventThatRequiresHydration(eventType) {\n          return discreteReplayableEvents.indexOf(eventType) > -1;\n        }\n        function createQueuedReplayableEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {\n          return {\n            blockedOn,\n            domEventName,\n            eventSystemFlags,\n            nativeEvent,\n            targetContainers: [targetContainer]\n          };\n        }\n        function clearIfContinuousEvent(domEventName, nativeEvent) {\n          switch (domEventName) {\n            case \"focusin\":\n            case \"focusout\":\n              queuedFocus = null;\n              break;\n            case \"dragenter\":\n            case \"dragleave\":\n              queuedDrag = null;\n              break;\n            case \"mouseover\":\n            case \"mouseout\":\n              queuedMouse = null;\n              break;\n            case \"pointerover\":\n            case \"pointerout\": {\n              var pointerId = nativeEvent.pointerId;\n              queuedPointers.delete(pointerId);\n              break;\n            }\n            case \"gotpointercapture\":\n            case \"lostpointercapture\": {\n              var _pointerId = nativeEvent.pointerId;\n              queuedPointerCaptures.delete(_pointerId);\n              break;\n            }\n          }\n        }\n        function accumulateOrCreateContinuousQueuedReplayableEvent(existingQueuedEvent, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {\n          if (existingQueuedEvent === null || existingQueuedEvent.nativeEvent !== nativeEvent) {\n            var queuedEvent = createQueuedReplayableEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent);\n            if (blockedOn !== null) {\n              var _fiber2 = getInstanceFromNode(blockedOn);\n              if (_fiber2 !== null) {\n                attemptContinuousHydration(_fiber2);\n              }\n            }\n            return queuedEvent;\n          }\n          existingQueuedEvent.eventSystemFlags |= eventSystemFlags;\n          var targetContainers = existingQueuedEvent.targetContainers;\n          if (targetContainer !== null && targetContainers.indexOf(targetContainer) === -1) {\n            targetContainers.push(targetContainer);\n          }\n          return existingQueuedEvent;\n        }\n        function queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {\n          switch (domEventName) {\n            case \"focusin\": {\n              var focusEvent = nativeEvent;\n              queuedFocus = accumulateOrCreateContinuousQueuedReplayableEvent(queuedFocus, blockedOn, domEventName, eventSystemFlags, targetContainer, focusEvent);\n              return true;\n            }\n            case \"dragenter\": {\n              var dragEvent = nativeEvent;\n              queuedDrag = accumulateOrCreateContinuousQueuedReplayableEvent(queuedDrag, blockedOn, domEventName, eventSystemFlags, targetContainer, dragEvent);\n              return true;\n            }\n            case \"mouseover\": {\n              var mouseEvent = nativeEvent;\n              queuedMouse = accumulateOrCreateContinuousQueuedReplayableEvent(queuedMouse, blockedOn, domEventName, eventSystemFlags, targetContainer, mouseEvent);\n              return true;\n            }\n            case \"pointerover\": {\n              var pointerEvent = nativeEvent;\n              var pointerId = pointerEvent.pointerId;\n              queuedPointers.set(pointerId, accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointers.get(pointerId) || null, blockedOn, domEventName, eventSystemFlags, targetContainer, pointerEvent));\n              return true;\n            }\n            case \"gotpointercapture\": {\n              var _pointerEvent = nativeEvent;\n              var _pointerId2 = _pointerEvent.pointerId;\n              queuedPointerCaptures.set(_pointerId2, accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointerCaptures.get(_pointerId2) || null, blockedOn, domEventName, eventSystemFlags, targetContainer, _pointerEvent));\n              return true;\n            }\n          }\n          return false;\n        }\n        function attemptExplicitHydrationTarget(queuedTarget) {\n          var targetInst = getClosestInstanceFromNode(queuedTarget.target);\n          if (targetInst !== null) {\n            var nearestMounted = getNearestMountedFiber(targetInst);\n            if (nearestMounted !== null) {\n              var tag = nearestMounted.tag;\n              if (tag === SuspenseComponent) {\n                var instance = getSuspenseInstanceFromFiber(nearestMounted);\n                if (instance !== null) {\n                  queuedTarget.blockedOn = instance;\n                  attemptHydrationAtPriority(queuedTarget.priority, function() {\n                    attemptHydrationAtCurrentPriority(nearestMounted);\n                  });\n                  return;\n                }\n              } else if (tag === HostRoot) {\n                var root2 = nearestMounted.stateNode;\n                if (isRootDehydrated(root2)) {\n                  queuedTarget.blockedOn = getContainerFromFiber(nearestMounted);\n                  return;\n                }\n              }\n            }\n          }\n          queuedTarget.blockedOn = null;\n        }\n        function queueExplicitHydrationTarget(target) {\n          var updatePriority = getCurrentUpdatePriority$1();\n          var queuedTarget = {\n            blockedOn: null,\n            target,\n            priority: updatePriority\n          };\n          var i = 0;\n          for (; i < queuedExplicitHydrationTargets.length; i++) {\n            if (!isHigherEventPriority(updatePriority, queuedExplicitHydrationTargets[i].priority)) {\n              break;\n            }\n          }\n          queuedExplicitHydrationTargets.splice(i, 0, queuedTarget);\n          if (i === 0) {\n            attemptExplicitHydrationTarget(queuedTarget);\n          }\n        }\n        function attemptReplayContinuousQueuedEvent(queuedEvent) {\n          if (queuedEvent.blockedOn !== null) {\n            return false;\n          }\n          var targetContainers = queuedEvent.targetContainers;\n          while (targetContainers.length > 0) {\n            var targetContainer = targetContainers[0];\n            var nextBlockedOn = findInstanceBlockingEvent(queuedEvent.domEventName, queuedEvent.eventSystemFlags, targetContainer, queuedEvent.nativeEvent);\n            if (nextBlockedOn === null) {\n              {\n                var nativeEvent = queuedEvent.nativeEvent;\n                var nativeEventClone = new nativeEvent.constructor(nativeEvent.type, nativeEvent);\n                setReplayingEvent(nativeEventClone);\n                nativeEvent.target.dispatchEvent(nativeEventClone);\n                resetReplayingEvent();\n              }\n            } else {\n              var _fiber3 = getInstanceFromNode(nextBlockedOn);\n              if (_fiber3 !== null) {\n                attemptContinuousHydration(_fiber3);\n              }\n              queuedEvent.blockedOn = nextBlockedOn;\n              return false;\n            }\n            targetContainers.shift();\n          }\n          return true;\n        }\n        function attemptReplayContinuousQueuedEventInMap(queuedEvent, key, map) {\n          if (attemptReplayContinuousQueuedEvent(queuedEvent)) {\n            map.delete(key);\n          }\n        }\n        function replayUnblockedEvents() {\n          hasScheduledReplayAttempt = false;\n          if (queuedFocus !== null && attemptReplayContinuousQueuedEvent(queuedFocus)) {\n            queuedFocus = null;\n          }\n          if (queuedDrag !== null && attemptReplayContinuousQueuedEvent(queuedDrag)) {\n            queuedDrag = null;\n          }\n          if (queuedMouse !== null && attemptReplayContinuousQueuedEvent(queuedMouse)) {\n            queuedMouse = null;\n          }\n          queuedPointers.forEach(attemptReplayContinuousQueuedEventInMap);\n          queuedPointerCaptures.forEach(attemptReplayContinuousQueuedEventInMap);\n        }\n        function scheduleCallbackIfUnblocked(queuedEvent, unblocked) {\n          if (queuedEvent.blockedOn === unblocked) {\n            queuedEvent.blockedOn = null;\n            if (!hasScheduledReplayAttempt) {\n              hasScheduledReplayAttempt = true;\n              Scheduler.unstable_scheduleCallback(Scheduler.unstable_NormalPriority, replayUnblockedEvents);\n            }\n          }\n        }\n        function retryIfBlockedOn(unblocked) {\n          if (queuedDiscreteEvents.length > 0) {\n            scheduleCallbackIfUnblocked(queuedDiscreteEvents[0], unblocked);\n            for (var i = 1; i < queuedDiscreteEvents.length; i++) {\n              var queuedEvent = queuedDiscreteEvents[i];\n              if (queuedEvent.blockedOn === unblocked) {\n                queuedEvent.blockedOn = null;\n              }\n            }\n          }\n          if (queuedFocus !== null) {\n            scheduleCallbackIfUnblocked(queuedFocus, unblocked);\n          }\n          if (queuedDrag !== null) {\n            scheduleCallbackIfUnblocked(queuedDrag, unblocked);\n          }\n          if (queuedMouse !== null) {\n            scheduleCallbackIfUnblocked(queuedMouse, unblocked);\n          }\n          var unblock = function(queuedEvent2) {\n            return scheduleCallbackIfUnblocked(queuedEvent2, unblocked);\n          };\n          queuedPointers.forEach(unblock);\n          queuedPointerCaptures.forEach(unblock);\n          for (var _i = 0; _i < queuedExplicitHydrationTargets.length; _i++) {\n            var queuedTarget = queuedExplicitHydrationTargets[_i];\n            if (queuedTarget.blockedOn === unblocked) {\n              queuedTarget.blockedOn = null;\n            }\n          }\n          while (queuedExplicitHydrationTargets.length > 0) {\n            var nextExplicitTarget = queuedExplicitHydrationTargets[0];\n            if (nextExplicitTarget.blockedOn !== null) {\n              break;\n            } else {\n              attemptExplicitHydrationTarget(nextExplicitTarget);\n              if (nextExplicitTarget.blockedOn === null) {\n                queuedExplicitHydrationTargets.shift();\n              }\n            }\n          }\n        }\n        var ReactCurrentBatchConfig = ReactSharedInternals.ReactCurrentBatchConfig;\n        var _enabled = true;\n        function setEnabled(enabled) {\n          _enabled = !!enabled;\n        }\n        function isEnabled() {\n          return _enabled;\n        }\n        function createEventListenerWrapperWithPriority(targetContainer, domEventName, eventSystemFlags) {\n          var eventPriority = getEventPriority(domEventName);\n          var listenerWrapper;\n          switch (eventPriority) {\n            case DiscreteEventPriority:\n              listenerWrapper = dispatchDiscreteEvent;\n              break;\n            case ContinuousEventPriority:\n              listenerWrapper = dispatchContinuousEvent;\n              break;\n            case DefaultEventPriority:\n            default:\n              listenerWrapper = dispatchEvent;\n              break;\n          }\n          return listenerWrapper.bind(null, domEventName, eventSystemFlags, targetContainer);\n        }\n        function dispatchDiscreteEvent(domEventName, eventSystemFlags, container, nativeEvent) {\n          var previousPriority = getCurrentUpdatePriority();\n          var prevTransition = ReactCurrentBatchConfig.transition;\n          ReactCurrentBatchConfig.transition = null;\n          try {\n            setCurrentUpdatePriority(DiscreteEventPriority);\n            dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);\n          } finally {\n            setCurrentUpdatePriority(previousPriority);\n            ReactCurrentBatchConfig.transition = prevTransition;\n          }\n        }\n        function dispatchContinuousEvent(domEventName, eventSystemFlags, container, nativeEvent) {\n          var previousPriority = getCurrentUpdatePriority();\n          var prevTransition = ReactCurrentBatchConfig.transition;\n          ReactCurrentBatchConfig.transition = null;\n          try {\n            setCurrentUpdatePriority(ContinuousEventPriority);\n            dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);\n          } finally {\n            setCurrentUpdatePriority(previousPriority);\n            ReactCurrentBatchConfig.transition = prevTransition;\n          }\n        }\n        function dispatchEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent) {\n          if (!_enabled) {\n            return;\n          }\n          {\n            dispatchEventWithEnableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay(domEventName, eventSystemFlags, targetContainer, nativeEvent);\n          }\n        }\n        function dispatchEventWithEnableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay(domEventName, eventSystemFlags, targetContainer, nativeEvent) {\n          var blockedOn = findInstanceBlockingEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent);\n          if (blockedOn === null) {\n            dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, return_targetInst, targetContainer);\n            clearIfContinuousEvent(domEventName, nativeEvent);\n            return;\n          }\n          if (queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent)) {\n            nativeEvent.stopPropagation();\n            return;\n          }\n          clearIfContinuousEvent(domEventName, nativeEvent);\n          if (eventSystemFlags & IS_CAPTURE_PHASE && isDiscreteEventThatRequiresHydration(domEventName)) {\n            while (blockedOn !== null) {\n              var fiber = getInstanceFromNode(blockedOn);\n              if (fiber !== null) {\n                attemptSynchronousHydration(fiber);\n              }\n              var nextBlockedOn = findInstanceBlockingEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent);\n              if (nextBlockedOn === null) {\n                dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, return_targetInst, targetContainer);\n              }\n              if (nextBlockedOn === blockedOn) {\n                break;\n              }\n              blockedOn = nextBlockedOn;\n            }\n            if (blockedOn !== null) {\n              nativeEvent.stopPropagation();\n            }\n            return;\n          }\n          dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, null, targetContainer);\n        }\n        var return_targetInst = null;\n        function findInstanceBlockingEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent) {\n          return_targetInst = null;\n          var nativeEventTarget = getEventTarget(nativeEvent);\n          var targetInst = getClosestInstanceFromNode(nativeEventTarget);\n          if (targetInst !== null) {\n            var nearestMounted = getNearestMountedFiber(targetInst);\n            if (nearestMounted === null) {\n              targetInst = null;\n            } else {\n              var tag = nearestMounted.tag;\n              if (tag === SuspenseComponent) {\n                var instance = getSuspenseInstanceFromFiber(nearestMounted);\n                if (instance !== null) {\n                  return instance;\n                }\n                targetInst = null;\n              } else if (tag === HostRoot) {\n                var root2 = nearestMounted.stateNode;\n                if (isRootDehydrated(root2)) {\n                  return getContainerFromFiber(nearestMounted);\n                }\n                targetInst = null;\n              } else if (nearestMounted !== targetInst) {\n                targetInst = null;\n              }\n            }\n          }\n          return_targetInst = targetInst;\n          return null;\n        }\n        function getEventPriority(domEventName) {\n          switch (domEventName) {\n            case \"cancel\":\n            case \"click\":\n            case \"close\":\n            case \"contextmenu\":\n            case \"copy\":\n            case \"cut\":\n            case \"auxclick\":\n            case \"dblclick\":\n            case \"dragend\":\n            case \"dragstart\":\n            case \"drop\":\n            case \"focusin\":\n            case \"focusout\":\n            case \"input\":\n            case \"invalid\":\n            case \"keydown\":\n            case \"keypress\":\n            case \"keyup\":\n            case \"mousedown\":\n            case \"mouseup\":\n            case \"paste\":\n            case \"pause\":\n            case \"play\":\n            case \"pointercancel\":\n            case \"pointerdown\":\n            case \"pointerup\":\n            case \"ratechange\":\n            case \"reset\":\n            case \"resize\":\n            case \"seeked\":\n            case \"submit\":\n            case \"touchcancel\":\n            case \"touchend\":\n            case \"touchstart\":\n            case \"volumechange\":\n            case \"change\":\n            case \"selectionchange\":\n            case \"textInput\":\n            case \"compositionstart\":\n            case \"compositionend\":\n            case \"compositionupdate\":\n            case \"beforeblur\":\n            case \"afterblur\":\n            case \"beforeinput\":\n            case \"blur\":\n            case \"fullscreenchange\":\n            case \"focus\":\n            case \"hashchange\":\n            case \"popstate\":\n            case \"select\":\n            case \"selectstart\":\n              return DiscreteEventPriority;\n            case \"drag\":\n            case \"dragenter\":\n            case \"dragexit\":\n            case \"dragleave\":\n            case \"dragover\":\n            case \"mousemove\":\n            case \"mouseout\":\n            case \"mouseover\":\n            case \"pointermove\":\n            case \"pointerout\":\n            case \"pointerover\":\n            case \"scroll\":\n            case \"toggle\":\n            case \"touchmove\":\n            case \"wheel\":\n            case \"mouseenter\":\n            case \"mouseleave\":\n            case \"pointerenter\":\n            case \"pointerleave\":\n              return ContinuousEventPriority;\n            case \"message\": {\n              var schedulerPriority = getCurrentPriorityLevel();\n              switch (schedulerPriority) {\n                case ImmediatePriority:\n                  return DiscreteEventPriority;\n                case UserBlockingPriority:\n                  return ContinuousEventPriority;\n                case NormalPriority:\n                case LowPriority:\n                  return DefaultEventPriority;\n                case IdlePriority:\n                  return IdleEventPriority;\n                default:\n                  return DefaultEventPriority;\n              }\n            }\n            default:\n              return DefaultEventPriority;\n          }\n        }\n        function addEventBubbleListener(target, eventType, listener) {\n          target.addEventListener(eventType, listener, false);\n          return listener;\n        }\n        function addEventCaptureListener(target, eventType, listener) {\n          target.addEventListener(eventType, listener, true);\n          return listener;\n        }\n        function addEventCaptureListenerWithPassiveFlag(target, eventType, listener, passive) {\n          target.addEventListener(eventType, listener, {\n            capture: true,\n            passive\n          });\n          return listener;\n        }\n        function addEventBubbleListenerWithPassiveFlag(target, eventType, listener, passive) {\n          target.addEventListener(eventType, listener, {\n            passive\n          });\n          return listener;\n        }\n        var root = null;\n        var startText = null;\n        var fallbackText = null;\n        function initialize(nativeEventTarget) {\n          root = nativeEventTarget;\n          startText = getText();\n          return true;\n        }\n        function reset() {\n          root = null;\n          startText = null;\n          fallbackText = null;\n        }\n        function getData() {\n          if (fallbackText) {\n            return fallbackText;\n          }\n          var start;\n          var startValue = startText;\n          var startLength = startValue.length;\n          var end;\n          var endValue = getText();\n          var endLength = endValue.length;\n          for (start = 0; start < startLength; start++) {\n            if (startValue[start] !== endValue[start]) {\n              break;\n            }\n          }\n          var minEnd = startLength - start;\n          for (end = 1; end <= minEnd; end++) {\n            if (startValue[startLength - end] !== endValue[endLength - end]) {\n              break;\n            }\n          }\n          var sliceTail = end > 1 ? 1 - end : void 0;\n          fallbackText = endValue.slice(start, sliceTail);\n          return fallbackText;\n        }\n        function getText() {\n          if (\"value\" in root) {\n            return root.value;\n          }\n          return root.textContent;\n        }\n        function getEventCharCode(nativeEvent) {\n          var charCode;\n          var keyCode = nativeEvent.keyCode;\n          if (\"charCode\" in nativeEvent) {\n            charCode = nativeEvent.charCode;\n            if (charCode === 0 && keyCode === 13) {\n              charCode = 13;\n            }\n          } else {\n            charCode = keyCode;\n          }\n          if (charCode === 10) {\n            charCode = 13;\n          }\n          if (charCode >= 32 || charCode === 13) {\n            return charCode;\n          }\n          return 0;\n        }\n        function functionThatReturnsTrue() {\n          return true;\n        }\n        function functionThatReturnsFalse() {\n          return false;\n        }\n        function createSyntheticEvent(Interface) {\n          function SyntheticBaseEvent(reactName, reactEventType, targetInst, nativeEvent, nativeEventTarget) {\n            this._reactName = reactName;\n            this._targetInst = targetInst;\n            this.type = reactEventType;\n            this.nativeEvent = nativeEvent;\n            this.target = nativeEventTarget;\n            this.currentTarget = null;\n            for (var _propName in Interface) {\n              if (!Interface.hasOwnProperty(_propName)) {\n                continue;\n              }\n              var normalize = Interface[_propName];\n              if (normalize) {\n                this[_propName] = normalize(nativeEvent);\n              } else {\n                this[_propName] = nativeEvent[_propName];\n              }\n            }\n            var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;\n            if (defaultPrevented) {\n              this.isDefaultPrevented = functionThatReturnsTrue;\n            } else {\n              this.isDefaultPrevented = functionThatReturnsFalse;\n            }\n            this.isPropagationStopped = functionThatReturnsFalse;\n            return this;\n          }\n          assign(SyntheticBaseEvent.prototype, {\n            preventDefault: function() {\n              this.defaultPrevented = true;\n              var event = this.nativeEvent;\n              if (!event) {\n                return;\n              }\n              if (event.preventDefault) {\n                event.preventDefault();\n              } else if (typeof event.returnValue !== \"unknown\") {\n                event.returnValue = false;\n              }\n              this.isDefaultPrevented = functionThatReturnsTrue;\n            },\n            stopPropagation: function() {\n              var event = this.nativeEvent;\n              if (!event) {\n                return;\n              }\n              if (event.stopPropagation) {\n                event.stopPropagation();\n              } else if (typeof event.cancelBubble !== \"unknown\") {\n                event.cancelBubble = true;\n              }\n              this.isPropagationStopped = functionThatReturnsTrue;\n            },\n            /**\n             * We release all dispatched `SyntheticEvent`s after each event loop, adding\n             * them back into the pool. This allows a way to hold onto a reference that\n             * won't be added back into the pool.\n             */\n            persist: function() {\n            },\n            /**\n             * Checks if this event should be released back into the pool.\n             *\n             * @return {boolean} True if this should not be released, false otherwise.\n             */\n            isPersistent: functionThatReturnsTrue\n          });\n          return SyntheticBaseEvent;\n        }\n        var EventInterface = {\n          eventPhase: 0,\n          bubbles: 0,\n          cancelable: 0,\n          timeStamp: function(event) {\n            return event.timeStamp || Date.now();\n          },\n          defaultPrevented: 0,\n          isTrusted: 0\n        };\n        var SyntheticEvent = createSyntheticEvent(EventInterface);\n        var UIEventInterface = assign({}, EventInterface, {\n          view: 0,\n          detail: 0\n        });\n        var SyntheticUIEvent = createSyntheticEvent(UIEventInterface);\n        var lastMovementX;\n        var lastMovementY;\n        var lastMouseEvent;\n        function updateMouseMovementPolyfillState(event) {\n          if (event !== lastMouseEvent) {\n            if (lastMouseEvent && event.type === \"mousemove\") {\n              lastMovementX = event.screenX - lastMouseEvent.screenX;\n              lastMovementY = event.screenY - lastMouseEvent.screenY;\n            } else {\n              lastMovementX = 0;\n              lastMovementY = 0;\n            }\n            lastMouseEvent = event;\n          }\n        }\n        var MouseEventInterface = assign({}, UIEventInterface, {\n          screenX: 0,\n          screenY: 0,\n          clientX: 0,\n          clientY: 0,\n          pageX: 0,\n          pageY: 0,\n          ctrlKey: 0,\n          shiftKey: 0,\n          altKey: 0,\n          metaKey: 0,\n          getModifierState: getEventModifierState,\n          button: 0,\n          buttons: 0,\n          relatedTarget: function(event) {\n            if (event.relatedTarget === void 0)\n              return event.fromElement === event.srcElement ? event.toElement : event.fromElement;\n            return event.relatedTarget;\n          },\n          movementX: function(event) {\n            if (\"movementX\" in event) {\n              return event.movementX;\n            }\n            updateMouseMovementPolyfillState(event);\n            return lastMovementX;\n          },\n          movementY: function(event) {\n            if (\"movementY\" in event) {\n              return event.movementY;\n            }\n            return lastMovementY;\n          }\n        });\n        var SyntheticMouseEvent = createSyntheticEvent(MouseEventInterface);\n        var DragEventInterface = assign({}, MouseEventInterface, {\n          dataTransfer: 0\n        });\n        var SyntheticDragEvent = createSyntheticEvent(DragEventInterface);\n        var FocusEventInterface = assign({}, UIEventInterface, {\n          relatedTarget: 0\n        });\n        var SyntheticFocusEvent = createSyntheticEvent(FocusEventInterface);\n        var AnimationEventInterface = assign({}, EventInterface, {\n          animationName: 0,\n          elapsedTime: 0,\n          pseudoElement: 0\n        });\n        var SyntheticAnimationEvent = createSyntheticEvent(AnimationEventInterface);\n        var ClipboardEventInterface = assign({}, EventInterface, {\n          clipboardData: function(event) {\n            return \"clipboardData\" in event ? event.clipboardData : window.clipboardData;\n          }\n        });\n        var SyntheticClipboardEvent = createSyntheticEvent(ClipboardEventInterface);\n        var CompositionEventInterface = assign({}, EventInterface, {\n          data: 0\n        });\n        var SyntheticCompositionEvent = createSyntheticEvent(CompositionEventInterface);\n        var SyntheticInputEvent = SyntheticCompositionEvent;\n        var normalizeKey = {\n          Esc: \"Escape\",\n          Spacebar: \" \",\n          Left: \"ArrowLeft\",\n          Up: \"ArrowUp\",\n          Right: \"ArrowRight\",\n          Down: \"ArrowDown\",\n          Del: \"Delete\",\n          Win: \"OS\",\n          Menu: \"ContextMenu\",\n          Apps: \"ContextMenu\",\n          Scroll: \"ScrollLock\",\n          MozPrintableKey: \"Unidentified\"\n        };\n        var translateToKey = {\n          \"8\": \"Backspace\",\n          \"9\": \"Tab\",\n          \"12\": \"Clear\",\n          \"13\": \"Enter\",\n          \"16\": \"Shift\",\n          \"17\": \"Control\",\n          \"18\": \"Alt\",\n          \"19\": \"Pause\",\n          \"20\": \"CapsLock\",\n          \"27\": \"Escape\",\n          \"32\": \" \",\n          \"33\": \"PageUp\",\n          \"34\": \"PageDown\",\n          \"35\": \"End\",\n          \"36\": \"Home\",\n          \"37\": \"ArrowLeft\",\n          \"38\": \"ArrowUp\",\n          \"39\": \"ArrowRight\",\n          \"40\": \"ArrowDown\",\n          \"45\": \"Insert\",\n          \"46\": \"Delete\",\n          \"112\": \"F1\",\n          \"113\": \"F2\",\n          \"114\": \"F3\",\n          \"115\": \"F4\",\n          \"116\": \"F5\",\n          \"117\": \"F6\",\n          \"118\": \"F7\",\n          \"119\": \"F8\",\n          \"120\": \"F9\",\n          \"121\": \"F10\",\n          \"122\": \"F11\",\n          \"123\": \"F12\",\n          \"144\": \"NumLock\",\n          \"145\": \"ScrollLock\",\n          \"224\": \"Meta\"\n        };\n        function getEventKey(nativeEvent) {\n          if (nativeEvent.key) {\n            var key = normalizeKey[nativeEvent.key] || nativeEvent.key;\n            if (key !== \"Unidentified\") {\n              return key;\n            }\n          }\n          if (nativeEvent.type === \"keypress\") {\n            var charCode = getEventCharCode(nativeEvent);\n            return charCode === 13 ? \"Enter\" : String.fromCharCode(charCode);\n          }\n          if (nativeEvent.type === \"keydown\" || nativeEvent.type === \"keyup\") {\n            return translateToKey[nativeEvent.keyCode] || \"Unidentified\";\n          }\n          return \"\";\n        }\n        var modifierKeyToProp = {\n          Alt: \"altKey\",\n          Control: \"ctrlKey\",\n          Meta: \"metaKey\",\n          Shift: \"shiftKey\"\n        };\n        function modifierStateGetter(keyArg) {\n          var syntheticEvent = this;\n          var nativeEvent = syntheticEvent.nativeEvent;\n          if (nativeEvent.getModifierState) {\n            return nativeEvent.getModifierState(keyArg);\n          }\n          var keyProp = modifierKeyToProp[keyArg];\n          return keyProp ? !!nativeEvent[keyProp] : false;\n        }\n        function getEventModifierState(nativeEvent) {\n          return modifierStateGetter;\n        }\n        var KeyboardEventInterface = assign({}, UIEventInterface, {\n          key: getEventKey,\n          code: 0,\n          location: 0,\n          ctrlKey: 0,\n          shiftKey: 0,\n          altKey: 0,\n          metaKey: 0,\n          repeat: 0,\n          locale: 0,\n          getModifierState: getEventModifierState,\n          // Legacy Interface\n          charCode: function(event) {\n            if (event.type === \"keypress\") {\n              return getEventCharCode(event);\n            }\n            return 0;\n          },\n          keyCode: function(event) {\n            if (event.type === \"keydown\" || event.type === \"keyup\") {\n              return event.keyCode;\n            }\n            return 0;\n          },\n          which: function(event) {\n            if (event.type === \"keypress\") {\n              return getEventCharCode(event);\n            }\n            if (event.type === \"keydown\" || event.type === \"keyup\") {\n              return event.keyCode;\n            }\n            return 0;\n          }\n        });\n        var SyntheticKeyboardEvent = createSyntheticEvent(KeyboardEventInterface);\n        var PointerEventInterface = assign({}, MouseEventInterface, {\n          pointerId: 0,\n          width: 0,\n          height: 0,\n          pressure: 0,\n          tangentialPressure: 0,\n          tiltX: 0,\n          tiltY: 0,\n          twist: 0,\n          pointerType: 0,\n          isPrimary: 0\n        });\n        var SyntheticPointerEvent = createSyntheticEvent(PointerEventInterface);\n        var TouchEventInterface = assign({}, UIEventInterface, {\n          touches: 0,\n          targetTouches: 0,\n          changedTouches: 0,\n          altKey: 0,\n          metaKey: 0,\n          ctrlKey: 0,\n          shiftKey: 0,\n          getModifierState: getEventModifierState\n        });\n        var SyntheticTouchEvent = createSyntheticEvent(TouchEventInterface);\n        var TransitionEventInterface = assign({}, EventInterface, {\n          propertyName: 0,\n          elapsedTime: 0,\n          pseudoElement: 0\n        });\n        var SyntheticTransitionEvent = createSyntheticEvent(TransitionEventInterface);\n        var WheelEventInterface = assign({}, MouseEventInterface, {\n          deltaX: function(event) {\n            return \"deltaX\" in event ? event.deltaX : (\n              // Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).\n              \"wheelDeltaX\" in event ? -event.wheelDeltaX : 0\n            );\n          },\n          deltaY: function(event) {\n            return \"deltaY\" in event ? event.deltaY : (\n              // Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).\n              \"wheelDeltaY\" in event ? -event.wheelDeltaY : (\n                // Fallback to `wheelDelta` for IE<9 and normalize (down is positive).\n                \"wheelDelta\" in event ? -event.wheelDelta : 0\n              )\n            );\n          },\n          deltaZ: 0,\n          // Browsers without \"deltaMode\" is reporting in raw wheel delta where one\n          // notch on the scroll is always +/- 120, roughly equivalent to pixels.\n          // A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or\n          // ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.\n          deltaMode: 0\n        });\n        var SyntheticWheelEvent = createSyntheticEvent(WheelEventInterface);\n        var END_KEYCODES = [9, 13, 27, 32];\n        var START_KEYCODE = 229;\n        var canUseCompositionEvent = canUseDOM && \"CompositionEvent\" in window;\n        var documentMode = null;\n        if (canUseDOM && \"documentMode\" in document) {\n          documentMode = document.documentMode;\n        }\n        var canUseTextInputEvent = canUseDOM && \"TextEvent\" in window && !documentMode;\n        var useFallbackCompositionData = canUseDOM && (!canUseCompositionEvent || documentMode && documentMode > 8 && documentMode <= 11);\n        var SPACEBAR_CODE = 32;\n        var SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE);\n        function registerEvents() {\n          registerTwoPhaseEvent(\"onBeforeInput\", [\"compositionend\", \"keypress\", \"textInput\", \"paste\"]);\n          registerTwoPhaseEvent(\"onCompositionEnd\", [\"compositionend\", \"focusout\", \"keydown\", \"keypress\", \"keyup\", \"mousedown\"]);\n          registerTwoPhaseEvent(\"onCompositionStart\", [\"compositionstart\", \"focusout\", \"keydown\", \"keypress\", \"keyup\", \"mousedown\"]);\n          registerTwoPhaseEvent(\"onCompositionUpdate\", [\"compositionupdate\", \"focusout\", \"keydown\", \"keypress\", \"keyup\", \"mousedown\"]);\n        }\n        var hasSpaceKeypress = false;\n        function isKeypressCommand(nativeEvent) {\n          return (nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) && // ctrlKey && altKey is equivalent to AltGr, and is not a command.\n          !(nativeEvent.ctrlKey && nativeEvent.altKey);\n        }\n        function getCompositionEventType(domEventName) {\n          switch (domEventName) {\n            case \"compositionstart\":\n              return \"onCompositionStart\";\n            case \"compositionend\":\n              return \"onCompositionEnd\";\n            case \"compositionupdate\":\n              return \"onCompositionUpdate\";\n          }\n        }\n        function isFallbackCompositionStart(domEventName, nativeEvent) {\n          return domEventName === \"keydown\" && nativeEvent.keyCode === START_KEYCODE;\n        }\n        function isFallbackCompositionEnd(domEventName, nativeEvent) {\n          switch (domEventName) {\n            case \"keyup\":\n              return END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1;\n            case \"keydown\":\n              return nativeEvent.keyCode !== START_KEYCODE;\n            case \"keypress\":\n            case \"mousedown\":\n            case \"focusout\":\n              return true;\n            default:\n              return false;\n          }\n        }\n        function getDataFromCustomEvent(nativeEvent) {\n          var detail = nativeEvent.detail;\n          if (typeof detail === \"object\" && \"data\" in detail) {\n            return detail.data;\n          }\n          return null;\n        }\n        function isUsingKoreanIME(nativeEvent) {\n          return nativeEvent.locale === \"ko\";\n        }\n        var isComposing = false;\n        function extractCompositionEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget) {\n          var eventType;\n          var fallbackData;\n          if (canUseCompositionEvent) {\n            eventType = getCompositionEventType(domEventName);\n          } else if (!isComposing) {\n            if (isFallbackCompositionStart(domEventName, nativeEvent)) {\n              eventType = \"onCompositionStart\";\n            }\n          } else if (isFallbackCompositionEnd(domEventName, nativeEvent)) {\n            eventType = \"onCompositionEnd\";\n          }\n          if (!eventType) {\n            return null;\n          }\n          if (useFallbackCompositionData && !isUsingKoreanIME(nativeEvent)) {\n            if (!isComposing && eventType === \"onCompositionStart\") {\n              isComposing = initialize(nativeEventTarget);\n            } else if (eventType === \"onCompositionEnd\") {\n              if (isComposing) {\n                fallbackData = getData();\n              }\n            }\n          }\n          var listeners = accumulateTwoPhaseListeners(targetInst, eventType);\n          if (listeners.length > 0) {\n            var event = new SyntheticCompositionEvent(eventType, domEventName, null, nativeEvent, nativeEventTarget);\n            dispatchQueue.push({\n              event,\n              listeners\n            });\n            if (fallbackData) {\n              event.data = fallbackData;\n            } else {\n              var customData = getDataFromCustomEvent(nativeEvent);\n              if (customData !== null) {\n                event.data = customData;\n              }\n            }\n          }\n        }\n        function getNativeBeforeInputChars(domEventName, nativeEvent) {\n          switch (domEventName) {\n            case \"compositionend\":\n              return getDataFromCustomEvent(nativeEvent);\n            case \"keypress\":\n              var which = nativeEvent.which;\n              if (which !== SPACEBAR_CODE) {\n                return null;\n              }\n              hasSpaceKeypress = true;\n              return SPACEBAR_CHAR;\n            case \"textInput\":\n              var chars = nativeEvent.data;\n              if (chars === SPACEBAR_CHAR && hasSpaceKeypress) {\n                return null;\n              }\n              return chars;\n            default:\n              return null;\n          }\n        }\n        function getFallbackBeforeInputChars(domEventName, nativeEvent) {\n          if (isComposing) {\n            if (domEventName === \"compositionend\" || !canUseCompositionEvent && isFallbackCompositionEnd(domEventName, nativeEvent)) {\n              var chars = getData();\n              reset();\n              isComposing = false;\n              return chars;\n            }\n            return null;\n          }\n          switch (domEventName) {\n            case \"paste\":\n              return null;\n            case \"keypress\":\n              if (!isKeypressCommand(nativeEvent)) {\n                if (nativeEvent.char && nativeEvent.char.length > 1) {\n                  return nativeEvent.char;\n                } else if (nativeEvent.which) {\n                  return String.fromCharCode(nativeEvent.which);\n                }\n              }\n              return null;\n            case \"compositionend\":\n              return useFallbackCompositionData && !isUsingKoreanIME(nativeEvent) ? null : nativeEvent.data;\n            default:\n              return null;\n          }\n        }\n        function extractBeforeInputEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget) {\n          var chars;\n          if (canUseTextInputEvent) {\n            chars = getNativeBeforeInputChars(domEventName, nativeEvent);\n          } else {\n            chars = getFallbackBeforeInputChars(domEventName, nativeEvent);\n          }\n          if (!chars) {\n            return null;\n          }\n          var listeners = accumulateTwoPhaseListeners(targetInst, \"onBeforeInput\");\n          if (listeners.length > 0) {\n            var event = new SyntheticInputEvent(\"onBeforeInput\", \"beforeinput\", null, nativeEvent, nativeEventTarget);\n            dispatchQueue.push({\n              event,\n              listeners\n            });\n            event.data = chars;\n          }\n        }\n        function extractEvents(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {\n          extractCompositionEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);\n          extractBeforeInputEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);\n        }\n        var supportedInputTypes = {\n          color: true,\n          date: true,\n          datetime: true,\n          \"datetime-local\": true,\n          email: true,\n          month: true,\n          number: true,\n          password: true,\n          range: true,\n          search: true,\n          tel: true,\n          text: true,\n          time: true,\n          url: true,\n          week: true\n        };\n        function isTextInputElement(elem) {\n          var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();\n          if (nodeName === \"input\") {\n            return !!supportedInputTypes[elem.type];\n          }\n          if (nodeName === \"textarea\") {\n            return true;\n          }\n          return false;\n        }\n        function isEventSupported(eventNameSuffix) {\n          if (!canUseDOM) {\n            return false;\n          }\n          var eventName = \"on\" + eventNameSuffix;\n          var isSupported = eventName in document;\n          if (!isSupported) {\n            var element = document.createElement(\"div\");\n            element.setAttribute(eventName, \"return;\");\n            isSupported = typeof element[eventName] === \"function\";\n          }\n          return isSupported;\n        }\n        function registerEvents$1() {\n          registerTwoPhaseEvent(\"onChange\", [\"change\", \"click\", \"focusin\", \"focusout\", \"input\", \"keydown\", \"keyup\", \"selectionchange\"]);\n        }\n        function createAndAccumulateChangeEvent(dispatchQueue, inst, nativeEvent, target) {\n          enqueueStateRestore(target);\n          var listeners = accumulateTwoPhaseListeners(inst, \"onChange\");\n          if (listeners.length > 0) {\n            var event = new SyntheticEvent(\"onChange\", \"change\", null, nativeEvent, target);\n            dispatchQueue.push({\n              event,\n              listeners\n            });\n          }\n        }\n        var activeElement = null;\n        var activeElementInst = null;\n        function shouldUseChangeEvent(elem) {\n          var nodeName = elem.nodeName && elem.nodeName.toLowerCase();\n          return nodeName === \"select\" || nodeName === \"input\" && elem.type === \"file\";\n        }\n        function manualDispatchChangeEvent(nativeEvent) {\n          var dispatchQueue = [];\n          createAndAccumulateChangeEvent(dispatchQueue, activeElementInst, nativeEvent, getEventTarget(nativeEvent));\n          batchedUpdates(runEventInBatch, dispatchQueue);\n        }\n        function runEventInBatch(dispatchQueue) {\n          processDispatchQueue(dispatchQueue, 0);\n        }\n        function getInstIfValueChanged(targetInst) {\n          var targetNode = getNodeFromInstance(targetInst);\n          if (updateValueIfChanged(targetNode)) {\n            return targetInst;\n          }\n        }\n        function getTargetInstForChangeEvent(domEventName, targetInst) {\n          if (domEventName === \"change\") {\n            return targetInst;\n          }\n        }\n        var isInputEventSupported = false;\n        if (canUseDOM) {\n          isInputEventSupported = isEventSupported(\"input\") && (!document.documentMode || document.documentMode > 9);\n        }\n        function startWatchingForValueChange(target, targetInst) {\n          activeElement = target;\n          activeElementInst = targetInst;\n          activeElement.attachEvent(\"onpropertychange\", handlePropertyChange);\n        }\n        function stopWatchingForValueChange() {\n          if (!activeElement) {\n            return;\n          }\n          activeElement.detachEvent(\"onpropertychange\", handlePropertyChange);\n          activeElement = null;\n          activeElementInst = null;\n        }\n        function handlePropertyChange(nativeEvent) {\n          if (nativeEvent.propertyName !== \"value\") {\n            return;\n          }\n          if (getInstIfValueChanged(activeElementInst)) {\n            manualDispatchChangeEvent(nativeEvent);\n          }\n        }\n        function handleEventsForInputEventPolyfill(domEventName, target, targetInst) {\n          if (domEventName === \"focusin\") {\n            stopWatchingForValueChange();\n            startWatchingForValueChange(target, targetInst);\n          } else if (domEventName === \"focusout\") {\n            stopWatchingForValueChange();\n          }\n        }\n        function getTargetInstForInputEventPolyfill(domEventName, targetInst) {\n          if (domEventName === \"selectionchange\" || domEventName === \"keyup\" || domEventName === \"keydown\") {\n            return getInstIfValueChanged(activeElementInst);\n          }\n        }\n        function shouldUseClickEvent(elem) {\n          var nodeName = elem.nodeName;\n          return nodeName && nodeName.toLowerCase() === \"input\" && (elem.type === \"checkbox\" || elem.type === \"radio\");\n        }\n        function getTargetInstForClickEvent(domEventName, targetInst) {\n          if (domEventName === \"click\") {\n            return getInstIfValueChanged(targetInst);\n          }\n        }\n        function getTargetInstForInputOrChangeEvent(domEventName, targetInst) {\n          if (domEventName === \"input\" || domEventName === \"change\") {\n            return getInstIfValueChanged(targetInst);\n          }\n        }\n        function handleControlledInputBlur(node) {\n          var state = node._wrapperState;\n          if (!state || !state.controlled || node.type !== \"number\") {\n            return;\n          }\n          {\n            setDefaultValue(node, \"number\", node.value);\n          }\n        }\n        function extractEvents$1(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {\n          var targetNode = targetInst ? getNodeFromInstance(targetInst) : window;\n          var getTargetInstFunc, handleEventFunc;\n          if (shouldUseChangeEvent(targetNode)) {\n            getTargetInstFunc = getTargetInstForChangeEvent;\n          } else if (isTextInputElement(targetNode)) {\n            if (isInputEventSupported) {\n              getTargetInstFunc = getTargetInstForInputOrChangeEvent;\n            } else {\n              getTargetInstFunc = getTargetInstForInputEventPolyfill;\n              handleEventFunc = handleEventsForInputEventPolyfill;\n            }\n          } else if (shouldUseClickEvent(targetNode)) {\n            getTargetInstFunc = getTargetInstForClickEvent;\n          }\n          if (getTargetInstFunc) {\n            var inst = getTargetInstFunc(domEventName, targetInst);\n            if (inst) {\n              createAndAccumulateChangeEvent(dispatchQueue, inst, nativeEvent, nativeEventTarget);\n              return;\n            }\n          }\n          if (handleEventFunc) {\n            handleEventFunc(domEventName, targetNode, targetInst);\n          }\n          if (domEventName === \"focusout\") {\n            handleControlledInputBlur(targetNode);\n          }\n        }\n        function registerEvents$2() {\n          registerDirectEvent(\"onMouseEnter\", [\"mouseout\", \"mouseover\"]);\n          registerDirectEvent(\"onMouseLeave\", [\"mouseout\", \"mouseover\"]);\n          registerDirectEvent(\"onPointerEnter\", [\"pointerout\", \"pointerover\"]);\n          registerDirectEvent(\"onPointerLeave\", [\"pointerout\", \"pointerover\"]);\n        }\n        function extractEvents$2(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {\n          var isOverEvent = domEventName === \"mouseover\" || domEventName === \"pointerover\";\n          var isOutEvent = domEventName === \"mouseout\" || domEventName === \"pointerout\";\n          if (isOverEvent && !isReplayingEvent(nativeEvent)) {\n            var related = nativeEvent.relatedTarget || nativeEvent.fromElement;\n            if (related) {\n              if (getClosestInstanceFromNode(related) || isContainerMarkedAsRoot(related)) {\n                return;\n              }\n            }\n          }\n          if (!isOutEvent && !isOverEvent) {\n            return;\n          }\n          var win;\n          if (nativeEventTarget.window === nativeEventTarget) {\n            win = nativeEventTarget;\n          } else {\n            var doc = nativeEventTarget.ownerDocument;\n            if (doc) {\n              win = doc.defaultView || doc.parentWindow;\n            } else {\n              win = window;\n            }\n          }\n          var from;\n          var to;\n          if (isOutEvent) {\n            var _related = nativeEvent.relatedTarget || nativeEvent.toElement;\n            from = targetInst;\n            to = _related ? getClosestInstanceFromNode(_related) : null;\n            if (to !== null) {\n              var nearestMounted = getNearestMountedFiber(to);\n              if (to !== nearestMounted || to.tag !== HostComponent && to.tag !== HostText) {\n                to = null;\n              }\n            }\n          } else {\n            from = null;\n            to = targetInst;\n          }\n          if (from === to) {\n            return;\n          }\n          var SyntheticEventCtor = SyntheticMouseEvent;\n          var leaveEventType = \"onMouseLeave\";\n          var enterEventType = \"onMouseEnter\";\n          var eventTypePrefix = \"mouse\";\n          if (domEventName === \"pointerout\" || domEventName === \"pointerover\") {\n            SyntheticEventCtor = SyntheticPointerEvent;\n            leaveEventType = \"onPointerLeave\";\n            enterEventType = \"onPointerEnter\";\n            eventTypePrefix = \"pointer\";\n          }\n          var fromNode = from == null ? win : getNodeFromInstance(from);\n          var toNode = to == null ? win : getNodeFromInstance(to);\n          var leave = new SyntheticEventCtor(leaveEventType, eventTypePrefix + \"leave\", from, nativeEvent, nativeEventTarget);\n          leave.target = fromNode;\n          leave.relatedTarget = toNode;\n          var enter = null;\n          var nativeTargetInst = getClosestInstanceFromNode(nativeEventTarget);\n          if (nativeTargetInst === targetInst) {\n            var enterEvent = new SyntheticEventCtor(enterEventType, eventTypePrefix + \"enter\", to, nativeEvent, nativeEventTarget);\n            enterEvent.target = toNode;\n            enterEvent.relatedTarget = fromNode;\n            enter = enterEvent;\n          }\n          accumulateEnterLeaveTwoPhaseListeners(dispatchQueue, leave, enter, from, to);\n        }\n        function is(x, y) {\n          return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y;\n        }\n        var objectIs = typeof Object.is === \"function\" ? Object.is : is;\n        function shallowEqual(objA, objB) {\n          if (objectIs(objA, objB)) {\n            return true;\n          }\n          if (typeof objA !== \"object\" || objA === null || typeof objB !== \"object\" || objB === null) {\n            return false;\n          }\n          var keysA = Object.keys(objA);\n          var keysB = Object.keys(objB);\n          if (keysA.length !== keysB.length) {\n            return false;\n          }\n          for (var i = 0; i < keysA.length; i++) {\n            var currentKey = keysA[i];\n            if (!hasOwnProperty.call(objB, currentKey) || !objectIs(objA[currentKey], objB[currentKey])) {\n              return false;\n            }\n          }\n          return true;\n        }\n        function getLeafNode(node) {\n          while (node && node.firstChild) {\n            node = node.firstChild;\n          }\n          return node;\n        }\n        function getSiblingNode(node) {\n          while (node) {\n            if (node.nextSibling) {\n              return node.nextSibling;\n            }\n            node = node.parentNode;\n          }\n        }\n        function getNodeForCharacterOffset(root2, offset) {\n          var node = getLeafNode(root2);\n          var nodeStart = 0;\n          var nodeEnd = 0;\n          while (node) {\n            if (node.nodeType === TEXT_NODE) {\n              nodeEnd = nodeStart + node.textContent.length;\n              if (nodeStart <= offset && nodeEnd >= offset) {\n                return {\n                  node,\n                  offset: offset - nodeStart\n                };\n              }\n              nodeStart = nodeEnd;\n            }\n            node = getLeafNode(getSiblingNode(node));\n          }\n        }\n        function getOffsets(outerNode) {\n          var ownerDocument = outerNode.ownerDocument;\n          var win = ownerDocument && ownerDocument.defaultView || window;\n          var selection = win.getSelection && win.getSelection();\n          if (!selection || selection.rangeCount === 0) {\n            return null;\n          }\n          var anchorNode = selection.anchorNode, anchorOffset = selection.anchorOffset, focusNode = selection.focusNode, focusOffset = selection.focusOffset;\n          try {\n            anchorNode.nodeType;\n            focusNode.nodeType;\n          } catch (e) {\n            return null;\n          }\n          return getModernOffsetsFromPoints(outerNode, anchorNode, anchorOffset, focusNode, focusOffset);\n        }\n        function getModernOffsetsFromPoints(outerNode, anchorNode, anchorOffset, focusNode, focusOffset) {\n          var length = 0;\n          var start = -1;\n          var end = -1;\n          var indexWithinAnchor = 0;\n          var indexWithinFocus = 0;\n          var node = outerNode;\n          var parentNode = null;\n          outer:\n            while (true) {\n              var next = null;\n              while (true) {\n                if (node === anchorNode && (anchorOffset === 0 || node.nodeType === TEXT_NODE)) {\n                  start = length + anchorOffset;\n                }\n                if (node === focusNode && (focusOffset === 0 || node.nodeType === TEXT_NODE)) {\n                  end = length + focusOffset;\n                }\n                if (node.nodeType === TEXT_NODE) {\n                  length += node.nodeValue.length;\n                }\n                if ((next = node.firstChild) === null) {\n                  break;\n                }\n                parentNode = node;\n                node = next;\n              }\n              while (true) {\n                if (node === outerNode) {\n                  break outer;\n                }\n                if (parentNode === anchorNode && ++indexWithinAnchor === anchorOffset) {\n                  start = length;\n                }\n                if (parentNode === focusNode && ++indexWithinFocus === focusOffset) {\n                  end = length;\n                }\n                if ((next = node.nextSibling) !== null) {\n                  break;\n                }\n                node = parentNode;\n                parentNode = node.parentNode;\n              }\n              node = next;\n            }\n          if (start === -1 || end === -1) {\n            return null;\n          }\n          return {\n            start,\n            end\n          };\n        }\n        function setOffsets(node, offsets) {\n          var doc = node.ownerDocument || document;\n          var win = doc && doc.defaultView || window;\n          if (!win.getSelection) {\n            return;\n          }\n          var selection = win.getSelection();\n          var length = node.textContent.length;\n          var start = Math.min(offsets.start, length);\n          var end = offsets.end === void 0 ? start : Math.min(offsets.end, length);\n          if (!selection.extend && start > end) {\n            var temp = end;\n            end = start;\n            start = temp;\n          }\n          var startMarker = getNodeForCharacterOffset(node, start);\n          var endMarker = getNodeForCharacterOffset(node, end);\n          if (startMarker && endMarker) {\n            if (selection.rangeCount === 1 && selection.anchorNode === startMarker.node && selection.anchorOffset === startMarker.offset && selection.focusNode === endMarker.node && selection.focusOffset === endMarker.offset) {\n              return;\n            }\n            var range = doc.createRange();\n            range.setStart(startMarker.node, startMarker.offset);\n            selection.removeAllRanges();\n            if (start > end) {\n              selection.addRange(range);\n              selection.extend(endMarker.node, endMarker.offset);\n            } else {\n              range.setEnd(endMarker.node, endMarker.offset);\n              selection.addRange(range);\n            }\n          }\n        }\n        function isTextNode(node) {\n          return node && node.nodeType === TEXT_NODE;\n        }\n        function containsNode(outerNode, innerNode) {\n          if (!outerNode || !innerNode) {\n            return false;\n          } else if (outerNode === innerNode) {\n            return true;\n          } else if (isTextNode(outerNode)) {\n            return false;\n          } else if (isTextNode(innerNode)) {\n            return containsNode(outerNode, innerNode.parentNode);\n          } else if (\"contains\" in outerNode) {\n            return outerNode.contains(innerNode);\n          } else if (outerNode.compareDocumentPosition) {\n            return !!(outerNode.compareDocumentPosition(innerNode) & 16);\n          } else {\n            return false;\n          }\n        }\n        function isInDocument(node) {\n          return node && node.ownerDocument && containsNode(node.ownerDocument.documentElement, node);\n        }\n        function isSameOriginFrame(iframe) {\n          try {\n            return typeof iframe.contentWindow.location.href === \"string\";\n          } catch (err) {\n            return false;\n          }\n        }\n        function getActiveElementDeep() {\n          var win = window;\n          var element = getActiveElement();\n          while (element instanceof win.HTMLIFrameElement) {\n            if (isSameOriginFrame(element)) {\n              win = element.contentWindow;\n            } else {\n              return element;\n            }\n            element = getActiveElement(win.document);\n          }\n          return element;\n        }\n        function hasSelectionCapabilities(elem) {\n          var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();\n          return nodeName && (nodeName === \"input\" && (elem.type === \"text\" || elem.type === \"search\" || elem.type === \"tel\" || elem.type === \"url\" || elem.type === \"password\") || nodeName === \"textarea\" || elem.contentEditable === \"true\");\n        }\n        function getSelectionInformation() {\n          var focusedElem = getActiveElementDeep();\n          return {\n            focusedElem,\n            selectionRange: hasSelectionCapabilities(focusedElem) ? getSelection(focusedElem) : null\n          };\n        }\n        function restoreSelection(priorSelectionInformation) {\n          var curFocusedElem = getActiveElementDeep();\n          var priorFocusedElem = priorSelectionInformation.focusedElem;\n          var priorSelectionRange = priorSelectionInformation.selectionRange;\n          if (curFocusedElem !== priorFocusedElem && isInDocument(priorFocusedElem)) {\n            if (priorSelectionRange !== null && hasSelectionCapabilities(priorFocusedElem)) {\n              setSelection(priorFocusedElem, priorSelectionRange);\n            }\n            var ancestors = [];\n            var ancestor = priorFocusedElem;\n            while (ancestor = ancestor.parentNode) {\n              if (ancestor.nodeType === ELEMENT_NODE) {\n                ancestors.push({\n                  element: ancestor,\n                  left: ancestor.scrollLeft,\n                  top: ancestor.scrollTop\n                });\n              }\n            }\n            if (typeof priorFocusedElem.focus === \"function\") {\n              priorFocusedElem.focus();\n            }\n            for (var i = 0; i < ancestors.length; i++) {\n              var info = ancestors[i];\n              info.element.scrollLeft = info.left;\n              info.element.scrollTop = info.top;\n            }\n          }\n        }\n        function getSelection(input) {\n          var selection;\n          if (\"selectionStart\" in input) {\n            selection = {\n              start: input.selectionStart,\n              end: input.selectionEnd\n            };\n          } else {\n            selection = getOffsets(input);\n          }\n          return selection || {\n            start: 0,\n            end: 0\n          };\n        }\n        function setSelection(input, offsets) {\n          var start = offsets.start;\n          var end = offsets.end;\n          if (end === void 0) {\n            end = start;\n          }\n          if (\"selectionStart\" in input) {\n            input.selectionStart = start;\n            input.selectionEnd = Math.min(end, input.value.length);\n          } else {\n            setOffsets(input, offsets);\n          }\n        }\n        var skipSelectionChangeEvent = canUseDOM && \"documentMode\" in document && document.documentMode <= 11;\n        function registerEvents$3() {\n          registerTwoPhaseEvent(\"onSelect\", [\"focusout\", \"contextmenu\", \"dragend\", \"focusin\", \"keydown\", \"keyup\", \"mousedown\", \"mouseup\", \"selectionchange\"]);\n        }\n        var activeElement$1 = null;\n        var activeElementInst$1 = null;\n        var lastSelection = null;\n        var mouseDown = false;\n        function getSelection$1(node) {\n          if (\"selectionStart\" in node && hasSelectionCapabilities(node)) {\n            return {\n              start: node.selectionStart,\n              end: node.selectionEnd\n            };\n          } else {\n            var win = node.ownerDocument && node.ownerDocument.defaultView || window;\n            var selection = win.getSelection();\n            return {\n              anchorNode: selection.anchorNode,\n              anchorOffset: selection.anchorOffset,\n              focusNode: selection.focusNode,\n              focusOffset: selection.focusOffset\n            };\n          }\n        }\n        function getEventTargetDocument(eventTarget) {\n          return eventTarget.window === eventTarget ? eventTarget.document : eventTarget.nodeType === DOCUMENT_NODE ? eventTarget : eventTarget.ownerDocument;\n        }\n        function constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget) {\n          var doc = getEventTargetDocument(nativeEventTarget);\n          if (mouseDown || activeElement$1 == null || activeElement$1 !== getActiveElement(doc)) {\n            return;\n          }\n          var currentSelection = getSelection$1(activeElement$1);\n          if (!lastSelection || !shallowEqual(lastSelection, currentSelection)) {\n            lastSelection = currentSelection;\n            var listeners = accumulateTwoPhaseListeners(activeElementInst$1, \"onSelect\");\n            if (listeners.length > 0) {\n              var event = new SyntheticEvent(\"onSelect\", \"select\", null, nativeEvent, nativeEventTarget);\n              dispatchQueue.push({\n                event,\n                listeners\n              });\n              event.target = activeElement$1;\n            }\n          }\n        }\n        function extractEvents$3(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {\n          var targetNode = targetInst ? getNodeFromInstance(targetInst) : window;\n          switch (domEventName) {\n            case \"focusin\":\n              if (isTextInputElement(targetNode) || targetNode.contentEditable === \"true\") {\n                activeElement$1 = targetNode;\n                activeElementInst$1 = targetInst;\n                lastSelection = null;\n              }\n              break;\n            case \"focusout\":\n              activeElement$1 = null;\n              activeElementInst$1 = null;\n              lastSelection = null;\n              break;\n            case \"mousedown\":\n              mouseDown = true;\n              break;\n            case \"contextmenu\":\n            case \"mouseup\":\n            case \"dragend\":\n              mouseDown = false;\n              constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);\n              break;\n            case \"selectionchange\":\n              if (skipSelectionChangeEvent) {\n                break;\n              }\n            case \"keydown\":\n            case \"keyup\":\n              constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);\n          }\n        }\n        function makePrefixMap(styleProp, eventName) {\n          var prefixes2 = {};\n          prefixes2[styleProp.toLowerCase()] = eventName.toLowerCase();\n          prefixes2[\"Webkit\" + styleProp] = \"webkit\" + eventName;\n          prefixes2[\"Moz\" + styleProp] = \"moz\" + eventName;\n          return prefixes2;\n        }\n        var vendorPrefixes = {\n          animationend: makePrefixMap(\"Animation\", \"AnimationEnd\"),\n          animationiteration: makePrefixMap(\"Animation\", \"AnimationIteration\"),\n          animationstart: makePrefixMap(\"Animation\", \"AnimationStart\"),\n          transitionend: makePrefixMap(\"Transition\", \"TransitionEnd\")\n        };\n        var prefixedEventNames = {};\n        var style = {};\n        if (canUseDOM) {\n          style = document.createElement(\"div\").style;\n          if (!(\"AnimationEvent\" in window)) {\n            delete vendorPrefixes.animationend.animation;\n            delete vendorPrefixes.animationiteration.animation;\n            delete vendorPrefixes.animationstart.animation;\n          }\n          if (!(\"TransitionEvent\" in window)) {\n            delete vendorPrefixes.transitionend.transition;\n          }\n        }\n        function getVendorPrefixedEventName(eventName) {\n          if (prefixedEventNames[eventName]) {\n            return prefixedEventNames[eventName];\n          } else if (!vendorPrefixes[eventName]) {\n            return eventName;\n          }\n          var prefixMap = vendorPrefixes[eventName];\n          for (var styleProp in prefixMap) {\n            if (prefixMap.hasOwnProperty(styleProp) && styleProp in style) {\n              return prefixedEventNames[eventName] = prefixMap[styleProp];\n            }\n          }\n          return eventName;\n        }\n        var ANIMATION_END = getVendorPrefixedEventName(\"animationend\");\n        var ANIMATION_ITERATION = getVendorPrefixedEventName(\"animationiteration\");\n        var ANIMATION_START = getVendorPrefixedEventName(\"animationstart\");\n        var TRANSITION_END = getVendorPrefixedEventName(\"transitionend\");\n        var topLevelEventsToReactNames = /* @__PURE__ */ new Map();\n        var simpleEventPluginEvents = [\"abort\", \"auxClick\", \"cancel\", \"canPlay\", \"canPlayThrough\", \"click\", \"close\", \"contextMenu\", \"copy\", \"cut\", \"drag\", \"dragEnd\", \"dragEnter\", \"dragExit\", \"dragLeave\", \"dragOver\", \"dragStart\", \"drop\", \"durationChange\", \"emptied\", \"encrypted\", \"ended\", \"error\", \"gotPointerCapture\", \"input\", \"invalid\", \"keyDown\", \"keyPress\", \"keyUp\", \"load\", \"loadedData\", \"loadedMetadata\", \"loadStart\", \"lostPointerCapture\", \"mouseDown\", \"mouseMove\", \"mouseOut\", \"mouseOver\", \"mouseUp\", \"paste\", \"pause\", \"play\", \"playing\", \"pointerCancel\", \"pointerDown\", \"pointerMove\", \"pointerOut\", \"pointerOver\", \"pointerUp\", \"progress\", \"rateChange\", \"reset\", \"resize\", \"seeked\", \"seeking\", \"stalled\", \"submit\", \"suspend\", \"timeUpdate\", \"touchCancel\", \"touchEnd\", \"touchStart\", \"volumeChange\", \"scroll\", \"toggle\", \"touchMove\", \"waiting\", \"wheel\"];\n        function registerSimpleEvent(domEventName, reactName) {\n          topLevelEventsToReactNames.set(domEventName, reactName);\n          registerTwoPhaseEvent(reactName, [domEventName]);\n        }\n        function registerSimpleEvents() {\n          for (var i = 0; i < simpleEventPluginEvents.length; i++) {\n            var eventName = simpleEventPluginEvents[i];\n            var domEventName = eventName.toLowerCase();\n            var capitalizedEvent = eventName[0].toUpperCase() + eventName.slice(1);\n            registerSimpleEvent(domEventName, \"on\" + capitalizedEvent);\n          }\n          registerSimpleEvent(ANIMATION_END, \"onAnimationEnd\");\n          registerSimpleEvent(ANIMATION_ITERATION, \"onAnimationIteration\");\n          registerSimpleEvent(ANIMATION_START, \"onAnimationStart\");\n          registerSimpleEvent(\"dblclick\", \"onDoubleClick\");\n          registerSimpleEvent(\"focusin\", \"onFocus\");\n          registerSimpleEvent(\"focusout\", \"onBlur\");\n          registerSimpleEvent(TRANSITION_END, \"onTransitionEnd\");\n        }\n        function extractEvents$4(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {\n          var reactName = topLevelEventsToReactNames.get(domEventName);\n          if (reactName === void 0) {\n            return;\n          }\n          var SyntheticEventCtor = SyntheticEvent;\n          var reactEventType = domEventName;\n          switch (domEventName) {\n            case \"keypress\":\n              if (getEventCharCode(nativeEvent) === 0) {\n                return;\n              }\n            case \"keydown\":\n            case \"keyup\":\n              SyntheticEventCtor = SyntheticKeyboardEvent;\n              break;\n            case \"focusin\":\n              reactEventType = \"focus\";\n              SyntheticEventCtor = SyntheticFocusEvent;\n              break;\n            case \"focusout\":\n              reactEventType = \"blur\";\n              SyntheticEventCtor = SyntheticFocusEvent;\n              break;\n            case \"beforeblur\":\n            case \"afterblur\":\n              SyntheticEventCtor = SyntheticFocusEvent;\n              break;\n            case \"click\":\n              if (nativeEvent.button === 2) {\n                return;\n              }\n            case \"auxclick\":\n            case \"dblclick\":\n            case \"mousedown\":\n            case \"mousemove\":\n            case \"mouseup\":\n            case \"mouseout\":\n            case \"mouseover\":\n            case \"contextmenu\":\n              SyntheticEventCtor = SyntheticMouseEvent;\n              break;\n            case \"drag\":\n            case \"dragend\":\n            case \"dragenter\":\n            case \"dragexit\":\n            case \"dragleave\":\n            case \"dragover\":\n            case \"dragstart\":\n            case \"drop\":\n              SyntheticEventCtor = SyntheticDragEvent;\n              break;\n            case \"touchcancel\":\n            case \"touchend\":\n            case \"touchmove\":\n            case \"touchstart\":\n              SyntheticEventCtor = SyntheticTouchEvent;\n              break;\n            case ANIMATION_END:\n            case ANIMATION_ITERATION:\n            case ANIMATION_START:\n              SyntheticEventCtor = SyntheticAnimationEvent;\n              break;\n            case TRANSITION_END:\n              SyntheticEventCtor = SyntheticTransitionEvent;\n              break;\n            case \"scroll\":\n              SyntheticEventCtor = SyntheticUIEvent;\n              break;\n            case \"wheel\":\n              SyntheticEventCtor = SyntheticWheelEvent;\n              break;\n            case \"copy\":\n            case \"cut\":\n            case \"paste\":\n              SyntheticEventCtor = SyntheticClipboardEvent;\n              break;\n            case \"gotpointercapture\":\n            case \"lostpointercapture\":\n            case \"pointercancel\":\n            case \"pointerdown\":\n            case \"pointermove\":\n            case \"pointerout\":\n            case \"pointerover\":\n            case \"pointerup\":\n              SyntheticEventCtor = SyntheticPointerEvent;\n              break;\n          }\n          var inCapturePhase = (eventSystemFlags & IS_CAPTURE_PHASE) !== 0;\n          {\n            var accumulateTargetOnly = !inCapturePhase && // TODO: ideally, we'd eventually add all events from\n            // nonDelegatedEvents list in DOMPluginEventSystem.\n            // Then we can remove this special list.\n            // This is a breaking change that can wait until React 18.\n            domEventName === \"scroll\";\n            var _listeners = accumulateSinglePhaseListeners(targetInst, reactName, nativeEvent.type, inCapturePhase, accumulateTargetOnly);\n            if (_listeners.length > 0) {\n              var _event = new SyntheticEventCtor(reactName, reactEventType, null, nativeEvent, nativeEventTarget);\n              dispatchQueue.push({\n                event: _event,\n                listeners: _listeners\n              });\n            }\n          }\n        }\n        registerSimpleEvents();\n        registerEvents$2();\n        registerEvents$1();\n        registerEvents$3();\n        registerEvents();\n        function extractEvents$5(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {\n          extractEvents$4(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags);\n          var shouldProcessPolyfillPlugins = (eventSystemFlags & SHOULD_NOT_PROCESS_POLYFILL_EVENT_PLUGINS) === 0;\n          if (shouldProcessPolyfillPlugins) {\n            extractEvents$2(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);\n            extractEvents$1(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);\n            extractEvents$3(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);\n            extractEvents(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);\n          }\n        }\n        var mediaEventTypes = [\"abort\", \"canplay\", \"canplaythrough\", \"durationchange\", \"emptied\", \"encrypted\", \"ended\", \"error\", \"loadeddata\", \"loadedmetadata\", \"loadstart\", \"pause\", \"play\", \"playing\", \"progress\", \"ratechange\", \"resize\", \"seeked\", \"seeking\", \"stalled\", \"suspend\", \"timeupdate\", \"volumechange\", \"waiting\"];\n        var nonDelegatedEvents = new Set([\"cancel\", \"close\", \"invalid\", \"load\", \"scroll\", \"toggle\"].concat(mediaEventTypes));\n        function executeDispatch(event, listener, currentTarget) {\n          var type = event.type || \"unknown-event\";\n          event.currentTarget = currentTarget;\n          invokeGuardedCallbackAndCatchFirstError(type, listener, void 0, event);\n          event.currentTarget = null;\n        }\n        function processDispatchQueueItemsInOrder(event, dispatchListeners, inCapturePhase) {\n          var previousInstance;\n          if (inCapturePhase) {\n            for (var i = dispatchListeners.length - 1; i >= 0; i--) {\n              var _dispatchListeners$i = dispatchListeners[i], instance = _dispatchListeners$i.instance, currentTarget = _dispatchListeners$i.currentTarget, listener = _dispatchListeners$i.listener;\n              if (instance !== previousInstance && event.isPropagationStopped()) {\n                return;\n              }\n              executeDispatch(event, listener, currentTarget);\n              previousInstance = instance;\n            }\n          } else {\n            for (var _i = 0; _i < dispatchListeners.length; _i++) {\n              var _dispatchListeners$_i = dispatchListeners[_i], _instance = _dispatchListeners$_i.instance, _currentTarget = _dispatchListeners$_i.currentTarget, _listener = _dispatchListeners$_i.listener;\n              if (_instance !== previousInstance && event.isPropagationStopped()) {\n                return;\n              }\n              executeDispatch(event, _listener, _currentTarget);\n              previousInstance = _instance;\n            }\n          }\n        }\n        function processDispatchQueue(dispatchQueue, eventSystemFlags) {\n          var inCapturePhase = (eventSystemFlags & IS_CAPTURE_PHASE) !== 0;\n          for (var i = 0; i < dispatchQueue.length; i++) {\n            var _dispatchQueue$i = dispatchQueue[i], event = _dispatchQueue$i.event, listeners = _dispatchQueue$i.listeners;\n            processDispatchQueueItemsInOrder(event, listeners, inCapturePhase);\n          }\n          rethrowCaughtError();\n        }\n        function dispatchEventsForPlugins(domEventName, eventSystemFlags, nativeEvent, targetInst, targetContainer) {\n          var nativeEventTarget = getEventTarget(nativeEvent);\n          var dispatchQueue = [];\n          extractEvents$5(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags);\n          processDispatchQueue(dispatchQueue, eventSystemFlags);\n        }\n        function listenToNonDelegatedEvent(domEventName, targetElement) {\n          {\n            if (!nonDelegatedEvents.has(domEventName)) {\n              error('Did not expect a listenToNonDelegatedEvent() call for \"%s\". This is a bug in React. Please file an issue.', domEventName);\n            }\n          }\n          var isCapturePhaseListener = false;\n          var listenerSet = getEventListenerSet(targetElement);\n          var listenerSetKey = getListenerSetKey(domEventName, isCapturePhaseListener);\n          if (!listenerSet.has(listenerSetKey)) {\n            addTrappedEventListener(targetElement, domEventName, IS_NON_DELEGATED, isCapturePhaseListener);\n            listenerSet.add(listenerSetKey);\n          }\n        }\n        function listenToNativeEvent(domEventName, isCapturePhaseListener, target) {\n          {\n            if (nonDelegatedEvents.has(domEventName) && !isCapturePhaseListener) {\n              error('Did not expect a listenToNativeEvent() call for \"%s\" in the bubble phase. This is a bug in React. Please file an issue.', domEventName);\n            }\n          }\n          var eventSystemFlags = 0;\n          if (isCapturePhaseListener) {\n            eventSystemFlags |= IS_CAPTURE_PHASE;\n          }\n          addTrappedEventListener(target, domEventName, eventSystemFlags, isCapturePhaseListener);\n        }\n        var listeningMarker = \"_reactListening\" + Math.random().toString(36).slice(2);\n        function listenToAllSupportedEvents(rootContainerElement) {\n          if (!rootContainerElement[listeningMarker]) {\n            rootContainerElement[listeningMarker] = true;\n            allNativeEvents.forEach(function(domEventName) {\n              if (domEventName !== \"selectionchange\") {\n                if (!nonDelegatedEvents.has(domEventName)) {\n                  listenToNativeEvent(domEventName, false, rootContainerElement);\n                }\n                listenToNativeEvent(domEventName, true, rootContainerElement);\n              }\n            });\n            var ownerDocument = rootContainerElement.nodeType === DOCUMENT_NODE ? rootContainerElement : rootContainerElement.ownerDocument;\n            if (ownerDocument !== null) {\n              if (!ownerDocument[listeningMarker]) {\n                ownerDocument[listeningMarker] = true;\n                listenToNativeEvent(\"selectionchange\", false, ownerDocument);\n              }\n            }\n          }\n        }\n        function addTrappedEventListener(targetContainer, domEventName, eventSystemFlags, isCapturePhaseListener, isDeferredListenerForLegacyFBSupport) {\n          var listener = createEventListenerWrapperWithPriority(targetContainer, domEventName, eventSystemFlags);\n          var isPassiveListener = void 0;\n          if (passiveBrowserEventsSupported) {\n            if (domEventName === \"touchstart\" || domEventName === \"touchmove\" || domEventName === \"wheel\") {\n              isPassiveListener = true;\n            }\n          }\n          targetContainer = targetContainer;\n          var unsubscribeListener;\n          if (isCapturePhaseListener) {\n            if (isPassiveListener !== void 0) {\n              unsubscribeListener = addEventCaptureListenerWithPassiveFlag(targetContainer, domEventName, listener, isPassiveListener);\n            } else {\n              unsubscribeListener = addEventCaptureListener(targetContainer, domEventName, listener);\n            }\n          } else {\n            if (isPassiveListener !== void 0) {\n              unsubscribeListener = addEventBubbleListenerWithPassiveFlag(targetContainer, domEventName, listener, isPassiveListener);\n            } else {\n              unsubscribeListener = addEventBubbleListener(targetContainer, domEventName, listener);\n            }\n          }\n        }\n        function isMatchingRootContainer(grandContainer, targetContainer) {\n          return grandContainer === targetContainer || grandContainer.nodeType === COMMENT_NODE && grandContainer.parentNode === targetContainer;\n        }\n        function dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, targetInst, targetContainer) {\n          var ancestorInst = targetInst;\n          if ((eventSystemFlags & IS_EVENT_HANDLE_NON_MANAGED_NODE) === 0 && (eventSystemFlags & IS_NON_DELEGATED) === 0) {\n            var targetContainerNode = targetContainer;\n            if (targetInst !== null) {\n              var node = targetInst;\n              mainLoop:\n                while (true) {\n                  if (node === null) {\n                    return;\n                  }\n                  var nodeTag = node.tag;\n                  if (nodeTag === HostRoot || nodeTag === HostPortal) {\n                    var container = node.stateNode.containerInfo;\n                    if (isMatchingRootContainer(container, targetContainerNode)) {\n                      break;\n                    }\n                    if (nodeTag === HostPortal) {\n                      var grandNode = node.return;\n                      while (grandNode !== null) {\n                        var grandTag = grandNode.tag;\n                        if (grandTag === HostRoot || grandTag === HostPortal) {\n                          var grandContainer = grandNode.stateNode.containerInfo;\n                          if (isMatchingRootContainer(grandContainer, targetContainerNode)) {\n                            return;\n                          }\n                        }\n                        grandNode = grandNode.return;\n                      }\n                    }\n                    while (container !== null) {\n                      var parentNode = getClosestInstanceFromNode(container);\n                      if (parentNode === null) {\n                        return;\n                      }\n                      var parentTag = parentNode.tag;\n                      if (parentTag === HostComponent || parentTag === HostText) {\n                        node = ancestorInst = parentNode;\n                        continue mainLoop;\n                      }\n                      container = container.parentNode;\n                    }\n                  }\n                  node = node.return;\n                }\n            }\n          }\n          batchedUpdates(function() {\n            return dispatchEventsForPlugins(domEventName, eventSystemFlags, nativeEvent, ancestorInst);\n          });\n        }\n        function createDispatchListener(instance, listener, currentTarget) {\n          return {\n            instance,\n            listener,\n            currentTarget\n          };\n        }\n        function accumulateSinglePhaseListeners(targetFiber, reactName, nativeEventType, inCapturePhase, accumulateTargetOnly, nativeEvent) {\n          var captureName = reactName !== null ? reactName + \"Capture\" : null;\n          var reactEventName = inCapturePhase ? captureName : reactName;\n          var listeners = [];\n          var instance = targetFiber;\n          var lastHostComponent = null;\n          while (instance !== null) {\n            var _instance2 = instance, stateNode = _instance2.stateNode, tag = _instance2.tag;\n            if (tag === HostComponent && stateNode !== null) {\n              lastHostComponent = stateNode;\n              if (reactEventName !== null) {\n                var listener = getListener(instance, reactEventName);\n                if (listener != null) {\n                  listeners.push(createDispatchListener(instance, listener, lastHostComponent));\n                }\n              }\n            }\n            if (accumulateTargetOnly) {\n              break;\n            }\n            instance = instance.return;\n          }\n          return listeners;\n        }\n        function accumulateTwoPhaseListeners(targetFiber, reactName) {\n          var captureName = reactName + \"Capture\";\n          var listeners = [];\n          var instance = targetFiber;\n          while (instance !== null) {\n            var _instance3 = instance, stateNode = _instance3.stateNode, tag = _instance3.tag;\n            if (tag === HostComponent && stateNode !== null) {\n              var currentTarget = stateNode;\n              var captureListener = getListener(instance, captureName);\n              if (captureListener != null) {\n                listeners.unshift(createDispatchListener(instance, captureListener, currentTarget));\n              }\n              var bubbleListener = getListener(instance, reactName);\n              if (bubbleListener != null) {\n                listeners.push(createDispatchListener(instance, bubbleListener, currentTarget));\n              }\n            }\n            instance = instance.return;\n          }\n          return listeners;\n        }\n        function getParent(inst) {\n          if (inst === null) {\n            return null;\n          }\n          do {\n            inst = inst.return;\n          } while (inst && inst.tag !== HostComponent);\n          if (inst) {\n            return inst;\n          }\n          return null;\n        }\n        function getLowestCommonAncestor(instA, instB) {\n          var nodeA = instA;\n          var nodeB = instB;\n          var depthA = 0;\n          for (var tempA = nodeA; tempA; tempA = getParent(tempA)) {\n            depthA++;\n          }\n          var depthB = 0;\n          for (var tempB = nodeB; tempB; tempB = getParent(tempB)) {\n            depthB++;\n          }\n          while (depthA - depthB > 0) {\n            nodeA = getParent(nodeA);\n            depthA--;\n          }\n          while (depthB - depthA > 0) {\n            nodeB = getParent(nodeB);\n            depthB--;\n          }\n          var depth = depthA;\n          while (depth--) {\n            if (nodeA === nodeB || nodeB !== null && nodeA === nodeB.alternate) {\n              return nodeA;\n            }\n            nodeA = getParent(nodeA);\n            nodeB = getParent(nodeB);\n          }\n          return null;\n        }\n        function accumulateEnterLeaveListenersForEvent(dispatchQueue, event, target, common, inCapturePhase) {\n          var registrationName = event._reactName;\n          var listeners = [];\n          var instance = target;\n          while (instance !== null) {\n            if (instance === common) {\n              break;\n            }\n            var _instance4 = instance, alternate = _instance4.alternate, stateNode = _instance4.stateNode, tag = _instance4.tag;\n            if (alternate !== null && alternate === common) {\n              break;\n            }\n            if (tag === HostComponent && stateNode !== null) {\n              var currentTarget = stateNode;\n              if (inCapturePhase) {\n                var captureListener = getListener(instance, registrationName);\n                if (captureListener != null) {\n                  listeners.unshift(createDispatchListener(instance, captureListener, currentTarget));\n                }\n              } else if (!inCapturePhase) {\n                var bubbleListener = getListener(instance, registrationName);\n                if (bubbleListener != null) {\n                  listeners.push(createDispatchListener(instance, bubbleListener, currentTarget));\n                }\n              }\n            }\n            instance = instance.return;\n          }\n          if (listeners.length !== 0) {\n            dispatchQueue.push({\n              event,\n              listeners\n            });\n          }\n        }\n        function accumulateEnterLeaveTwoPhaseListeners(dispatchQueue, leaveEvent, enterEvent, from, to) {\n          var common = from && to ? getLowestCommonAncestor(from, to) : null;\n          if (from !== null) {\n            accumulateEnterLeaveListenersForEvent(dispatchQueue, leaveEvent, from, common, false);\n          }\n          if (to !== null && enterEvent !== null) {\n            accumulateEnterLeaveListenersForEvent(dispatchQueue, enterEvent, to, common, true);\n          }\n        }\n        function getListenerSetKey(domEventName, capture) {\n          return domEventName + \"__\" + (capture ? \"capture\" : \"bubble\");\n        }\n        var didWarnInvalidHydration = false;\n        var DANGEROUSLY_SET_INNER_HTML = \"dangerouslySetInnerHTML\";\n        var SUPPRESS_CONTENT_EDITABLE_WARNING = \"suppressContentEditableWarning\";\n        var SUPPRESS_HYDRATION_WARNING = \"suppressHydrationWarning\";\n        var AUTOFOCUS = \"autoFocus\";\n        var CHILDREN = \"children\";\n        var STYLE = \"style\";\n        var HTML$1 = \"__html\";\n        var warnedUnknownTags;\n        var validatePropertiesInDevelopment;\n        var warnForPropDifference;\n        var warnForExtraAttributes;\n        var warnForInvalidEventListener;\n        var canDiffStyleForHydrationWarning;\n        var normalizeHTML;\n        {\n          warnedUnknownTags = {\n            // There are working polyfills for <dialog>. Let people use it.\n            dialog: true,\n            // Electron ships a custom <webview> tag to display external web content in\n            // an isolated frame and process.\n            // This tag is not present in non Electron environments such as JSDom which\n            // is often used for testing purposes.\n            // @see https://electronjs.org/docs/api/webview-tag\n            webview: true\n          };\n          validatePropertiesInDevelopment = function(type, props) {\n            validateProperties(type, props);\n            validateProperties$1(type, props);\n            validateProperties$2(type, props, {\n              registrationNameDependencies,\n              possibleRegistrationNames\n            });\n          };\n          canDiffStyleForHydrationWarning = canUseDOM && !document.documentMode;\n          warnForPropDifference = function(propName, serverValue, clientValue) {\n            if (didWarnInvalidHydration) {\n              return;\n            }\n            var normalizedClientValue = normalizeMarkupForTextOrAttribute(clientValue);\n            var normalizedServerValue = normalizeMarkupForTextOrAttribute(serverValue);\n            if (normalizedServerValue === normalizedClientValue) {\n              return;\n            }\n            didWarnInvalidHydration = true;\n            error(\"Prop `%s` did not match. Server: %s Client: %s\", propName, JSON.stringify(normalizedServerValue), JSON.stringify(normalizedClientValue));\n          };\n          warnForExtraAttributes = function(attributeNames) {\n            if (didWarnInvalidHydration) {\n              return;\n            }\n            didWarnInvalidHydration = true;\n            var names = [];\n            attributeNames.forEach(function(name) {\n              names.push(name);\n            });\n            error(\"Extra attributes from the server: %s\", names);\n          };\n          warnForInvalidEventListener = function(registrationName, listener) {\n            if (listener === false) {\n              error(\"Expected `%s` listener to be a function, instead got `false`.\\n\\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.\", registrationName, registrationName, registrationName);\n            } else {\n              error(\"Expected `%s` listener to be a function, instead got a value of `%s` type.\", registrationName, typeof listener);\n            }\n          };\n          normalizeHTML = function(parent, html) {\n            var testElement = parent.namespaceURI === HTML_NAMESPACE ? parent.ownerDocument.createElement(parent.tagName) : parent.ownerDocument.createElementNS(parent.namespaceURI, parent.tagName);\n            testElement.innerHTML = html;\n            return testElement.innerHTML;\n          };\n        }\n        var NORMALIZE_NEWLINES_REGEX = /\\r\\n?/g;\n        var NORMALIZE_NULL_AND_REPLACEMENT_REGEX = /\\u0000|\\uFFFD/g;\n        function normalizeMarkupForTextOrAttribute(markup) {\n          {\n            checkHtmlStringCoercion(markup);\n          }\n          var markupString = typeof markup === \"string\" ? markup : \"\" + markup;\n          return markupString.replace(NORMALIZE_NEWLINES_REGEX, \"\\n\").replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX, \"\");\n        }\n        function checkForUnmatchedText(serverText, clientText, isConcurrentMode, shouldWarnDev) {\n          var normalizedClientText = normalizeMarkupForTextOrAttribute(clientText);\n          var normalizedServerText = normalizeMarkupForTextOrAttribute(serverText);\n          if (normalizedServerText === normalizedClientText) {\n            return;\n          }\n          if (shouldWarnDev) {\n            {\n              if (!didWarnInvalidHydration) {\n                didWarnInvalidHydration = true;\n                error('Text content did not match. Server: \"%s\" Client: \"%s\"', normalizedServerText, normalizedClientText);\n              }\n            }\n          }\n          if (isConcurrentMode && enableClientRenderFallbackOnTextMismatch) {\n            throw new Error(\"Text content does not match server-rendered HTML.\");\n          }\n        }\n        function getOwnerDocumentFromRootContainer(rootContainerElement) {\n          return rootContainerElement.nodeType === DOCUMENT_NODE ? rootContainerElement : rootContainerElement.ownerDocument;\n        }\n        function noop() {\n        }\n        function trapClickOnNonInteractiveElement(node) {\n          node.onclick = noop;\n        }\n        function setInitialDOMProperties(tag, domElement, rootContainerElement, nextProps, isCustomComponentTag) {\n          for (var propKey in nextProps) {\n            if (!nextProps.hasOwnProperty(propKey)) {\n              continue;\n            }\n            var nextProp = nextProps[propKey];\n            if (propKey === STYLE) {\n              {\n                if (nextProp) {\n                  Object.freeze(nextProp);\n                }\n              }\n              setValueForStyles(domElement, nextProp);\n            } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {\n              var nextHtml = nextProp ? nextProp[HTML$1] : void 0;\n              if (nextHtml != null) {\n                setInnerHTML(domElement, nextHtml);\n              }\n            } else if (propKey === CHILDREN) {\n              if (typeof nextProp === \"string\") {\n                var canSetTextContent = tag !== \"textarea\" || nextProp !== \"\";\n                if (canSetTextContent) {\n                  setTextContent(domElement, nextProp);\n                }\n              } else if (typeof nextProp === \"number\") {\n                setTextContent(domElement, \"\" + nextProp);\n              }\n            } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING)\n              ;\n            else if (propKey === AUTOFOCUS)\n              ;\n            else if (registrationNameDependencies.hasOwnProperty(propKey)) {\n              if (nextProp != null) {\n                if (typeof nextProp !== \"function\") {\n                  warnForInvalidEventListener(propKey, nextProp);\n                }\n                if (propKey === \"onScroll\") {\n                  listenToNonDelegatedEvent(\"scroll\", domElement);\n                }\n              }\n            } else if (nextProp != null) {\n              setValueForProperty(domElement, propKey, nextProp, isCustomComponentTag);\n            }\n          }\n        }\n        function updateDOMProperties(domElement, updatePayload, wasCustomComponentTag, isCustomComponentTag) {\n          for (var i = 0; i < updatePayload.length; i += 2) {\n            var propKey = updatePayload[i];\n            var propValue = updatePayload[i + 1];\n            if (propKey === STYLE) {\n              setValueForStyles(domElement, propValue);\n            } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {\n              setInnerHTML(domElement, propValue);\n            } else if (propKey === CHILDREN) {\n              setTextContent(domElement, propValue);\n            } else {\n              setValueForProperty(domElement, propKey, propValue, isCustomComponentTag);\n            }\n          }\n        }\n        function createElement(type, props, rootContainerElement, parentNamespace) {\n          var isCustomComponentTag;\n          var ownerDocument = getOwnerDocumentFromRootContainer(rootContainerElement);\n          var domElement;\n          var namespaceURI = parentNamespace;\n          if (namespaceURI === HTML_NAMESPACE) {\n            namespaceURI = getIntrinsicNamespace(type);\n          }\n          if (namespaceURI === HTML_NAMESPACE) {\n            {\n              isCustomComponentTag = isCustomComponent(type, props);\n              if (!isCustomComponentTag && type !== type.toLowerCase()) {\n                error(\"<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.\", type);\n              }\n            }\n            if (type === \"script\") {\n              var div = ownerDocument.createElement(\"div\");\n              div.innerHTML = \"<script><\\/script>\";\n              var firstChild = div.firstChild;\n              domElement = div.removeChild(firstChild);\n            } else if (typeof props.is === \"string\") {\n              domElement = ownerDocument.createElement(type, {\n                is: props.is\n              });\n            } else {\n              domElement = ownerDocument.createElement(type);\n              if (type === \"select\") {\n                var node = domElement;\n                if (props.multiple) {\n                  node.multiple = true;\n                } else if (props.size) {\n                  node.size = props.size;\n                }\n              }\n            }\n          } else {\n            domElement = ownerDocument.createElementNS(namespaceURI, type);\n          }\n          {\n            if (namespaceURI === HTML_NAMESPACE) {\n              if (!isCustomComponentTag && Object.prototype.toString.call(domElement) === \"[object HTMLUnknownElement]\" && !hasOwnProperty.call(warnedUnknownTags, type)) {\n                warnedUnknownTags[type] = true;\n                error(\"The tag <%s> is unrecognized in this browser. If you meant to render a React component, start its name with an uppercase letter.\", type);\n              }\n            }\n          }\n          return domElement;\n        }\n        function createTextNode(text, rootContainerElement) {\n          return getOwnerDocumentFromRootContainer(rootContainerElement).createTextNode(text);\n        }\n        function setInitialProperties(domElement, tag, rawProps, rootContainerElement) {\n          var isCustomComponentTag = isCustomComponent(tag, rawProps);\n          {\n            validatePropertiesInDevelopment(tag, rawProps);\n          }\n          var props;\n          switch (tag) {\n            case \"dialog\":\n              listenToNonDelegatedEvent(\"cancel\", domElement);\n              listenToNonDelegatedEvent(\"close\", domElement);\n              props = rawProps;\n              break;\n            case \"iframe\":\n            case \"object\":\n            case \"embed\":\n              listenToNonDelegatedEvent(\"load\", domElement);\n              props = rawProps;\n              break;\n            case \"video\":\n            case \"audio\":\n              for (var i = 0; i < mediaEventTypes.length; i++) {\n                listenToNonDelegatedEvent(mediaEventTypes[i], domElement);\n              }\n              props = rawProps;\n              break;\n            case \"source\":\n              listenToNonDelegatedEvent(\"error\", domElement);\n              props = rawProps;\n              break;\n            case \"img\":\n            case \"image\":\n            case \"link\":\n              listenToNonDelegatedEvent(\"error\", domElement);\n              listenToNonDelegatedEvent(\"load\", domElement);\n              props = rawProps;\n              break;\n            case \"details\":\n              listenToNonDelegatedEvent(\"toggle\", domElement);\n              props = rawProps;\n              break;\n            case \"input\":\n              initWrapperState(domElement, rawProps);\n              props = getHostProps(domElement, rawProps);\n              listenToNonDelegatedEvent(\"invalid\", domElement);\n              break;\n            case \"option\":\n              validateProps(domElement, rawProps);\n              props = rawProps;\n              break;\n            case \"select\":\n              initWrapperState$1(domElement, rawProps);\n              props = getHostProps$1(domElement, rawProps);\n              listenToNonDelegatedEvent(\"invalid\", domElement);\n              break;\n            case \"textarea\":\n              initWrapperState$2(domElement, rawProps);\n              props = getHostProps$2(domElement, rawProps);\n              listenToNonDelegatedEvent(\"invalid\", domElement);\n              break;\n            default:\n              props = rawProps;\n          }\n          assertValidProps(tag, props);\n          setInitialDOMProperties(tag, domElement, rootContainerElement, props, isCustomComponentTag);\n          switch (tag) {\n            case \"input\":\n              track(domElement);\n              postMountWrapper(domElement, rawProps, false);\n              break;\n            case \"textarea\":\n              track(domElement);\n              postMountWrapper$3(domElement);\n              break;\n            case \"option\":\n              postMountWrapper$1(domElement, rawProps);\n              break;\n            case \"select\":\n              postMountWrapper$2(domElement, rawProps);\n              break;\n            default:\n              if (typeof props.onClick === \"function\") {\n                trapClickOnNonInteractiveElement(domElement);\n              }\n              break;\n          }\n        }\n        function diffProperties(domElement, tag, lastRawProps, nextRawProps, rootContainerElement) {\n          {\n            validatePropertiesInDevelopment(tag, nextRawProps);\n          }\n          var updatePayload = null;\n          var lastProps;\n          var nextProps;\n          switch (tag) {\n            case \"input\":\n              lastProps = getHostProps(domElement, lastRawProps);\n              nextProps = getHostProps(domElement, nextRawProps);\n              updatePayload = [];\n              break;\n            case \"select\":\n              lastProps = getHostProps$1(domElement, lastRawProps);\n              nextProps = getHostProps$1(domElement, nextRawProps);\n              updatePayload = [];\n              break;\n            case \"textarea\":\n              lastProps = getHostProps$2(domElement, lastRawProps);\n              nextProps = getHostProps$2(domElement, nextRawProps);\n              updatePayload = [];\n              break;\n            default:\n              lastProps = lastRawProps;\n              nextProps = nextRawProps;\n              if (typeof lastProps.onClick !== \"function\" && typeof nextProps.onClick === \"function\") {\n                trapClickOnNonInteractiveElement(domElement);\n              }\n              break;\n          }\n          assertValidProps(tag, nextProps);\n          var propKey;\n          var styleName;\n          var styleUpdates = null;\n          for (propKey in lastProps) {\n            if (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey) || lastProps[propKey] == null) {\n              continue;\n            }\n            if (propKey === STYLE) {\n              var lastStyle = lastProps[propKey];\n              for (styleName in lastStyle) {\n                if (lastStyle.hasOwnProperty(styleName)) {\n                  if (!styleUpdates) {\n                    styleUpdates = {};\n                  }\n                  styleUpdates[styleName] = \"\";\n                }\n              }\n            } else if (propKey === DANGEROUSLY_SET_INNER_HTML || propKey === CHILDREN)\n              ;\n            else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING)\n              ;\n            else if (propKey === AUTOFOCUS)\n              ;\n            else if (registrationNameDependencies.hasOwnProperty(propKey)) {\n              if (!updatePayload) {\n                updatePayload = [];\n              }\n            } else {\n              (updatePayload = updatePayload || []).push(propKey, null);\n            }\n          }\n          for (propKey in nextProps) {\n            var nextProp = nextProps[propKey];\n            var lastProp = lastProps != null ? lastProps[propKey] : void 0;\n            if (!nextProps.hasOwnProperty(propKey) || nextProp === lastProp || nextProp == null && lastProp == null) {\n              continue;\n            }\n            if (propKey === STYLE) {\n              {\n                if (nextProp) {\n                  Object.freeze(nextProp);\n                }\n              }\n              if (lastProp) {\n                for (styleName in lastProp) {\n                  if (lastProp.hasOwnProperty(styleName) && (!nextProp || !nextProp.hasOwnProperty(styleName))) {\n                    if (!styleUpdates) {\n                      styleUpdates = {};\n                    }\n                    styleUpdates[styleName] = \"\";\n                  }\n                }\n                for (styleName in nextProp) {\n                  if (nextProp.hasOwnProperty(styleName) && lastProp[styleName] !== nextProp[styleName]) {\n                    if (!styleUpdates) {\n                      styleUpdates = {};\n                    }\n                    styleUpdates[styleName] = nextProp[styleName];\n                  }\n                }\n              } else {\n                if (!styleUpdates) {\n                  if (!updatePayload) {\n                    updatePayload = [];\n                  }\n                  updatePayload.push(propKey, styleUpdates);\n                }\n                styleUpdates = nextProp;\n              }\n            } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {\n              var nextHtml = nextProp ? nextProp[HTML$1] : void 0;\n              var lastHtml = lastProp ? lastProp[HTML$1] : void 0;\n              if (nextHtml != null) {\n                if (lastHtml !== nextHtml) {\n                  (updatePayload = updatePayload || []).push(propKey, nextHtml);\n                }\n              }\n            } else if (propKey === CHILDREN) {\n              if (typeof nextProp === \"string\" || typeof nextProp === \"number\") {\n                (updatePayload = updatePayload || []).push(propKey, \"\" + nextProp);\n              }\n            } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING)\n              ;\n            else if (registrationNameDependencies.hasOwnProperty(propKey)) {\n              if (nextProp != null) {\n                if (typeof nextProp !== \"function\") {\n                  warnForInvalidEventListener(propKey, nextProp);\n                }\n                if (propKey === \"onScroll\") {\n                  listenToNonDelegatedEvent(\"scroll\", domElement);\n                }\n              }\n              if (!updatePayload && lastProp !== nextProp) {\n                updatePayload = [];\n              }\n            } else {\n              (updatePayload = updatePayload || []).push(propKey, nextProp);\n            }\n          }\n          if (styleUpdates) {\n            {\n              validateShorthandPropertyCollisionInDev(styleUpdates, nextProps[STYLE]);\n            }\n            (updatePayload = updatePayload || []).push(STYLE, styleUpdates);\n          }\n          return updatePayload;\n        }\n        function updateProperties(domElement, updatePayload, tag, lastRawProps, nextRawProps) {\n          if (tag === \"input\" && nextRawProps.type === \"radio\" && nextRawProps.name != null) {\n            updateChecked(domElement, nextRawProps);\n          }\n          var wasCustomComponentTag = isCustomComponent(tag, lastRawProps);\n          var isCustomComponentTag = isCustomComponent(tag, nextRawProps);\n          updateDOMProperties(domElement, updatePayload, wasCustomComponentTag, isCustomComponentTag);\n          switch (tag) {\n            case \"input\":\n              updateWrapper(domElement, nextRawProps);\n              break;\n            case \"textarea\":\n              updateWrapper$1(domElement, nextRawProps);\n              break;\n            case \"select\":\n              postUpdateWrapper(domElement, nextRawProps);\n              break;\n          }\n        }\n        function getPossibleStandardName(propName) {\n          {\n            var lowerCasedName = propName.toLowerCase();\n            if (!possibleStandardNames.hasOwnProperty(lowerCasedName)) {\n              return null;\n            }\n            return possibleStandardNames[lowerCasedName] || null;\n          }\n        }\n        function diffHydratedProperties(domElement, tag, rawProps, parentNamespace, rootContainerElement, isConcurrentMode, shouldWarnDev) {\n          var isCustomComponentTag;\n          var extraAttributeNames;\n          {\n            isCustomComponentTag = isCustomComponent(tag, rawProps);\n            validatePropertiesInDevelopment(tag, rawProps);\n          }\n          switch (tag) {\n            case \"dialog\":\n              listenToNonDelegatedEvent(\"cancel\", domElement);\n              listenToNonDelegatedEvent(\"close\", domElement);\n              break;\n            case \"iframe\":\n            case \"object\":\n            case \"embed\":\n              listenToNonDelegatedEvent(\"load\", domElement);\n              break;\n            case \"video\":\n            case \"audio\":\n              for (var i = 0; i < mediaEventTypes.length; i++) {\n                listenToNonDelegatedEvent(mediaEventTypes[i], domElement);\n              }\n              break;\n            case \"source\":\n              listenToNonDelegatedEvent(\"error\", domElement);\n              break;\n            case \"img\":\n            case \"image\":\n            case \"link\":\n              listenToNonDelegatedEvent(\"error\", domElement);\n              listenToNonDelegatedEvent(\"load\", domElement);\n              break;\n            case \"details\":\n              listenToNonDelegatedEvent(\"toggle\", domElement);\n              break;\n            case \"input\":\n              initWrapperState(domElement, rawProps);\n              listenToNonDelegatedEvent(\"invalid\", domElement);\n              break;\n            case \"option\":\n              validateProps(domElement, rawProps);\n              break;\n            case \"select\":\n              initWrapperState$1(domElement, rawProps);\n              listenToNonDelegatedEvent(\"invalid\", domElement);\n              break;\n            case \"textarea\":\n              initWrapperState$2(domElement, rawProps);\n              listenToNonDelegatedEvent(\"invalid\", domElement);\n              break;\n          }\n          assertValidProps(tag, rawProps);\n          {\n            extraAttributeNames = /* @__PURE__ */ new Set();\n            var attributes = domElement.attributes;\n            for (var _i = 0; _i < attributes.length; _i++) {\n              var name = attributes[_i].name.toLowerCase();\n              switch (name) {\n                case \"value\":\n                  break;\n                case \"checked\":\n                  break;\n                case \"selected\":\n                  break;\n                default:\n                  extraAttributeNames.add(attributes[_i].name);\n              }\n            }\n          }\n          var updatePayload = null;\n          for (var propKey in rawProps) {\n            if (!rawProps.hasOwnProperty(propKey)) {\n              continue;\n            }\n            var nextProp = rawProps[propKey];\n            if (propKey === CHILDREN) {\n              if (typeof nextProp === \"string\") {\n                if (domElement.textContent !== nextProp) {\n                  if (rawProps[SUPPRESS_HYDRATION_WARNING] !== true) {\n                    checkForUnmatchedText(domElement.textContent, nextProp, isConcurrentMode, shouldWarnDev);\n                  }\n                  updatePayload = [CHILDREN, nextProp];\n                }\n              } else if (typeof nextProp === \"number\") {\n                if (domElement.textContent !== \"\" + nextProp) {\n                  if (rawProps[SUPPRESS_HYDRATION_WARNING] !== true) {\n                    checkForUnmatchedText(domElement.textContent, nextProp, isConcurrentMode, shouldWarnDev);\n                  }\n                  updatePayload = [CHILDREN, \"\" + nextProp];\n                }\n              }\n            } else if (registrationNameDependencies.hasOwnProperty(propKey)) {\n              if (nextProp != null) {\n                if (typeof nextProp !== \"function\") {\n                  warnForInvalidEventListener(propKey, nextProp);\n                }\n                if (propKey === \"onScroll\") {\n                  listenToNonDelegatedEvent(\"scroll\", domElement);\n                }\n              }\n            } else if (shouldWarnDev && true && // Convince Flow we've calculated it (it's DEV-only in this method.)\n            typeof isCustomComponentTag === \"boolean\") {\n              var serverValue = void 0;\n              var propertyInfo = isCustomComponentTag && enableCustomElementPropertySupport ? null : getPropertyInfo(propKey);\n              if (rawProps[SUPPRESS_HYDRATION_WARNING] === true)\n                ;\n              else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING || // Controlled attributes are not validated\n              // TODO: Only ignore them on controlled tags.\n              propKey === \"value\" || propKey === \"checked\" || propKey === \"selected\")\n                ;\n              else if (propKey === DANGEROUSLY_SET_INNER_HTML) {\n                var serverHTML = domElement.innerHTML;\n                var nextHtml = nextProp ? nextProp[HTML$1] : void 0;\n                if (nextHtml != null) {\n                  var expectedHTML = normalizeHTML(domElement, nextHtml);\n                  if (expectedHTML !== serverHTML) {\n                    warnForPropDifference(propKey, serverHTML, expectedHTML);\n                  }\n                }\n              } else if (propKey === STYLE) {\n                extraAttributeNames.delete(propKey);\n                if (canDiffStyleForHydrationWarning) {\n                  var expectedStyle = createDangerousStringForStyles(nextProp);\n                  serverValue = domElement.getAttribute(\"style\");\n                  if (expectedStyle !== serverValue) {\n                    warnForPropDifference(propKey, serverValue, expectedStyle);\n                  }\n                }\n              } else if (isCustomComponentTag && !enableCustomElementPropertySupport) {\n                extraAttributeNames.delete(propKey.toLowerCase());\n                serverValue = getValueForAttribute(domElement, propKey, nextProp);\n                if (nextProp !== serverValue) {\n                  warnForPropDifference(propKey, serverValue, nextProp);\n                }\n              } else if (!shouldIgnoreAttribute(propKey, propertyInfo, isCustomComponentTag) && !shouldRemoveAttribute(propKey, nextProp, propertyInfo, isCustomComponentTag)) {\n                var isMismatchDueToBadCasing = false;\n                if (propertyInfo !== null) {\n                  extraAttributeNames.delete(propertyInfo.attributeName);\n                  serverValue = getValueForProperty(domElement, propKey, nextProp, propertyInfo);\n                } else {\n                  var ownNamespace = parentNamespace;\n                  if (ownNamespace === HTML_NAMESPACE) {\n                    ownNamespace = getIntrinsicNamespace(tag);\n                  }\n                  if (ownNamespace === HTML_NAMESPACE) {\n                    extraAttributeNames.delete(propKey.toLowerCase());\n                  } else {\n                    var standardName = getPossibleStandardName(propKey);\n                    if (standardName !== null && standardName !== propKey) {\n                      isMismatchDueToBadCasing = true;\n                      extraAttributeNames.delete(standardName);\n                    }\n                    extraAttributeNames.delete(propKey);\n                  }\n                  serverValue = getValueForAttribute(domElement, propKey, nextProp);\n                }\n                var dontWarnCustomElement = enableCustomElementPropertySupport;\n                if (!dontWarnCustomElement && nextProp !== serverValue && !isMismatchDueToBadCasing) {\n                  warnForPropDifference(propKey, serverValue, nextProp);\n                }\n              }\n            }\n          }\n          {\n            if (shouldWarnDev) {\n              if (\n                // $FlowFixMe - Should be inferred as not undefined.\n                extraAttributeNames.size > 0 && rawProps[SUPPRESS_HYDRATION_WARNING] !== true\n              ) {\n                warnForExtraAttributes(extraAttributeNames);\n              }\n            }\n          }\n          switch (tag) {\n            case \"input\":\n              track(domElement);\n              postMountWrapper(domElement, rawProps, true);\n              break;\n            case \"textarea\":\n              track(domElement);\n              postMountWrapper$3(domElement);\n              break;\n            case \"select\":\n            case \"option\":\n              break;\n            default:\n              if (typeof rawProps.onClick === \"function\") {\n                trapClickOnNonInteractiveElement(domElement);\n              }\n              break;\n          }\n          return updatePayload;\n        }\n        function diffHydratedText(textNode, text, isConcurrentMode) {\n          var isDifferent = textNode.nodeValue !== text;\n          return isDifferent;\n        }\n        function warnForDeletedHydratableElement(parentNode, child) {\n          {\n            if (didWarnInvalidHydration) {\n              return;\n            }\n            didWarnInvalidHydration = true;\n            error(\"Did not expect server HTML to contain a <%s> in <%s>.\", child.nodeName.toLowerCase(), parentNode.nodeName.toLowerCase());\n          }\n        }\n        function warnForDeletedHydratableText(parentNode, child) {\n          {\n            if (didWarnInvalidHydration) {\n              return;\n            }\n            didWarnInvalidHydration = true;\n            error('Did not expect server HTML to contain the text node \"%s\" in <%s>.', child.nodeValue, parentNode.nodeName.toLowerCase());\n          }\n        }\n        function warnForInsertedHydratedElement(parentNode, tag, props) {\n          {\n            if (didWarnInvalidHydration) {\n              return;\n            }\n            didWarnInvalidHydration = true;\n            error(\"Expected server HTML to contain a matching <%s> in <%s>.\", tag, parentNode.nodeName.toLowerCase());\n          }\n        }\n        function warnForInsertedHydratedText(parentNode, text) {\n          {\n            if (text === \"\") {\n              return;\n            }\n            if (didWarnInvalidHydration) {\n              return;\n            }\n            didWarnInvalidHydration = true;\n            error('Expected server HTML to contain a matching text node for \"%s\" in <%s>.', text, parentNode.nodeName.toLowerCase());\n          }\n        }\n        function restoreControlledState$3(domElement, tag, props) {\n          switch (tag) {\n            case \"input\":\n              restoreControlledState(domElement, props);\n              return;\n            case \"textarea\":\n              restoreControlledState$2(domElement, props);\n              return;\n            case \"select\":\n              restoreControlledState$1(domElement, props);\n              return;\n          }\n        }\n        var validateDOMNesting = function() {\n        };\n        var updatedAncestorInfo = function() {\n        };\n        {\n          var specialTags = [\"address\", \"applet\", \"area\", \"article\", \"aside\", \"base\", \"basefont\", \"bgsound\", \"blockquote\", \"body\", \"br\", \"button\", \"caption\", \"center\", \"col\", \"colgroup\", \"dd\", \"details\", \"dir\", \"div\", \"dl\", \"dt\", \"embed\", \"fieldset\", \"figcaption\", \"figure\", \"footer\", \"form\", \"frame\", \"frameset\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"head\", \"header\", \"hgroup\", \"hr\", \"html\", \"iframe\", \"img\", \"input\", \"isindex\", \"li\", \"link\", \"listing\", \"main\", \"marquee\", \"menu\", \"menuitem\", \"meta\", \"nav\", \"noembed\", \"noframes\", \"noscript\", \"object\", \"ol\", \"p\", \"param\", \"plaintext\", \"pre\", \"script\", \"section\", \"select\", \"source\", \"style\", \"summary\", \"table\", \"tbody\", \"td\", \"template\", \"textarea\", \"tfoot\", \"th\", \"thead\", \"title\", \"tr\", \"track\", \"ul\", \"wbr\", \"xmp\"];\n          var inScopeTags = [\n            \"applet\",\n            \"caption\",\n            \"html\",\n            \"table\",\n            \"td\",\n            \"th\",\n            \"marquee\",\n            \"object\",\n            \"template\",\n            // https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point\n            // TODO: Distinguish by namespace here -- for <title>, including it here\n            // errs on the side of fewer warnings\n            \"foreignObject\",\n            \"desc\",\n            \"title\"\n          ];\n          var buttonScopeTags = inScopeTags.concat([\"button\"]);\n          var impliedEndTags = [\"dd\", \"dt\", \"li\", \"option\", \"optgroup\", \"p\", \"rp\", \"rt\"];\n          var emptyAncestorInfo = {\n            current: null,\n            formTag: null,\n            aTagInScope: null,\n            buttonTagInScope: null,\n            nobrTagInScope: null,\n            pTagInButtonScope: null,\n            listItemTagAutoclosing: null,\n            dlItemTagAutoclosing: null\n          };\n          updatedAncestorInfo = function(oldInfo, tag) {\n            var ancestorInfo = assign({}, oldInfo || emptyAncestorInfo);\n            var info = {\n              tag\n            };\n            if (inScopeTags.indexOf(tag) !== -1) {\n              ancestorInfo.aTagInScope = null;\n              ancestorInfo.buttonTagInScope = null;\n              ancestorInfo.nobrTagInScope = null;\n            }\n            if (buttonScopeTags.indexOf(tag) !== -1) {\n              ancestorInfo.pTagInButtonScope = null;\n            }\n            if (specialTags.indexOf(tag) !== -1 && tag !== \"address\" && tag !== \"div\" && tag !== \"p\") {\n              ancestorInfo.listItemTagAutoclosing = null;\n              ancestorInfo.dlItemTagAutoclosing = null;\n            }\n            ancestorInfo.current = info;\n            if (tag === \"form\") {\n              ancestorInfo.formTag = info;\n            }\n            if (tag === \"a\") {\n              ancestorInfo.aTagInScope = info;\n            }\n            if (tag === \"button\") {\n              ancestorInfo.buttonTagInScope = info;\n            }\n            if (tag === \"nobr\") {\n              ancestorInfo.nobrTagInScope = info;\n            }\n            if (tag === \"p\") {\n              ancestorInfo.pTagInButtonScope = info;\n            }\n            if (tag === \"li\") {\n              ancestorInfo.listItemTagAutoclosing = info;\n            }\n            if (tag === \"dd\" || tag === \"dt\") {\n              ancestorInfo.dlItemTagAutoclosing = info;\n            }\n            return ancestorInfo;\n          };\n          var isTagValidWithParent = function(tag, parentTag) {\n            switch (parentTag) {\n              case \"select\":\n                return tag === \"option\" || tag === \"optgroup\" || tag === \"#text\";\n              case \"optgroup\":\n                return tag === \"option\" || tag === \"#text\";\n              case \"option\":\n                return tag === \"#text\";\n              case \"tr\":\n                return tag === \"th\" || tag === \"td\" || tag === \"style\" || tag === \"script\" || tag === \"template\";\n              case \"tbody\":\n              case \"thead\":\n              case \"tfoot\":\n                return tag === \"tr\" || tag === \"style\" || tag === \"script\" || tag === \"template\";\n              case \"colgroup\":\n                return tag === \"col\" || tag === \"template\";\n              case \"table\":\n                return tag === \"caption\" || tag === \"colgroup\" || tag === \"tbody\" || tag === \"tfoot\" || tag === \"thead\" || tag === \"style\" || tag === \"script\" || tag === \"template\";\n              case \"head\":\n                return tag === \"base\" || tag === \"basefont\" || tag === \"bgsound\" || tag === \"link\" || tag === \"meta\" || tag === \"title\" || tag === \"noscript\" || tag === \"noframes\" || tag === \"style\" || tag === \"script\" || tag === \"template\";\n              case \"html\":\n                return tag === \"head\" || tag === \"body\" || tag === \"frameset\";\n              case \"frameset\":\n                return tag === \"frame\";\n              case \"#document\":\n                return tag === \"html\";\n            }\n            switch (tag) {\n              case \"h1\":\n              case \"h2\":\n              case \"h3\":\n              case \"h4\":\n              case \"h5\":\n              case \"h6\":\n                return parentTag !== \"h1\" && parentTag !== \"h2\" && parentTag !== \"h3\" && parentTag !== \"h4\" && parentTag !== \"h5\" && parentTag !== \"h6\";\n              case \"rp\":\n              case \"rt\":\n                return impliedEndTags.indexOf(parentTag) === -1;\n              case \"body\":\n              case \"caption\":\n              case \"col\":\n              case \"colgroup\":\n              case \"frameset\":\n              case \"frame\":\n              case \"head\":\n              case \"html\":\n              case \"tbody\":\n              case \"td\":\n              case \"tfoot\":\n              case \"th\":\n              case \"thead\":\n              case \"tr\":\n                return parentTag == null;\n            }\n            return true;\n          };\n          var findInvalidAncestorForTag = function(tag, ancestorInfo) {\n            switch (tag) {\n              case \"address\":\n              case \"article\":\n              case \"aside\":\n              case \"blockquote\":\n              case \"center\":\n              case \"details\":\n              case \"dialog\":\n              case \"dir\":\n              case \"div\":\n              case \"dl\":\n              case \"fieldset\":\n              case \"figcaption\":\n              case \"figure\":\n              case \"footer\":\n              case \"header\":\n              case \"hgroup\":\n              case \"main\":\n              case \"menu\":\n              case \"nav\":\n              case \"ol\":\n              case \"p\":\n              case \"section\":\n              case \"summary\":\n              case \"ul\":\n              case \"pre\":\n              case \"listing\":\n              case \"table\":\n              case \"hr\":\n              case \"xmp\":\n              case \"h1\":\n              case \"h2\":\n              case \"h3\":\n              case \"h4\":\n              case \"h5\":\n              case \"h6\":\n                return ancestorInfo.pTagInButtonScope;\n              case \"form\":\n                return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;\n              case \"li\":\n                return ancestorInfo.listItemTagAutoclosing;\n              case \"dd\":\n              case \"dt\":\n                return ancestorInfo.dlItemTagAutoclosing;\n              case \"button\":\n                return ancestorInfo.buttonTagInScope;\n              case \"a\":\n                return ancestorInfo.aTagInScope;\n              case \"nobr\":\n                return ancestorInfo.nobrTagInScope;\n            }\n            return null;\n          };\n          var didWarn$1 = {};\n          validateDOMNesting = function(childTag, childText, ancestorInfo) {\n            ancestorInfo = ancestorInfo || emptyAncestorInfo;\n            var parentInfo = ancestorInfo.current;\n            var parentTag = parentInfo && parentInfo.tag;\n            if (childText != null) {\n              if (childTag != null) {\n                error(\"validateDOMNesting: when childText is passed, childTag should be null\");\n              }\n              childTag = \"#text\";\n            }\n            var invalidParent = isTagValidWithParent(childTag, parentTag) ? null : parentInfo;\n            var invalidAncestor = invalidParent ? null : findInvalidAncestorForTag(childTag, ancestorInfo);\n            var invalidParentOrAncestor = invalidParent || invalidAncestor;\n            if (!invalidParentOrAncestor) {\n              return;\n            }\n            var ancestorTag = invalidParentOrAncestor.tag;\n            var warnKey = !!invalidParent + \"|\" + childTag + \"|\" + ancestorTag;\n            if (didWarn$1[warnKey]) {\n              return;\n            }\n            didWarn$1[warnKey] = true;\n            var tagDisplayName = childTag;\n            var whitespaceInfo = \"\";\n            if (childTag === \"#text\") {\n              if (/\\S/.test(childText)) {\n                tagDisplayName = \"Text nodes\";\n              } else {\n                tagDisplayName = \"Whitespace text nodes\";\n                whitespaceInfo = \" Make sure you don't have any extra whitespace between tags on each line of your source code.\";\n              }\n            } else {\n              tagDisplayName = \"<\" + childTag + \">\";\n            }\n            if (invalidParent) {\n              var info = \"\";\n              if (ancestorTag === \"table\" && childTag === \"tr\") {\n                info += \" Add a <tbody>, <thead> or <tfoot> to your code to match the DOM tree generated by the browser.\";\n              }\n              error(\"validateDOMNesting(...): %s cannot appear as a child of <%s>.%s%s\", tagDisplayName, ancestorTag, whitespaceInfo, info);\n            } else {\n              error(\"validateDOMNesting(...): %s cannot appear as a descendant of <%s>.\", tagDisplayName, ancestorTag);\n            }\n          };\n        }\n        var SUPPRESS_HYDRATION_WARNING$1 = \"suppressHydrationWarning\";\n        var SUSPENSE_START_DATA = \"$\";\n        var SUSPENSE_END_DATA = \"/$\";\n        var SUSPENSE_PENDING_START_DATA = \"$?\";\n        var SUSPENSE_FALLBACK_START_DATA = \"$!\";\n        var STYLE$1 = \"style\";\n        var eventsEnabled = null;\n        var selectionInformation = null;\n        function getRootHostContext(rootContainerInstance) {\n          var type;\n          var namespace;\n          var nodeType = rootContainerInstance.nodeType;\n          switch (nodeType) {\n            case DOCUMENT_NODE:\n            case DOCUMENT_FRAGMENT_NODE: {\n              type = nodeType === DOCUMENT_NODE ? \"#document\" : \"#fragment\";\n              var root2 = rootContainerInstance.documentElement;\n              namespace = root2 ? root2.namespaceURI : getChildNamespace(null, \"\");\n              break;\n            }\n            default: {\n              var container = nodeType === COMMENT_NODE ? rootContainerInstance.parentNode : rootContainerInstance;\n              var ownNamespace = container.namespaceURI || null;\n              type = container.tagName;\n              namespace = getChildNamespace(ownNamespace, type);\n              break;\n            }\n          }\n          {\n            var validatedTag = type.toLowerCase();\n            var ancestorInfo = updatedAncestorInfo(null, validatedTag);\n            return {\n              namespace,\n              ancestorInfo\n            };\n          }\n        }\n        function getChildHostContext(parentHostContext, type, rootContainerInstance) {\n          {\n            var parentHostContextDev = parentHostContext;\n            var namespace = getChildNamespace(parentHostContextDev.namespace, type);\n            var ancestorInfo = updatedAncestorInfo(parentHostContextDev.ancestorInfo, type);\n            return {\n              namespace,\n              ancestorInfo\n            };\n          }\n        }\n        function getPublicInstance(instance) {\n          return instance;\n        }\n        function prepareForCommit(containerInfo) {\n          eventsEnabled = isEnabled();\n          selectionInformation = getSelectionInformation();\n          var activeInstance = null;\n          setEnabled(false);\n          return activeInstance;\n        }\n        function resetAfterCommit(containerInfo) {\n          restoreSelection(selectionInformation);\n          setEnabled(eventsEnabled);\n          eventsEnabled = null;\n          selectionInformation = null;\n        }\n        function createInstance(type, props, rootContainerInstance, hostContext, internalInstanceHandle) {\n          var parentNamespace;\n          {\n            var hostContextDev = hostContext;\n            validateDOMNesting(type, null, hostContextDev.ancestorInfo);\n            if (typeof props.children === \"string\" || typeof props.children === \"number\") {\n              var string = \"\" + props.children;\n              var ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type);\n              validateDOMNesting(null, string, ownAncestorInfo);\n            }\n            parentNamespace = hostContextDev.namespace;\n          }\n          var domElement = createElement(type, props, rootContainerInstance, parentNamespace);\n          precacheFiberNode(internalInstanceHandle, domElement);\n          updateFiberProps(domElement, props);\n          return domElement;\n        }\n        function appendInitialChild(parentInstance, child) {\n          parentInstance.appendChild(child);\n        }\n        function finalizeInitialChildren(domElement, type, props, rootContainerInstance, hostContext) {\n          setInitialProperties(domElement, type, props, rootContainerInstance);\n          switch (type) {\n            case \"button\":\n            case \"input\":\n            case \"select\":\n            case \"textarea\":\n              return !!props.autoFocus;\n            case \"img\":\n              return true;\n            default:\n              return false;\n          }\n        }\n        function prepareUpdate(domElement, type, oldProps, newProps, rootContainerInstance, hostContext) {\n          {\n            var hostContextDev = hostContext;\n            if (typeof newProps.children !== typeof oldProps.children && (typeof newProps.children === \"string\" || typeof newProps.children === \"number\")) {\n              var string = \"\" + newProps.children;\n              var ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type);\n              validateDOMNesting(null, string, ownAncestorInfo);\n            }\n          }\n          return diffProperties(domElement, type, oldProps, newProps);\n        }\n        function shouldSetTextContent(type, props) {\n          return type === \"textarea\" || type === \"noscript\" || typeof props.children === \"string\" || typeof props.children === \"number\" || typeof props.dangerouslySetInnerHTML === \"object\" && props.dangerouslySetInnerHTML !== null && props.dangerouslySetInnerHTML.__html != null;\n        }\n        function createTextInstance(text, rootContainerInstance, hostContext, internalInstanceHandle) {\n          {\n            var hostContextDev = hostContext;\n            validateDOMNesting(null, text, hostContextDev.ancestorInfo);\n          }\n          var textNode = createTextNode(text, rootContainerInstance);\n          precacheFiberNode(internalInstanceHandle, textNode);\n          return textNode;\n        }\n        function getCurrentEventPriority() {\n          var currentEvent = window.event;\n          if (currentEvent === void 0) {\n            return DefaultEventPriority;\n          }\n          return getEventPriority(currentEvent.type);\n        }\n        var scheduleTimeout = typeof setTimeout === \"function\" ? setTimeout : void 0;\n        var cancelTimeout = typeof clearTimeout === \"function\" ? clearTimeout : void 0;\n        var noTimeout = -1;\n        var localPromise = typeof Promise === \"function\" ? Promise : void 0;\n        var scheduleMicrotask = typeof queueMicrotask === \"function\" ? queueMicrotask : typeof localPromise !== \"undefined\" ? function(callback) {\n          return localPromise.resolve(null).then(callback).catch(handleErrorInNextTick);\n        } : scheduleTimeout;\n        function handleErrorInNextTick(error2) {\n          setTimeout(function() {\n            throw error2;\n          });\n        }\n        function commitMount(domElement, type, newProps, internalInstanceHandle) {\n          switch (type) {\n            case \"button\":\n            case \"input\":\n            case \"select\":\n            case \"textarea\":\n              if (newProps.autoFocus) {\n                domElement.focus();\n              }\n              return;\n            case \"img\": {\n              if (newProps.src) {\n                domElement.src = newProps.src;\n              }\n              return;\n            }\n          }\n        }\n        function commitUpdate(domElement, updatePayload, type, oldProps, newProps, internalInstanceHandle) {\n          updateProperties(domElement, updatePayload, type, oldProps, newProps);\n          updateFiberProps(domElement, newProps);\n        }\n        function resetTextContent(domElement) {\n          setTextContent(domElement, \"\");\n        }\n        function commitTextUpdate(textInstance, oldText, newText) {\n          textInstance.nodeValue = newText;\n        }\n        function appendChild(parentInstance, child) {\n          parentInstance.appendChild(child);\n        }\n        function appendChildToContainer(container, child) {\n          var parentNode;\n          if (container.nodeType === COMMENT_NODE) {\n            parentNode = container.parentNode;\n            parentNode.insertBefore(child, container);\n          } else {\n            parentNode = container;\n            parentNode.appendChild(child);\n          }\n          var reactRootContainer = container._reactRootContainer;\n          if ((reactRootContainer === null || reactRootContainer === void 0) && parentNode.onclick === null) {\n            trapClickOnNonInteractiveElement(parentNode);\n          }\n        }\n        function insertBefore(parentInstance, child, beforeChild) {\n          parentInstance.insertBefore(child, beforeChild);\n        }\n        function insertInContainerBefore(container, child, beforeChild) {\n          if (container.nodeType === COMMENT_NODE) {\n            container.parentNode.insertBefore(child, beforeChild);\n          } else {\n            container.insertBefore(child, beforeChild);\n          }\n        }\n        function removeChild(parentInstance, child) {\n          parentInstance.removeChild(child);\n        }\n        function removeChildFromContainer(container, child) {\n          if (container.nodeType === COMMENT_NODE) {\n            container.parentNode.removeChild(child);\n          } else {\n            container.removeChild(child);\n          }\n        }\n        function clearSuspenseBoundary(parentInstance, suspenseInstance) {\n          var node = suspenseInstance;\n          var depth = 0;\n          do {\n            var nextNode = node.nextSibling;\n            parentInstance.removeChild(node);\n            if (nextNode && nextNode.nodeType === COMMENT_NODE) {\n              var data = nextNode.data;\n              if (data === SUSPENSE_END_DATA) {\n                if (depth === 0) {\n                  parentInstance.removeChild(nextNode);\n                  retryIfBlockedOn(suspenseInstance);\n                  return;\n                } else {\n                  depth--;\n                }\n              } else if (data === SUSPENSE_START_DATA || data === SUSPENSE_PENDING_START_DATA || data === SUSPENSE_FALLBACK_START_DATA) {\n                depth++;\n              }\n            }\n            node = nextNode;\n          } while (node);\n          retryIfBlockedOn(suspenseInstance);\n        }\n        function clearSuspenseBoundaryFromContainer(container, suspenseInstance) {\n          if (container.nodeType === COMMENT_NODE) {\n            clearSuspenseBoundary(container.parentNode, suspenseInstance);\n          } else if (container.nodeType === ELEMENT_NODE) {\n            clearSuspenseBoundary(container, suspenseInstance);\n          }\n          retryIfBlockedOn(container);\n        }\n        function hideInstance(instance) {\n          instance = instance;\n          var style2 = instance.style;\n          if (typeof style2.setProperty === \"function\") {\n            style2.setProperty(\"display\", \"none\", \"important\");\n          } else {\n            style2.display = \"none\";\n          }\n        }\n        function hideTextInstance(textInstance) {\n          textInstance.nodeValue = \"\";\n        }\n        function unhideInstance(instance, props) {\n          instance = instance;\n          var styleProp = props[STYLE$1];\n          var display = styleProp !== void 0 && styleProp !== null && styleProp.hasOwnProperty(\"display\") ? styleProp.display : null;\n          instance.style.display = dangerousStyleValue(\"display\", display);\n        }\n        function unhideTextInstance(textInstance, text) {\n          textInstance.nodeValue = text;\n        }\n        function clearContainer(container) {\n          if (container.nodeType === ELEMENT_NODE) {\n            container.textContent = \"\";\n          } else if (container.nodeType === DOCUMENT_NODE) {\n            if (container.documentElement) {\n              container.removeChild(container.documentElement);\n            }\n          }\n        }\n        function canHydrateInstance(instance, type, props) {\n          if (instance.nodeType !== ELEMENT_NODE || type.toLowerCase() !== instance.nodeName.toLowerCase()) {\n            return null;\n          }\n          return instance;\n        }\n        function canHydrateTextInstance(instance, text) {\n          if (text === \"\" || instance.nodeType !== TEXT_NODE) {\n            return null;\n          }\n          return instance;\n        }\n        function canHydrateSuspenseInstance(instance) {\n          if (instance.nodeType !== COMMENT_NODE) {\n            return null;\n          }\n          return instance;\n        }\n        function isSuspenseInstancePending(instance) {\n          return instance.data === SUSPENSE_PENDING_START_DATA;\n        }\n        function isSuspenseInstanceFallback(instance) {\n          return instance.data === SUSPENSE_FALLBACK_START_DATA;\n        }\n        function getSuspenseInstanceFallbackErrorDetails(instance) {\n          var dataset = instance.nextSibling && instance.nextSibling.dataset;\n          var digest, message, stack;\n          if (dataset) {\n            digest = dataset.dgst;\n            {\n              message = dataset.msg;\n              stack = dataset.stck;\n            }\n          }\n          {\n            return {\n              message,\n              digest,\n              stack\n            };\n          }\n        }\n        function registerSuspenseInstanceRetry(instance, callback) {\n          instance._reactRetry = callback;\n        }\n        function getNextHydratable(node) {\n          for (; node != null; node = node.nextSibling) {\n            var nodeType = node.nodeType;\n            if (nodeType === ELEMENT_NODE || nodeType === TEXT_NODE) {\n              break;\n            }\n            if (nodeType === COMMENT_NODE) {\n              var nodeData = node.data;\n              if (nodeData === SUSPENSE_START_DATA || nodeData === SUSPENSE_FALLBACK_START_DATA || nodeData === SUSPENSE_PENDING_START_DATA) {\n                break;\n              }\n              if (nodeData === SUSPENSE_END_DATA) {\n                return null;\n              }\n            }\n          }\n          return node;\n        }\n        function getNextHydratableSibling(instance) {\n          return getNextHydratable(instance.nextSibling);\n        }\n        function getFirstHydratableChild(parentInstance) {\n          return getNextHydratable(parentInstance.firstChild);\n        }\n        function getFirstHydratableChildWithinContainer(parentContainer) {\n          return getNextHydratable(parentContainer.firstChild);\n        }\n        function getFirstHydratableChildWithinSuspenseInstance(parentInstance) {\n          return getNextHydratable(parentInstance.nextSibling);\n        }\n        function hydrateInstance(instance, type, props, rootContainerInstance, hostContext, internalInstanceHandle, shouldWarnDev) {\n          precacheFiberNode(internalInstanceHandle, instance);\n          updateFiberProps(instance, props);\n          var parentNamespace;\n          {\n            var hostContextDev = hostContext;\n            parentNamespace = hostContextDev.namespace;\n          }\n          var isConcurrentMode = (internalInstanceHandle.mode & ConcurrentMode) !== NoMode;\n          return diffHydratedProperties(instance, type, props, parentNamespace, rootContainerInstance, isConcurrentMode, shouldWarnDev);\n        }\n        function hydrateTextInstance(textInstance, text, internalInstanceHandle, shouldWarnDev) {\n          precacheFiberNode(internalInstanceHandle, textInstance);\n          var isConcurrentMode = (internalInstanceHandle.mode & ConcurrentMode) !== NoMode;\n          return diffHydratedText(textInstance, text);\n        }\n        function hydrateSuspenseInstance(suspenseInstance, internalInstanceHandle) {\n          precacheFiberNode(internalInstanceHandle, suspenseInstance);\n        }\n        function getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance) {\n          var node = suspenseInstance.nextSibling;\n          var depth = 0;\n          while (node) {\n            if (node.nodeType === COMMENT_NODE) {\n              var data = node.data;\n              if (data === SUSPENSE_END_DATA) {\n                if (depth === 0) {\n                  return getNextHydratableSibling(node);\n                } else {\n                  depth--;\n                }\n              } else if (data === SUSPENSE_START_DATA || data === SUSPENSE_FALLBACK_START_DATA || data === SUSPENSE_PENDING_START_DATA) {\n                depth++;\n              }\n            }\n            node = node.nextSibling;\n          }\n          return null;\n        }\n        function getParentSuspenseInstance(targetInstance) {\n          var node = targetInstance.previousSibling;\n          var depth = 0;\n          while (node) {\n            if (node.nodeType === COMMENT_NODE) {\n              var data = node.data;\n              if (data === SUSPENSE_START_DATA || data === SUSPENSE_FALLBACK_START_DATA || data === SUSPENSE_PENDING_START_DATA) {\n                if (depth === 0) {\n                  return node;\n                } else {\n                  depth--;\n                }\n              } else if (data === SUSPENSE_END_DATA) {\n                depth++;\n              }\n            }\n            node = node.previousSibling;\n          }\n          return null;\n        }\n        function commitHydratedContainer(container) {\n          retryIfBlockedOn(container);\n        }\n        function commitHydratedSuspenseInstance(suspenseInstance) {\n          retryIfBlockedOn(suspenseInstance);\n        }\n        function shouldDeleteUnhydratedTailInstances(parentType) {\n          return parentType !== \"head\" && parentType !== \"body\";\n        }\n        function didNotMatchHydratedContainerTextInstance(parentContainer, textInstance, text, isConcurrentMode) {\n          var shouldWarnDev = true;\n          checkForUnmatchedText(textInstance.nodeValue, text, isConcurrentMode, shouldWarnDev);\n        }\n        function didNotMatchHydratedTextInstance(parentType, parentProps, parentInstance, textInstance, text, isConcurrentMode) {\n          if (parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) {\n            var shouldWarnDev = true;\n            checkForUnmatchedText(textInstance.nodeValue, text, isConcurrentMode, shouldWarnDev);\n          }\n        }\n        function didNotHydrateInstanceWithinContainer(parentContainer, instance) {\n          {\n            if (instance.nodeType === ELEMENT_NODE) {\n              warnForDeletedHydratableElement(parentContainer, instance);\n            } else if (instance.nodeType === COMMENT_NODE)\n              ;\n            else {\n              warnForDeletedHydratableText(parentContainer, instance);\n            }\n          }\n        }\n        function didNotHydrateInstanceWithinSuspenseInstance(parentInstance, instance) {\n          {\n            var parentNode = parentInstance.parentNode;\n            if (parentNode !== null) {\n              if (instance.nodeType === ELEMENT_NODE) {\n                warnForDeletedHydratableElement(parentNode, instance);\n              } else if (instance.nodeType === COMMENT_NODE)\n                ;\n              else {\n                warnForDeletedHydratableText(parentNode, instance);\n              }\n            }\n          }\n        }\n        function didNotHydrateInstance(parentType, parentProps, parentInstance, instance, isConcurrentMode) {\n          {\n            if (isConcurrentMode || parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) {\n              if (instance.nodeType === ELEMENT_NODE) {\n                warnForDeletedHydratableElement(parentInstance, instance);\n              } else if (instance.nodeType === COMMENT_NODE)\n                ;\n              else {\n                warnForDeletedHydratableText(parentInstance, instance);\n              }\n            }\n          }\n        }\n        function didNotFindHydratableInstanceWithinContainer(parentContainer, type, props) {\n          {\n            warnForInsertedHydratedElement(parentContainer, type);\n          }\n        }\n        function didNotFindHydratableTextInstanceWithinContainer(parentContainer, text) {\n          {\n            warnForInsertedHydratedText(parentContainer, text);\n          }\n        }\n        function didNotFindHydratableInstanceWithinSuspenseInstance(parentInstance, type, props) {\n          {\n            var parentNode = parentInstance.parentNode;\n            if (parentNode !== null)\n              warnForInsertedHydratedElement(parentNode, type);\n          }\n        }\n        function didNotFindHydratableTextInstanceWithinSuspenseInstance(parentInstance, text) {\n          {\n            var parentNode = parentInstance.parentNode;\n            if (parentNode !== null)\n              warnForInsertedHydratedText(parentNode, text);\n          }\n        }\n        function didNotFindHydratableInstance(parentType, parentProps, parentInstance, type, props, isConcurrentMode) {\n          {\n            if (isConcurrentMode || parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) {\n              warnForInsertedHydratedElement(parentInstance, type);\n            }\n          }\n        }\n        function didNotFindHydratableTextInstance(parentType, parentProps, parentInstance, text, isConcurrentMode) {\n          {\n            if (isConcurrentMode || parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) {\n              warnForInsertedHydratedText(parentInstance, text);\n            }\n          }\n        }\n        function errorHydratingContainer(parentContainer) {\n          {\n            error(\"An error occurred during hydration. The server HTML was replaced with client content in <%s>.\", parentContainer.nodeName.toLowerCase());\n          }\n        }\n        function preparePortalMount(portalInstance) {\n          listenToAllSupportedEvents(portalInstance);\n        }\n        var randomKey = Math.random().toString(36).slice(2);\n        var internalInstanceKey = \"__reactFiber$\" + randomKey;\n        var internalPropsKey = \"__reactProps$\" + randomKey;\n        var internalContainerInstanceKey = \"__reactContainer$\" + randomKey;\n        var internalEventHandlersKey = \"__reactEvents$\" + randomKey;\n        var internalEventHandlerListenersKey = \"__reactListeners$\" + randomKey;\n        var internalEventHandlesSetKey = \"__reactHandles$\" + randomKey;\n        function detachDeletedInstance(node) {\n          delete node[internalInstanceKey];\n          delete node[internalPropsKey];\n          delete node[internalEventHandlersKey];\n          delete node[internalEventHandlerListenersKey];\n          delete node[internalEventHandlesSetKey];\n        }\n        function precacheFiberNode(hostInst, node) {\n          node[internalInstanceKey] = hostInst;\n        }\n        function markContainerAsRoot(hostRoot, node) {\n          node[internalContainerInstanceKey] = hostRoot;\n        }\n        function unmarkContainerAsRoot(node) {\n          node[internalContainerInstanceKey] = null;\n        }\n        function isContainerMarkedAsRoot(node) {\n          return !!node[internalContainerInstanceKey];\n        }\n        function getClosestInstanceFromNode(targetNode) {\n          var targetInst = targetNode[internalInstanceKey];\n          if (targetInst) {\n            return targetInst;\n          }\n          var parentNode = targetNode.parentNode;\n          while (parentNode) {\n            targetInst = parentNode[internalContainerInstanceKey] || parentNode[internalInstanceKey];\n            if (targetInst) {\n              var alternate = targetInst.alternate;\n              if (targetInst.child !== null || alternate !== null && alternate.child !== null) {\n                var suspenseInstance = getParentSuspenseInstance(targetNode);\n                while (suspenseInstance !== null) {\n                  var targetSuspenseInst = suspenseInstance[internalInstanceKey];\n                  if (targetSuspenseInst) {\n                    return targetSuspenseInst;\n                  }\n                  suspenseInstance = getParentSuspenseInstance(suspenseInstance);\n                }\n              }\n              return targetInst;\n            }\n            targetNode = parentNode;\n            parentNode = targetNode.parentNode;\n          }\n          return null;\n        }\n        function getInstanceFromNode(node) {\n          var inst = node[internalInstanceKey] || node[internalContainerInstanceKey];\n          if (inst) {\n            if (inst.tag === HostComponent || inst.tag === HostText || inst.tag === SuspenseComponent || inst.tag === HostRoot) {\n              return inst;\n            } else {\n              return null;\n            }\n          }\n          return null;\n        }\n        function getNodeFromInstance(inst) {\n          if (inst.tag === HostComponent || inst.tag === HostText) {\n            return inst.stateNode;\n          }\n          throw new Error(\"getNodeFromInstance: Invalid argument.\");\n        }\n        function getFiberCurrentPropsFromNode(node) {\n          return node[internalPropsKey] || null;\n        }\n        function updateFiberProps(node, props) {\n          node[internalPropsKey] = props;\n        }\n        function getEventListenerSet(node) {\n          var elementListenerSet = node[internalEventHandlersKey];\n          if (elementListenerSet === void 0) {\n            elementListenerSet = node[internalEventHandlersKey] = /* @__PURE__ */ new Set();\n          }\n          return elementListenerSet;\n        }\n        var loggedTypeFailures = {};\n        var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;\n        function setCurrentlyValidatingElement(element) {\n          {\n            if (element) {\n              var owner = element._owner;\n              var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n              ReactDebugCurrentFrame$1.setExtraStackFrame(stack);\n            } else {\n              ReactDebugCurrentFrame$1.setExtraStackFrame(null);\n            }\n          }\n        }\n        function checkPropTypes(typeSpecs, values, location, componentName, element) {\n          {\n            var has2 = Function.call.bind(hasOwnProperty);\n            for (var typeSpecName in typeSpecs) {\n              if (has2(typeSpecs, typeSpecName)) {\n                var error$1 = void 0;\n                try {\n                  if (typeof typeSpecs[typeSpecName] !== \"function\") {\n                    var err = Error((componentName || \"React class\") + \": \" + location + \" type `\" + typeSpecName + \"` is invalid; it must be a function, usually from the `prop-types` package, but received `\" + typeof typeSpecs[typeSpecName] + \"`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.\");\n                    err.name = \"Invariant Violation\";\n                    throw err;\n                  }\n                  error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, \"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED\");\n                } catch (ex) {\n                  error$1 = ex;\n                }\n                if (error$1 && !(error$1 instanceof Error)) {\n                  setCurrentlyValidatingElement(element);\n                  error(\"%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).\", componentName || \"React class\", location, typeSpecName, typeof error$1);\n                  setCurrentlyValidatingElement(null);\n                }\n                if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {\n                  loggedTypeFailures[error$1.message] = true;\n                  setCurrentlyValidatingElement(element);\n                  error(\"Failed %s type: %s\", location, error$1.message);\n                  setCurrentlyValidatingElement(null);\n                }\n              }\n            }\n          }\n        }\n        var valueStack = [];\n        var fiberStack;\n        {\n          fiberStack = [];\n        }\n        var index = -1;\n        function createCursor(defaultValue) {\n          return {\n            current: defaultValue\n          };\n        }\n        function pop(cursor, fiber) {\n          if (index < 0) {\n            {\n              error(\"Unexpected pop.\");\n            }\n            return;\n          }\n          {\n            if (fiber !== fiberStack[index]) {\n              error(\"Unexpected Fiber popped.\");\n            }\n          }\n          cursor.current = valueStack[index];\n          valueStack[index] = null;\n          {\n            fiberStack[index] = null;\n          }\n          index--;\n        }\n        function push(cursor, value, fiber) {\n          index++;\n          valueStack[index] = cursor.current;\n          {\n            fiberStack[index] = fiber;\n          }\n          cursor.current = value;\n        }\n        var warnedAboutMissingGetChildContext;\n        {\n          warnedAboutMissingGetChildContext = {};\n        }\n        var emptyContextObject = {};\n        {\n          Object.freeze(emptyContextObject);\n        }\n        var contextStackCursor = createCursor(emptyContextObject);\n        var didPerformWorkStackCursor = createCursor(false);\n        var previousContext = emptyContextObject;\n        function getUnmaskedContext(workInProgress2, Component, didPushOwnContextIfProvider) {\n          {\n            if (didPushOwnContextIfProvider && isContextProvider(Component)) {\n              return previousContext;\n            }\n            return contextStackCursor.current;\n          }\n        }\n        function cacheContext(workInProgress2, unmaskedContext, maskedContext) {\n          {\n            var instance = workInProgress2.stateNode;\n            instance.__reactInternalMemoizedUnmaskedChildContext = unmaskedContext;\n            instance.__reactInternalMemoizedMaskedChildContext = maskedContext;\n          }\n        }\n        function getMaskedContext(workInProgress2, unmaskedContext) {\n          {\n            var type = workInProgress2.type;\n            var contextTypes = type.contextTypes;\n            if (!contextTypes) {\n              return emptyContextObject;\n            }\n            var instance = workInProgress2.stateNode;\n            if (instance && instance.__reactInternalMemoizedUnmaskedChildContext === unmaskedContext) {\n              return instance.__reactInternalMemoizedMaskedChildContext;\n            }\n            var context = {};\n            for (var key in contextTypes) {\n              context[key] = unmaskedContext[key];\n            }\n            {\n              var name = getComponentNameFromFiber(workInProgress2) || \"Unknown\";\n              checkPropTypes(contextTypes, context, \"context\", name);\n            }\n            if (instance) {\n              cacheContext(workInProgress2, unmaskedContext, context);\n            }\n            return context;\n          }\n        }\n        function hasContextChanged() {\n          {\n            return didPerformWorkStackCursor.current;\n          }\n        }\n        function isContextProvider(type) {\n          {\n            var childContextTypes = type.childContextTypes;\n            return childContextTypes !== null && childContextTypes !== void 0;\n          }\n        }\n        function popContext(fiber) {\n          {\n            pop(didPerformWorkStackCursor, fiber);\n            pop(contextStackCursor, fiber);\n          }\n        }\n        function popTopLevelContextObject(fiber) {\n          {\n            pop(didPerformWorkStackCursor, fiber);\n            pop(contextStackCursor, fiber);\n          }\n        }\n        function pushTopLevelContextObject(fiber, context, didChange) {\n          {\n            if (contextStackCursor.current !== emptyContextObject) {\n              throw new Error(\"Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue.\");\n            }\n            push(contextStackCursor, context, fiber);\n            push(didPerformWorkStackCursor, didChange, fiber);\n          }\n        }\n        function processChildContext(fiber, type, parentContext) {\n          {\n            var instance = fiber.stateNode;\n            var childContextTypes = type.childContextTypes;\n            if (typeof instance.getChildContext !== \"function\") {\n              {\n                var componentName = getComponentNameFromFiber(fiber) || \"Unknown\";\n                if (!warnedAboutMissingGetChildContext[componentName]) {\n                  warnedAboutMissingGetChildContext[componentName] = true;\n                  error(\"%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.\", componentName, componentName);\n                }\n              }\n              return parentContext;\n            }\n            var childContext = instance.getChildContext();\n            for (var contextKey in childContext) {\n              if (!(contextKey in childContextTypes)) {\n                throw new Error((getComponentNameFromFiber(fiber) || \"Unknown\") + '.getChildContext(): key \"' + contextKey + '\" is not defined in childContextTypes.');\n              }\n            }\n            {\n              var name = getComponentNameFromFiber(fiber) || \"Unknown\";\n              checkPropTypes(childContextTypes, childContext, \"child context\", name);\n            }\n            return assign({}, parentContext, childContext);\n          }\n        }\n        function pushContextProvider(workInProgress2) {\n          {\n            var instance = workInProgress2.stateNode;\n            var memoizedMergedChildContext = instance && instance.__reactInternalMemoizedMergedChildContext || emptyContextObject;\n            previousContext = contextStackCursor.current;\n            push(contextStackCursor, memoizedMergedChildContext, workInProgress2);\n            push(didPerformWorkStackCursor, didPerformWorkStackCursor.current, workInProgress2);\n            return true;\n          }\n        }\n        function invalidateContextProvider(workInProgress2, type, didChange) {\n          {\n            var instance = workInProgress2.stateNode;\n            if (!instance) {\n              throw new Error(\"Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue.\");\n            }\n            if (didChange) {\n              var mergedContext = processChildContext(workInProgress2, type, previousContext);\n              instance.__reactInternalMemoizedMergedChildContext = mergedContext;\n              pop(didPerformWorkStackCursor, workInProgress2);\n              pop(contextStackCursor, workInProgress2);\n              push(contextStackCursor, mergedContext, workInProgress2);\n              push(didPerformWorkStackCursor, didChange, workInProgress2);\n            } else {\n              pop(didPerformWorkStackCursor, workInProgress2);\n              push(didPerformWorkStackCursor, didChange, workInProgress2);\n            }\n          }\n        }\n        function findCurrentUnmaskedContext(fiber) {\n          {\n            if (!isFiberMounted(fiber) || fiber.tag !== ClassComponent) {\n              throw new Error(\"Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue.\");\n            }\n            var node = fiber;\n            do {\n              switch (node.tag) {\n                case HostRoot:\n                  return node.stateNode.context;\n                case ClassComponent: {\n                  var Component = node.type;\n                  if (isContextProvider(Component)) {\n                    return node.stateNode.__reactInternalMemoizedMergedChildContext;\n                  }\n                  break;\n                }\n              }\n              node = node.return;\n            } while (node !== null);\n            throw new Error(\"Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue.\");\n          }\n        }\n        var LegacyRoot = 0;\n        var ConcurrentRoot = 1;\n        var syncQueue = null;\n        var includesLegacySyncCallbacks = false;\n        var isFlushingSyncQueue = false;\n        function scheduleSyncCallback(callback) {\n          if (syncQueue === null) {\n            syncQueue = [callback];\n          } else {\n            syncQueue.push(callback);\n          }\n        }\n        function scheduleLegacySyncCallback(callback) {\n          includesLegacySyncCallbacks = true;\n          scheduleSyncCallback(callback);\n        }\n        function flushSyncCallbacksOnlyInLegacyMode() {\n          if (includesLegacySyncCallbacks) {\n            flushSyncCallbacks();\n          }\n        }\n        function flushSyncCallbacks() {\n          if (!isFlushingSyncQueue && syncQueue !== null) {\n            isFlushingSyncQueue = true;\n            var i = 0;\n            var previousUpdatePriority = getCurrentUpdatePriority();\n            try {\n              var isSync = true;\n              var queue = syncQueue;\n              setCurrentUpdatePriority(DiscreteEventPriority);\n              for (; i < queue.length; i++) {\n                var callback = queue[i];\n                do {\n                  callback = callback(isSync);\n                } while (callback !== null);\n              }\n              syncQueue = null;\n              includesLegacySyncCallbacks = false;\n            } catch (error2) {\n              if (syncQueue !== null) {\n                syncQueue = syncQueue.slice(i + 1);\n              }\n              scheduleCallback(ImmediatePriority, flushSyncCallbacks);\n              throw error2;\n            } finally {\n              setCurrentUpdatePriority(previousUpdatePriority);\n              isFlushingSyncQueue = false;\n            }\n          }\n          return null;\n        }\n        var forkStack = [];\n        var forkStackIndex = 0;\n        var treeForkProvider = null;\n        var treeForkCount = 0;\n        var idStack = [];\n        var idStackIndex = 0;\n        var treeContextProvider = null;\n        var treeContextId = 1;\n        var treeContextOverflow = \"\";\n        function isForkedChild(workInProgress2) {\n          warnIfNotHydrating();\n          return (workInProgress2.flags & Forked) !== NoFlags;\n        }\n        function getForksAtLevel(workInProgress2) {\n          warnIfNotHydrating();\n          return treeForkCount;\n        }\n        function getTreeId() {\n          var overflow = treeContextOverflow;\n          var idWithLeadingBit = treeContextId;\n          var id = idWithLeadingBit & ~getLeadingBit(idWithLeadingBit);\n          return id.toString(32) + overflow;\n        }\n        function pushTreeFork(workInProgress2, totalChildren) {\n          warnIfNotHydrating();\n          forkStack[forkStackIndex++] = treeForkCount;\n          forkStack[forkStackIndex++] = treeForkProvider;\n          treeForkProvider = workInProgress2;\n          treeForkCount = totalChildren;\n        }\n        function pushTreeId(workInProgress2, totalChildren, index2) {\n          warnIfNotHydrating();\n          idStack[idStackIndex++] = treeContextId;\n          idStack[idStackIndex++] = treeContextOverflow;\n          idStack[idStackIndex++] = treeContextProvider;\n          treeContextProvider = workInProgress2;\n          var baseIdWithLeadingBit = treeContextId;\n          var baseOverflow = treeContextOverflow;\n          var baseLength = getBitLength(baseIdWithLeadingBit) - 1;\n          var baseId = baseIdWithLeadingBit & ~(1 << baseLength);\n          var slot = index2 + 1;\n          var length = getBitLength(totalChildren) + baseLength;\n          if (length > 30) {\n            var numberOfOverflowBits = baseLength - baseLength % 5;\n            var newOverflowBits = (1 << numberOfOverflowBits) - 1;\n            var newOverflow = (baseId & newOverflowBits).toString(32);\n            var restOfBaseId = baseId >> numberOfOverflowBits;\n            var restOfBaseLength = baseLength - numberOfOverflowBits;\n            var restOfLength = getBitLength(totalChildren) + restOfBaseLength;\n            var restOfNewBits = slot << restOfBaseLength;\n            var id = restOfNewBits | restOfBaseId;\n            var overflow = newOverflow + baseOverflow;\n            treeContextId = 1 << restOfLength | id;\n            treeContextOverflow = overflow;\n          } else {\n            var newBits = slot << baseLength;\n            var _id = newBits | baseId;\n            var _overflow = baseOverflow;\n            treeContextId = 1 << length | _id;\n            treeContextOverflow = _overflow;\n          }\n        }\n        function pushMaterializedTreeId(workInProgress2) {\n          warnIfNotHydrating();\n          var returnFiber = workInProgress2.return;\n          if (returnFiber !== null) {\n            var numberOfForks = 1;\n            var slotIndex = 0;\n            pushTreeFork(workInProgress2, numberOfForks);\n            pushTreeId(workInProgress2, numberOfForks, slotIndex);\n          }\n        }\n        function getBitLength(number) {\n          return 32 - clz32(number);\n        }\n        function getLeadingBit(id) {\n          return 1 << getBitLength(id) - 1;\n        }\n        function popTreeContext(workInProgress2) {\n          while (workInProgress2 === treeForkProvider) {\n            treeForkProvider = forkStack[--forkStackIndex];\n            forkStack[forkStackIndex] = null;\n            treeForkCount = forkStack[--forkStackIndex];\n            forkStack[forkStackIndex] = null;\n          }\n          while (workInProgress2 === treeContextProvider) {\n            treeContextProvider = idStack[--idStackIndex];\n            idStack[idStackIndex] = null;\n            treeContextOverflow = idStack[--idStackIndex];\n            idStack[idStackIndex] = null;\n            treeContextId = idStack[--idStackIndex];\n            idStack[idStackIndex] = null;\n          }\n        }\n        function getSuspendedTreeContext() {\n          warnIfNotHydrating();\n          if (treeContextProvider !== null) {\n            return {\n              id: treeContextId,\n              overflow: treeContextOverflow\n            };\n          } else {\n            return null;\n          }\n        }\n        function restoreSuspendedTreeContext(workInProgress2, suspendedContext) {\n          warnIfNotHydrating();\n          idStack[idStackIndex++] = treeContextId;\n          idStack[idStackIndex++] = treeContextOverflow;\n          idStack[idStackIndex++] = treeContextProvider;\n          treeContextId = suspendedContext.id;\n          treeContextOverflow = suspendedContext.overflow;\n          treeContextProvider = workInProgress2;\n        }\n        function warnIfNotHydrating() {\n          {\n            if (!getIsHydrating()) {\n              error(\"Expected to be hydrating. This is a bug in React. Please file an issue.\");\n            }\n          }\n        }\n        var hydrationParentFiber = null;\n        var nextHydratableInstance = null;\n        var isHydrating = false;\n        var didSuspendOrErrorDEV = false;\n        var hydrationErrors = null;\n        function warnIfHydrating() {\n          {\n            if (isHydrating) {\n              error(\"We should not be hydrating here. This is a bug in React. Please file a bug.\");\n            }\n          }\n        }\n        function markDidThrowWhileHydratingDEV() {\n          {\n            didSuspendOrErrorDEV = true;\n          }\n        }\n        function didSuspendOrErrorWhileHydratingDEV() {\n          {\n            return didSuspendOrErrorDEV;\n          }\n        }\n        function enterHydrationState(fiber) {\n          var parentInstance = fiber.stateNode.containerInfo;\n          nextHydratableInstance = getFirstHydratableChildWithinContainer(parentInstance);\n          hydrationParentFiber = fiber;\n          isHydrating = true;\n          hydrationErrors = null;\n          didSuspendOrErrorDEV = false;\n          return true;\n        }\n        function reenterHydrationStateFromDehydratedSuspenseInstance(fiber, suspenseInstance, treeContext) {\n          nextHydratableInstance = getFirstHydratableChildWithinSuspenseInstance(suspenseInstance);\n          hydrationParentFiber = fiber;\n          isHydrating = true;\n          hydrationErrors = null;\n          didSuspendOrErrorDEV = false;\n          if (treeContext !== null) {\n            restoreSuspendedTreeContext(fiber, treeContext);\n          }\n          return true;\n        }\n        function warnUnhydratedInstance(returnFiber, instance) {\n          {\n            switch (returnFiber.tag) {\n              case HostRoot: {\n                didNotHydrateInstanceWithinContainer(returnFiber.stateNode.containerInfo, instance);\n                break;\n              }\n              case HostComponent: {\n                var isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;\n                didNotHydrateInstance(\n                  returnFiber.type,\n                  returnFiber.memoizedProps,\n                  returnFiber.stateNode,\n                  instance,\n                  // TODO: Delete this argument when we remove the legacy root API.\n                  isConcurrentMode\n                );\n                break;\n              }\n              case SuspenseComponent: {\n                var suspenseState = returnFiber.memoizedState;\n                if (suspenseState.dehydrated !== null)\n                  didNotHydrateInstanceWithinSuspenseInstance(suspenseState.dehydrated, instance);\n                break;\n              }\n            }\n          }\n        }\n        function deleteHydratableInstance(returnFiber, instance) {\n          warnUnhydratedInstance(returnFiber, instance);\n          var childToDelete = createFiberFromHostInstanceForDeletion();\n          childToDelete.stateNode = instance;\n          childToDelete.return = returnFiber;\n          var deletions = returnFiber.deletions;\n          if (deletions === null) {\n            returnFiber.deletions = [childToDelete];\n            returnFiber.flags |= ChildDeletion;\n          } else {\n            deletions.push(childToDelete);\n          }\n        }\n        function warnNonhydratedInstance(returnFiber, fiber) {\n          {\n            if (didSuspendOrErrorDEV) {\n              return;\n            }\n            switch (returnFiber.tag) {\n              case HostRoot: {\n                var parentContainer = returnFiber.stateNode.containerInfo;\n                switch (fiber.tag) {\n                  case HostComponent:\n                    var type = fiber.type;\n                    var props = fiber.pendingProps;\n                    didNotFindHydratableInstanceWithinContainer(parentContainer, type);\n                    break;\n                  case HostText:\n                    var text = fiber.pendingProps;\n                    didNotFindHydratableTextInstanceWithinContainer(parentContainer, text);\n                    break;\n                }\n                break;\n              }\n              case HostComponent: {\n                var parentType = returnFiber.type;\n                var parentProps = returnFiber.memoizedProps;\n                var parentInstance = returnFiber.stateNode;\n                switch (fiber.tag) {\n                  case HostComponent: {\n                    var _type = fiber.type;\n                    var _props = fiber.pendingProps;\n                    var isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;\n                    didNotFindHydratableInstance(\n                      parentType,\n                      parentProps,\n                      parentInstance,\n                      _type,\n                      _props,\n                      // TODO: Delete this argument when we remove the legacy root API.\n                      isConcurrentMode\n                    );\n                    break;\n                  }\n                  case HostText: {\n                    var _text = fiber.pendingProps;\n                    var _isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;\n                    didNotFindHydratableTextInstance(\n                      parentType,\n                      parentProps,\n                      parentInstance,\n                      _text,\n                      // TODO: Delete this argument when we remove the legacy root API.\n                      _isConcurrentMode\n                    );\n                    break;\n                  }\n                }\n                break;\n              }\n              case SuspenseComponent: {\n                var suspenseState = returnFiber.memoizedState;\n                var _parentInstance = suspenseState.dehydrated;\n                if (_parentInstance !== null)\n                  switch (fiber.tag) {\n                    case HostComponent:\n                      var _type2 = fiber.type;\n                      var _props2 = fiber.pendingProps;\n                      didNotFindHydratableInstanceWithinSuspenseInstance(_parentInstance, _type2);\n                      break;\n                    case HostText:\n                      var _text2 = fiber.pendingProps;\n                      didNotFindHydratableTextInstanceWithinSuspenseInstance(_parentInstance, _text2);\n                      break;\n                  }\n                break;\n              }\n              default:\n                return;\n            }\n          }\n        }\n        function insertNonHydratedInstance(returnFiber, fiber) {\n          fiber.flags = fiber.flags & ~Hydrating | Placement;\n          warnNonhydratedInstance(returnFiber, fiber);\n        }\n        function tryHydrate(fiber, nextInstance) {\n          switch (fiber.tag) {\n            case HostComponent: {\n              var type = fiber.type;\n              var props = fiber.pendingProps;\n              var instance = canHydrateInstance(nextInstance, type);\n              if (instance !== null) {\n                fiber.stateNode = instance;\n                hydrationParentFiber = fiber;\n                nextHydratableInstance = getFirstHydratableChild(instance);\n                return true;\n              }\n              return false;\n            }\n            case HostText: {\n              var text = fiber.pendingProps;\n              var textInstance = canHydrateTextInstance(nextInstance, text);\n              if (textInstance !== null) {\n                fiber.stateNode = textInstance;\n                hydrationParentFiber = fiber;\n                nextHydratableInstance = null;\n                return true;\n              }\n              return false;\n            }\n            case SuspenseComponent: {\n              var suspenseInstance = canHydrateSuspenseInstance(nextInstance);\n              if (suspenseInstance !== null) {\n                var suspenseState = {\n                  dehydrated: suspenseInstance,\n                  treeContext: getSuspendedTreeContext(),\n                  retryLane: OffscreenLane\n                };\n                fiber.memoizedState = suspenseState;\n                var dehydratedFragment = createFiberFromDehydratedFragment(suspenseInstance);\n                dehydratedFragment.return = fiber;\n                fiber.child = dehydratedFragment;\n                hydrationParentFiber = fiber;\n                nextHydratableInstance = null;\n                return true;\n              }\n              return false;\n            }\n            default:\n              return false;\n          }\n        }\n        function shouldClientRenderOnMismatch(fiber) {\n          return (fiber.mode & ConcurrentMode) !== NoMode && (fiber.flags & DidCapture) === NoFlags;\n        }\n        function throwOnHydrationMismatch(fiber) {\n          throw new Error(\"Hydration failed because the initial UI does not match what was rendered on the server.\");\n        }\n        function tryToClaimNextHydratableInstance(fiber) {\n          if (!isHydrating) {\n            return;\n          }\n          var nextInstance = nextHydratableInstance;\n          if (!nextInstance) {\n            if (shouldClientRenderOnMismatch(fiber)) {\n              warnNonhydratedInstance(hydrationParentFiber, fiber);\n              throwOnHydrationMismatch();\n            }\n            insertNonHydratedInstance(hydrationParentFiber, fiber);\n            isHydrating = false;\n            hydrationParentFiber = fiber;\n            return;\n          }\n          var firstAttemptedInstance = nextInstance;\n          if (!tryHydrate(fiber, nextInstance)) {\n            if (shouldClientRenderOnMismatch(fiber)) {\n              warnNonhydratedInstance(hydrationParentFiber, fiber);\n              throwOnHydrationMismatch();\n            }\n            nextInstance = getNextHydratableSibling(firstAttemptedInstance);\n            var prevHydrationParentFiber = hydrationParentFiber;\n            if (!nextInstance || !tryHydrate(fiber, nextInstance)) {\n              insertNonHydratedInstance(hydrationParentFiber, fiber);\n              isHydrating = false;\n              hydrationParentFiber = fiber;\n              return;\n            }\n            deleteHydratableInstance(prevHydrationParentFiber, firstAttemptedInstance);\n          }\n        }\n        function prepareToHydrateHostInstance(fiber, rootContainerInstance, hostContext) {\n          var instance = fiber.stateNode;\n          var shouldWarnIfMismatchDev = !didSuspendOrErrorDEV;\n          var updatePayload = hydrateInstance(instance, fiber.type, fiber.memoizedProps, rootContainerInstance, hostContext, fiber, shouldWarnIfMismatchDev);\n          fiber.updateQueue = updatePayload;\n          if (updatePayload !== null) {\n            return true;\n          }\n          return false;\n        }\n        function prepareToHydrateHostTextInstance(fiber) {\n          var textInstance = fiber.stateNode;\n          var textContent = fiber.memoizedProps;\n          var shouldUpdate = hydrateTextInstance(textInstance, textContent, fiber);\n          if (shouldUpdate) {\n            var returnFiber = hydrationParentFiber;\n            if (returnFiber !== null) {\n              switch (returnFiber.tag) {\n                case HostRoot: {\n                  var parentContainer = returnFiber.stateNode.containerInfo;\n                  var isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;\n                  didNotMatchHydratedContainerTextInstance(\n                    parentContainer,\n                    textInstance,\n                    textContent,\n                    // TODO: Delete this argument when we remove the legacy root API.\n                    isConcurrentMode\n                  );\n                  break;\n                }\n                case HostComponent: {\n                  var parentType = returnFiber.type;\n                  var parentProps = returnFiber.memoizedProps;\n                  var parentInstance = returnFiber.stateNode;\n                  var _isConcurrentMode2 = (returnFiber.mode & ConcurrentMode) !== NoMode;\n                  didNotMatchHydratedTextInstance(\n                    parentType,\n                    parentProps,\n                    parentInstance,\n                    textInstance,\n                    textContent,\n                    // TODO: Delete this argument when we remove the legacy root API.\n                    _isConcurrentMode2\n                  );\n                  break;\n                }\n              }\n            }\n          }\n          return shouldUpdate;\n        }\n        function prepareToHydrateHostSuspenseInstance(fiber) {\n          var suspenseState = fiber.memoizedState;\n          var suspenseInstance = suspenseState !== null ? suspenseState.dehydrated : null;\n          if (!suspenseInstance) {\n            throw new Error(\"Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.\");\n          }\n          hydrateSuspenseInstance(suspenseInstance, fiber);\n        }\n        function skipPastDehydratedSuspenseInstance(fiber) {\n          var suspenseState = fiber.memoizedState;\n          var suspenseInstance = suspenseState !== null ? suspenseState.dehydrated : null;\n          if (!suspenseInstance) {\n            throw new Error(\"Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.\");\n          }\n          return getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance);\n        }\n        function popToNextHostParent(fiber) {\n          var parent = fiber.return;\n          while (parent !== null && parent.tag !== HostComponent && parent.tag !== HostRoot && parent.tag !== SuspenseComponent) {\n            parent = parent.return;\n          }\n          hydrationParentFiber = parent;\n        }\n        function popHydrationState(fiber) {\n          if (fiber !== hydrationParentFiber) {\n            return false;\n          }\n          if (!isHydrating) {\n            popToNextHostParent(fiber);\n            isHydrating = true;\n            return false;\n          }\n          if (fiber.tag !== HostRoot && (fiber.tag !== HostComponent || shouldDeleteUnhydratedTailInstances(fiber.type) && !shouldSetTextContent(fiber.type, fiber.memoizedProps))) {\n            var nextInstance = nextHydratableInstance;\n            if (nextInstance) {\n              if (shouldClientRenderOnMismatch(fiber)) {\n                warnIfUnhydratedTailNodes(fiber);\n                throwOnHydrationMismatch();\n              } else {\n                while (nextInstance) {\n                  deleteHydratableInstance(fiber, nextInstance);\n                  nextInstance = getNextHydratableSibling(nextInstance);\n                }\n              }\n            }\n          }\n          popToNextHostParent(fiber);\n          if (fiber.tag === SuspenseComponent) {\n            nextHydratableInstance = skipPastDehydratedSuspenseInstance(fiber);\n          } else {\n            nextHydratableInstance = hydrationParentFiber ? getNextHydratableSibling(fiber.stateNode) : null;\n          }\n          return true;\n        }\n        function hasUnhydratedTailNodes() {\n          return isHydrating && nextHydratableInstance !== null;\n        }\n        function warnIfUnhydratedTailNodes(fiber) {\n          var nextInstance = nextHydratableInstance;\n          while (nextInstance) {\n            warnUnhydratedInstance(fiber, nextInstance);\n            nextInstance = getNextHydratableSibling(nextInstance);\n          }\n        }\n        function resetHydrationState() {\n          hydrationParentFiber = null;\n          nextHydratableInstance = null;\n          isHydrating = false;\n          didSuspendOrErrorDEV = false;\n        }\n        function upgradeHydrationErrorsToRecoverable() {\n          if (hydrationErrors !== null) {\n            queueRecoverableErrors(hydrationErrors);\n            hydrationErrors = null;\n          }\n        }\n        function getIsHydrating() {\n          return isHydrating;\n        }\n        function queueHydrationError(error2) {\n          if (hydrationErrors === null) {\n            hydrationErrors = [error2];\n          } else {\n            hydrationErrors.push(error2);\n          }\n        }\n        var ReactCurrentBatchConfig$1 = ReactSharedInternals.ReactCurrentBatchConfig;\n        var NoTransition = null;\n        function requestCurrentTransition() {\n          return ReactCurrentBatchConfig$1.transition;\n        }\n        var ReactStrictModeWarnings = {\n          recordUnsafeLifecycleWarnings: function(fiber, instance) {\n          },\n          flushPendingUnsafeLifecycleWarnings: function() {\n          },\n          recordLegacyContextWarning: function(fiber, instance) {\n          },\n          flushLegacyContextWarning: function() {\n          },\n          discardPendingWarnings: function() {\n          }\n        };\n        {\n          var findStrictRoot = function(fiber) {\n            var maybeStrictRoot = null;\n            var node = fiber;\n            while (node !== null) {\n              if (node.mode & StrictLegacyMode) {\n                maybeStrictRoot = node;\n              }\n              node = node.return;\n            }\n            return maybeStrictRoot;\n          };\n          var setToSortedString = function(set2) {\n            var array = [];\n            set2.forEach(function(value) {\n              array.push(value);\n            });\n            return array.sort().join(\", \");\n          };\n          var pendingComponentWillMountWarnings = [];\n          var pendingUNSAFE_ComponentWillMountWarnings = [];\n          var pendingComponentWillReceivePropsWarnings = [];\n          var pendingUNSAFE_ComponentWillReceivePropsWarnings = [];\n          var pendingComponentWillUpdateWarnings = [];\n          var pendingUNSAFE_ComponentWillUpdateWarnings = [];\n          var didWarnAboutUnsafeLifecycles = /* @__PURE__ */ new Set();\n          ReactStrictModeWarnings.recordUnsafeLifecycleWarnings = function(fiber, instance) {\n            if (didWarnAboutUnsafeLifecycles.has(fiber.type)) {\n              return;\n            }\n            if (typeof instance.componentWillMount === \"function\" && // Don't warn about react-lifecycles-compat polyfilled components.\n            instance.componentWillMount.__suppressDeprecationWarning !== true) {\n              pendingComponentWillMountWarnings.push(fiber);\n            }\n            if (fiber.mode & StrictLegacyMode && typeof instance.UNSAFE_componentWillMount === \"function\") {\n              pendingUNSAFE_ComponentWillMountWarnings.push(fiber);\n            }\n            if (typeof instance.componentWillReceiveProps === \"function\" && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {\n              pendingComponentWillReceivePropsWarnings.push(fiber);\n            }\n            if (fiber.mode & StrictLegacyMode && typeof instance.UNSAFE_componentWillReceiveProps === \"function\") {\n              pendingUNSAFE_ComponentWillReceivePropsWarnings.push(fiber);\n            }\n            if (typeof instance.componentWillUpdate === \"function\" && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {\n              pendingComponentWillUpdateWarnings.push(fiber);\n            }\n            if (fiber.mode & StrictLegacyMode && typeof instance.UNSAFE_componentWillUpdate === \"function\") {\n              pendingUNSAFE_ComponentWillUpdateWarnings.push(fiber);\n            }\n          };\n          ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings = function() {\n            var componentWillMountUniqueNames = /* @__PURE__ */ new Set();\n            if (pendingComponentWillMountWarnings.length > 0) {\n              pendingComponentWillMountWarnings.forEach(function(fiber) {\n                componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber) || \"Component\");\n                didWarnAboutUnsafeLifecycles.add(fiber.type);\n              });\n              pendingComponentWillMountWarnings = [];\n            }\n            var UNSAFE_componentWillMountUniqueNames = /* @__PURE__ */ new Set();\n            if (pendingUNSAFE_ComponentWillMountWarnings.length > 0) {\n              pendingUNSAFE_ComponentWillMountWarnings.forEach(function(fiber) {\n                UNSAFE_componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber) || \"Component\");\n                didWarnAboutUnsafeLifecycles.add(fiber.type);\n              });\n              pendingUNSAFE_ComponentWillMountWarnings = [];\n            }\n            var componentWillReceivePropsUniqueNames = /* @__PURE__ */ new Set();\n            if (pendingComponentWillReceivePropsWarnings.length > 0) {\n              pendingComponentWillReceivePropsWarnings.forEach(function(fiber) {\n                componentWillReceivePropsUniqueNames.add(getComponentNameFromFiber(fiber) || \"Component\");\n                didWarnAboutUnsafeLifecycles.add(fiber.type);\n              });\n              pendingComponentWillReceivePropsWarnings = [];\n            }\n            var UNSAFE_componentWillReceivePropsUniqueNames = /* @__PURE__ */ new Set();\n            if (pendingUNSAFE_ComponentWillReceivePropsWarnings.length > 0) {\n              pendingUNSAFE_ComponentWillReceivePropsWarnings.forEach(function(fiber) {\n                UNSAFE_componentWillReceivePropsUniqueNames.add(getComponentNameFromFiber(fiber) || \"Component\");\n                didWarnAboutUnsafeLifecycles.add(fiber.type);\n              });\n              pendingUNSAFE_ComponentWillReceivePropsWarnings = [];\n            }\n            var componentWillUpdateUniqueNames = /* @__PURE__ */ new Set();\n            if (pendingComponentWillUpdateWarnings.length > 0) {\n              pendingComponentWillUpdateWarnings.forEach(function(fiber) {\n                componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber) || \"Component\");\n                didWarnAboutUnsafeLifecycles.add(fiber.type);\n              });\n              pendingComponentWillUpdateWarnings = [];\n            }\n            var UNSAFE_componentWillUpdateUniqueNames = /* @__PURE__ */ new Set();\n            if (pendingUNSAFE_ComponentWillUpdateWarnings.length > 0) {\n              pendingUNSAFE_ComponentWillUpdateWarnings.forEach(function(fiber) {\n                UNSAFE_componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber) || \"Component\");\n                didWarnAboutUnsafeLifecycles.add(fiber.type);\n              });\n              pendingUNSAFE_ComponentWillUpdateWarnings = [];\n            }\n            if (UNSAFE_componentWillMountUniqueNames.size > 0) {\n              var sortedNames = setToSortedString(UNSAFE_componentWillMountUniqueNames);\n              error(\"Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.\\n\\n* Move code with side effects to componentDidMount, and set initial state in the constructor.\\n\\nPlease update the following components: %s\", sortedNames);\n            }\n            if (UNSAFE_componentWillReceivePropsUniqueNames.size > 0) {\n              var _sortedNames = setToSortedString(UNSAFE_componentWillReceivePropsUniqueNames);\n              error(\"Using UNSAFE_componentWillReceiveProps in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.\\n\\n* Move data fetching code or side effects to componentDidUpdate.\\n* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state\\n\\nPlease update the following components: %s\", _sortedNames);\n            }\n            if (UNSAFE_componentWillUpdateUniqueNames.size > 0) {\n              var _sortedNames2 = setToSortedString(UNSAFE_componentWillUpdateUniqueNames);\n              error(\"Using UNSAFE_componentWillUpdate in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.\\n\\n* Move data fetching code or side effects to componentDidUpdate.\\n\\nPlease update the following components: %s\", _sortedNames2);\n            }\n            if (componentWillMountUniqueNames.size > 0) {\n              var _sortedNames3 = setToSortedString(componentWillMountUniqueNames);\n              warn(\"componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.\\n\\n* Move code with side effects to componentDidMount, and set initial state in the constructor.\\n* Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\\n\\nPlease update the following components: %s\", _sortedNames3);\n            }\n            if (componentWillReceivePropsUniqueNames.size > 0) {\n              var _sortedNames4 = setToSortedString(componentWillReceivePropsUniqueNames);\n              warn(\"componentWillReceiveProps has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.\\n\\n* Move data fetching code or side effects to componentDidUpdate.\\n* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state\\n* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\\n\\nPlease update the following components: %s\", _sortedNames4);\n            }\n            if (componentWillUpdateUniqueNames.size > 0) {\n              var _sortedNames5 = setToSortedString(componentWillUpdateUniqueNames);\n              warn(\"componentWillUpdate has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.\\n\\n* Move data fetching code or side effects to componentDidUpdate.\\n* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\\n\\nPlease update the following components: %s\", _sortedNames5);\n            }\n          };\n          var pendingLegacyContextWarning = /* @__PURE__ */ new Map();\n          var didWarnAboutLegacyContext = /* @__PURE__ */ new Set();\n          ReactStrictModeWarnings.recordLegacyContextWarning = function(fiber, instance) {\n            var strictRoot = findStrictRoot(fiber);\n            if (strictRoot === null) {\n              error(\"Expected to find a StrictMode component in a strict mode tree. This error is likely caused by a bug in React. Please file an issue.\");\n              return;\n            }\n            if (didWarnAboutLegacyContext.has(fiber.type)) {\n              return;\n            }\n            var warningsForRoot = pendingLegacyContextWarning.get(strictRoot);\n            if (fiber.type.contextTypes != null || fiber.type.childContextTypes != null || instance !== null && typeof instance.getChildContext === \"function\") {\n              if (warningsForRoot === void 0) {\n                warningsForRoot = [];\n                pendingLegacyContextWarning.set(strictRoot, warningsForRoot);\n              }\n              warningsForRoot.push(fiber);\n            }\n          };\n          ReactStrictModeWarnings.flushLegacyContextWarning = function() {\n            pendingLegacyContextWarning.forEach(function(fiberArray, strictRoot) {\n              if (fiberArray.length === 0) {\n                return;\n              }\n              var firstFiber = fiberArray[0];\n              var uniqueNames = /* @__PURE__ */ new Set();\n              fiberArray.forEach(function(fiber) {\n                uniqueNames.add(getComponentNameFromFiber(fiber) || \"Component\");\n                didWarnAboutLegacyContext.add(fiber.type);\n              });\n              var sortedNames = setToSortedString(uniqueNames);\n              try {\n                setCurrentFiber(firstFiber);\n                error(\"Legacy context API has been detected within a strict-mode tree.\\n\\nThe old API will be supported in all 16.x releases, but applications using it should migrate to the new version.\\n\\nPlease update the following components: %s\\n\\nLearn more about this warning here: https://reactjs.org/link/legacy-context\", sortedNames);\n              } finally {\n                resetCurrentFiber();\n              }\n            });\n          };\n          ReactStrictModeWarnings.discardPendingWarnings = function() {\n            pendingComponentWillMountWarnings = [];\n            pendingUNSAFE_ComponentWillMountWarnings = [];\n            pendingComponentWillReceivePropsWarnings = [];\n            pendingUNSAFE_ComponentWillReceivePropsWarnings = [];\n            pendingComponentWillUpdateWarnings = [];\n            pendingUNSAFE_ComponentWillUpdateWarnings = [];\n            pendingLegacyContextWarning = /* @__PURE__ */ new Map();\n          };\n        }\n        function resolveDefaultProps(Component, baseProps) {\n          if (Component && Component.defaultProps) {\n            var props = assign({}, baseProps);\n            var defaultProps = Component.defaultProps;\n            for (var propName in defaultProps) {\n              if (props[propName] === void 0) {\n                props[propName] = defaultProps[propName];\n              }\n            }\n            return props;\n          }\n          return baseProps;\n        }\n        var valueCursor = createCursor(null);\n        var rendererSigil;\n        {\n          rendererSigil = {};\n        }\n        var currentlyRenderingFiber = null;\n        var lastContextDependency = null;\n        var lastFullyObservedContext = null;\n        var isDisallowedContextReadInDEV = false;\n        function resetContextDependencies() {\n          currentlyRenderingFiber = null;\n          lastContextDependency = null;\n          lastFullyObservedContext = null;\n          {\n            isDisallowedContextReadInDEV = false;\n          }\n        }\n        function enterDisallowedContextReadInDEV() {\n          {\n            isDisallowedContextReadInDEV = true;\n          }\n        }\n        function exitDisallowedContextReadInDEV() {\n          {\n            isDisallowedContextReadInDEV = false;\n          }\n        }\n        function pushProvider(providerFiber, context, nextValue) {\n          {\n            push(valueCursor, context._currentValue, providerFiber);\n            context._currentValue = nextValue;\n            {\n              if (context._currentRenderer !== void 0 && context._currentRenderer !== null && context._currentRenderer !== rendererSigil) {\n                error(\"Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported.\");\n              }\n              context._currentRenderer = rendererSigil;\n            }\n          }\n        }\n        function popProvider(context, providerFiber) {\n          var currentValue = valueCursor.current;\n          pop(valueCursor, providerFiber);\n          {\n            {\n              context._currentValue = currentValue;\n            }\n          }\n        }\n        function scheduleContextWorkOnParentPath(parent, renderLanes2, propagationRoot) {\n          var node = parent;\n          while (node !== null) {\n            var alternate = node.alternate;\n            if (!isSubsetOfLanes(node.childLanes, renderLanes2)) {\n              node.childLanes = mergeLanes(node.childLanes, renderLanes2);\n              if (alternate !== null) {\n                alternate.childLanes = mergeLanes(alternate.childLanes, renderLanes2);\n              }\n            } else if (alternate !== null && !isSubsetOfLanes(alternate.childLanes, renderLanes2)) {\n              alternate.childLanes = mergeLanes(alternate.childLanes, renderLanes2);\n            }\n            if (node === propagationRoot) {\n              break;\n            }\n            node = node.return;\n          }\n          {\n            if (node !== propagationRoot) {\n              error(\"Expected to find the propagation root when scheduling context work. This error is likely caused by a bug in React. Please file an issue.\");\n            }\n          }\n        }\n        function propagateContextChange(workInProgress2, context, renderLanes2) {\n          {\n            propagateContextChange_eager(workInProgress2, context, renderLanes2);\n          }\n        }\n        function propagateContextChange_eager(workInProgress2, context, renderLanes2) {\n          var fiber = workInProgress2.child;\n          if (fiber !== null) {\n            fiber.return = workInProgress2;\n          }\n          while (fiber !== null) {\n            var nextFiber = void 0;\n            var list = fiber.dependencies;\n            if (list !== null) {\n              nextFiber = fiber.child;\n              var dependency = list.firstContext;\n              while (dependency !== null) {\n                if (dependency.context === context) {\n                  if (fiber.tag === ClassComponent) {\n                    var lane = pickArbitraryLane(renderLanes2);\n                    var update = createUpdate(NoTimestamp, lane);\n                    update.tag = ForceUpdate;\n                    var updateQueue = fiber.updateQueue;\n                    if (updateQueue === null)\n                      ;\n                    else {\n                      var sharedQueue = updateQueue.shared;\n                      var pending = sharedQueue.pending;\n                      if (pending === null) {\n                        update.next = update;\n                      } else {\n                        update.next = pending.next;\n                        pending.next = update;\n                      }\n                      sharedQueue.pending = update;\n                    }\n                  }\n                  fiber.lanes = mergeLanes(fiber.lanes, renderLanes2);\n                  var alternate = fiber.alternate;\n                  if (alternate !== null) {\n                    alternate.lanes = mergeLanes(alternate.lanes, renderLanes2);\n                  }\n                  scheduleContextWorkOnParentPath(fiber.return, renderLanes2, workInProgress2);\n                  list.lanes = mergeLanes(list.lanes, renderLanes2);\n                  break;\n                }\n                dependency = dependency.next;\n              }\n            } else if (fiber.tag === ContextProvider) {\n              nextFiber = fiber.type === workInProgress2.type ? null : fiber.child;\n            } else if (fiber.tag === DehydratedFragment) {\n              var parentSuspense = fiber.return;\n              if (parentSuspense === null) {\n                throw new Error(\"We just came from a parent so we must have had a parent. This is a bug in React.\");\n              }\n              parentSuspense.lanes = mergeLanes(parentSuspense.lanes, renderLanes2);\n              var _alternate = parentSuspense.alternate;\n              if (_alternate !== null) {\n                _alternate.lanes = mergeLanes(_alternate.lanes, renderLanes2);\n              }\n              scheduleContextWorkOnParentPath(parentSuspense, renderLanes2, workInProgress2);\n              nextFiber = fiber.sibling;\n            } else {\n              nextFiber = fiber.child;\n            }\n            if (nextFiber !== null) {\n              nextFiber.return = fiber;\n            } else {\n              nextFiber = fiber;\n              while (nextFiber !== null) {\n                if (nextFiber === workInProgress2) {\n                  nextFiber = null;\n                  break;\n                }\n                var sibling = nextFiber.sibling;\n                if (sibling !== null) {\n                  sibling.return = nextFiber.return;\n                  nextFiber = sibling;\n                  break;\n                }\n                nextFiber = nextFiber.return;\n              }\n            }\n            fiber = nextFiber;\n          }\n        }\n        function prepareToReadContext(workInProgress2, renderLanes2) {\n          currentlyRenderingFiber = workInProgress2;\n          lastContextDependency = null;\n          lastFullyObservedContext = null;\n          var dependencies = workInProgress2.dependencies;\n          if (dependencies !== null) {\n            {\n              var firstContext = dependencies.firstContext;\n              if (firstContext !== null) {\n                if (includesSomeLane(dependencies.lanes, renderLanes2)) {\n                  markWorkInProgressReceivedUpdate();\n                }\n                dependencies.firstContext = null;\n              }\n            }\n          }\n        }\n        function readContext(context) {\n          {\n            if (isDisallowedContextReadInDEV) {\n              error(\"Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().\");\n            }\n          }\n          var value = context._currentValue;\n          if (lastFullyObservedContext === context)\n            ;\n          else {\n            var contextItem = {\n              context,\n              memoizedValue: value,\n              next: null\n            };\n            if (lastContextDependency === null) {\n              if (currentlyRenderingFiber === null) {\n                throw new Error(\"Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().\");\n              }\n              lastContextDependency = contextItem;\n              currentlyRenderingFiber.dependencies = {\n                lanes: NoLanes,\n                firstContext: contextItem\n              };\n            } else {\n              lastContextDependency = lastContextDependency.next = contextItem;\n            }\n          }\n          return value;\n        }\n        var concurrentQueues = null;\n        function pushConcurrentUpdateQueue(queue) {\n          if (concurrentQueues === null) {\n            concurrentQueues = [queue];\n          } else {\n            concurrentQueues.push(queue);\n          }\n        }\n        function finishQueueingConcurrentUpdates() {\n          if (concurrentQueues !== null) {\n            for (var i = 0; i < concurrentQueues.length; i++) {\n              var queue = concurrentQueues[i];\n              var lastInterleavedUpdate = queue.interleaved;\n              if (lastInterleavedUpdate !== null) {\n                queue.interleaved = null;\n                var firstInterleavedUpdate = lastInterleavedUpdate.next;\n                var lastPendingUpdate = queue.pending;\n                if (lastPendingUpdate !== null) {\n                  var firstPendingUpdate = lastPendingUpdate.next;\n                  lastPendingUpdate.next = firstInterleavedUpdate;\n                  lastInterleavedUpdate.next = firstPendingUpdate;\n                }\n                queue.pending = lastInterleavedUpdate;\n              }\n            }\n            concurrentQueues = null;\n          }\n        }\n        function enqueueConcurrentHookUpdate(fiber, queue, update, lane) {\n          var interleaved = queue.interleaved;\n          if (interleaved === null) {\n            update.next = update;\n            pushConcurrentUpdateQueue(queue);\n          } else {\n            update.next = interleaved.next;\n            interleaved.next = update;\n          }\n          queue.interleaved = update;\n          return markUpdateLaneFromFiberToRoot(fiber, lane);\n        }\n        function enqueueConcurrentHookUpdateAndEagerlyBailout(fiber, queue, update, lane) {\n          var interleaved = queue.interleaved;\n          if (interleaved === null) {\n            update.next = update;\n            pushConcurrentUpdateQueue(queue);\n          } else {\n            update.next = interleaved.next;\n            interleaved.next = update;\n          }\n          queue.interleaved = update;\n        }\n        function enqueueConcurrentClassUpdate(fiber, queue, update, lane) {\n          var interleaved = queue.interleaved;\n          if (interleaved === null) {\n            update.next = update;\n            pushConcurrentUpdateQueue(queue);\n          } else {\n            update.next = interleaved.next;\n            interleaved.next = update;\n          }\n          queue.interleaved = update;\n          return markUpdateLaneFromFiberToRoot(fiber, lane);\n        }\n        function enqueueConcurrentRenderForLane(fiber, lane) {\n          return markUpdateLaneFromFiberToRoot(fiber, lane);\n        }\n        var unsafe_markUpdateLaneFromFiberToRoot = markUpdateLaneFromFiberToRoot;\n        function markUpdateLaneFromFiberToRoot(sourceFiber, lane) {\n          sourceFiber.lanes = mergeLanes(sourceFiber.lanes, lane);\n          var alternate = sourceFiber.alternate;\n          if (alternate !== null) {\n            alternate.lanes = mergeLanes(alternate.lanes, lane);\n          }\n          {\n            if (alternate === null && (sourceFiber.flags & (Placement | Hydrating)) !== NoFlags) {\n              warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);\n            }\n          }\n          var node = sourceFiber;\n          var parent = sourceFiber.return;\n          while (parent !== null) {\n            parent.childLanes = mergeLanes(parent.childLanes, lane);\n            alternate = parent.alternate;\n            if (alternate !== null) {\n              alternate.childLanes = mergeLanes(alternate.childLanes, lane);\n            } else {\n              {\n                if ((parent.flags & (Placement | Hydrating)) !== NoFlags) {\n                  warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);\n                }\n              }\n            }\n            node = parent;\n            parent = parent.return;\n          }\n          if (node.tag === HostRoot) {\n            var root2 = node.stateNode;\n            return root2;\n          } else {\n            return null;\n          }\n        }\n        var UpdateState = 0;\n        var ReplaceState = 1;\n        var ForceUpdate = 2;\n        var CaptureUpdate = 3;\n        var hasForceUpdate = false;\n        var didWarnUpdateInsideUpdate;\n        var currentlyProcessingQueue;\n        {\n          didWarnUpdateInsideUpdate = false;\n          currentlyProcessingQueue = null;\n        }\n        function initializeUpdateQueue(fiber) {\n          var queue = {\n            baseState: fiber.memoizedState,\n            firstBaseUpdate: null,\n            lastBaseUpdate: null,\n            shared: {\n              pending: null,\n              interleaved: null,\n              lanes: NoLanes\n            },\n            effects: null\n          };\n          fiber.updateQueue = queue;\n        }\n        function cloneUpdateQueue(current2, workInProgress2) {\n          var queue = workInProgress2.updateQueue;\n          var currentQueue = current2.updateQueue;\n          if (queue === currentQueue) {\n            var clone = {\n              baseState: currentQueue.baseState,\n              firstBaseUpdate: currentQueue.firstBaseUpdate,\n              lastBaseUpdate: currentQueue.lastBaseUpdate,\n              shared: currentQueue.shared,\n              effects: currentQueue.effects\n            };\n            workInProgress2.updateQueue = clone;\n          }\n        }\n        function createUpdate(eventTime, lane) {\n          var update = {\n            eventTime,\n            lane,\n            tag: UpdateState,\n            payload: null,\n            callback: null,\n            next: null\n          };\n          return update;\n        }\n        function enqueueUpdate(fiber, update, lane) {\n          var updateQueue = fiber.updateQueue;\n          if (updateQueue === null) {\n            return null;\n          }\n          var sharedQueue = updateQueue.shared;\n          {\n            if (currentlyProcessingQueue === sharedQueue && !didWarnUpdateInsideUpdate) {\n              error(\"An update (setState, replaceState, or forceUpdate) was scheduled from inside an update function. Update functions should be pure, with zero side-effects. Consider using componentDidUpdate or a callback.\");\n              didWarnUpdateInsideUpdate = true;\n            }\n          }\n          if (isUnsafeClassRenderPhaseUpdate()) {\n            var pending = sharedQueue.pending;\n            if (pending === null) {\n              update.next = update;\n            } else {\n              update.next = pending.next;\n              pending.next = update;\n            }\n            sharedQueue.pending = update;\n            return unsafe_markUpdateLaneFromFiberToRoot(fiber, lane);\n          } else {\n            return enqueueConcurrentClassUpdate(fiber, sharedQueue, update, lane);\n          }\n        }\n        function entangleTransitions(root2, fiber, lane) {\n          var updateQueue = fiber.updateQueue;\n          if (updateQueue === null) {\n            return;\n          }\n          var sharedQueue = updateQueue.shared;\n          if (isTransitionLane(lane)) {\n            var queueLanes = sharedQueue.lanes;\n            queueLanes = intersectLanes(queueLanes, root2.pendingLanes);\n            var newQueueLanes = mergeLanes(queueLanes, lane);\n            sharedQueue.lanes = newQueueLanes;\n            markRootEntangled(root2, newQueueLanes);\n          }\n        }\n        function enqueueCapturedUpdate(workInProgress2, capturedUpdate) {\n          var queue = workInProgress2.updateQueue;\n          var current2 = workInProgress2.alternate;\n          if (current2 !== null) {\n            var currentQueue = current2.updateQueue;\n            if (queue === currentQueue) {\n              var newFirst = null;\n              var newLast = null;\n              var firstBaseUpdate = queue.firstBaseUpdate;\n              if (firstBaseUpdate !== null) {\n                var update = firstBaseUpdate;\n                do {\n                  var clone = {\n                    eventTime: update.eventTime,\n                    lane: update.lane,\n                    tag: update.tag,\n                    payload: update.payload,\n                    callback: update.callback,\n                    next: null\n                  };\n                  if (newLast === null) {\n                    newFirst = newLast = clone;\n                  } else {\n                    newLast.next = clone;\n                    newLast = clone;\n                  }\n                  update = update.next;\n                } while (update !== null);\n                if (newLast === null) {\n                  newFirst = newLast = capturedUpdate;\n                } else {\n                  newLast.next = capturedUpdate;\n                  newLast = capturedUpdate;\n                }\n              } else {\n                newFirst = newLast = capturedUpdate;\n              }\n              queue = {\n                baseState: currentQueue.baseState,\n                firstBaseUpdate: newFirst,\n                lastBaseUpdate: newLast,\n                shared: currentQueue.shared,\n                effects: currentQueue.effects\n              };\n              workInProgress2.updateQueue = queue;\n              return;\n            }\n          }\n          var lastBaseUpdate = queue.lastBaseUpdate;\n          if (lastBaseUpdate === null) {\n            queue.firstBaseUpdate = capturedUpdate;\n          } else {\n            lastBaseUpdate.next = capturedUpdate;\n          }\n          queue.lastBaseUpdate = capturedUpdate;\n        }\n        function getStateFromUpdate(workInProgress2, queue, update, prevState, nextProps, instance) {\n          switch (update.tag) {\n            case ReplaceState: {\n              var payload = update.payload;\n              if (typeof payload === \"function\") {\n                {\n                  enterDisallowedContextReadInDEV();\n                }\n                var nextState = payload.call(instance, prevState, nextProps);\n                {\n                  if (workInProgress2.mode & StrictLegacyMode) {\n                    setIsStrictModeForDevtools(true);\n                    try {\n                      payload.call(instance, prevState, nextProps);\n                    } finally {\n                      setIsStrictModeForDevtools(false);\n                    }\n                  }\n                  exitDisallowedContextReadInDEV();\n                }\n                return nextState;\n              }\n              return payload;\n            }\n            case CaptureUpdate: {\n              workInProgress2.flags = workInProgress2.flags & ~ShouldCapture | DidCapture;\n            }\n            case UpdateState: {\n              var _payload = update.payload;\n              var partialState;\n              if (typeof _payload === \"function\") {\n                {\n                  enterDisallowedContextReadInDEV();\n                }\n                partialState = _payload.call(instance, prevState, nextProps);\n                {\n                  if (workInProgress2.mode & StrictLegacyMode) {\n                    setIsStrictModeForDevtools(true);\n                    try {\n                      _payload.call(instance, prevState, nextProps);\n                    } finally {\n                      setIsStrictModeForDevtools(false);\n                    }\n                  }\n                  exitDisallowedContextReadInDEV();\n                }\n              } else {\n                partialState = _payload;\n              }\n              if (partialState === null || partialState === void 0) {\n                return prevState;\n              }\n              return assign({}, prevState, partialState);\n            }\n            case ForceUpdate: {\n              hasForceUpdate = true;\n              return prevState;\n            }\n          }\n          return prevState;\n        }\n        function processUpdateQueue(workInProgress2, props, instance, renderLanes2) {\n          var queue = workInProgress2.updateQueue;\n          hasForceUpdate = false;\n          {\n            currentlyProcessingQueue = queue.shared;\n          }\n          var firstBaseUpdate = queue.firstBaseUpdate;\n          var lastBaseUpdate = queue.lastBaseUpdate;\n          var pendingQueue = queue.shared.pending;\n          if (pendingQueue !== null) {\n            queue.shared.pending = null;\n            var lastPendingUpdate = pendingQueue;\n            var firstPendingUpdate = lastPendingUpdate.next;\n            lastPendingUpdate.next = null;\n            if (lastBaseUpdate === null) {\n              firstBaseUpdate = firstPendingUpdate;\n            } else {\n              lastBaseUpdate.next = firstPendingUpdate;\n            }\n            lastBaseUpdate = lastPendingUpdate;\n            var current2 = workInProgress2.alternate;\n            if (current2 !== null) {\n              var currentQueue = current2.updateQueue;\n              var currentLastBaseUpdate = currentQueue.lastBaseUpdate;\n              if (currentLastBaseUpdate !== lastBaseUpdate) {\n                if (currentLastBaseUpdate === null) {\n                  currentQueue.firstBaseUpdate = firstPendingUpdate;\n                } else {\n                  currentLastBaseUpdate.next = firstPendingUpdate;\n                }\n                currentQueue.lastBaseUpdate = lastPendingUpdate;\n              }\n            }\n          }\n          if (firstBaseUpdate !== null) {\n            var newState = queue.baseState;\n            var newLanes = NoLanes;\n            var newBaseState = null;\n            var newFirstBaseUpdate = null;\n            var newLastBaseUpdate = null;\n            var update = firstBaseUpdate;\n            do {\n              var updateLane = update.lane;\n              var updateEventTime = update.eventTime;\n              if (!isSubsetOfLanes(renderLanes2, updateLane)) {\n                var clone = {\n                  eventTime: updateEventTime,\n                  lane: updateLane,\n                  tag: update.tag,\n                  payload: update.payload,\n                  callback: update.callback,\n                  next: null\n                };\n                if (newLastBaseUpdate === null) {\n                  newFirstBaseUpdate = newLastBaseUpdate = clone;\n                  newBaseState = newState;\n                } else {\n                  newLastBaseUpdate = newLastBaseUpdate.next = clone;\n                }\n                newLanes = mergeLanes(newLanes, updateLane);\n              } else {\n                if (newLastBaseUpdate !== null) {\n                  var _clone = {\n                    eventTime: updateEventTime,\n                    // This update is going to be committed so we never want uncommit\n                    // it. Using NoLane works because 0 is a subset of all bitmasks, so\n                    // this will never be skipped by the check above.\n                    lane: NoLane,\n                    tag: update.tag,\n                    payload: update.payload,\n                    callback: update.callback,\n                    next: null\n                  };\n                  newLastBaseUpdate = newLastBaseUpdate.next = _clone;\n                }\n                newState = getStateFromUpdate(workInProgress2, queue, update, newState, props, instance);\n                var callback = update.callback;\n                if (callback !== null && // If the update was already committed, we should not queue its\n                // callback again.\n                update.lane !== NoLane) {\n                  workInProgress2.flags |= Callback;\n                  var effects = queue.effects;\n                  if (effects === null) {\n                    queue.effects = [update];\n                  } else {\n                    effects.push(update);\n                  }\n                }\n              }\n              update = update.next;\n              if (update === null) {\n                pendingQueue = queue.shared.pending;\n                if (pendingQueue === null) {\n                  break;\n                } else {\n                  var _lastPendingUpdate = pendingQueue;\n                  var _firstPendingUpdate = _lastPendingUpdate.next;\n                  _lastPendingUpdate.next = null;\n                  update = _firstPendingUpdate;\n                  queue.lastBaseUpdate = _lastPendingUpdate;\n                  queue.shared.pending = null;\n                }\n              }\n            } while (true);\n            if (newLastBaseUpdate === null) {\n              newBaseState = newState;\n            }\n            queue.baseState = newBaseState;\n            queue.firstBaseUpdate = newFirstBaseUpdate;\n            queue.lastBaseUpdate = newLastBaseUpdate;\n            var lastInterleaved = queue.shared.interleaved;\n            if (lastInterleaved !== null) {\n              var interleaved = lastInterleaved;\n              do {\n                newLanes = mergeLanes(newLanes, interleaved.lane);\n                interleaved = interleaved.next;\n              } while (interleaved !== lastInterleaved);\n            } else if (firstBaseUpdate === null) {\n              queue.shared.lanes = NoLanes;\n            }\n            markSkippedUpdateLanes(newLanes);\n            workInProgress2.lanes = newLanes;\n            workInProgress2.memoizedState = newState;\n          }\n          {\n            currentlyProcessingQueue = null;\n          }\n        }\n        function callCallback(callback, context) {\n          if (typeof callback !== \"function\") {\n            throw new Error(\"Invalid argument passed as callback. Expected a function. Instead \" + (\"received: \" + callback));\n          }\n          callback.call(context);\n        }\n        function resetHasForceUpdateBeforeProcessing() {\n          hasForceUpdate = false;\n        }\n        function checkHasForceUpdateAfterProcessing() {\n          return hasForceUpdate;\n        }\n        function commitUpdateQueue(finishedWork, finishedQueue, instance) {\n          var effects = finishedQueue.effects;\n          finishedQueue.effects = null;\n          if (effects !== null) {\n            for (var i = 0; i < effects.length; i++) {\n              var effect = effects[i];\n              var callback = effect.callback;\n              if (callback !== null) {\n                effect.callback = null;\n                callCallback(callback, instance);\n              }\n            }\n          }\n        }\n        var fakeInternalInstance = {};\n        var emptyRefsObject = new React.Component().refs;\n        var didWarnAboutStateAssignmentForComponent;\n        var didWarnAboutUninitializedState;\n        var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate;\n        var didWarnAboutLegacyLifecyclesAndDerivedState;\n        var didWarnAboutUndefinedDerivedState;\n        var warnOnUndefinedDerivedState;\n        var warnOnInvalidCallback;\n        var didWarnAboutDirectlyAssigningPropsToState;\n        var didWarnAboutContextTypeAndContextTypes;\n        var didWarnAboutInvalidateContextType;\n        {\n          didWarnAboutStateAssignmentForComponent = /* @__PURE__ */ new Set();\n          didWarnAboutUninitializedState = /* @__PURE__ */ new Set();\n          didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = /* @__PURE__ */ new Set();\n          didWarnAboutLegacyLifecyclesAndDerivedState = /* @__PURE__ */ new Set();\n          didWarnAboutDirectlyAssigningPropsToState = /* @__PURE__ */ new Set();\n          didWarnAboutUndefinedDerivedState = /* @__PURE__ */ new Set();\n          didWarnAboutContextTypeAndContextTypes = /* @__PURE__ */ new Set();\n          didWarnAboutInvalidateContextType = /* @__PURE__ */ new Set();\n          var didWarnOnInvalidCallback = /* @__PURE__ */ new Set();\n          warnOnInvalidCallback = function(callback, callerName) {\n            if (callback === null || typeof callback === \"function\") {\n              return;\n            }\n            var key = callerName + \"_\" + callback;\n            if (!didWarnOnInvalidCallback.has(key)) {\n              didWarnOnInvalidCallback.add(key);\n              error(\"%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.\", callerName, callback);\n            }\n          };\n          warnOnUndefinedDerivedState = function(type, partialState) {\n            if (partialState === void 0) {\n              var componentName = getComponentNameFromType(type) || \"Component\";\n              if (!didWarnAboutUndefinedDerivedState.has(componentName)) {\n                didWarnAboutUndefinedDerivedState.add(componentName);\n                error(\"%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.\", componentName);\n              }\n            }\n          };\n          Object.defineProperty(fakeInternalInstance, \"_processChildContext\", {\n            enumerable: false,\n            value: function() {\n              throw new Error(\"_processChildContext is not available in React 16+. This likely means you have multiple copies of React and are attempting to nest a React 15 tree inside a React 16 tree using unstable_renderSubtreeIntoContainer, which isn't supported. Try to make sure you have only one copy of React (and ideally, switch to ReactDOM.createPortal).\");\n            }\n          });\n          Object.freeze(fakeInternalInstance);\n        }\n        function applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, nextProps) {\n          var prevState = workInProgress2.memoizedState;\n          var partialState = getDerivedStateFromProps(nextProps, prevState);\n          {\n            if (workInProgress2.mode & StrictLegacyMode) {\n              setIsStrictModeForDevtools(true);\n              try {\n                partialState = getDerivedStateFromProps(nextProps, prevState);\n              } finally {\n                setIsStrictModeForDevtools(false);\n              }\n            }\n            warnOnUndefinedDerivedState(ctor, partialState);\n          }\n          var memoizedState = partialState === null || partialState === void 0 ? prevState : assign({}, prevState, partialState);\n          workInProgress2.memoizedState = memoizedState;\n          if (workInProgress2.lanes === NoLanes) {\n            var updateQueue = workInProgress2.updateQueue;\n            updateQueue.baseState = memoizedState;\n          }\n        }\n        var classComponentUpdater = {\n          isMounted,\n          enqueueSetState: function(inst, payload, callback) {\n            var fiber = get(inst);\n            var eventTime = requestEventTime();\n            var lane = requestUpdateLane(fiber);\n            var update = createUpdate(eventTime, lane);\n            update.payload = payload;\n            if (callback !== void 0 && callback !== null) {\n              {\n                warnOnInvalidCallback(callback, \"setState\");\n              }\n              update.callback = callback;\n            }\n            var root2 = enqueueUpdate(fiber, update, lane);\n            if (root2 !== null) {\n              scheduleUpdateOnFiber(root2, fiber, lane, eventTime);\n              entangleTransitions(root2, fiber, lane);\n            }\n            {\n              markStateUpdateScheduled(fiber, lane);\n            }\n          },\n          enqueueReplaceState: function(inst, payload, callback) {\n            var fiber = get(inst);\n            var eventTime = requestEventTime();\n            var lane = requestUpdateLane(fiber);\n            var update = createUpdate(eventTime, lane);\n            update.tag = ReplaceState;\n            update.payload = payload;\n            if (callback !== void 0 && callback !== null) {\n              {\n                warnOnInvalidCallback(callback, \"replaceState\");\n              }\n              update.callback = callback;\n            }\n            var root2 = enqueueUpdate(fiber, update, lane);\n            if (root2 !== null) {\n              scheduleUpdateOnFiber(root2, fiber, lane, eventTime);\n              entangleTransitions(root2, fiber, lane);\n            }\n            {\n              markStateUpdateScheduled(fiber, lane);\n            }\n          },\n          enqueueForceUpdate: function(inst, callback) {\n            var fiber = get(inst);\n            var eventTime = requestEventTime();\n            var lane = requestUpdateLane(fiber);\n            var update = createUpdate(eventTime, lane);\n            update.tag = ForceUpdate;\n            if (callback !== void 0 && callback !== null) {\n              {\n                warnOnInvalidCallback(callback, \"forceUpdate\");\n              }\n              update.callback = callback;\n            }\n            var root2 = enqueueUpdate(fiber, update, lane);\n            if (root2 !== null) {\n              scheduleUpdateOnFiber(root2, fiber, lane, eventTime);\n              entangleTransitions(root2, fiber, lane);\n            }\n            {\n              markForceUpdateScheduled(fiber, lane);\n            }\n          }\n        };\n        function checkShouldComponentUpdate(workInProgress2, ctor, oldProps, newProps, oldState, newState, nextContext) {\n          var instance = workInProgress2.stateNode;\n          if (typeof instance.shouldComponentUpdate === \"function\") {\n            var shouldUpdate = instance.shouldComponentUpdate(newProps, newState, nextContext);\n            {\n              if (workInProgress2.mode & StrictLegacyMode) {\n                setIsStrictModeForDevtools(true);\n                try {\n                  shouldUpdate = instance.shouldComponentUpdate(newProps, newState, nextContext);\n                } finally {\n                  setIsStrictModeForDevtools(false);\n                }\n              }\n              if (shouldUpdate === void 0) {\n                error(\"%s.shouldComponentUpdate(): Returned undefined instead of a boolean value. Make sure to return true or false.\", getComponentNameFromType(ctor) || \"Component\");\n              }\n            }\n            return shouldUpdate;\n          }\n          if (ctor.prototype && ctor.prototype.isPureReactComponent) {\n            return !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState);\n          }\n          return true;\n        }\n        function checkClassInstance(workInProgress2, ctor, newProps) {\n          var instance = workInProgress2.stateNode;\n          {\n            var name = getComponentNameFromType(ctor) || \"Component\";\n            var renderPresent = instance.render;\n            if (!renderPresent) {\n              if (ctor.prototype && typeof ctor.prototype.render === \"function\") {\n                error(\"%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?\", name);\n              } else {\n                error(\"%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.\", name);\n              }\n            }\n            if (instance.getInitialState && !instance.getInitialState.isReactClassApproved && !instance.state) {\n              error(\"getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?\", name);\n            }\n            if (instance.getDefaultProps && !instance.getDefaultProps.isReactClassApproved) {\n              error(\"getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.\", name);\n            }\n            if (instance.propTypes) {\n              error(\"propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.\", name);\n            }\n            if (instance.contextType) {\n              error(\"contextType was defined as an instance property on %s. Use a static property to define contextType instead.\", name);\n            }\n            {\n              if (instance.contextTypes) {\n                error(\"contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.\", name);\n              }\n              if (ctor.contextType && ctor.contextTypes && !didWarnAboutContextTypeAndContextTypes.has(ctor)) {\n                didWarnAboutContextTypeAndContextTypes.add(ctor);\n                error(\"%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.\", name);\n              }\n            }\n            if (typeof instance.componentShouldUpdate === \"function\") {\n              error(\"%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.\", name);\n            }\n            if (ctor.prototype && ctor.prototype.isPureReactComponent && typeof instance.shouldComponentUpdate !== \"undefined\") {\n              error(\"%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.\", getComponentNameFromType(ctor) || \"A pure component\");\n            }\n            if (typeof instance.componentDidUnmount === \"function\") {\n              error(\"%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?\", name);\n            }\n            if (typeof instance.componentDidReceiveProps === \"function\") {\n              error(\"%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().\", name);\n            }\n            if (typeof instance.componentWillRecieveProps === \"function\") {\n              error(\"%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?\", name);\n            }\n            if (typeof instance.UNSAFE_componentWillRecieveProps === \"function\") {\n              error(\"%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?\", name);\n            }\n            var hasMutatedProps = instance.props !== newProps;\n            if (instance.props !== void 0 && hasMutatedProps) {\n              error(\"%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.\", name, name);\n            }\n            if (instance.defaultProps) {\n              error(\"Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.\", name, name);\n            }\n            if (typeof instance.getSnapshotBeforeUpdate === \"function\" && typeof instance.componentDidUpdate !== \"function\" && !didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor)) {\n              didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor);\n              error(\"%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.\", getComponentNameFromType(ctor));\n            }\n            if (typeof instance.getDerivedStateFromProps === \"function\") {\n              error(\"%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.\", name);\n            }\n            if (typeof instance.getDerivedStateFromError === \"function\") {\n              error(\"%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.\", name);\n            }\n            if (typeof ctor.getSnapshotBeforeUpdate === \"function\") {\n              error(\"%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.\", name);\n            }\n            var _state = instance.state;\n            if (_state && (typeof _state !== \"object\" || isArray(_state))) {\n              error(\"%s.state: must be set to an object or null\", name);\n            }\n            if (typeof instance.getChildContext === \"function\" && typeof ctor.childContextTypes !== \"object\") {\n              error(\"%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().\", name);\n            }\n          }\n        }\n        function adoptClassInstance(workInProgress2, instance) {\n          instance.updater = classComponentUpdater;\n          workInProgress2.stateNode = instance;\n          set(instance, workInProgress2);\n          {\n            instance._reactInternalInstance = fakeInternalInstance;\n          }\n        }\n        function constructClassInstance(workInProgress2, ctor, props) {\n          var isLegacyContextConsumer = false;\n          var unmaskedContext = emptyContextObject;\n          var context = emptyContextObject;\n          var contextType = ctor.contextType;\n          {\n            if (\"contextType\" in ctor) {\n              var isValid = (\n                // Allow null for conditional declaration\n                contextType === null || contextType !== void 0 && contextType.$$typeof === REACT_CONTEXT_TYPE && contextType._context === void 0\n              );\n              if (!isValid && !didWarnAboutInvalidateContextType.has(ctor)) {\n                didWarnAboutInvalidateContextType.add(ctor);\n                var addendum = \"\";\n                if (contextType === void 0) {\n                  addendum = \" However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file.\";\n                } else if (typeof contextType !== \"object\") {\n                  addendum = \" However, it is set to a \" + typeof contextType + \".\";\n                } else if (contextType.$$typeof === REACT_PROVIDER_TYPE) {\n                  addendum = \" Did you accidentally pass the Context.Provider instead?\";\n                } else if (contextType._context !== void 0) {\n                  addendum = \" Did you accidentally pass the Context.Consumer instead?\";\n                } else {\n                  addendum = \" However, it is set to an object with keys {\" + Object.keys(contextType).join(\", \") + \"}.\";\n                }\n                error(\"%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s\", getComponentNameFromType(ctor) || \"Component\", addendum);\n              }\n            }\n          }\n          if (typeof contextType === \"object\" && contextType !== null) {\n            context = readContext(contextType);\n          } else {\n            unmaskedContext = getUnmaskedContext(workInProgress2, ctor, true);\n            var contextTypes = ctor.contextTypes;\n            isLegacyContextConsumer = contextTypes !== null && contextTypes !== void 0;\n            context = isLegacyContextConsumer ? getMaskedContext(workInProgress2, unmaskedContext) : emptyContextObject;\n          }\n          var instance = new ctor(props, context);\n          {\n            if (workInProgress2.mode & StrictLegacyMode) {\n              setIsStrictModeForDevtools(true);\n              try {\n                instance = new ctor(props, context);\n              } finally {\n                setIsStrictModeForDevtools(false);\n              }\n            }\n          }\n          var state = workInProgress2.memoizedState = instance.state !== null && instance.state !== void 0 ? instance.state : null;\n          adoptClassInstance(workInProgress2, instance);\n          {\n            if (typeof ctor.getDerivedStateFromProps === \"function\" && state === null) {\n              var componentName = getComponentNameFromType(ctor) || \"Component\";\n              if (!didWarnAboutUninitializedState.has(componentName)) {\n                didWarnAboutUninitializedState.add(componentName);\n                error(\"`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.\", componentName, instance.state === null ? \"null\" : \"undefined\", componentName);\n              }\n            }\n            if (typeof ctor.getDerivedStateFromProps === \"function\" || typeof instance.getSnapshotBeforeUpdate === \"function\") {\n              var foundWillMountName = null;\n              var foundWillReceivePropsName = null;\n              var foundWillUpdateName = null;\n              if (typeof instance.componentWillMount === \"function\" && instance.componentWillMount.__suppressDeprecationWarning !== true) {\n                foundWillMountName = \"componentWillMount\";\n              } else if (typeof instance.UNSAFE_componentWillMount === \"function\") {\n                foundWillMountName = \"UNSAFE_componentWillMount\";\n              }\n              if (typeof instance.componentWillReceiveProps === \"function\" && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {\n                foundWillReceivePropsName = \"componentWillReceiveProps\";\n              } else if (typeof instance.UNSAFE_componentWillReceiveProps === \"function\") {\n                foundWillReceivePropsName = \"UNSAFE_componentWillReceiveProps\";\n              }\n              if (typeof instance.componentWillUpdate === \"function\" && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {\n                foundWillUpdateName = \"componentWillUpdate\";\n              } else if (typeof instance.UNSAFE_componentWillUpdate === \"function\") {\n                foundWillUpdateName = \"UNSAFE_componentWillUpdate\";\n              }\n              if (foundWillMountName !== null || foundWillReceivePropsName !== null || foundWillUpdateName !== null) {\n                var _componentName = getComponentNameFromType(ctor) || \"Component\";\n                var newApiName = typeof ctor.getDerivedStateFromProps === \"function\" ? \"getDerivedStateFromProps()\" : \"getSnapshotBeforeUpdate()\";\n                if (!didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName)) {\n                  didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName);\n                  error(\"Unsafe legacy lifecycles will not be called for components using new component APIs.\\n\\n%s uses %s but also contains the following legacy lifecycles:%s%s%s\\n\\nThe above lifecycles should be removed. Learn more about this warning here:\\nhttps://reactjs.org/link/unsafe-component-lifecycles\", _componentName, newApiName, foundWillMountName !== null ? \"\\n  \" + foundWillMountName : \"\", foundWillReceivePropsName !== null ? \"\\n  \" + foundWillReceivePropsName : \"\", foundWillUpdateName !== null ? \"\\n  \" + foundWillUpdateName : \"\");\n                }\n              }\n            }\n          }\n          if (isLegacyContextConsumer) {\n            cacheContext(workInProgress2, unmaskedContext, context);\n          }\n          return instance;\n        }\n        function callComponentWillMount(workInProgress2, instance) {\n          var oldState = instance.state;\n          if (typeof instance.componentWillMount === \"function\") {\n            instance.componentWillMount();\n          }\n          if (typeof instance.UNSAFE_componentWillMount === \"function\") {\n            instance.UNSAFE_componentWillMount();\n          }\n          if (oldState !== instance.state) {\n            {\n              error(\"%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.\", getComponentNameFromFiber(workInProgress2) || \"Component\");\n            }\n            classComponentUpdater.enqueueReplaceState(instance, instance.state, null);\n          }\n        }\n        function callComponentWillReceiveProps(workInProgress2, instance, newProps, nextContext) {\n          var oldState = instance.state;\n          if (typeof instance.componentWillReceiveProps === \"function\") {\n            instance.componentWillReceiveProps(newProps, nextContext);\n          }\n          if (typeof instance.UNSAFE_componentWillReceiveProps === \"function\") {\n            instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);\n          }\n          if (instance.state !== oldState) {\n            {\n              var componentName = getComponentNameFromFiber(workInProgress2) || \"Component\";\n              if (!didWarnAboutStateAssignmentForComponent.has(componentName)) {\n                didWarnAboutStateAssignmentForComponent.add(componentName);\n                error(\"%s.componentWillReceiveProps(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.\", componentName);\n              }\n            }\n            classComponentUpdater.enqueueReplaceState(instance, instance.state, null);\n          }\n        }\n        function mountClassInstance(workInProgress2, ctor, newProps, renderLanes2) {\n          {\n            checkClassInstance(workInProgress2, ctor, newProps);\n          }\n          var instance = workInProgress2.stateNode;\n          instance.props = newProps;\n          instance.state = workInProgress2.memoizedState;\n          instance.refs = emptyRefsObject;\n          initializeUpdateQueue(workInProgress2);\n          var contextType = ctor.contextType;\n          if (typeof contextType === \"object\" && contextType !== null) {\n            instance.context = readContext(contextType);\n          } else {\n            var unmaskedContext = getUnmaskedContext(workInProgress2, ctor, true);\n            instance.context = getMaskedContext(workInProgress2, unmaskedContext);\n          }\n          {\n            if (instance.state === newProps) {\n              var componentName = getComponentNameFromType(ctor) || \"Component\";\n              if (!didWarnAboutDirectlyAssigningPropsToState.has(componentName)) {\n                didWarnAboutDirectlyAssigningPropsToState.add(componentName);\n                error(\"%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.\", componentName);\n              }\n            }\n            if (workInProgress2.mode & StrictLegacyMode) {\n              ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress2, instance);\n            }\n            {\n              ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(workInProgress2, instance);\n            }\n          }\n          instance.state = workInProgress2.memoizedState;\n          var getDerivedStateFromProps = ctor.getDerivedStateFromProps;\n          if (typeof getDerivedStateFromProps === \"function\") {\n            applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, newProps);\n            instance.state = workInProgress2.memoizedState;\n          }\n          if (typeof ctor.getDerivedStateFromProps !== \"function\" && typeof instance.getSnapshotBeforeUpdate !== \"function\" && (typeof instance.UNSAFE_componentWillMount === \"function\" || typeof instance.componentWillMount === \"function\")) {\n            callComponentWillMount(workInProgress2, instance);\n            processUpdateQueue(workInProgress2, newProps, instance, renderLanes2);\n            instance.state = workInProgress2.memoizedState;\n          }\n          if (typeof instance.componentDidMount === \"function\") {\n            var fiberFlags = Update;\n            {\n              fiberFlags |= LayoutStatic;\n            }\n            if ((workInProgress2.mode & StrictEffectsMode) !== NoMode) {\n              fiberFlags |= MountLayoutDev;\n            }\n            workInProgress2.flags |= fiberFlags;\n          }\n        }\n        function resumeMountClassInstance(workInProgress2, ctor, newProps, renderLanes2) {\n          var instance = workInProgress2.stateNode;\n          var oldProps = workInProgress2.memoizedProps;\n          instance.props = oldProps;\n          var oldContext = instance.context;\n          var contextType = ctor.contextType;\n          var nextContext = emptyContextObject;\n          if (typeof contextType === \"object\" && contextType !== null) {\n            nextContext = readContext(contextType);\n          } else {\n            var nextLegacyUnmaskedContext = getUnmaskedContext(workInProgress2, ctor, true);\n            nextContext = getMaskedContext(workInProgress2, nextLegacyUnmaskedContext);\n          }\n          var getDerivedStateFromProps = ctor.getDerivedStateFromProps;\n          var hasNewLifecycles = typeof getDerivedStateFromProps === \"function\" || typeof instance.getSnapshotBeforeUpdate === \"function\";\n          if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillReceiveProps === \"function\" || typeof instance.componentWillReceiveProps === \"function\")) {\n            if (oldProps !== newProps || oldContext !== nextContext) {\n              callComponentWillReceiveProps(workInProgress2, instance, newProps, nextContext);\n            }\n          }\n          resetHasForceUpdateBeforeProcessing();\n          var oldState = workInProgress2.memoizedState;\n          var newState = instance.state = oldState;\n          processUpdateQueue(workInProgress2, newProps, instance, renderLanes2);\n          newState = workInProgress2.memoizedState;\n          if (oldProps === newProps && oldState === newState && !hasContextChanged() && !checkHasForceUpdateAfterProcessing()) {\n            if (typeof instance.componentDidMount === \"function\") {\n              var fiberFlags = Update;\n              {\n                fiberFlags |= LayoutStatic;\n              }\n              if ((workInProgress2.mode & StrictEffectsMode) !== NoMode) {\n                fiberFlags |= MountLayoutDev;\n              }\n              workInProgress2.flags |= fiberFlags;\n            }\n            return false;\n          }\n          if (typeof getDerivedStateFromProps === \"function\") {\n            applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, newProps);\n            newState = workInProgress2.memoizedState;\n          }\n          var shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress2, ctor, oldProps, newProps, oldState, newState, nextContext);\n          if (shouldUpdate) {\n            if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillMount === \"function\" || typeof instance.componentWillMount === \"function\")) {\n              if (typeof instance.componentWillMount === \"function\") {\n                instance.componentWillMount();\n              }\n              if (typeof instance.UNSAFE_componentWillMount === \"function\") {\n                instance.UNSAFE_componentWillMount();\n              }\n            }\n            if (typeof instance.componentDidMount === \"function\") {\n              var _fiberFlags = Update;\n              {\n                _fiberFlags |= LayoutStatic;\n              }\n              if ((workInProgress2.mode & StrictEffectsMode) !== NoMode) {\n                _fiberFlags |= MountLayoutDev;\n              }\n              workInProgress2.flags |= _fiberFlags;\n            }\n          } else {\n            if (typeof instance.componentDidMount === \"function\") {\n              var _fiberFlags2 = Update;\n              {\n                _fiberFlags2 |= LayoutStatic;\n              }\n              if ((workInProgress2.mode & StrictEffectsMode) !== NoMode) {\n                _fiberFlags2 |= MountLayoutDev;\n              }\n              workInProgress2.flags |= _fiberFlags2;\n            }\n            workInProgress2.memoizedProps = newProps;\n            workInProgress2.memoizedState = newState;\n          }\n          instance.props = newProps;\n          instance.state = newState;\n          instance.context = nextContext;\n          return shouldUpdate;\n        }\n        function updateClassInstance(current2, workInProgress2, ctor, newProps, renderLanes2) {\n          var instance = workInProgress2.stateNode;\n          cloneUpdateQueue(current2, workInProgress2);\n          var unresolvedOldProps = workInProgress2.memoizedProps;\n          var oldProps = workInProgress2.type === workInProgress2.elementType ? unresolvedOldProps : resolveDefaultProps(workInProgress2.type, unresolvedOldProps);\n          instance.props = oldProps;\n          var unresolvedNewProps = workInProgress2.pendingProps;\n          var oldContext = instance.context;\n          var contextType = ctor.contextType;\n          var nextContext = emptyContextObject;\n          if (typeof contextType === \"object\" && contextType !== null) {\n            nextContext = readContext(contextType);\n          } else {\n            var nextUnmaskedContext = getUnmaskedContext(workInProgress2, ctor, true);\n            nextContext = getMaskedContext(workInProgress2, nextUnmaskedContext);\n          }\n          var getDerivedStateFromProps = ctor.getDerivedStateFromProps;\n          var hasNewLifecycles = typeof getDerivedStateFromProps === \"function\" || typeof instance.getSnapshotBeforeUpdate === \"function\";\n          if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillReceiveProps === \"function\" || typeof instance.componentWillReceiveProps === \"function\")) {\n            if (unresolvedOldProps !== unresolvedNewProps || oldContext !== nextContext) {\n              callComponentWillReceiveProps(workInProgress2, instance, newProps, nextContext);\n            }\n          }\n          resetHasForceUpdateBeforeProcessing();\n          var oldState = workInProgress2.memoizedState;\n          var newState = instance.state = oldState;\n          processUpdateQueue(workInProgress2, newProps, instance, renderLanes2);\n          newState = workInProgress2.memoizedState;\n          if (unresolvedOldProps === unresolvedNewProps && oldState === newState && !hasContextChanged() && !checkHasForceUpdateAfterProcessing() && !enableLazyContextPropagation) {\n            if (typeof instance.componentDidUpdate === \"function\") {\n              if (unresolvedOldProps !== current2.memoizedProps || oldState !== current2.memoizedState) {\n                workInProgress2.flags |= Update;\n              }\n            }\n            if (typeof instance.getSnapshotBeforeUpdate === \"function\") {\n              if (unresolvedOldProps !== current2.memoizedProps || oldState !== current2.memoizedState) {\n                workInProgress2.flags |= Snapshot;\n              }\n            }\n            return false;\n          }\n          if (typeof getDerivedStateFromProps === \"function\") {\n            applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, newProps);\n            newState = workInProgress2.memoizedState;\n          }\n          var shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress2, ctor, oldProps, newProps, oldState, newState, nextContext) || // TODO: In some cases, we'll end up checking if context has changed twice,\n          // both before and after `shouldComponentUpdate` has been called. Not ideal,\n          // but I'm loath to refactor this function. This only happens for memoized\n          // components so it's not that common.\n          enableLazyContextPropagation;\n          if (shouldUpdate) {\n            if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillUpdate === \"function\" || typeof instance.componentWillUpdate === \"function\")) {\n              if (typeof instance.componentWillUpdate === \"function\") {\n                instance.componentWillUpdate(newProps, newState, nextContext);\n              }\n              if (typeof instance.UNSAFE_componentWillUpdate === \"function\") {\n                instance.UNSAFE_componentWillUpdate(newProps, newState, nextContext);\n              }\n            }\n            if (typeof instance.componentDidUpdate === \"function\") {\n              workInProgress2.flags |= Update;\n            }\n            if (typeof instance.getSnapshotBeforeUpdate === \"function\") {\n              workInProgress2.flags |= Snapshot;\n            }\n          } else {\n            if (typeof instance.componentDidUpdate === \"function\") {\n              if (unresolvedOldProps !== current2.memoizedProps || oldState !== current2.memoizedState) {\n                workInProgress2.flags |= Update;\n              }\n            }\n            if (typeof instance.getSnapshotBeforeUpdate === \"function\") {\n              if (unresolvedOldProps !== current2.memoizedProps || oldState !== current2.memoizedState) {\n                workInProgress2.flags |= Snapshot;\n              }\n            }\n            workInProgress2.memoizedProps = newProps;\n            workInProgress2.memoizedState = newState;\n          }\n          instance.props = newProps;\n          instance.state = newState;\n          instance.context = nextContext;\n          return shouldUpdate;\n        }\n        var didWarnAboutMaps;\n        var didWarnAboutGenerators;\n        var didWarnAboutStringRefs;\n        var ownerHasKeyUseWarning;\n        var ownerHasFunctionTypeWarning;\n        var warnForMissingKey = function(child, returnFiber) {\n        };\n        {\n          didWarnAboutMaps = false;\n          didWarnAboutGenerators = false;\n          didWarnAboutStringRefs = {};\n          ownerHasKeyUseWarning = {};\n          ownerHasFunctionTypeWarning = {};\n          warnForMissingKey = function(child, returnFiber) {\n            if (child === null || typeof child !== \"object\") {\n              return;\n            }\n            if (!child._store || child._store.validated || child.key != null) {\n              return;\n            }\n            if (typeof child._store !== \"object\") {\n              throw new Error(\"React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.\");\n            }\n            child._store.validated = true;\n            var componentName = getComponentNameFromFiber(returnFiber) || \"Component\";\n            if (ownerHasKeyUseWarning[componentName]) {\n              return;\n            }\n            ownerHasKeyUseWarning[componentName] = true;\n            error('Each child in a list should have a unique \"key\" prop. See https://reactjs.org/link/warning-keys for more information.');\n          };\n        }\n        function coerceRef(returnFiber, current2, element) {\n          var mixedRef = element.ref;\n          if (mixedRef !== null && typeof mixedRef !== \"function\" && typeof mixedRef !== \"object\") {\n            {\n              if ((returnFiber.mode & StrictLegacyMode || warnAboutStringRefs) && // We warn in ReactElement.js if owner and self are equal for string refs\n              // because these cannot be automatically converted to an arrow function\n              // using a codemod. Therefore, we don't have to warn about string refs again.\n              !(element._owner && element._self && element._owner.stateNode !== element._self)) {\n                var componentName = getComponentNameFromFiber(returnFiber) || \"Component\";\n                if (!didWarnAboutStringRefs[componentName]) {\n                  {\n                    error('A string ref, \"%s\", has been found within a strict mode tree. String refs are a source of potential bugs and should be avoided. We recommend using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', mixedRef);\n                  }\n                  didWarnAboutStringRefs[componentName] = true;\n                }\n              }\n            }\n            if (element._owner) {\n              var owner = element._owner;\n              var inst;\n              if (owner) {\n                var ownerFiber = owner;\n                if (ownerFiber.tag !== ClassComponent) {\n                  throw new Error(\"Function components cannot have string refs. We recommend using useRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref\");\n                }\n                inst = ownerFiber.stateNode;\n              }\n              if (!inst) {\n                throw new Error(\"Missing owner for string ref \" + mixedRef + \". This error is likely caused by a bug in React. Please file an issue.\");\n              }\n              var resolvedInst = inst;\n              {\n                checkPropStringCoercion(mixedRef, \"ref\");\n              }\n              var stringRef = \"\" + mixedRef;\n              if (current2 !== null && current2.ref !== null && typeof current2.ref === \"function\" && current2.ref._stringRef === stringRef) {\n                return current2.ref;\n              }\n              var ref = function(value) {\n                var refs = resolvedInst.refs;\n                if (refs === emptyRefsObject) {\n                  refs = resolvedInst.refs = {};\n                }\n                if (value === null) {\n                  delete refs[stringRef];\n                } else {\n                  refs[stringRef] = value;\n                }\n              };\n              ref._stringRef = stringRef;\n              return ref;\n            } else {\n              if (typeof mixedRef !== \"string\") {\n                throw new Error(\"Expected ref to be a function, a string, an object returned by React.createRef(), or null.\");\n              }\n              if (!element._owner) {\n                throw new Error(\"Element ref was specified as a string (\" + mixedRef + \") but no owner was set. This could happen for one of the following reasons:\\n1. You may be adding a ref to a function component\\n2. You may be adding a ref to a component that was not created inside a component's render method\\n3. You have multiple copies of React loaded\\nSee https://reactjs.org/link/refs-must-have-owner for more information.\");\n              }\n            }\n          }\n          return mixedRef;\n        }\n        function throwOnInvalidObjectType(returnFiber, newChild) {\n          var childString = Object.prototype.toString.call(newChild);\n          throw new Error(\"Objects are not valid as a React child (found: \" + (childString === \"[object Object]\" ? \"object with keys {\" + Object.keys(newChild).join(\", \") + \"}\" : childString) + \"). If you meant to render a collection of children, use an array instead.\");\n        }\n        function warnOnFunctionType(returnFiber) {\n          {\n            var componentName = getComponentNameFromFiber(returnFiber) || \"Component\";\n            if (ownerHasFunctionTypeWarning[componentName]) {\n              return;\n            }\n            ownerHasFunctionTypeWarning[componentName] = true;\n            error(\"Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.\");\n          }\n        }\n        function resolveLazy(lazyType) {\n          var payload = lazyType._payload;\n          var init = lazyType._init;\n          return init(payload);\n        }\n        function ChildReconciler(shouldTrackSideEffects) {\n          function deleteChild(returnFiber, childToDelete) {\n            if (!shouldTrackSideEffects) {\n              return;\n            }\n            var deletions = returnFiber.deletions;\n            if (deletions === null) {\n              returnFiber.deletions = [childToDelete];\n              returnFiber.flags |= ChildDeletion;\n            } else {\n              deletions.push(childToDelete);\n            }\n          }\n          function deleteRemainingChildren(returnFiber, currentFirstChild) {\n            if (!shouldTrackSideEffects) {\n              return null;\n            }\n            var childToDelete = currentFirstChild;\n            while (childToDelete !== null) {\n              deleteChild(returnFiber, childToDelete);\n              childToDelete = childToDelete.sibling;\n            }\n            return null;\n          }\n          function mapRemainingChildren(returnFiber, currentFirstChild) {\n            var existingChildren = /* @__PURE__ */ new Map();\n            var existingChild = currentFirstChild;\n            while (existingChild !== null) {\n              if (existingChild.key !== null) {\n                existingChildren.set(existingChild.key, existingChild);\n              } else {\n                existingChildren.set(existingChild.index, existingChild);\n              }\n              existingChild = existingChild.sibling;\n            }\n            return existingChildren;\n          }\n          function useFiber(fiber, pendingProps) {\n            var clone = createWorkInProgress(fiber, pendingProps);\n            clone.index = 0;\n            clone.sibling = null;\n            return clone;\n          }\n          function placeChild(newFiber, lastPlacedIndex, newIndex) {\n            newFiber.index = newIndex;\n            if (!shouldTrackSideEffects) {\n              newFiber.flags |= Forked;\n              return lastPlacedIndex;\n            }\n            var current2 = newFiber.alternate;\n            if (current2 !== null) {\n              var oldIndex = current2.index;\n              if (oldIndex < lastPlacedIndex) {\n                newFiber.flags |= Placement;\n                return lastPlacedIndex;\n              } else {\n                return oldIndex;\n              }\n            } else {\n              newFiber.flags |= Placement;\n              return lastPlacedIndex;\n            }\n          }\n          function placeSingleChild(newFiber) {\n            if (shouldTrackSideEffects && newFiber.alternate === null) {\n              newFiber.flags |= Placement;\n            }\n            return newFiber;\n          }\n          function updateTextNode(returnFiber, current2, textContent, lanes) {\n            if (current2 === null || current2.tag !== HostText) {\n              var created = createFiberFromText(textContent, returnFiber.mode, lanes);\n              created.return = returnFiber;\n              return created;\n            } else {\n              var existing = useFiber(current2, textContent);\n              existing.return = returnFiber;\n              return existing;\n            }\n          }\n          function updateElement(returnFiber, current2, element, lanes) {\n            var elementType = element.type;\n            if (elementType === REACT_FRAGMENT_TYPE) {\n              return updateFragment2(returnFiber, current2, element.props.children, lanes, element.key);\n            }\n            if (current2 !== null) {\n              if (current2.elementType === elementType || // Keep this check inline so it only runs on the false path:\n              isCompatibleFamilyForHotReloading(current2, element) || // Lazy types should reconcile their resolved type.\n              // We need to do this after the Hot Reloading check above,\n              // because hot reloading has different semantics than prod because\n              // it doesn't resuspend. So we can't let the call below suspend.\n              typeof elementType === \"object\" && elementType !== null && elementType.$$typeof === REACT_LAZY_TYPE && resolveLazy(elementType) === current2.type) {\n                var existing = useFiber(current2, element.props);\n                existing.ref = coerceRef(returnFiber, current2, element);\n                existing.return = returnFiber;\n                {\n                  existing._debugSource = element._source;\n                  existing._debugOwner = element._owner;\n                }\n                return existing;\n              }\n            }\n            var created = createFiberFromElement(element, returnFiber.mode, lanes);\n            created.ref = coerceRef(returnFiber, current2, element);\n            created.return = returnFiber;\n            return created;\n          }\n          function updatePortal(returnFiber, current2, portal, lanes) {\n            if (current2 === null || current2.tag !== HostPortal || current2.stateNode.containerInfo !== portal.containerInfo || current2.stateNode.implementation !== portal.implementation) {\n              var created = createFiberFromPortal(portal, returnFiber.mode, lanes);\n              created.return = returnFiber;\n              return created;\n            } else {\n              var existing = useFiber(current2, portal.children || []);\n              existing.return = returnFiber;\n              return existing;\n            }\n          }\n          function updateFragment2(returnFiber, current2, fragment, lanes, key) {\n            if (current2 === null || current2.tag !== Fragment) {\n              var created = createFiberFromFragment(fragment, returnFiber.mode, lanes, key);\n              created.return = returnFiber;\n              return created;\n            } else {\n              var existing = useFiber(current2, fragment);\n              existing.return = returnFiber;\n              return existing;\n            }\n          }\n          function createChild(returnFiber, newChild, lanes) {\n            if (typeof newChild === \"string\" && newChild !== \"\" || typeof newChild === \"number\") {\n              var created = createFiberFromText(\"\" + newChild, returnFiber.mode, lanes);\n              created.return = returnFiber;\n              return created;\n            }\n            if (typeof newChild === \"object\" && newChild !== null) {\n              switch (newChild.$$typeof) {\n                case REACT_ELEMENT_TYPE: {\n                  var _created = createFiberFromElement(newChild, returnFiber.mode, lanes);\n                  _created.ref = coerceRef(returnFiber, null, newChild);\n                  _created.return = returnFiber;\n                  return _created;\n                }\n                case REACT_PORTAL_TYPE: {\n                  var _created2 = createFiberFromPortal(newChild, returnFiber.mode, lanes);\n                  _created2.return = returnFiber;\n                  return _created2;\n                }\n                case REACT_LAZY_TYPE: {\n                  var payload = newChild._payload;\n                  var init = newChild._init;\n                  return createChild(returnFiber, init(payload), lanes);\n                }\n              }\n              if (isArray(newChild) || getIteratorFn(newChild)) {\n                var _created3 = createFiberFromFragment(newChild, returnFiber.mode, lanes, null);\n                _created3.return = returnFiber;\n                return _created3;\n              }\n              throwOnInvalidObjectType(returnFiber, newChild);\n            }\n            {\n              if (typeof newChild === \"function\") {\n                warnOnFunctionType(returnFiber);\n              }\n            }\n            return null;\n          }\n          function updateSlot(returnFiber, oldFiber, newChild, lanes) {\n            var key = oldFiber !== null ? oldFiber.key : null;\n            if (typeof newChild === \"string\" && newChild !== \"\" || typeof newChild === \"number\") {\n              if (key !== null) {\n                return null;\n              }\n              return updateTextNode(returnFiber, oldFiber, \"\" + newChild, lanes);\n            }\n            if (typeof newChild === \"object\" && newChild !== null) {\n              switch (newChild.$$typeof) {\n                case REACT_ELEMENT_TYPE: {\n                  if (newChild.key === key) {\n                    return updateElement(returnFiber, oldFiber, newChild, lanes);\n                  } else {\n                    return null;\n                  }\n                }\n                case REACT_PORTAL_TYPE: {\n                  if (newChild.key === key) {\n                    return updatePortal(returnFiber, oldFiber, newChild, lanes);\n                  } else {\n                    return null;\n                  }\n                }\n                case REACT_LAZY_TYPE: {\n                  var payload = newChild._payload;\n                  var init = newChild._init;\n                  return updateSlot(returnFiber, oldFiber, init(payload), lanes);\n                }\n              }\n              if (isArray(newChild) || getIteratorFn(newChild)) {\n                if (key !== null) {\n                  return null;\n                }\n                return updateFragment2(returnFiber, oldFiber, newChild, lanes, null);\n              }\n              throwOnInvalidObjectType(returnFiber, newChild);\n            }\n            {\n              if (typeof newChild === \"function\") {\n                warnOnFunctionType(returnFiber);\n              }\n            }\n            return null;\n          }\n          function updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes) {\n            if (typeof newChild === \"string\" && newChild !== \"\" || typeof newChild === \"number\") {\n              var matchedFiber = existingChildren.get(newIdx) || null;\n              return updateTextNode(returnFiber, matchedFiber, \"\" + newChild, lanes);\n            }\n            if (typeof newChild === \"object\" && newChild !== null) {\n              switch (newChild.$$typeof) {\n                case REACT_ELEMENT_TYPE: {\n                  var _matchedFiber = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;\n                  return updateElement(returnFiber, _matchedFiber, newChild, lanes);\n                }\n                case REACT_PORTAL_TYPE: {\n                  var _matchedFiber2 = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;\n                  return updatePortal(returnFiber, _matchedFiber2, newChild, lanes);\n                }\n                case REACT_LAZY_TYPE:\n                  var payload = newChild._payload;\n                  var init = newChild._init;\n                  return updateFromMap(existingChildren, returnFiber, newIdx, init(payload), lanes);\n              }\n              if (isArray(newChild) || getIteratorFn(newChild)) {\n                var _matchedFiber3 = existingChildren.get(newIdx) || null;\n                return updateFragment2(returnFiber, _matchedFiber3, newChild, lanes, null);\n              }\n              throwOnInvalidObjectType(returnFiber, newChild);\n            }\n            {\n              if (typeof newChild === \"function\") {\n                warnOnFunctionType(returnFiber);\n              }\n            }\n            return null;\n          }\n          function warnOnInvalidKey(child, knownKeys, returnFiber) {\n            {\n              if (typeof child !== \"object\" || child === null) {\n                return knownKeys;\n              }\n              switch (child.$$typeof) {\n                case REACT_ELEMENT_TYPE:\n                case REACT_PORTAL_TYPE:\n                  warnForMissingKey(child, returnFiber);\n                  var key = child.key;\n                  if (typeof key !== \"string\") {\n                    break;\n                  }\n                  if (knownKeys === null) {\n                    knownKeys = /* @__PURE__ */ new Set();\n                    knownKeys.add(key);\n                    break;\n                  }\n                  if (!knownKeys.has(key)) {\n                    knownKeys.add(key);\n                    break;\n                  }\n                  error(\"Encountered two children with the same key, `%s`. Keys should be unique so that components maintain their identity across updates. Non-unique keys may cause children to be duplicated and/or omitted  the behavior is unsupported and could change in a future version.\", key);\n                  break;\n                case REACT_LAZY_TYPE:\n                  var payload = child._payload;\n                  var init = child._init;\n                  warnOnInvalidKey(init(payload), knownKeys, returnFiber);\n                  break;\n              }\n            }\n            return knownKeys;\n          }\n          function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, lanes) {\n            {\n              var knownKeys = null;\n              for (var i = 0; i < newChildren.length; i++) {\n                var child = newChildren[i];\n                knownKeys = warnOnInvalidKey(child, knownKeys, returnFiber);\n              }\n            }\n            var resultingFirstChild = null;\n            var previousNewFiber = null;\n            var oldFiber = currentFirstChild;\n            var lastPlacedIndex = 0;\n            var newIdx = 0;\n            var nextOldFiber = null;\n            for (; oldFiber !== null && newIdx < newChildren.length; newIdx++) {\n              if (oldFiber.index > newIdx) {\n                nextOldFiber = oldFiber;\n                oldFiber = null;\n              } else {\n                nextOldFiber = oldFiber.sibling;\n              }\n              var newFiber = updateSlot(returnFiber, oldFiber, newChildren[newIdx], lanes);\n              if (newFiber === null) {\n                if (oldFiber === null) {\n                  oldFiber = nextOldFiber;\n                }\n                break;\n              }\n              if (shouldTrackSideEffects) {\n                if (oldFiber && newFiber.alternate === null) {\n                  deleteChild(returnFiber, oldFiber);\n                }\n              }\n              lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n              if (previousNewFiber === null) {\n                resultingFirstChild = newFiber;\n              } else {\n                previousNewFiber.sibling = newFiber;\n              }\n              previousNewFiber = newFiber;\n              oldFiber = nextOldFiber;\n            }\n            if (newIdx === newChildren.length) {\n              deleteRemainingChildren(returnFiber, oldFiber);\n              if (getIsHydrating()) {\n                var numberOfForks = newIdx;\n                pushTreeFork(returnFiber, numberOfForks);\n              }\n              return resultingFirstChild;\n            }\n            if (oldFiber === null) {\n              for (; newIdx < newChildren.length; newIdx++) {\n                var _newFiber = createChild(returnFiber, newChildren[newIdx], lanes);\n                if (_newFiber === null) {\n                  continue;\n                }\n                lastPlacedIndex = placeChild(_newFiber, lastPlacedIndex, newIdx);\n                if (previousNewFiber === null) {\n                  resultingFirstChild = _newFiber;\n                } else {\n                  previousNewFiber.sibling = _newFiber;\n                }\n                previousNewFiber = _newFiber;\n              }\n              if (getIsHydrating()) {\n                var _numberOfForks = newIdx;\n                pushTreeFork(returnFiber, _numberOfForks);\n              }\n              return resultingFirstChild;\n            }\n            var existingChildren = mapRemainingChildren(returnFiber, oldFiber);\n            for (; newIdx < newChildren.length; newIdx++) {\n              var _newFiber2 = updateFromMap(existingChildren, returnFiber, newIdx, newChildren[newIdx], lanes);\n              if (_newFiber2 !== null) {\n                if (shouldTrackSideEffects) {\n                  if (_newFiber2.alternate !== null) {\n                    existingChildren.delete(_newFiber2.key === null ? newIdx : _newFiber2.key);\n                  }\n                }\n                lastPlacedIndex = placeChild(_newFiber2, lastPlacedIndex, newIdx);\n                if (previousNewFiber === null) {\n                  resultingFirstChild = _newFiber2;\n                } else {\n                  previousNewFiber.sibling = _newFiber2;\n                }\n                previousNewFiber = _newFiber2;\n              }\n            }\n            if (shouldTrackSideEffects) {\n              existingChildren.forEach(function(child2) {\n                return deleteChild(returnFiber, child2);\n              });\n            }\n            if (getIsHydrating()) {\n              var _numberOfForks2 = newIdx;\n              pushTreeFork(returnFiber, _numberOfForks2);\n            }\n            return resultingFirstChild;\n          }\n          function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildrenIterable, lanes) {\n            var iteratorFn = getIteratorFn(newChildrenIterable);\n            if (typeof iteratorFn !== \"function\") {\n              throw new Error(\"An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.\");\n            }\n            {\n              if (typeof Symbol === \"function\" && // $FlowFixMe Flow doesn't know about toStringTag\n              newChildrenIterable[Symbol.toStringTag] === \"Generator\") {\n                if (!didWarnAboutGenerators) {\n                  error(\"Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers.\");\n                }\n                didWarnAboutGenerators = true;\n              }\n              if (newChildrenIterable.entries === iteratorFn) {\n                if (!didWarnAboutMaps) {\n                  error(\"Using Maps as children is not supported. Use an array of keyed ReactElements instead.\");\n                }\n                didWarnAboutMaps = true;\n              }\n              var _newChildren = iteratorFn.call(newChildrenIterable);\n              if (_newChildren) {\n                var knownKeys = null;\n                var _step = _newChildren.next();\n                for (; !_step.done; _step = _newChildren.next()) {\n                  var child = _step.value;\n                  knownKeys = warnOnInvalidKey(child, knownKeys, returnFiber);\n                }\n              }\n            }\n            var newChildren = iteratorFn.call(newChildrenIterable);\n            if (newChildren == null) {\n              throw new Error(\"An iterable object provided no iterator.\");\n            }\n            var resultingFirstChild = null;\n            var previousNewFiber = null;\n            var oldFiber = currentFirstChild;\n            var lastPlacedIndex = 0;\n            var newIdx = 0;\n            var nextOldFiber = null;\n            var step = newChildren.next();\n            for (; oldFiber !== null && !step.done; newIdx++, step = newChildren.next()) {\n              if (oldFiber.index > newIdx) {\n                nextOldFiber = oldFiber;\n                oldFiber = null;\n              } else {\n                nextOldFiber = oldFiber.sibling;\n              }\n              var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);\n              if (newFiber === null) {\n                if (oldFiber === null) {\n                  oldFiber = nextOldFiber;\n                }\n                break;\n              }\n              if (shouldTrackSideEffects) {\n                if (oldFiber && newFiber.alternate === null) {\n                  deleteChild(returnFiber, oldFiber);\n                }\n              }\n              lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n              if (previousNewFiber === null) {\n                resultingFirstChild = newFiber;\n              } else {\n                previousNewFiber.sibling = newFiber;\n              }\n              previousNewFiber = newFiber;\n              oldFiber = nextOldFiber;\n            }\n            if (step.done) {\n              deleteRemainingChildren(returnFiber, oldFiber);\n              if (getIsHydrating()) {\n                var numberOfForks = newIdx;\n                pushTreeFork(returnFiber, numberOfForks);\n              }\n              return resultingFirstChild;\n            }\n            if (oldFiber === null) {\n              for (; !step.done; newIdx++, step = newChildren.next()) {\n                var _newFiber3 = createChild(returnFiber, step.value, lanes);\n                if (_newFiber3 === null) {\n                  continue;\n                }\n                lastPlacedIndex = placeChild(_newFiber3, lastPlacedIndex, newIdx);\n                if (previousNewFiber === null) {\n                  resultingFirstChild = _newFiber3;\n                } else {\n                  previousNewFiber.sibling = _newFiber3;\n                }\n                previousNewFiber = _newFiber3;\n              }\n              if (getIsHydrating()) {\n                var _numberOfForks3 = newIdx;\n                pushTreeFork(returnFiber, _numberOfForks3);\n              }\n              return resultingFirstChild;\n            }\n            var existingChildren = mapRemainingChildren(returnFiber, oldFiber);\n            for (; !step.done; newIdx++, step = newChildren.next()) {\n              var _newFiber4 = updateFromMap(existingChildren, returnFiber, newIdx, step.value, lanes);\n              if (_newFiber4 !== null) {\n                if (shouldTrackSideEffects) {\n                  if (_newFiber4.alternate !== null) {\n                    existingChildren.delete(_newFiber4.key === null ? newIdx : _newFiber4.key);\n                  }\n                }\n                lastPlacedIndex = placeChild(_newFiber4, lastPlacedIndex, newIdx);\n                if (previousNewFiber === null) {\n                  resultingFirstChild = _newFiber4;\n                } else {\n                  previousNewFiber.sibling = _newFiber4;\n                }\n                previousNewFiber = _newFiber4;\n              }\n            }\n            if (shouldTrackSideEffects) {\n              existingChildren.forEach(function(child2) {\n                return deleteChild(returnFiber, child2);\n              });\n            }\n            if (getIsHydrating()) {\n              var _numberOfForks4 = newIdx;\n              pushTreeFork(returnFiber, _numberOfForks4);\n            }\n            return resultingFirstChild;\n          }\n          function reconcileSingleTextNode(returnFiber, currentFirstChild, textContent, lanes) {\n            if (currentFirstChild !== null && currentFirstChild.tag === HostText) {\n              deleteRemainingChildren(returnFiber, currentFirstChild.sibling);\n              var existing = useFiber(currentFirstChild, textContent);\n              existing.return = returnFiber;\n              return existing;\n            }\n            deleteRemainingChildren(returnFiber, currentFirstChild);\n            var created = createFiberFromText(textContent, returnFiber.mode, lanes);\n            created.return = returnFiber;\n            return created;\n          }\n          function reconcileSingleElement(returnFiber, currentFirstChild, element, lanes) {\n            var key = element.key;\n            var child = currentFirstChild;\n            while (child !== null) {\n              if (child.key === key) {\n                var elementType = element.type;\n                if (elementType === REACT_FRAGMENT_TYPE) {\n                  if (child.tag === Fragment) {\n                    deleteRemainingChildren(returnFiber, child.sibling);\n                    var existing = useFiber(child, element.props.children);\n                    existing.return = returnFiber;\n                    {\n                      existing._debugSource = element._source;\n                      existing._debugOwner = element._owner;\n                    }\n                    return existing;\n                  }\n                } else {\n                  if (child.elementType === elementType || // Keep this check inline so it only runs on the false path:\n                  isCompatibleFamilyForHotReloading(child, element) || // Lazy types should reconcile their resolved type.\n                  // We need to do this after the Hot Reloading check above,\n                  // because hot reloading has different semantics than prod because\n                  // it doesn't resuspend. So we can't let the call below suspend.\n                  typeof elementType === \"object\" && elementType !== null && elementType.$$typeof === REACT_LAZY_TYPE && resolveLazy(elementType) === child.type) {\n                    deleteRemainingChildren(returnFiber, child.sibling);\n                    var _existing = useFiber(child, element.props);\n                    _existing.ref = coerceRef(returnFiber, child, element);\n                    _existing.return = returnFiber;\n                    {\n                      _existing._debugSource = element._source;\n                      _existing._debugOwner = element._owner;\n                    }\n                    return _existing;\n                  }\n                }\n                deleteRemainingChildren(returnFiber, child);\n                break;\n              } else {\n                deleteChild(returnFiber, child);\n              }\n              child = child.sibling;\n            }\n            if (element.type === REACT_FRAGMENT_TYPE) {\n              var created = createFiberFromFragment(element.props.children, returnFiber.mode, lanes, element.key);\n              created.return = returnFiber;\n              return created;\n            } else {\n              var _created4 = createFiberFromElement(element, returnFiber.mode, lanes);\n              _created4.ref = coerceRef(returnFiber, currentFirstChild, element);\n              _created4.return = returnFiber;\n              return _created4;\n            }\n          }\n          function reconcileSinglePortal(returnFiber, currentFirstChild, portal, lanes) {\n            var key = portal.key;\n            var child = currentFirstChild;\n            while (child !== null) {\n              if (child.key === key) {\n                if (child.tag === HostPortal && child.stateNode.containerInfo === portal.containerInfo && child.stateNode.implementation === portal.implementation) {\n                  deleteRemainingChildren(returnFiber, child.sibling);\n                  var existing = useFiber(child, portal.children || []);\n                  existing.return = returnFiber;\n                  return existing;\n                } else {\n                  deleteRemainingChildren(returnFiber, child);\n                  break;\n                }\n              } else {\n                deleteChild(returnFiber, child);\n              }\n              child = child.sibling;\n            }\n            var created = createFiberFromPortal(portal, returnFiber.mode, lanes);\n            created.return = returnFiber;\n            return created;\n          }\n          function reconcileChildFibers2(returnFiber, currentFirstChild, newChild, lanes) {\n            var isUnkeyedTopLevelFragment = typeof newChild === \"object\" && newChild !== null && newChild.type === REACT_FRAGMENT_TYPE && newChild.key === null;\n            if (isUnkeyedTopLevelFragment) {\n              newChild = newChild.props.children;\n            }\n            if (typeof newChild === \"object\" && newChild !== null) {\n              switch (newChild.$$typeof) {\n                case REACT_ELEMENT_TYPE:\n                  return placeSingleChild(reconcileSingleElement(returnFiber, currentFirstChild, newChild, lanes));\n                case REACT_PORTAL_TYPE:\n                  return placeSingleChild(reconcileSinglePortal(returnFiber, currentFirstChild, newChild, lanes));\n                case REACT_LAZY_TYPE:\n                  var payload = newChild._payload;\n                  var init = newChild._init;\n                  return reconcileChildFibers2(returnFiber, currentFirstChild, init(payload), lanes);\n              }\n              if (isArray(newChild)) {\n                return reconcileChildrenArray(returnFiber, currentFirstChild, newChild, lanes);\n              }\n              if (getIteratorFn(newChild)) {\n                return reconcileChildrenIterator(returnFiber, currentFirstChild, newChild, lanes);\n              }\n              throwOnInvalidObjectType(returnFiber, newChild);\n            }\n            if (typeof newChild === \"string\" && newChild !== \"\" || typeof newChild === \"number\") {\n              return placeSingleChild(reconcileSingleTextNode(returnFiber, currentFirstChild, \"\" + newChild, lanes));\n            }\n            {\n              if (typeof newChild === \"function\") {\n                warnOnFunctionType(returnFiber);\n              }\n            }\n            return deleteRemainingChildren(returnFiber, currentFirstChild);\n          }\n          return reconcileChildFibers2;\n        }\n        var reconcileChildFibers = ChildReconciler(true);\n        var mountChildFibers = ChildReconciler(false);\n        function cloneChildFibers(current2, workInProgress2) {\n          if (current2 !== null && workInProgress2.child !== current2.child) {\n            throw new Error(\"Resuming work not yet implemented.\");\n          }\n          if (workInProgress2.child === null) {\n            return;\n          }\n          var currentChild = workInProgress2.child;\n          var newChild = createWorkInProgress(currentChild, currentChild.pendingProps);\n          workInProgress2.child = newChild;\n          newChild.return = workInProgress2;\n          while (currentChild.sibling !== null) {\n            currentChild = currentChild.sibling;\n            newChild = newChild.sibling = createWorkInProgress(currentChild, currentChild.pendingProps);\n            newChild.return = workInProgress2;\n          }\n          newChild.sibling = null;\n        }\n        function resetChildFibers(workInProgress2, lanes) {\n          var child = workInProgress2.child;\n          while (child !== null) {\n            resetWorkInProgress(child, lanes);\n            child = child.sibling;\n          }\n        }\n        var NO_CONTEXT = {};\n        var contextStackCursor$1 = createCursor(NO_CONTEXT);\n        var contextFiberStackCursor = createCursor(NO_CONTEXT);\n        var rootInstanceStackCursor = createCursor(NO_CONTEXT);\n        function requiredContext(c) {\n          if (c === NO_CONTEXT) {\n            throw new Error(\"Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.\");\n          }\n          return c;\n        }\n        function getRootHostContainer() {\n          var rootInstance = requiredContext(rootInstanceStackCursor.current);\n          return rootInstance;\n        }\n        function pushHostContainer(fiber, nextRootInstance) {\n          push(rootInstanceStackCursor, nextRootInstance, fiber);\n          push(contextFiberStackCursor, fiber, fiber);\n          push(contextStackCursor$1, NO_CONTEXT, fiber);\n          var nextRootContext = getRootHostContext(nextRootInstance);\n          pop(contextStackCursor$1, fiber);\n          push(contextStackCursor$1, nextRootContext, fiber);\n        }\n        function popHostContainer(fiber) {\n          pop(contextStackCursor$1, fiber);\n          pop(contextFiberStackCursor, fiber);\n          pop(rootInstanceStackCursor, fiber);\n        }\n        function getHostContext() {\n          var context = requiredContext(contextStackCursor$1.current);\n          return context;\n        }\n        function pushHostContext(fiber) {\n          var rootInstance = requiredContext(rootInstanceStackCursor.current);\n          var context = requiredContext(contextStackCursor$1.current);\n          var nextContext = getChildHostContext(context, fiber.type);\n          if (context === nextContext) {\n            return;\n          }\n          push(contextFiberStackCursor, fiber, fiber);\n          push(contextStackCursor$1, nextContext, fiber);\n        }\n        function popHostContext(fiber) {\n          if (contextFiberStackCursor.current !== fiber) {\n            return;\n          }\n          pop(contextStackCursor$1, fiber);\n          pop(contextFiberStackCursor, fiber);\n        }\n        var DefaultSuspenseContext = 0;\n        var SubtreeSuspenseContextMask = 1;\n        var InvisibleParentSuspenseContext = 1;\n        var ForceSuspenseFallback = 2;\n        var suspenseStackCursor = createCursor(DefaultSuspenseContext);\n        function hasSuspenseContext(parentContext, flag) {\n          return (parentContext & flag) !== 0;\n        }\n        function setDefaultShallowSuspenseContext(parentContext) {\n          return parentContext & SubtreeSuspenseContextMask;\n        }\n        function setShallowSuspenseContext(parentContext, shallowContext) {\n          return parentContext & SubtreeSuspenseContextMask | shallowContext;\n        }\n        function addSubtreeSuspenseContext(parentContext, subtreeContext) {\n          return parentContext | subtreeContext;\n        }\n        function pushSuspenseContext(fiber, newContext) {\n          push(suspenseStackCursor, newContext, fiber);\n        }\n        function popSuspenseContext(fiber) {\n          pop(suspenseStackCursor, fiber);\n        }\n        function shouldCaptureSuspense(workInProgress2, hasInvisibleParent) {\n          var nextState = workInProgress2.memoizedState;\n          if (nextState !== null) {\n            if (nextState.dehydrated !== null) {\n              return true;\n            }\n            return false;\n          }\n          var props = workInProgress2.memoizedProps;\n          {\n            return true;\n          }\n        }\n        function findFirstSuspended(row) {\n          var node = row;\n          while (node !== null) {\n            if (node.tag === SuspenseComponent) {\n              var state = node.memoizedState;\n              if (state !== null) {\n                var dehydrated = state.dehydrated;\n                if (dehydrated === null || isSuspenseInstancePending(dehydrated) || isSuspenseInstanceFallback(dehydrated)) {\n                  return node;\n                }\n              }\n            } else if (node.tag === SuspenseListComponent && // revealOrder undefined can't be trusted because it don't\n            // keep track of whether it suspended or not.\n            node.memoizedProps.revealOrder !== void 0) {\n              var didSuspend = (node.flags & DidCapture) !== NoFlags;\n              if (didSuspend) {\n                return node;\n              }\n            } else if (node.child !== null) {\n              node.child.return = node;\n              node = node.child;\n              continue;\n            }\n            if (node === row) {\n              return null;\n            }\n            while (node.sibling === null) {\n              if (node.return === null || node.return === row) {\n                return null;\n              }\n              node = node.return;\n            }\n            node.sibling.return = node.return;\n            node = node.sibling;\n          }\n          return null;\n        }\n        var NoFlags$1 = (\n          /*   */\n          0\n        );\n        var HasEffect = (\n          /* */\n          1\n        );\n        var Insertion = (\n          /*  */\n          2\n        );\n        var Layout = (\n          /*    */\n          4\n        );\n        var Passive$1 = (\n          /*   */\n          8\n        );\n        var workInProgressSources = [];\n        function resetWorkInProgressVersions() {\n          for (var i = 0; i < workInProgressSources.length; i++) {\n            var mutableSource = workInProgressSources[i];\n            {\n              mutableSource._workInProgressVersionPrimary = null;\n            }\n          }\n          workInProgressSources.length = 0;\n        }\n        function registerMutableSourceForHydration(root2, mutableSource) {\n          var getVersion = mutableSource._getVersion;\n          var version = getVersion(mutableSource._source);\n          if (root2.mutableSourceEagerHydrationData == null) {\n            root2.mutableSourceEagerHydrationData = [mutableSource, version];\n          } else {\n            root2.mutableSourceEagerHydrationData.push(mutableSource, version);\n          }\n        }\n        var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher, ReactCurrentBatchConfig$2 = ReactSharedInternals.ReactCurrentBatchConfig;\n        var didWarnAboutMismatchedHooksForComponent;\n        var didWarnUncachedGetSnapshot;\n        {\n          didWarnAboutMismatchedHooksForComponent = /* @__PURE__ */ new Set();\n        }\n        var renderLanes = NoLanes;\n        var currentlyRenderingFiber$1 = null;\n        var currentHook = null;\n        var workInProgressHook = null;\n        var didScheduleRenderPhaseUpdate = false;\n        var didScheduleRenderPhaseUpdateDuringThisPass = false;\n        var localIdCounter = 0;\n        var globalClientIdCounter = 0;\n        var RE_RENDER_LIMIT = 25;\n        var currentHookNameInDev = null;\n        var hookTypesDev = null;\n        var hookTypesUpdateIndexDev = -1;\n        var ignorePreviousDependencies = false;\n        function mountHookTypesDev() {\n          {\n            var hookName = currentHookNameInDev;\n            if (hookTypesDev === null) {\n              hookTypesDev = [hookName];\n            } else {\n              hookTypesDev.push(hookName);\n            }\n          }\n        }\n        function updateHookTypesDev() {\n          {\n            var hookName = currentHookNameInDev;\n            if (hookTypesDev !== null) {\n              hookTypesUpdateIndexDev++;\n              if (hookTypesDev[hookTypesUpdateIndexDev] !== hookName) {\n                warnOnHookMismatchInDev(hookName);\n              }\n            }\n          }\n        }\n        function checkDepsAreArrayDev(deps) {\n          {\n            if (deps !== void 0 && deps !== null && !isArray(deps)) {\n              error(\"%s received a final argument that is not an array (instead, received `%s`). When specified, the final argument must be an array.\", currentHookNameInDev, typeof deps);\n            }\n          }\n        }\n        function warnOnHookMismatchInDev(currentHookName) {\n          {\n            var componentName = getComponentNameFromFiber(currentlyRenderingFiber$1);\n            if (!didWarnAboutMismatchedHooksForComponent.has(componentName)) {\n              didWarnAboutMismatchedHooksForComponent.add(componentName);\n              if (hookTypesDev !== null) {\n                var table = \"\";\n                var secondColumnStart = 30;\n                for (var i = 0; i <= hookTypesUpdateIndexDev; i++) {\n                  var oldHookName = hookTypesDev[i];\n                  var newHookName = i === hookTypesUpdateIndexDev ? currentHookName : oldHookName;\n                  var row = i + 1 + \". \" + oldHookName;\n                  while (row.length < secondColumnStart) {\n                    row += \" \";\n                  }\n                  row += newHookName + \"\\n\";\n                  table += row;\n                }\n                error(\"React has detected a change in the order of Hooks called by %s. This will lead to bugs and errors if not fixed. For more information, read the Rules of Hooks: https://reactjs.org/link/rules-of-hooks\\n\\n   Previous render            Next render\\n   ------------------------------------------------------\\n%s   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n\", componentName, table);\n              }\n            }\n          }\n        }\n        function throwInvalidHookError() {\n          throw new Error(\"Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\\n1. You might have mismatching versions of React and the renderer (such as React DOM)\\n2. You might be breaking the Rules of Hooks\\n3. You might have more than one copy of React in the same app\\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.\");\n        }\n        function areHookInputsEqual(nextDeps, prevDeps) {\n          {\n            if (ignorePreviousDependencies) {\n              return false;\n            }\n          }\n          if (prevDeps === null) {\n            {\n              error(\"%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.\", currentHookNameInDev);\n            }\n            return false;\n          }\n          {\n            if (nextDeps.length !== prevDeps.length) {\n              error(\"The final argument passed to %s changed size between renders. The order and size of this array must remain constant.\\n\\nPrevious: %s\\nIncoming: %s\", currentHookNameInDev, \"[\" + prevDeps.join(\", \") + \"]\", \"[\" + nextDeps.join(\", \") + \"]\");\n            }\n          }\n          for (var i = 0; i < prevDeps.length && i < nextDeps.length; i++) {\n            if (objectIs(nextDeps[i], prevDeps[i])) {\n              continue;\n            }\n            return false;\n          }\n          return true;\n        }\n        function renderWithHooks(current2, workInProgress2, Component, props, secondArg, nextRenderLanes) {\n          renderLanes = nextRenderLanes;\n          currentlyRenderingFiber$1 = workInProgress2;\n          {\n            hookTypesDev = current2 !== null ? current2._debugHookTypes : null;\n            hookTypesUpdateIndexDev = -1;\n            ignorePreviousDependencies = current2 !== null && current2.type !== workInProgress2.type;\n          }\n          workInProgress2.memoizedState = null;\n          workInProgress2.updateQueue = null;\n          workInProgress2.lanes = NoLanes;\n          {\n            if (current2 !== null && current2.memoizedState !== null) {\n              ReactCurrentDispatcher$1.current = HooksDispatcherOnUpdateInDEV;\n            } else if (hookTypesDev !== null) {\n              ReactCurrentDispatcher$1.current = HooksDispatcherOnMountWithHookTypesInDEV;\n            } else {\n              ReactCurrentDispatcher$1.current = HooksDispatcherOnMountInDEV;\n            }\n          }\n          var children = Component(props, secondArg);\n          if (didScheduleRenderPhaseUpdateDuringThisPass) {\n            var numberOfReRenders = 0;\n            do {\n              didScheduleRenderPhaseUpdateDuringThisPass = false;\n              localIdCounter = 0;\n              if (numberOfReRenders >= RE_RENDER_LIMIT) {\n                throw new Error(\"Too many re-renders. React limits the number of renders to prevent an infinite loop.\");\n              }\n              numberOfReRenders += 1;\n              {\n                ignorePreviousDependencies = false;\n              }\n              currentHook = null;\n              workInProgressHook = null;\n              workInProgress2.updateQueue = null;\n              {\n                hookTypesUpdateIndexDev = -1;\n              }\n              ReactCurrentDispatcher$1.current = HooksDispatcherOnRerenderInDEV;\n              children = Component(props, secondArg);\n            } while (didScheduleRenderPhaseUpdateDuringThisPass);\n          }\n          ReactCurrentDispatcher$1.current = ContextOnlyDispatcher;\n          {\n            workInProgress2._debugHookTypes = hookTypesDev;\n          }\n          var didRenderTooFewHooks = currentHook !== null && currentHook.next !== null;\n          renderLanes = NoLanes;\n          currentlyRenderingFiber$1 = null;\n          currentHook = null;\n          workInProgressHook = null;\n          {\n            currentHookNameInDev = null;\n            hookTypesDev = null;\n            hookTypesUpdateIndexDev = -1;\n            if (current2 !== null && (current2.flags & StaticMask) !== (workInProgress2.flags & StaticMask) && // Disable this warning in legacy mode, because legacy Suspense is weird\n            // and creates false positives. To make this work in legacy mode, we'd\n            // need to mark fibers that commit in an incomplete state, somehow. For\n            // now I'll disable the warning that most of the bugs that would trigger\n            // it are either exclusive to concurrent mode or exist in both.\n            (current2.mode & ConcurrentMode) !== NoMode) {\n              error(\"Internal React error: Expected static flag was missing. Please notify the React team.\");\n            }\n          }\n          didScheduleRenderPhaseUpdate = false;\n          if (didRenderTooFewHooks) {\n            throw new Error(\"Rendered fewer hooks than expected. This may be caused by an accidental early return statement.\");\n          }\n          return children;\n        }\n        function checkDidRenderIdHook() {\n          var didRenderIdHook = localIdCounter !== 0;\n          localIdCounter = 0;\n          return didRenderIdHook;\n        }\n        function bailoutHooks(current2, workInProgress2, lanes) {\n          workInProgress2.updateQueue = current2.updateQueue;\n          if ((workInProgress2.mode & StrictEffectsMode) !== NoMode) {\n            workInProgress2.flags &= ~(MountPassiveDev | MountLayoutDev | Passive | Update);\n          } else {\n            workInProgress2.flags &= ~(Passive | Update);\n          }\n          current2.lanes = removeLanes(current2.lanes, lanes);\n        }\n        function resetHooksAfterThrow() {\n          ReactCurrentDispatcher$1.current = ContextOnlyDispatcher;\n          if (didScheduleRenderPhaseUpdate) {\n            var hook = currentlyRenderingFiber$1.memoizedState;\n            while (hook !== null) {\n              var queue = hook.queue;\n              if (queue !== null) {\n                queue.pending = null;\n              }\n              hook = hook.next;\n            }\n            didScheduleRenderPhaseUpdate = false;\n          }\n          renderLanes = NoLanes;\n          currentlyRenderingFiber$1 = null;\n          currentHook = null;\n          workInProgressHook = null;\n          {\n            hookTypesDev = null;\n            hookTypesUpdateIndexDev = -1;\n            currentHookNameInDev = null;\n            isUpdatingOpaqueValueInRenderPhase = false;\n          }\n          didScheduleRenderPhaseUpdateDuringThisPass = false;\n          localIdCounter = 0;\n        }\n        function mountWorkInProgressHook() {\n          var hook = {\n            memoizedState: null,\n            baseState: null,\n            baseQueue: null,\n            queue: null,\n            next: null\n          };\n          if (workInProgressHook === null) {\n            currentlyRenderingFiber$1.memoizedState = workInProgressHook = hook;\n          } else {\n            workInProgressHook = workInProgressHook.next = hook;\n          }\n          return workInProgressHook;\n        }\n        function updateWorkInProgressHook() {\n          var nextCurrentHook;\n          if (currentHook === null) {\n            var current2 = currentlyRenderingFiber$1.alternate;\n            if (current2 !== null) {\n              nextCurrentHook = current2.memoizedState;\n            } else {\n              nextCurrentHook = null;\n            }\n          } else {\n            nextCurrentHook = currentHook.next;\n          }\n          var nextWorkInProgressHook;\n          if (workInProgressHook === null) {\n            nextWorkInProgressHook = currentlyRenderingFiber$1.memoizedState;\n          } else {\n            nextWorkInProgressHook = workInProgressHook.next;\n          }\n          if (nextWorkInProgressHook !== null) {\n            workInProgressHook = nextWorkInProgressHook;\n            nextWorkInProgressHook = workInProgressHook.next;\n            currentHook = nextCurrentHook;\n          } else {\n            if (nextCurrentHook === null) {\n              throw new Error(\"Rendered more hooks than during the previous render.\");\n            }\n            currentHook = nextCurrentHook;\n            var newHook = {\n              memoizedState: currentHook.memoizedState,\n              baseState: currentHook.baseState,\n              baseQueue: currentHook.baseQueue,\n              queue: currentHook.queue,\n              next: null\n            };\n            if (workInProgressHook === null) {\n              currentlyRenderingFiber$1.memoizedState = workInProgressHook = newHook;\n            } else {\n              workInProgressHook = workInProgressHook.next = newHook;\n            }\n          }\n          return workInProgressHook;\n        }\n        function createFunctionComponentUpdateQueue() {\n          return {\n            lastEffect: null,\n            stores: null\n          };\n        }\n        function basicStateReducer(state, action) {\n          return typeof action === \"function\" ? action(state) : action;\n        }\n        function mountReducer(reducer, initialArg, init) {\n          var hook = mountWorkInProgressHook();\n          var initialState;\n          if (init !== void 0) {\n            initialState = init(initialArg);\n          } else {\n            initialState = initialArg;\n          }\n          hook.memoizedState = hook.baseState = initialState;\n          var queue = {\n            pending: null,\n            interleaved: null,\n            lanes: NoLanes,\n            dispatch: null,\n            lastRenderedReducer: reducer,\n            lastRenderedState: initialState\n          };\n          hook.queue = queue;\n          var dispatch = queue.dispatch = dispatchReducerAction.bind(null, currentlyRenderingFiber$1, queue);\n          return [hook.memoizedState, dispatch];\n        }\n        function updateReducer(reducer, initialArg, init) {\n          var hook = updateWorkInProgressHook();\n          var queue = hook.queue;\n          if (queue === null) {\n            throw new Error(\"Should have a queue. This is likely a bug in React. Please file an issue.\");\n          }\n          queue.lastRenderedReducer = reducer;\n          var current2 = currentHook;\n          var baseQueue = current2.baseQueue;\n          var pendingQueue = queue.pending;\n          if (pendingQueue !== null) {\n            if (baseQueue !== null) {\n              var baseFirst = baseQueue.next;\n              var pendingFirst = pendingQueue.next;\n              baseQueue.next = pendingFirst;\n              pendingQueue.next = baseFirst;\n            }\n            {\n              if (current2.baseQueue !== baseQueue) {\n                error(\"Internal error: Expected work-in-progress queue to be a clone. This is a bug in React.\");\n              }\n            }\n            current2.baseQueue = baseQueue = pendingQueue;\n            queue.pending = null;\n          }\n          if (baseQueue !== null) {\n            var first = baseQueue.next;\n            var newState = current2.baseState;\n            var newBaseState = null;\n            var newBaseQueueFirst = null;\n            var newBaseQueueLast = null;\n            var update = first;\n            do {\n              var updateLane = update.lane;\n              if (!isSubsetOfLanes(renderLanes, updateLane)) {\n                var clone = {\n                  lane: updateLane,\n                  action: update.action,\n                  hasEagerState: update.hasEagerState,\n                  eagerState: update.eagerState,\n                  next: null\n                };\n                if (newBaseQueueLast === null) {\n                  newBaseQueueFirst = newBaseQueueLast = clone;\n                  newBaseState = newState;\n                } else {\n                  newBaseQueueLast = newBaseQueueLast.next = clone;\n                }\n                currentlyRenderingFiber$1.lanes = mergeLanes(currentlyRenderingFiber$1.lanes, updateLane);\n                markSkippedUpdateLanes(updateLane);\n              } else {\n                if (newBaseQueueLast !== null) {\n                  var _clone = {\n                    // This update is going to be committed so we never want uncommit\n                    // it. Using NoLane works because 0 is a subset of all bitmasks, so\n                    // this will never be skipped by the check above.\n                    lane: NoLane,\n                    action: update.action,\n                    hasEagerState: update.hasEagerState,\n                    eagerState: update.eagerState,\n                    next: null\n                  };\n                  newBaseQueueLast = newBaseQueueLast.next = _clone;\n                }\n                if (update.hasEagerState) {\n                  newState = update.eagerState;\n                } else {\n                  var action = update.action;\n                  newState = reducer(newState, action);\n                }\n              }\n              update = update.next;\n            } while (update !== null && update !== first);\n            if (newBaseQueueLast === null) {\n              newBaseState = newState;\n            } else {\n              newBaseQueueLast.next = newBaseQueueFirst;\n            }\n            if (!objectIs(newState, hook.memoizedState)) {\n              markWorkInProgressReceivedUpdate();\n            }\n            hook.memoizedState = newState;\n            hook.baseState = newBaseState;\n            hook.baseQueue = newBaseQueueLast;\n            queue.lastRenderedState = newState;\n          }\n          var lastInterleaved = queue.interleaved;\n          if (lastInterleaved !== null) {\n            var interleaved = lastInterleaved;\n            do {\n              var interleavedLane = interleaved.lane;\n              currentlyRenderingFiber$1.lanes = mergeLanes(currentlyRenderingFiber$1.lanes, interleavedLane);\n              markSkippedUpdateLanes(interleavedLane);\n              interleaved = interleaved.next;\n            } while (interleaved !== lastInterleaved);\n          } else if (baseQueue === null) {\n            queue.lanes = NoLanes;\n          }\n          var dispatch = queue.dispatch;\n          return [hook.memoizedState, dispatch];\n        }\n        function rerenderReducer(reducer, initialArg, init) {\n          var hook = updateWorkInProgressHook();\n          var queue = hook.queue;\n          if (queue === null) {\n            throw new Error(\"Should have a queue. This is likely a bug in React. Please file an issue.\");\n          }\n          queue.lastRenderedReducer = reducer;\n          var dispatch = queue.dispatch;\n          var lastRenderPhaseUpdate = queue.pending;\n          var newState = hook.memoizedState;\n          if (lastRenderPhaseUpdate !== null) {\n            queue.pending = null;\n            var firstRenderPhaseUpdate = lastRenderPhaseUpdate.next;\n            var update = firstRenderPhaseUpdate;\n            do {\n              var action = update.action;\n              newState = reducer(newState, action);\n              update = update.next;\n            } while (update !== firstRenderPhaseUpdate);\n            if (!objectIs(newState, hook.memoizedState)) {\n              markWorkInProgressReceivedUpdate();\n            }\n            hook.memoizedState = newState;\n            if (hook.baseQueue === null) {\n              hook.baseState = newState;\n            }\n            queue.lastRenderedState = newState;\n          }\n          return [newState, dispatch];\n        }\n        function mountMutableSource(source, getSnapshot, subscribe) {\n          {\n            return void 0;\n          }\n        }\n        function updateMutableSource(source, getSnapshot, subscribe) {\n          {\n            return void 0;\n          }\n        }\n        function mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {\n          var fiber = currentlyRenderingFiber$1;\n          var hook = mountWorkInProgressHook();\n          var nextSnapshot;\n          var isHydrating2 = getIsHydrating();\n          if (isHydrating2) {\n            if (getServerSnapshot === void 0) {\n              throw new Error(\"Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.\");\n            }\n            nextSnapshot = getServerSnapshot();\n            {\n              if (!didWarnUncachedGetSnapshot) {\n                if (nextSnapshot !== getServerSnapshot()) {\n                  error(\"The result of getServerSnapshot should be cached to avoid an infinite loop\");\n                  didWarnUncachedGetSnapshot = true;\n                }\n              }\n            }\n          } else {\n            nextSnapshot = getSnapshot();\n            {\n              if (!didWarnUncachedGetSnapshot) {\n                var cachedSnapshot = getSnapshot();\n                if (!objectIs(nextSnapshot, cachedSnapshot)) {\n                  error(\"The result of getSnapshot should be cached to avoid an infinite loop\");\n                  didWarnUncachedGetSnapshot = true;\n                }\n              }\n            }\n            var root2 = getWorkInProgressRoot();\n            if (root2 === null) {\n              throw new Error(\"Expected a work-in-progress root. This is a bug in React. Please file an issue.\");\n            }\n            if (!includesBlockingLane(root2, renderLanes)) {\n              pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot);\n            }\n          }\n          hook.memoizedState = nextSnapshot;\n          var inst = {\n            value: nextSnapshot,\n            getSnapshot\n          };\n          hook.queue = inst;\n          mountEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [subscribe]);\n          fiber.flags |= Passive;\n          pushEffect(HasEffect | Passive$1, updateStoreInstance.bind(null, fiber, inst, nextSnapshot, getSnapshot), void 0, null);\n          return nextSnapshot;\n        }\n        function updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {\n          var fiber = currentlyRenderingFiber$1;\n          var hook = updateWorkInProgressHook();\n          var nextSnapshot = getSnapshot();\n          {\n            if (!didWarnUncachedGetSnapshot) {\n              var cachedSnapshot = getSnapshot();\n              if (!objectIs(nextSnapshot, cachedSnapshot)) {\n                error(\"The result of getSnapshot should be cached to avoid an infinite loop\");\n                didWarnUncachedGetSnapshot = true;\n              }\n            }\n          }\n          var prevSnapshot = hook.memoizedState;\n          var snapshotChanged = !objectIs(prevSnapshot, nextSnapshot);\n          if (snapshotChanged) {\n            hook.memoizedState = nextSnapshot;\n            markWorkInProgressReceivedUpdate();\n          }\n          var inst = hook.queue;\n          updateEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [subscribe]);\n          if (inst.getSnapshot !== getSnapshot || snapshotChanged || // Check if the susbcribe function changed. We can save some memory by\n          // checking whether we scheduled a subscription effect above.\n          workInProgressHook !== null && workInProgressHook.memoizedState.tag & HasEffect) {\n            fiber.flags |= Passive;\n            pushEffect(HasEffect | Passive$1, updateStoreInstance.bind(null, fiber, inst, nextSnapshot, getSnapshot), void 0, null);\n            var root2 = getWorkInProgressRoot();\n            if (root2 === null) {\n              throw new Error(\"Expected a work-in-progress root. This is a bug in React. Please file an issue.\");\n            }\n            if (!includesBlockingLane(root2, renderLanes)) {\n              pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot);\n            }\n          }\n          return nextSnapshot;\n        }\n        function pushStoreConsistencyCheck(fiber, getSnapshot, renderedSnapshot) {\n          fiber.flags |= StoreConsistency;\n          var check = {\n            getSnapshot,\n            value: renderedSnapshot\n          };\n          var componentUpdateQueue = currentlyRenderingFiber$1.updateQueue;\n          if (componentUpdateQueue === null) {\n            componentUpdateQueue = createFunctionComponentUpdateQueue();\n            currentlyRenderingFiber$1.updateQueue = componentUpdateQueue;\n            componentUpdateQueue.stores = [check];\n          } else {\n            var stores = componentUpdateQueue.stores;\n            if (stores === null) {\n              componentUpdateQueue.stores = [check];\n            } else {\n              stores.push(check);\n            }\n          }\n        }\n        function updateStoreInstance(fiber, inst, nextSnapshot, getSnapshot) {\n          inst.value = nextSnapshot;\n          inst.getSnapshot = getSnapshot;\n          if (checkIfSnapshotChanged(inst)) {\n            forceStoreRerender(fiber);\n          }\n        }\n        function subscribeToStore(fiber, inst, subscribe) {\n          var handleStoreChange = function() {\n            if (checkIfSnapshotChanged(inst)) {\n              forceStoreRerender(fiber);\n            }\n          };\n          return subscribe(handleStoreChange);\n        }\n        function checkIfSnapshotChanged(inst) {\n          var latestGetSnapshot = inst.getSnapshot;\n          var prevValue = inst.value;\n          try {\n            var nextValue = latestGetSnapshot();\n            return !objectIs(prevValue, nextValue);\n          } catch (error2) {\n            return true;\n          }\n        }\n        function forceStoreRerender(fiber) {\n          var root2 = enqueueConcurrentRenderForLane(fiber, SyncLane);\n          if (root2 !== null) {\n            scheduleUpdateOnFiber(root2, fiber, SyncLane, NoTimestamp);\n          }\n        }\n        function mountState(initialState) {\n          var hook = mountWorkInProgressHook();\n          if (typeof initialState === \"function\") {\n            initialState = initialState();\n          }\n          hook.memoizedState = hook.baseState = initialState;\n          var queue = {\n            pending: null,\n            interleaved: null,\n            lanes: NoLanes,\n            dispatch: null,\n            lastRenderedReducer: basicStateReducer,\n            lastRenderedState: initialState\n          };\n          hook.queue = queue;\n          var dispatch = queue.dispatch = dispatchSetState.bind(null, currentlyRenderingFiber$1, queue);\n          return [hook.memoizedState, dispatch];\n        }\n        function updateState(initialState) {\n          return updateReducer(basicStateReducer);\n        }\n        function rerenderState(initialState) {\n          return rerenderReducer(basicStateReducer);\n        }\n        function pushEffect(tag, create, destroy, deps) {\n          var effect = {\n            tag,\n            create,\n            destroy,\n            deps,\n            // Circular\n            next: null\n          };\n          var componentUpdateQueue = currentlyRenderingFiber$1.updateQueue;\n          if (componentUpdateQueue === null) {\n            componentUpdateQueue = createFunctionComponentUpdateQueue();\n            currentlyRenderingFiber$1.updateQueue = componentUpdateQueue;\n            componentUpdateQueue.lastEffect = effect.next = effect;\n          } else {\n            var lastEffect = componentUpdateQueue.lastEffect;\n            if (lastEffect === null) {\n              componentUpdateQueue.lastEffect = effect.next = effect;\n            } else {\n              var firstEffect = lastEffect.next;\n              lastEffect.next = effect;\n              effect.next = firstEffect;\n              componentUpdateQueue.lastEffect = effect;\n            }\n          }\n          return effect;\n        }\n        function mountRef(initialValue) {\n          var hook = mountWorkInProgressHook();\n          {\n            var _ref2 = {\n              current: initialValue\n            };\n            hook.memoizedState = _ref2;\n            return _ref2;\n          }\n        }\n        function updateRef(initialValue) {\n          var hook = updateWorkInProgressHook();\n          return hook.memoizedState;\n        }\n        function mountEffectImpl(fiberFlags, hookFlags, create, deps) {\n          var hook = mountWorkInProgressHook();\n          var nextDeps = deps === void 0 ? null : deps;\n          currentlyRenderingFiber$1.flags |= fiberFlags;\n          hook.memoizedState = pushEffect(HasEffect | hookFlags, create, void 0, nextDeps);\n        }\n        function updateEffectImpl(fiberFlags, hookFlags, create, deps) {\n          var hook = updateWorkInProgressHook();\n          var nextDeps = deps === void 0 ? null : deps;\n          var destroy = void 0;\n          if (currentHook !== null) {\n            var prevEffect = currentHook.memoizedState;\n            destroy = prevEffect.destroy;\n            if (nextDeps !== null) {\n              var prevDeps = prevEffect.deps;\n              if (areHookInputsEqual(nextDeps, prevDeps)) {\n                hook.memoizedState = pushEffect(hookFlags, create, destroy, nextDeps);\n                return;\n              }\n            }\n          }\n          currentlyRenderingFiber$1.flags |= fiberFlags;\n          hook.memoizedState = pushEffect(HasEffect | hookFlags, create, destroy, nextDeps);\n        }\n        function mountEffect(create, deps) {\n          if ((currentlyRenderingFiber$1.mode & StrictEffectsMode) !== NoMode) {\n            return mountEffectImpl(MountPassiveDev | Passive | PassiveStatic, Passive$1, create, deps);\n          } else {\n            return mountEffectImpl(Passive | PassiveStatic, Passive$1, create, deps);\n          }\n        }\n        function updateEffect(create, deps) {\n          return updateEffectImpl(Passive, Passive$1, create, deps);\n        }\n        function mountInsertionEffect(create, deps) {\n          return mountEffectImpl(Update, Insertion, create, deps);\n        }\n        function updateInsertionEffect(create, deps) {\n          return updateEffectImpl(Update, Insertion, create, deps);\n        }\n        function mountLayoutEffect(create, deps) {\n          var fiberFlags = Update;\n          {\n            fiberFlags |= LayoutStatic;\n          }\n          if ((currentlyRenderingFiber$1.mode & StrictEffectsMode) !== NoMode) {\n            fiberFlags |= MountLayoutDev;\n          }\n          return mountEffectImpl(fiberFlags, Layout, create, deps);\n        }\n        function updateLayoutEffect(create, deps) {\n          return updateEffectImpl(Update, Layout, create, deps);\n        }\n        function imperativeHandleEffect(create, ref) {\n          if (typeof ref === \"function\") {\n            var refCallback = ref;\n            var _inst = create();\n            refCallback(_inst);\n            return function() {\n              refCallback(null);\n            };\n          } else if (ref !== null && ref !== void 0) {\n            var refObject = ref;\n            {\n              if (!refObject.hasOwnProperty(\"current\")) {\n                error(\"Expected useImperativeHandle() first argument to either be a ref callback or React.createRef() object. Instead received: %s.\", \"an object with keys {\" + Object.keys(refObject).join(\", \") + \"}\");\n              }\n            }\n            var _inst2 = create();\n            refObject.current = _inst2;\n            return function() {\n              refObject.current = null;\n            };\n          }\n        }\n        function mountImperativeHandle(ref, create, deps) {\n          {\n            if (typeof create !== \"function\") {\n              error(\"Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.\", create !== null ? typeof create : \"null\");\n            }\n          }\n          var effectDeps = deps !== null && deps !== void 0 ? deps.concat([ref]) : null;\n          var fiberFlags = Update;\n          {\n            fiberFlags |= LayoutStatic;\n          }\n          if ((currentlyRenderingFiber$1.mode & StrictEffectsMode) !== NoMode) {\n            fiberFlags |= MountLayoutDev;\n          }\n          return mountEffectImpl(fiberFlags, Layout, imperativeHandleEffect.bind(null, create, ref), effectDeps);\n        }\n        function updateImperativeHandle(ref, create, deps) {\n          {\n            if (typeof create !== \"function\") {\n              error(\"Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.\", create !== null ? typeof create : \"null\");\n            }\n          }\n          var effectDeps = deps !== null && deps !== void 0 ? deps.concat([ref]) : null;\n          return updateEffectImpl(Update, Layout, imperativeHandleEffect.bind(null, create, ref), effectDeps);\n        }\n        function mountDebugValue(value, formatterFn) {\n        }\n        var updateDebugValue = mountDebugValue;\n        function mountCallback(callback, deps) {\n          var hook = mountWorkInProgressHook();\n          var nextDeps = deps === void 0 ? null : deps;\n          hook.memoizedState = [callback, nextDeps];\n          return callback;\n        }\n        function updateCallback(callback, deps) {\n          var hook = updateWorkInProgressHook();\n          var nextDeps = deps === void 0 ? null : deps;\n          var prevState = hook.memoizedState;\n          if (prevState !== null) {\n            if (nextDeps !== null) {\n              var prevDeps = prevState[1];\n              if (areHookInputsEqual(nextDeps, prevDeps)) {\n                return prevState[0];\n              }\n            }\n          }\n          hook.memoizedState = [callback, nextDeps];\n          return callback;\n        }\n        function mountMemo(nextCreate, deps) {\n          var hook = mountWorkInProgressHook();\n          var nextDeps = deps === void 0 ? null : deps;\n          var nextValue = nextCreate();\n          hook.memoizedState = [nextValue, nextDeps];\n          return nextValue;\n        }\n        function updateMemo(nextCreate, deps) {\n          var hook = updateWorkInProgressHook();\n          var nextDeps = deps === void 0 ? null : deps;\n          var prevState = hook.memoizedState;\n          if (prevState !== null) {\n            if (nextDeps !== null) {\n              var prevDeps = prevState[1];\n              if (areHookInputsEqual(nextDeps, prevDeps)) {\n                return prevState[0];\n              }\n            }\n          }\n          var nextValue = nextCreate();\n          hook.memoizedState = [nextValue, nextDeps];\n          return nextValue;\n        }\n        function mountDeferredValue(value) {\n          var hook = mountWorkInProgressHook();\n          hook.memoizedState = value;\n          return value;\n        }\n        function updateDeferredValue(value) {\n          var hook = updateWorkInProgressHook();\n          var resolvedCurrentHook = currentHook;\n          var prevValue = resolvedCurrentHook.memoizedState;\n          return updateDeferredValueImpl(hook, prevValue, value);\n        }\n        function rerenderDeferredValue(value) {\n          var hook = updateWorkInProgressHook();\n          if (currentHook === null) {\n            hook.memoizedState = value;\n            return value;\n          } else {\n            var prevValue = currentHook.memoizedState;\n            return updateDeferredValueImpl(hook, prevValue, value);\n          }\n        }\n        function updateDeferredValueImpl(hook, prevValue, value) {\n          var shouldDeferValue = !includesOnlyNonUrgentLanes(renderLanes);\n          if (shouldDeferValue) {\n            if (!objectIs(value, prevValue)) {\n              var deferredLane = claimNextTransitionLane();\n              currentlyRenderingFiber$1.lanes = mergeLanes(currentlyRenderingFiber$1.lanes, deferredLane);\n              markSkippedUpdateLanes(deferredLane);\n              hook.baseState = true;\n            }\n            return prevValue;\n          } else {\n            if (hook.baseState) {\n              hook.baseState = false;\n              markWorkInProgressReceivedUpdate();\n            }\n            hook.memoizedState = value;\n            return value;\n          }\n        }\n        function startTransition(setPending, callback, options2) {\n          var previousPriority = getCurrentUpdatePriority();\n          setCurrentUpdatePriority(higherEventPriority(previousPriority, ContinuousEventPriority));\n          setPending(true);\n          var prevTransition = ReactCurrentBatchConfig$2.transition;\n          ReactCurrentBatchConfig$2.transition = {};\n          var currentTransition = ReactCurrentBatchConfig$2.transition;\n          {\n            ReactCurrentBatchConfig$2.transition._updatedFibers = /* @__PURE__ */ new Set();\n          }\n          try {\n            setPending(false);\n            callback();\n          } finally {\n            setCurrentUpdatePriority(previousPriority);\n            ReactCurrentBatchConfig$2.transition = prevTransition;\n            {\n              if (prevTransition === null && currentTransition._updatedFibers) {\n                var updatedFibersCount = currentTransition._updatedFibers.size;\n                if (updatedFibersCount > 10) {\n                  warn(\"Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table.\");\n                }\n                currentTransition._updatedFibers.clear();\n              }\n            }\n          }\n        }\n        function mountTransition() {\n          var _mountState = mountState(false), isPending = _mountState[0], setPending = _mountState[1];\n          var start = startTransition.bind(null, setPending);\n          var hook = mountWorkInProgressHook();\n          hook.memoizedState = start;\n          return [isPending, start];\n        }\n        function updateTransition() {\n          var _updateState = updateState(), isPending = _updateState[0];\n          var hook = updateWorkInProgressHook();\n          var start = hook.memoizedState;\n          return [isPending, start];\n        }\n        function rerenderTransition() {\n          var _rerenderState = rerenderState(), isPending = _rerenderState[0];\n          var hook = updateWorkInProgressHook();\n          var start = hook.memoizedState;\n          return [isPending, start];\n        }\n        var isUpdatingOpaqueValueInRenderPhase = false;\n        function getIsUpdatingOpaqueValueInRenderPhaseInDEV() {\n          {\n            return isUpdatingOpaqueValueInRenderPhase;\n          }\n        }\n        function mountId() {\n          var hook = mountWorkInProgressHook();\n          var root2 = getWorkInProgressRoot();\n          var identifierPrefix = root2.identifierPrefix;\n          var id;\n          if (getIsHydrating()) {\n            var treeId = getTreeId();\n            id = \":\" + identifierPrefix + \"R\" + treeId;\n            var localId = localIdCounter++;\n            if (localId > 0) {\n              id += \"H\" + localId.toString(32);\n            }\n            id += \":\";\n          } else {\n            var globalClientId = globalClientIdCounter++;\n            id = \":\" + identifierPrefix + \"r\" + globalClientId.toString(32) + \":\";\n          }\n          hook.memoizedState = id;\n          return id;\n        }\n        function updateId() {\n          var hook = updateWorkInProgressHook();\n          var id = hook.memoizedState;\n          return id;\n        }\n        function dispatchReducerAction(fiber, queue, action) {\n          {\n            if (typeof arguments[3] === \"function\") {\n              error(\"State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().\");\n            }\n          }\n          var lane = requestUpdateLane(fiber);\n          var update = {\n            lane,\n            action,\n            hasEagerState: false,\n            eagerState: null,\n            next: null\n          };\n          if (isRenderPhaseUpdate(fiber)) {\n            enqueueRenderPhaseUpdate(queue, update);\n          } else {\n            var root2 = enqueueConcurrentHookUpdate(fiber, queue, update, lane);\n            if (root2 !== null) {\n              var eventTime = requestEventTime();\n              scheduleUpdateOnFiber(root2, fiber, lane, eventTime);\n              entangleTransitionUpdate(root2, queue, lane);\n            }\n          }\n          markUpdateInDevTools(fiber, lane);\n        }\n        function dispatchSetState(fiber, queue, action) {\n          {\n            if (typeof arguments[3] === \"function\") {\n              error(\"State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().\");\n            }\n          }\n          var lane = requestUpdateLane(fiber);\n          var update = {\n            lane,\n            action,\n            hasEagerState: false,\n            eagerState: null,\n            next: null\n          };\n          if (isRenderPhaseUpdate(fiber)) {\n            enqueueRenderPhaseUpdate(queue, update);\n          } else {\n            var alternate = fiber.alternate;\n            if (fiber.lanes === NoLanes && (alternate === null || alternate.lanes === NoLanes)) {\n              var lastRenderedReducer = queue.lastRenderedReducer;\n              if (lastRenderedReducer !== null) {\n                var prevDispatcher;\n                {\n                  prevDispatcher = ReactCurrentDispatcher$1.current;\n                  ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n                }\n                try {\n                  var currentState = queue.lastRenderedState;\n                  var eagerState = lastRenderedReducer(currentState, action);\n                  update.hasEagerState = true;\n                  update.eagerState = eagerState;\n                  if (objectIs(eagerState, currentState)) {\n                    enqueueConcurrentHookUpdateAndEagerlyBailout(fiber, queue, update, lane);\n                    return;\n                  }\n                } catch (error2) {\n                } finally {\n                  {\n                    ReactCurrentDispatcher$1.current = prevDispatcher;\n                  }\n                }\n              }\n            }\n            var root2 = enqueueConcurrentHookUpdate(fiber, queue, update, lane);\n            if (root2 !== null) {\n              var eventTime = requestEventTime();\n              scheduleUpdateOnFiber(root2, fiber, lane, eventTime);\n              entangleTransitionUpdate(root2, queue, lane);\n            }\n          }\n          markUpdateInDevTools(fiber, lane);\n        }\n        function isRenderPhaseUpdate(fiber) {\n          var alternate = fiber.alternate;\n          return fiber === currentlyRenderingFiber$1 || alternate !== null && alternate === currentlyRenderingFiber$1;\n        }\n        function enqueueRenderPhaseUpdate(queue, update) {\n          didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = true;\n          var pending = queue.pending;\n          if (pending === null) {\n            update.next = update;\n          } else {\n            update.next = pending.next;\n            pending.next = update;\n          }\n          queue.pending = update;\n        }\n        function entangleTransitionUpdate(root2, queue, lane) {\n          if (isTransitionLane(lane)) {\n            var queueLanes = queue.lanes;\n            queueLanes = intersectLanes(queueLanes, root2.pendingLanes);\n            var newQueueLanes = mergeLanes(queueLanes, lane);\n            queue.lanes = newQueueLanes;\n            markRootEntangled(root2, newQueueLanes);\n          }\n        }\n        function markUpdateInDevTools(fiber, lane, action) {\n          {\n            markStateUpdateScheduled(fiber, lane);\n          }\n        }\n        var ContextOnlyDispatcher = {\n          readContext,\n          useCallback: throwInvalidHookError,\n          useContext: throwInvalidHookError,\n          useEffect: throwInvalidHookError,\n          useImperativeHandle: throwInvalidHookError,\n          useInsertionEffect: throwInvalidHookError,\n          useLayoutEffect: throwInvalidHookError,\n          useMemo: throwInvalidHookError,\n          useReducer: throwInvalidHookError,\n          useRef: throwInvalidHookError,\n          useState: throwInvalidHookError,\n          useDebugValue: throwInvalidHookError,\n          useDeferredValue: throwInvalidHookError,\n          useTransition: throwInvalidHookError,\n          useMutableSource: throwInvalidHookError,\n          useSyncExternalStore: throwInvalidHookError,\n          useId: throwInvalidHookError,\n          unstable_isNewReconciler: enableNewReconciler\n        };\n        var HooksDispatcherOnMountInDEV = null;\n        var HooksDispatcherOnMountWithHookTypesInDEV = null;\n        var HooksDispatcherOnUpdateInDEV = null;\n        var HooksDispatcherOnRerenderInDEV = null;\n        var InvalidNestedHooksDispatcherOnMountInDEV = null;\n        var InvalidNestedHooksDispatcherOnUpdateInDEV = null;\n        var InvalidNestedHooksDispatcherOnRerenderInDEV = null;\n        {\n          var warnInvalidContextAccess = function() {\n            error(\"Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().\");\n          };\n          var warnInvalidHookAccess = function() {\n            error(\"Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks\");\n          };\n          HooksDispatcherOnMountInDEV = {\n            readContext: function(context) {\n              return readContext(context);\n            },\n            useCallback: function(callback, deps) {\n              currentHookNameInDev = \"useCallback\";\n              mountHookTypesDev();\n              checkDepsAreArrayDev(deps);\n              return mountCallback(callback, deps);\n            },\n            useContext: function(context) {\n              currentHookNameInDev = \"useContext\";\n              mountHookTypesDev();\n              return readContext(context);\n            },\n            useEffect: function(create, deps) {\n              currentHookNameInDev = \"useEffect\";\n              mountHookTypesDev();\n              checkDepsAreArrayDev(deps);\n              return mountEffect(create, deps);\n            },\n            useImperativeHandle: function(ref, create, deps) {\n              currentHookNameInDev = \"useImperativeHandle\";\n              mountHookTypesDev();\n              checkDepsAreArrayDev(deps);\n              return mountImperativeHandle(ref, create, deps);\n            },\n            useInsertionEffect: function(create, deps) {\n              currentHookNameInDev = \"useInsertionEffect\";\n              mountHookTypesDev();\n              checkDepsAreArrayDev(deps);\n              return mountInsertionEffect(create, deps);\n            },\n            useLayoutEffect: function(create, deps) {\n              currentHookNameInDev = \"useLayoutEffect\";\n              mountHookTypesDev();\n              checkDepsAreArrayDev(deps);\n              return mountLayoutEffect(create, deps);\n            },\n            useMemo: function(create, deps) {\n              currentHookNameInDev = \"useMemo\";\n              mountHookTypesDev();\n              checkDepsAreArrayDev(deps);\n              var prevDispatcher = ReactCurrentDispatcher$1.current;\n              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;\n              try {\n                return mountMemo(create, deps);\n              } finally {\n                ReactCurrentDispatcher$1.current = prevDispatcher;\n              }\n            },\n            useReducer: function(reducer, initialArg, init) {\n              currentHookNameInDev = \"useReducer\";\n              mountHookTypesDev();\n              var prevDispatcher = ReactCurrentDispatcher$1.current;\n              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;\n              try {\n                return mountReducer(reducer, initialArg, init);\n              } finally {\n                ReactCurrentDispatcher$1.current = prevDispatcher;\n              }\n            },\n            useRef: function(initialValue) {\n              currentHookNameInDev = \"useRef\";\n              mountHookTypesDev();\n              return mountRef(initialValue);\n            },\n            useState: function(initialState) {\n              currentHookNameInDev = \"useState\";\n              mountHookTypesDev();\n              var prevDispatcher = ReactCurrentDispatcher$1.current;\n              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;\n              try {\n                return mountState(initialState);\n              } finally {\n                ReactCurrentDispatcher$1.current = prevDispatcher;\n              }\n            },\n            useDebugValue: function(value, formatterFn) {\n              currentHookNameInDev = \"useDebugValue\";\n              mountHookTypesDev();\n              return mountDebugValue();\n            },\n            useDeferredValue: function(value) {\n              currentHookNameInDev = \"useDeferredValue\";\n              mountHookTypesDev();\n              return mountDeferredValue(value);\n            },\n            useTransition: function() {\n              currentHookNameInDev = \"useTransition\";\n              mountHookTypesDev();\n              return mountTransition();\n            },\n            useMutableSource: function(source, getSnapshot, subscribe) {\n              currentHookNameInDev = \"useMutableSource\";\n              mountHookTypesDev();\n              return mountMutableSource();\n            },\n            useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {\n              currentHookNameInDev = \"useSyncExternalStore\";\n              mountHookTypesDev();\n              return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n            },\n            useId: function() {\n              currentHookNameInDev = \"useId\";\n              mountHookTypesDev();\n              return mountId();\n            },\n            unstable_isNewReconciler: enableNewReconciler\n          };\n          HooksDispatcherOnMountWithHookTypesInDEV = {\n            readContext: function(context) {\n              return readContext(context);\n            },\n            useCallback: function(callback, deps) {\n              currentHookNameInDev = \"useCallback\";\n              updateHookTypesDev();\n              return mountCallback(callback, deps);\n            },\n            useContext: function(context) {\n              currentHookNameInDev = \"useContext\";\n              updateHookTypesDev();\n              return readContext(context);\n            },\n            useEffect: function(create, deps) {\n              currentHookNameInDev = \"useEffect\";\n              updateHookTypesDev();\n              return mountEffect(create, deps);\n            },\n            useImperativeHandle: function(ref, create, deps) {\n              currentHookNameInDev = \"useImperativeHandle\";\n              updateHookTypesDev();\n              return mountImperativeHandle(ref, create, deps);\n            },\n            useInsertionEffect: function(create, deps) {\n              currentHookNameInDev = \"useInsertionEffect\";\n              updateHookTypesDev();\n              return mountInsertionEffect(create, deps);\n            },\n            useLayoutEffect: function(create, deps) {\n              currentHookNameInDev = \"useLayoutEffect\";\n              updateHookTypesDev();\n              return mountLayoutEffect(create, deps);\n            },\n            useMemo: function(create, deps) {\n              currentHookNameInDev = \"useMemo\";\n              updateHookTypesDev();\n              var prevDispatcher = ReactCurrentDispatcher$1.current;\n              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;\n              try {\n                return mountMemo(create, deps);\n              } finally {\n                ReactCurrentDispatcher$1.current = prevDispatcher;\n              }\n            },\n            useReducer: function(reducer, initialArg, init) {\n              currentHookNameInDev = \"useReducer\";\n              updateHookTypesDev();\n              var prevDispatcher = ReactCurrentDispatcher$1.current;\n              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;\n              try {\n                return mountReducer(reducer, initialArg, init);\n              } finally {\n                ReactCurrentDispatcher$1.current = prevDispatcher;\n              }\n            },\n            useRef: function(initialValue) {\n              currentHookNameInDev = \"useRef\";\n              updateHookTypesDev();\n              return mountRef(initialValue);\n            },\n            useState: function(initialState) {\n              currentHookNameInDev = \"useState\";\n              updateHookTypesDev();\n              var prevDispatcher = ReactCurrentDispatcher$1.current;\n              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;\n              try {\n                return mountState(initialState);\n              } finally {\n                ReactCurrentDispatcher$1.current = prevDispatcher;\n              }\n            },\n            useDebugValue: function(value, formatterFn) {\n              currentHookNameInDev = \"useDebugValue\";\n              updateHookTypesDev();\n              return mountDebugValue();\n            },\n            useDeferredValue: function(value) {\n              currentHookNameInDev = \"useDeferredValue\";\n              updateHookTypesDev();\n              return mountDeferredValue(value);\n            },\n            useTransition: function() {\n              currentHookNameInDev = \"useTransition\";\n              updateHookTypesDev();\n              return mountTransition();\n            },\n            useMutableSource: function(source, getSnapshot, subscribe) {\n              currentHookNameInDev = \"useMutableSource\";\n              updateHookTypesDev();\n              return mountMutableSource();\n            },\n            useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {\n              currentHookNameInDev = \"useSyncExternalStore\";\n              updateHookTypesDev();\n              return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n            },\n            useId: function() {\n              currentHookNameInDev = \"useId\";\n              updateHookTypesDev();\n              return mountId();\n            },\n            unstable_isNewReconciler: enableNewReconciler\n          };\n          HooksDispatcherOnUpdateInDEV = {\n            readContext: function(context) {\n              return readContext(context);\n            },\n            useCallback: function(callback, deps) {\n              currentHookNameInDev = \"useCallback\";\n              updateHookTypesDev();\n              return updateCallback(callback, deps);\n            },\n            useContext: function(context) {\n              currentHookNameInDev = \"useContext\";\n              updateHookTypesDev();\n              return readContext(context);\n            },\n            useEffect: function(create, deps) {\n              currentHookNameInDev = \"useEffect\";\n              updateHookTypesDev();\n              return updateEffect(create, deps);\n            },\n            useImperativeHandle: function(ref, create, deps) {\n              currentHookNameInDev = \"useImperativeHandle\";\n              updateHookTypesDev();\n              return updateImperativeHandle(ref, create, deps);\n            },\n            useInsertionEffect: function(create, deps) {\n              currentHookNameInDev = \"useInsertionEffect\";\n              updateHookTypesDev();\n              return updateInsertionEffect(create, deps);\n            },\n            useLayoutEffect: function(create, deps) {\n              currentHookNameInDev = \"useLayoutEffect\";\n              updateHookTypesDev();\n              return updateLayoutEffect(create, deps);\n            },\n            useMemo: function(create, deps) {\n              currentHookNameInDev = \"useMemo\";\n              updateHookTypesDev();\n              var prevDispatcher = ReactCurrentDispatcher$1.current;\n              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n              try {\n                return updateMemo(create, deps);\n              } finally {\n                ReactCurrentDispatcher$1.current = prevDispatcher;\n              }\n            },\n            useReducer: function(reducer, initialArg, init) {\n              currentHookNameInDev = \"useReducer\";\n              updateHookTypesDev();\n              var prevDispatcher = ReactCurrentDispatcher$1.current;\n              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n              try {\n                return updateReducer(reducer, initialArg, init);\n              } finally {\n                ReactCurrentDispatcher$1.current = prevDispatcher;\n              }\n            },\n            useRef: function(initialValue) {\n              currentHookNameInDev = \"useRef\";\n              updateHookTypesDev();\n              return updateRef();\n            },\n            useState: function(initialState) {\n              currentHookNameInDev = \"useState\";\n              updateHookTypesDev();\n              var prevDispatcher = ReactCurrentDispatcher$1.current;\n              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n              try {\n                return updateState(initialState);\n              } finally {\n                ReactCurrentDispatcher$1.current = prevDispatcher;\n              }\n            },\n            useDebugValue: function(value, formatterFn) {\n              currentHookNameInDev = \"useDebugValue\";\n              updateHookTypesDev();\n              return updateDebugValue();\n            },\n            useDeferredValue: function(value) {\n              currentHookNameInDev = \"useDeferredValue\";\n              updateHookTypesDev();\n              return updateDeferredValue(value);\n            },\n            useTransition: function() {\n              currentHookNameInDev = \"useTransition\";\n              updateHookTypesDev();\n              return updateTransition();\n            },\n            useMutableSource: function(source, getSnapshot, subscribe) {\n              currentHookNameInDev = \"useMutableSource\";\n              updateHookTypesDev();\n              return updateMutableSource();\n            },\n            useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {\n              currentHookNameInDev = \"useSyncExternalStore\";\n              updateHookTypesDev();\n              return updateSyncExternalStore(subscribe, getSnapshot);\n            },\n            useId: function() {\n              currentHookNameInDev = \"useId\";\n              updateHookTypesDev();\n              return updateId();\n            },\n            unstable_isNewReconciler: enableNewReconciler\n          };\n          HooksDispatcherOnRerenderInDEV = {\n            readContext: function(context) {\n              return readContext(context);\n            },\n            useCallback: function(callback, deps) {\n              currentHookNameInDev = \"useCallback\";\n              updateHookTypesDev();\n              return updateCallback(callback, deps);\n            },\n            useContext: function(context) {\n              currentHookNameInDev = \"useContext\";\n              updateHookTypesDev();\n              return readContext(context);\n            },\n            useEffect: function(create, deps) {\n              currentHookNameInDev = \"useEffect\";\n              updateHookTypesDev();\n              return updateEffect(create, deps);\n            },\n            useImperativeHandle: function(ref, create, deps) {\n              currentHookNameInDev = \"useImperativeHandle\";\n              updateHookTypesDev();\n              return updateImperativeHandle(ref, create, deps);\n            },\n            useInsertionEffect: function(create, deps) {\n              currentHookNameInDev = \"useInsertionEffect\";\n              updateHookTypesDev();\n              return updateInsertionEffect(create, deps);\n            },\n            useLayoutEffect: function(create, deps) {\n              currentHookNameInDev = \"useLayoutEffect\";\n              updateHookTypesDev();\n              return updateLayoutEffect(create, deps);\n            },\n            useMemo: function(create, deps) {\n              currentHookNameInDev = \"useMemo\";\n              updateHookTypesDev();\n              var prevDispatcher = ReactCurrentDispatcher$1.current;\n              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;\n              try {\n                return updateMemo(create, deps);\n              } finally {\n                ReactCurrentDispatcher$1.current = prevDispatcher;\n              }\n            },\n            useReducer: function(reducer, initialArg, init) {\n              currentHookNameInDev = \"useReducer\";\n              updateHookTypesDev();\n              var prevDispatcher = ReactCurrentDispatcher$1.current;\n              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;\n              try {\n                return rerenderReducer(reducer, initialArg, init);\n              } finally {\n                ReactCurrentDispatcher$1.current = prevDispatcher;\n              }\n            },\n            useRef: function(initialValue) {\n              currentHookNameInDev = \"useRef\";\n              updateHookTypesDev();\n              return updateRef();\n            },\n            useState: function(initialState) {\n              currentHookNameInDev = \"useState\";\n              updateHookTypesDev();\n              var prevDispatcher = ReactCurrentDispatcher$1.current;\n              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;\n              try {\n                return rerenderState(initialState);\n              } finally {\n                ReactCurrentDispatcher$1.current = prevDispatcher;\n              }\n            },\n            useDebugValue: function(value, formatterFn) {\n              currentHookNameInDev = \"useDebugValue\";\n              updateHookTypesDev();\n              return updateDebugValue();\n            },\n            useDeferredValue: function(value) {\n              currentHookNameInDev = \"useDeferredValue\";\n              updateHookTypesDev();\n              return rerenderDeferredValue(value);\n            },\n            useTransition: function() {\n              currentHookNameInDev = \"useTransition\";\n              updateHookTypesDev();\n              return rerenderTransition();\n            },\n            useMutableSource: function(source, getSnapshot, subscribe) {\n              currentHookNameInDev = \"useMutableSource\";\n              updateHookTypesDev();\n              return updateMutableSource();\n            },\n            useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {\n              currentHookNameInDev = \"useSyncExternalStore\";\n              updateHookTypesDev();\n              return updateSyncExternalStore(subscribe, getSnapshot);\n            },\n            useId: function() {\n              currentHookNameInDev = \"useId\";\n              updateHookTypesDev();\n              return updateId();\n            },\n            unstable_isNewReconciler: enableNewReconciler\n          };\n          InvalidNestedHooksDispatcherOnMountInDEV = {\n            readContext: function(context) {\n              warnInvalidContextAccess();\n              return readContext(context);\n            },\n            useCallback: function(callback, deps) {\n              currentHookNameInDev = \"useCallback\";\n              warnInvalidHookAccess();\n              mountHookTypesDev();\n              return mountCallback(callback, deps);\n            },\n            useContext: function(context) {\n              currentHookNameInDev = \"useContext\";\n              warnInvalidHookAccess();\n              mountHookTypesDev();\n              return readContext(context);\n            },\n            useEffect: function(create, deps) {\n              currentHookNameInDev = \"useEffect\";\n              warnInvalidHookAccess();\n              mountHookTypesDev();\n              return mountEffect(create, deps);\n            },\n            useImperativeHandle: function(ref, create, deps) {\n              currentHookNameInDev = \"useImperativeHandle\";\n              warnInvalidHookAccess();\n              mountHookTypesDev();\n              return mountImperativeHandle(ref, create, deps);\n            },\n            useInsertionEffect: function(create, deps) {\n              currentHookNameInDev = \"useInsertionEffect\";\n              warnInvalidHookAccess();\n              mountHookTypesDev();\n              return mountInsertionEffect(create, deps);\n            },\n            useLayoutEffect: function(create, deps) {\n              currentHookNameInDev = \"useLayoutEffect\";\n              warnInvalidHookAccess();\n              mountHookTypesDev();\n              return mountLayoutEffect(create, deps);\n            },\n            useMemo: function(create, deps) {\n              currentHookNameInDev = \"useMemo\";\n              warnInvalidHookAccess();\n              mountHookTypesDev();\n              var prevDispatcher = ReactCurrentDispatcher$1.current;\n              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;\n              try {\n                return mountMemo(create, deps);\n              } finally {\n                ReactCurrentDispatcher$1.current = prevDispatcher;\n              }\n            },\n            useReducer: function(reducer, initialArg, init) {\n              currentHookNameInDev = \"useReducer\";\n              warnInvalidHookAccess();\n              mountHookTypesDev();\n              var prevDispatcher = ReactCurrentDispatcher$1.current;\n              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;\n              try {\n                return mountReducer(reducer, initialArg, init);\n              } finally {\n                ReactCurrentDispatcher$1.current = prevDispatcher;\n              }\n            },\n            useRef: function(initialValue) {\n              currentHookNameInDev = \"useRef\";\n              warnInvalidHookAccess();\n              mountHookTypesDev();\n              return mountRef(initialValue);\n            },\n            useState: function(initialState) {\n              currentHookNameInDev = \"useState\";\n              warnInvalidHookAccess();\n              mountHookTypesDev();\n              var prevDispatcher = ReactCurrentDispatcher$1.current;\n              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;\n              try {\n                return mountState(initialState);\n              } finally {\n                ReactCurrentDispatcher$1.current = prevDispatcher;\n              }\n            },\n            useDebugValue: function(value, formatterFn) {\n              currentHookNameInDev = \"useDebugValue\";\n              warnInvalidHookAccess();\n              mountHookTypesDev();\n              return mountDebugValue();\n            },\n            useDeferredValue: function(value) {\n              currentHookNameInDev = \"useDeferredValue\";\n              warnInvalidHookAccess();\n              mountHookTypesDev();\n              return mountDeferredValue(value);\n            },\n            useTransition: function() {\n              currentHookNameInDev = \"useTransition\";\n              warnInvalidHookAccess();\n              mountHookTypesDev();\n              return mountTransition();\n            },\n            useMutableSource: function(source, getSnapshot, subscribe) {\n              currentHookNameInDev = \"useMutableSource\";\n              warnInvalidHookAccess();\n              mountHookTypesDev();\n              return mountMutableSource();\n            },\n            useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {\n              currentHookNameInDev = \"useSyncExternalStore\";\n              warnInvalidHookAccess();\n              mountHookTypesDev();\n              return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n            },\n            useId: function() {\n              currentHookNameInDev = \"useId\";\n              warnInvalidHookAccess();\n              mountHookTypesDev();\n              return mountId();\n            },\n            unstable_isNewReconciler: enableNewReconciler\n          };\n          InvalidNestedHooksDispatcherOnUpdateInDEV = {\n            readContext: function(context) {\n              warnInvalidContextAccess();\n              return readContext(context);\n            },\n            useCallback: function(callback, deps) {\n              currentHookNameInDev = \"useCallback\";\n              warnInvalidHookAccess();\n              updateHookTypesDev();\n              return updateCallback(callback, deps);\n            },\n            useContext: function(context) {\n              currentHookNameInDev = \"useContext\";\n              warnInvalidHookAccess();\n              updateHookTypesDev();\n              return readContext(context);\n            },\n            useEffect: function(create, deps) {\n              currentHookNameInDev = \"useEffect\";\n              warnInvalidHookAccess();\n              updateHookTypesDev();\n              return updateEffect(create, deps);\n            },\n            useImperativeHandle: function(ref, create, deps) {\n              currentHookNameInDev = \"useImperativeHandle\";\n              warnInvalidHookAccess();\n              updateHookTypesDev();\n              return updateImperativeHandle(ref, create, deps);\n            },\n            useInsertionEffect: function(create, deps) {\n              currentHookNameInDev = \"useInsertionEffect\";\n              warnInvalidHookAccess();\n              updateHookTypesDev();\n              return updateInsertionEffect(create, deps);\n            },\n            useLayoutEffect: function(create, deps) {\n              currentHookNameInDev = \"useLayoutEffect\";\n              warnInvalidHookAccess();\n              updateHookTypesDev();\n              return updateLayoutEffect(create, deps);\n            },\n            useMemo: function(create, deps) {\n              currentHookNameInDev = \"useMemo\";\n              warnInvalidHookAccess();\n              updateHookTypesDev();\n              var prevDispatcher = ReactCurrentDispatcher$1.current;\n              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n              try {\n                return updateMemo(create, deps);\n              } finally {\n                ReactCurrentDispatcher$1.current = prevDispatcher;\n              }\n            },\n            useReducer: function(reducer, initialArg, init) {\n              currentHookNameInDev = \"useReducer\";\n              warnInvalidHookAccess();\n              updateHookTypesDev();\n              var prevDispatcher = ReactCurrentDispatcher$1.current;\n              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n              try {\n                return updateReducer(reducer, initialArg, init);\n              } finally {\n                ReactCurrentDispatcher$1.current = prevDispatcher;\n              }\n            },\n            useRef: function(initialValue) {\n              currentHookNameInDev = \"useRef\";\n              warnInvalidHookAccess();\n              updateHookTypesDev();\n              return updateRef();\n            },\n            useState: function(initialState) {\n              currentHookNameInDev = \"useState\";\n              warnInvalidHookAccess();\n              updateHookTypesDev();\n              var prevDispatcher = ReactCurrentDispatcher$1.current;\n              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n              try {\n                return updateState(initialState);\n              } finally {\n                ReactCurrentDispatcher$1.current = prevDispatcher;\n              }\n            },\n            useDebugValue: function(value, formatterFn) {\n              currentHookNameInDev = \"useDebugValue\";\n              warnInvalidHookAccess();\n              updateHookTypesDev();\n              return updateDebugValue();\n            },\n            useDeferredValue: function(value) {\n              currentHookNameInDev = \"useDeferredValue\";\n              warnInvalidHookAccess();\n              updateHookTypesDev();\n              return updateDeferredValue(value);\n            },\n            useTransition: function() {\n              currentHookNameInDev = \"useTransition\";\n              warnInvalidHookAccess();\n              updateHookTypesDev();\n              return updateTransition();\n            },\n            useMutableSource: function(source, getSnapshot, subscribe) {\n              currentHookNameInDev = \"useMutableSource\";\n              warnInvalidHookAccess();\n              updateHookTypesDev();\n              return updateMutableSource();\n            },\n            useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {\n              currentHookNameInDev = \"useSyncExternalStore\";\n              warnInvalidHookAccess();\n              updateHookTypesDev();\n              return updateSyncExternalStore(subscribe, getSnapshot);\n            },\n            useId: function() {\n              currentHookNameInDev = \"useId\";\n              warnInvalidHookAccess();\n              updateHookTypesDev();\n              return updateId();\n            },\n            unstable_isNewReconciler: enableNewReconciler\n          };\n          InvalidNestedHooksDispatcherOnRerenderInDEV = {\n            readContext: function(context) {\n              warnInvalidContextAccess();\n              return readContext(context);\n            },\n            useCallback: function(callback, deps) {\n              currentHookNameInDev = \"useCallback\";\n              warnInvalidHookAccess();\n              updateHookTypesDev();\n              return updateCallback(callback, deps);\n            },\n            useContext: function(context) {\n              currentHookNameInDev = \"useContext\";\n              warnInvalidHookAccess();\n              updateHookTypesDev();\n              return readContext(context);\n            },\n            useEffect: function(create, deps) {\n              currentHookNameInDev = \"useEffect\";\n              warnInvalidHookAccess();\n              updateHookTypesDev();\n              return updateEffect(create, deps);\n            },\n            useImperativeHandle: function(ref, create, deps) {\n              currentHookNameInDev = \"useImperativeHandle\";\n              warnInvalidHookAccess();\n              updateHookTypesDev();\n              return updateImperativeHandle(ref, create, deps);\n            },\n            useInsertionEffect: function(create, deps) {\n              currentHookNameInDev = \"useInsertionEffect\";\n              warnInvalidHookAccess();\n              updateHookTypesDev();\n              return updateInsertionEffect(create, deps);\n            },\n            useLayoutEffect: function(create, deps) {\n              currentHookNameInDev = \"useLayoutEffect\";\n              warnInvalidHookAccess();\n              updateHookTypesDev();\n              return updateLayoutEffect(create, deps);\n            },\n            useMemo: function(create, deps) {\n              currentHookNameInDev = \"useMemo\";\n              warnInvalidHookAccess();\n              updateHookTypesDev();\n              var prevDispatcher = ReactCurrentDispatcher$1.current;\n              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n              try {\n                return updateMemo(create, deps);\n              } finally {\n                ReactCurrentDispatcher$1.current = prevDispatcher;\n              }\n            },\n            useReducer: function(reducer, initialArg, init) {\n              currentHookNameInDev = \"useReducer\";\n              warnInvalidHookAccess();\n              updateHookTypesDev();\n              var prevDispatcher = ReactCurrentDispatcher$1.current;\n              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n              try {\n                return rerenderReducer(reducer, initialArg, init);\n              } finally {\n                ReactCurrentDispatcher$1.current = prevDispatcher;\n              }\n            },\n            useRef: function(initialValue) {\n              currentHookNameInDev = \"useRef\";\n              warnInvalidHookAccess();\n              updateHookTypesDev();\n              return updateRef();\n            },\n            useState: function(initialState) {\n              currentHookNameInDev = \"useState\";\n              warnInvalidHookAccess();\n              updateHookTypesDev();\n              var prevDispatcher = ReactCurrentDispatcher$1.current;\n              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n              try {\n                return rerenderState(initialState);\n              } finally {\n                ReactCurrentDispatcher$1.current = prevDispatcher;\n              }\n            },\n            useDebugValue: function(value, formatterFn) {\n              currentHookNameInDev = \"useDebugValue\";\n              warnInvalidHookAccess();\n              updateHookTypesDev();\n              return updateDebugValue();\n            },\n            useDeferredValue: function(value) {\n              currentHookNameInDev = \"useDeferredValue\";\n              warnInvalidHookAccess();\n              updateHookTypesDev();\n              return rerenderDeferredValue(value);\n            },\n            useTransition: function() {\n              currentHookNameInDev = \"useTransition\";\n              warnInvalidHookAccess();\n              updateHookTypesDev();\n              return rerenderTransition();\n            },\n            useMutableSource: function(source, getSnapshot, subscribe) {\n              currentHookNameInDev = \"useMutableSource\";\n              warnInvalidHookAccess();\n              updateHookTypesDev();\n              return updateMutableSource();\n            },\n            useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {\n              currentHookNameInDev = \"useSyncExternalStore\";\n              warnInvalidHookAccess();\n              updateHookTypesDev();\n              return updateSyncExternalStore(subscribe, getSnapshot);\n            },\n            useId: function() {\n              currentHookNameInDev = \"useId\";\n              warnInvalidHookAccess();\n              updateHookTypesDev();\n              return updateId();\n            },\n            unstable_isNewReconciler: enableNewReconciler\n          };\n        }\n        var now$1 = Scheduler.unstable_now;\n        var commitTime = 0;\n        var layoutEffectStartTime = -1;\n        var profilerStartTime = -1;\n        var passiveEffectStartTime = -1;\n        var currentUpdateIsNested = false;\n        var nestedUpdateScheduled = false;\n        function isCurrentUpdateNested() {\n          return currentUpdateIsNested;\n        }\n        function markNestedUpdateScheduled() {\n          {\n            nestedUpdateScheduled = true;\n          }\n        }\n        function resetNestedUpdateFlag() {\n          {\n            currentUpdateIsNested = false;\n            nestedUpdateScheduled = false;\n          }\n        }\n        function syncNestedUpdateFlag() {\n          {\n            currentUpdateIsNested = nestedUpdateScheduled;\n            nestedUpdateScheduled = false;\n          }\n        }\n        function getCommitTime() {\n          return commitTime;\n        }\n        function recordCommitTime() {\n          commitTime = now$1();\n        }\n        function startProfilerTimer(fiber) {\n          profilerStartTime = now$1();\n          if (fiber.actualStartTime < 0) {\n            fiber.actualStartTime = now$1();\n          }\n        }\n        function stopProfilerTimerIfRunning(fiber) {\n          profilerStartTime = -1;\n        }\n        function stopProfilerTimerIfRunningAndRecordDelta(fiber, overrideBaseTime) {\n          if (profilerStartTime >= 0) {\n            var elapsedTime = now$1() - profilerStartTime;\n            fiber.actualDuration += elapsedTime;\n            if (overrideBaseTime) {\n              fiber.selfBaseDuration = elapsedTime;\n            }\n            profilerStartTime = -1;\n          }\n        }\n        function recordLayoutEffectDuration(fiber) {\n          if (layoutEffectStartTime >= 0) {\n            var elapsedTime = now$1() - layoutEffectStartTime;\n            layoutEffectStartTime = -1;\n            var parentFiber = fiber.return;\n            while (parentFiber !== null) {\n              switch (parentFiber.tag) {\n                case HostRoot:\n                  var root2 = parentFiber.stateNode;\n                  root2.effectDuration += elapsedTime;\n                  return;\n                case Profiler:\n                  var parentStateNode = parentFiber.stateNode;\n                  parentStateNode.effectDuration += elapsedTime;\n                  return;\n              }\n              parentFiber = parentFiber.return;\n            }\n          }\n        }\n        function recordPassiveEffectDuration(fiber) {\n          if (passiveEffectStartTime >= 0) {\n            var elapsedTime = now$1() - passiveEffectStartTime;\n            passiveEffectStartTime = -1;\n            var parentFiber = fiber.return;\n            while (parentFiber !== null) {\n              switch (parentFiber.tag) {\n                case HostRoot:\n                  var root2 = parentFiber.stateNode;\n                  if (root2 !== null) {\n                    root2.passiveEffectDuration += elapsedTime;\n                  }\n                  return;\n                case Profiler:\n                  var parentStateNode = parentFiber.stateNode;\n                  if (parentStateNode !== null) {\n                    parentStateNode.passiveEffectDuration += elapsedTime;\n                  }\n                  return;\n              }\n              parentFiber = parentFiber.return;\n            }\n          }\n        }\n        function startLayoutEffectTimer() {\n          layoutEffectStartTime = now$1();\n        }\n        function startPassiveEffectTimer() {\n          passiveEffectStartTime = now$1();\n        }\n        function transferActualDuration(fiber) {\n          var child = fiber.child;\n          while (child) {\n            fiber.actualDuration += child.actualDuration;\n            child = child.sibling;\n          }\n        }\n        function createCapturedValueAtFiber(value, source) {\n          return {\n            value,\n            source,\n            stack: getStackByFiberInDevAndProd(source),\n            digest: null\n          };\n        }\n        function createCapturedValue(value, digest, stack) {\n          return {\n            value,\n            source: null,\n            stack: stack != null ? stack : null,\n            digest: digest != null ? digest : null\n          };\n        }\n        function showErrorDialog(boundary, errorInfo) {\n          return true;\n        }\n        function logCapturedError(boundary, errorInfo) {\n          try {\n            var logError = showErrorDialog(boundary, errorInfo);\n            if (logError === false) {\n              return;\n            }\n            var error2 = errorInfo.value;\n            if (true) {\n              var source = errorInfo.source;\n              var stack = errorInfo.stack;\n              var componentStack = stack !== null ? stack : \"\";\n              if (error2 != null && error2._suppressLogging) {\n                if (boundary.tag === ClassComponent) {\n                  return;\n                }\n                console[\"error\"](error2);\n              }\n              var componentName = source ? getComponentNameFromFiber(source) : null;\n              var componentNameMessage = componentName ? \"The above error occurred in the <\" + componentName + \"> component:\" : \"The above error occurred in one of your React components:\";\n              var errorBoundaryMessage;\n              if (boundary.tag === HostRoot) {\n                errorBoundaryMessage = \"Consider adding an error boundary to your tree to customize error handling behavior.\\nVisit https://reactjs.org/link/error-boundaries to learn more about error boundaries.\";\n              } else {\n                var errorBoundaryName = getComponentNameFromFiber(boundary) || \"Anonymous\";\n                errorBoundaryMessage = \"React will try to recreate this component tree from scratch \" + (\"using the error boundary you provided, \" + errorBoundaryName + \".\");\n              }\n              var combinedMessage = componentNameMessage + \"\\n\" + componentStack + \"\\n\\n\" + (\"\" + errorBoundaryMessage);\n              console[\"error\"](combinedMessage);\n            } else {\n              console[\"error\"](error2);\n            }\n          } catch (e) {\n            setTimeout(function() {\n              throw e;\n            });\n          }\n        }\n        var PossiblyWeakMap$1 = typeof WeakMap === \"function\" ? WeakMap : Map;\n        function createRootErrorUpdate(fiber, errorInfo, lane) {\n          var update = createUpdate(NoTimestamp, lane);\n          update.tag = CaptureUpdate;\n          update.payload = {\n            element: null\n          };\n          var error2 = errorInfo.value;\n          update.callback = function() {\n            onUncaughtError(error2);\n            logCapturedError(fiber, errorInfo);\n          };\n          return update;\n        }\n        function createClassErrorUpdate(fiber, errorInfo, lane) {\n          var update = createUpdate(NoTimestamp, lane);\n          update.tag = CaptureUpdate;\n          var getDerivedStateFromError = fiber.type.getDerivedStateFromError;\n          if (typeof getDerivedStateFromError === \"function\") {\n            var error$1 = errorInfo.value;\n            update.payload = function() {\n              return getDerivedStateFromError(error$1);\n            };\n            update.callback = function() {\n              {\n                markFailedErrorBoundaryForHotReloading(fiber);\n              }\n              logCapturedError(fiber, errorInfo);\n            };\n          }\n          var inst = fiber.stateNode;\n          if (inst !== null && typeof inst.componentDidCatch === \"function\") {\n            update.callback = function callback() {\n              {\n                markFailedErrorBoundaryForHotReloading(fiber);\n              }\n              logCapturedError(fiber, errorInfo);\n              if (typeof getDerivedStateFromError !== \"function\") {\n                markLegacyErrorBoundaryAsFailed(this);\n              }\n              var error$12 = errorInfo.value;\n              var stack = errorInfo.stack;\n              this.componentDidCatch(error$12, {\n                componentStack: stack !== null ? stack : \"\"\n              });\n              {\n                if (typeof getDerivedStateFromError !== \"function\") {\n                  if (!includesSomeLane(fiber.lanes, SyncLane)) {\n                    error(\"%s: Error boundaries should implement getDerivedStateFromError(). In that method, return a state update to display an error message or fallback UI.\", getComponentNameFromFiber(fiber) || \"Unknown\");\n                  }\n                }\n              }\n            };\n          }\n          return update;\n        }\n        function attachPingListener(root2, wakeable, lanes) {\n          var pingCache = root2.pingCache;\n          var threadIDs;\n          if (pingCache === null) {\n            pingCache = root2.pingCache = new PossiblyWeakMap$1();\n            threadIDs = /* @__PURE__ */ new Set();\n            pingCache.set(wakeable, threadIDs);\n          } else {\n            threadIDs = pingCache.get(wakeable);\n            if (threadIDs === void 0) {\n              threadIDs = /* @__PURE__ */ new Set();\n              pingCache.set(wakeable, threadIDs);\n            }\n          }\n          if (!threadIDs.has(lanes)) {\n            threadIDs.add(lanes);\n            var ping = pingSuspendedRoot.bind(null, root2, wakeable, lanes);\n            {\n              if (isDevToolsPresent) {\n                restorePendingUpdaters(root2, lanes);\n              }\n            }\n            wakeable.then(ping, ping);\n          }\n        }\n        function attachRetryListener(suspenseBoundary, root2, wakeable, lanes) {\n          var wakeables = suspenseBoundary.updateQueue;\n          if (wakeables === null) {\n            var updateQueue = /* @__PURE__ */ new Set();\n            updateQueue.add(wakeable);\n            suspenseBoundary.updateQueue = updateQueue;\n          } else {\n            wakeables.add(wakeable);\n          }\n        }\n        function resetSuspendedComponent(sourceFiber, rootRenderLanes) {\n          var tag = sourceFiber.tag;\n          if ((sourceFiber.mode & ConcurrentMode) === NoMode && (tag === FunctionComponent || tag === ForwardRef || tag === SimpleMemoComponent)) {\n            var currentSource = sourceFiber.alternate;\n            if (currentSource) {\n              sourceFiber.updateQueue = currentSource.updateQueue;\n              sourceFiber.memoizedState = currentSource.memoizedState;\n              sourceFiber.lanes = currentSource.lanes;\n            } else {\n              sourceFiber.updateQueue = null;\n              sourceFiber.memoizedState = null;\n            }\n          }\n        }\n        function getNearestSuspenseBoundaryToCapture(returnFiber) {\n          var node = returnFiber;\n          do {\n            if (node.tag === SuspenseComponent && shouldCaptureSuspense(node)) {\n              return node;\n            }\n            node = node.return;\n          } while (node !== null);\n          return null;\n        }\n        function markSuspenseBoundaryShouldCapture(suspenseBoundary, returnFiber, sourceFiber, root2, rootRenderLanes) {\n          if ((suspenseBoundary.mode & ConcurrentMode) === NoMode) {\n            if (suspenseBoundary === returnFiber) {\n              suspenseBoundary.flags |= ShouldCapture;\n            } else {\n              suspenseBoundary.flags |= DidCapture;\n              sourceFiber.flags |= ForceUpdateForLegacySuspense;\n              sourceFiber.flags &= ~(LifecycleEffectMask | Incomplete);\n              if (sourceFiber.tag === ClassComponent) {\n                var currentSourceFiber = sourceFiber.alternate;\n                if (currentSourceFiber === null) {\n                  sourceFiber.tag = IncompleteClassComponent;\n                } else {\n                  var update = createUpdate(NoTimestamp, SyncLane);\n                  update.tag = ForceUpdate;\n                  enqueueUpdate(sourceFiber, update, SyncLane);\n                }\n              }\n              sourceFiber.lanes = mergeLanes(sourceFiber.lanes, SyncLane);\n            }\n            return suspenseBoundary;\n          }\n          suspenseBoundary.flags |= ShouldCapture;\n          suspenseBoundary.lanes = rootRenderLanes;\n          return suspenseBoundary;\n        }\n        function throwException(root2, returnFiber, sourceFiber, value, rootRenderLanes) {\n          sourceFiber.flags |= Incomplete;\n          {\n            if (isDevToolsPresent) {\n              restorePendingUpdaters(root2, rootRenderLanes);\n            }\n          }\n          if (value !== null && typeof value === \"object\" && typeof value.then === \"function\") {\n            var wakeable = value;\n            resetSuspendedComponent(sourceFiber);\n            {\n              if (getIsHydrating() && sourceFiber.mode & ConcurrentMode) {\n                markDidThrowWhileHydratingDEV();\n              }\n            }\n            var suspenseBoundary = getNearestSuspenseBoundaryToCapture(returnFiber);\n            if (suspenseBoundary !== null) {\n              suspenseBoundary.flags &= ~ForceClientRender;\n              markSuspenseBoundaryShouldCapture(suspenseBoundary, returnFiber, sourceFiber, root2, rootRenderLanes);\n              if (suspenseBoundary.mode & ConcurrentMode) {\n                attachPingListener(root2, wakeable, rootRenderLanes);\n              }\n              attachRetryListener(suspenseBoundary, root2, wakeable);\n              return;\n            } else {\n              if (!includesSyncLane(rootRenderLanes)) {\n                attachPingListener(root2, wakeable, rootRenderLanes);\n                renderDidSuspendDelayIfPossible();\n                return;\n              }\n              var uncaughtSuspenseError = new Error(\"A component suspended while responding to synchronous input. This will cause the UI to be replaced with a loading indicator. To fix, updates that suspend should be wrapped with startTransition.\");\n              value = uncaughtSuspenseError;\n            }\n          } else {\n            if (getIsHydrating() && sourceFiber.mode & ConcurrentMode) {\n              markDidThrowWhileHydratingDEV();\n              var _suspenseBoundary = getNearestSuspenseBoundaryToCapture(returnFiber);\n              if (_suspenseBoundary !== null) {\n                if ((_suspenseBoundary.flags & ShouldCapture) === NoFlags) {\n                  _suspenseBoundary.flags |= ForceClientRender;\n                }\n                markSuspenseBoundaryShouldCapture(_suspenseBoundary, returnFiber, sourceFiber, root2, rootRenderLanes);\n                queueHydrationError(createCapturedValueAtFiber(value, sourceFiber));\n                return;\n              }\n            }\n          }\n          value = createCapturedValueAtFiber(value, sourceFiber);\n          renderDidError(value);\n          var workInProgress2 = returnFiber;\n          do {\n            switch (workInProgress2.tag) {\n              case HostRoot: {\n                var _errorInfo = value;\n                workInProgress2.flags |= ShouldCapture;\n                var lane = pickArbitraryLane(rootRenderLanes);\n                workInProgress2.lanes = mergeLanes(workInProgress2.lanes, lane);\n                var update = createRootErrorUpdate(workInProgress2, _errorInfo, lane);\n                enqueueCapturedUpdate(workInProgress2, update);\n                return;\n              }\n              case ClassComponent:\n                var errorInfo = value;\n                var ctor = workInProgress2.type;\n                var instance = workInProgress2.stateNode;\n                if ((workInProgress2.flags & DidCapture) === NoFlags && (typeof ctor.getDerivedStateFromError === \"function\" || instance !== null && typeof instance.componentDidCatch === \"function\" && !isAlreadyFailedLegacyErrorBoundary(instance))) {\n                  workInProgress2.flags |= ShouldCapture;\n                  var _lane = pickArbitraryLane(rootRenderLanes);\n                  workInProgress2.lanes = mergeLanes(workInProgress2.lanes, _lane);\n                  var _update = createClassErrorUpdate(workInProgress2, errorInfo, _lane);\n                  enqueueCapturedUpdate(workInProgress2, _update);\n                  return;\n                }\n                break;\n            }\n            workInProgress2 = workInProgress2.return;\n          } while (workInProgress2 !== null);\n        }\n        function getSuspendedCache() {\n          {\n            return null;\n          }\n        }\n        var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;\n        var didReceiveUpdate = false;\n        var didWarnAboutBadClass;\n        var didWarnAboutModulePatternComponent;\n        var didWarnAboutContextTypeOnFunctionComponent;\n        var didWarnAboutGetDerivedStateOnFunctionComponent;\n        var didWarnAboutFunctionRefs;\n        var didWarnAboutReassigningProps;\n        var didWarnAboutRevealOrder;\n        var didWarnAboutTailOptions;\n        {\n          didWarnAboutBadClass = {};\n          didWarnAboutModulePatternComponent = {};\n          didWarnAboutContextTypeOnFunctionComponent = {};\n          didWarnAboutGetDerivedStateOnFunctionComponent = {};\n          didWarnAboutFunctionRefs = {};\n          didWarnAboutReassigningProps = false;\n          didWarnAboutRevealOrder = {};\n          didWarnAboutTailOptions = {};\n        }\n        function reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2) {\n          if (current2 === null) {\n            workInProgress2.child = mountChildFibers(workInProgress2, null, nextChildren, renderLanes2);\n          } else {\n            workInProgress2.child = reconcileChildFibers(workInProgress2, current2.child, nextChildren, renderLanes2);\n          }\n        }\n        function forceUnmountCurrentAndReconcile(current2, workInProgress2, nextChildren, renderLanes2) {\n          workInProgress2.child = reconcileChildFibers(workInProgress2, current2.child, null, renderLanes2);\n          workInProgress2.child = reconcileChildFibers(workInProgress2, null, nextChildren, renderLanes2);\n        }\n        function updateForwardRef(current2, workInProgress2, Component, nextProps, renderLanes2) {\n          {\n            if (workInProgress2.type !== workInProgress2.elementType) {\n              var innerPropTypes = Component.propTypes;\n              if (innerPropTypes) {\n                checkPropTypes(\n                  innerPropTypes,\n                  nextProps,\n                  // Resolved props\n                  \"prop\",\n                  getComponentNameFromType(Component)\n                );\n              }\n            }\n          }\n          var render2 = Component.render;\n          var ref = workInProgress2.ref;\n          var nextChildren;\n          var hasId;\n          prepareToReadContext(workInProgress2, renderLanes2);\n          {\n            markComponentRenderStarted(workInProgress2);\n          }\n          {\n            ReactCurrentOwner$1.current = workInProgress2;\n            setIsRendering(true);\n            nextChildren = renderWithHooks(current2, workInProgress2, render2, nextProps, ref, renderLanes2);\n            hasId = checkDidRenderIdHook();\n            if (workInProgress2.mode & StrictLegacyMode) {\n              setIsStrictModeForDevtools(true);\n              try {\n                nextChildren = renderWithHooks(current2, workInProgress2, render2, nextProps, ref, renderLanes2);\n                hasId = checkDidRenderIdHook();\n              } finally {\n                setIsStrictModeForDevtools(false);\n              }\n            }\n            setIsRendering(false);\n          }\n          {\n            markComponentRenderStopped();\n          }\n          if (current2 !== null && !didReceiveUpdate) {\n            bailoutHooks(current2, workInProgress2, renderLanes2);\n            return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);\n          }\n          if (getIsHydrating() && hasId) {\n            pushMaterializedTreeId(workInProgress2);\n          }\n          workInProgress2.flags |= PerformedWork;\n          reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);\n          return workInProgress2.child;\n        }\n        function updateMemoComponent(current2, workInProgress2, Component, nextProps, renderLanes2) {\n          if (current2 === null) {\n            var type = Component.type;\n            if (isSimpleFunctionComponent(type) && Component.compare === null && // SimpleMemoComponent codepath doesn't resolve outer props either.\n            Component.defaultProps === void 0) {\n              var resolvedType = type;\n              {\n                resolvedType = resolveFunctionForHotReloading(type);\n              }\n              workInProgress2.tag = SimpleMemoComponent;\n              workInProgress2.type = resolvedType;\n              {\n                validateFunctionComponentInDev(workInProgress2, type);\n              }\n              return updateSimpleMemoComponent(current2, workInProgress2, resolvedType, nextProps, renderLanes2);\n            }\n            {\n              var innerPropTypes = type.propTypes;\n              if (innerPropTypes) {\n                checkPropTypes(\n                  innerPropTypes,\n                  nextProps,\n                  // Resolved props\n                  \"prop\",\n                  getComponentNameFromType(type)\n                );\n              }\n            }\n            var child = createFiberFromTypeAndProps(Component.type, null, nextProps, workInProgress2, workInProgress2.mode, renderLanes2);\n            child.ref = workInProgress2.ref;\n            child.return = workInProgress2;\n            workInProgress2.child = child;\n            return child;\n          }\n          {\n            var _type = Component.type;\n            var _innerPropTypes = _type.propTypes;\n            if (_innerPropTypes) {\n              checkPropTypes(\n                _innerPropTypes,\n                nextProps,\n                // Resolved props\n                \"prop\",\n                getComponentNameFromType(_type)\n              );\n            }\n          }\n          var currentChild = current2.child;\n          var hasScheduledUpdateOrContext = checkScheduledUpdateOrContext(current2, renderLanes2);\n          if (!hasScheduledUpdateOrContext) {\n            var prevProps = currentChild.memoizedProps;\n            var compare = Component.compare;\n            compare = compare !== null ? compare : shallowEqual;\n            if (compare(prevProps, nextProps) && current2.ref === workInProgress2.ref) {\n              return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);\n            }\n          }\n          workInProgress2.flags |= PerformedWork;\n          var newChild = createWorkInProgress(currentChild, nextProps);\n          newChild.ref = workInProgress2.ref;\n          newChild.return = workInProgress2;\n          workInProgress2.child = newChild;\n          return newChild;\n        }\n        function updateSimpleMemoComponent(current2, workInProgress2, Component, nextProps, renderLanes2) {\n          {\n            if (workInProgress2.type !== workInProgress2.elementType) {\n              var outerMemoType = workInProgress2.elementType;\n              if (outerMemoType.$$typeof === REACT_LAZY_TYPE) {\n                var lazyComponent = outerMemoType;\n                var payload = lazyComponent._payload;\n                var init = lazyComponent._init;\n                try {\n                  outerMemoType = init(payload);\n                } catch (x) {\n                  outerMemoType = null;\n                }\n                var outerPropTypes = outerMemoType && outerMemoType.propTypes;\n                if (outerPropTypes) {\n                  checkPropTypes(\n                    outerPropTypes,\n                    nextProps,\n                    // Resolved (SimpleMemoComponent has no defaultProps)\n                    \"prop\",\n                    getComponentNameFromType(outerMemoType)\n                  );\n                }\n              }\n            }\n          }\n          if (current2 !== null) {\n            var prevProps = current2.memoizedProps;\n            if (shallowEqual(prevProps, nextProps) && current2.ref === workInProgress2.ref && // Prevent bailout if the implementation changed due to hot reload.\n            workInProgress2.type === current2.type) {\n              didReceiveUpdate = false;\n              workInProgress2.pendingProps = nextProps = prevProps;\n              if (!checkScheduledUpdateOrContext(current2, renderLanes2)) {\n                workInProgress2.lanes = current2.lanes;\n                return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);\n              } else if ((current2.flags & ForceUpdateForLegacySuspense) !== NoFlags) {\n                didReceiveUpdate = true;\n              }\n            }\n          }\n          return updateFunctionComponent(current2, workInProgress2, Component, nextProps, renderLanes2);\n        }\n        function updateOffscreenComponent(current2, workInProgress2, renderLanes2) {\n          var nextProps = workInProgress2.pendingProps;\n          var nextChildren = nextProps.children;\n          var prevState = current2 !== null ? current2.memoizedState : null;\n          if (nextProps.mode === \"hidden\" || enableLegacyHidden) {\n            if ((workInProgress2.mode & ConcurrentMode) === NoMode) {\n              var nextState = {\n                baseLanes: NoLanes,\n                cachePool: null,\n                transitions: null\n              };\n              workInProgress2.memoizedState = nextState;\n              pushRenderLanes(workInProgress2, renderLanes2);\n            } else if (!includesSomeLane(renderLanes2, OffscreenLane)) {\n              var spawnedCachePool = null;\n              var nextBaseLanes;\n              if (prevState !== null) {\n                var prevBaseLanes = prevState.baseLanes;\n                nextBaseLanes = mergeLanes(prevBaseLanes, renderLanes2);\n              } else {\n                nextBaseLanes = renderLanes2;\n              }\n              workInProgress2.lanes = workInProgress2.childLanes = laneToLanes(OffscreenLane);\n              var _nextState = {\n                baseLanes: nextBaseLanes,\n                cachePool: spawnedCachePool,\n                transitions: null\n              };\n              workInProgress2.memoizedState = _nextState;\n              workInProgress2.updateQueue = null;\n              pushRenderLanes(workInProgress2, nextBaseLanes);\n              return null;\n            } else {\n              var _nextState2 = {\n                baseLanes: NoLanes,\n                cachePool: null,\n                transitions: null\n              };\n              workInProgress2.memoizedState = _nextState2;\n              var subtreeRenderLanes2 = prevState !== null ? prevState.baseLanes : renderLanes2;\n              pushRenderLanes(workInProgress2, subtreeRenderLanes2);\n            }\n          } else {\n            var _subtreeRenderLanes;\n            if (prevState !== null) {\n              _subtreeRenderLanes = mergeLanes(prevState.baseLanes, renderLanes2);\n              workInProgress2.memoizedState = null;\n            } else {\n              _subtreeRenderLanes = renderLanes2;\n            }\n            pushRenderLanes(workInProgress2, _subtreeRenderLanes);\n          }\n          reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);\n          return workInProgress2.child;\n        }\n        function updateFragment(current2, workInProgress2, renderLanes2) {\n          var nextChildren = workInProgress2.pendingProps;\n          reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);\n          return workInProgress2.child;\n        }\n        function updateMode(current2, workInProgress2, renderLanes2) {\n          var nextChildren = workInProgress2.pendingProps.children;\n          reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);\n          return workInProgress2.child;\n        }\n        function updateProfiler(current2, workInProgress2, renderLanes2) {\n          {\n            workInProgress2.flags |= Update;\n            {\n              var stateNode = workInProgress2.stateNode;\n              stateNode.effectDuration = 0;\n              stateNode.passiveEffectDuration = 0;\n            }\n          }\n          var nextProps = workInProgress2.pendingProps;\n          var nextChildren = nextProps.children;\n          reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);\n          return workInProgress2.child;\n        }\n        function markRef(current2, workInProgress2) {\n          var ref = workInProgress2.ref;\n          if (current2 === null && ref !== null || current2 !== null && current2.ref !== ref) {\n            workInProgress2.flags |= Ref;\n            {\n              workInProgress2.flags |= RefStatic;\n            }\n          }\n        }\n        function updateFunctionComponent(current2, workInProgress2, Component, nextProps, renderLanes2) {\n          {\n            if (workInProgress2.type !== workInProgress2.elementType) {\n              var innerPropTypes = Component.propTypes;\n              if (innerPropTypes) {\n                checkPropTypes(\n                  innerPropTypes,\n                  nextProps,\n                  // Resolved props\n                  \"prop\",\n                  getComponentNameFromType(Component)\n                );\n              }\n            }\n          }\n          var context;\n          {\n            var unmaskedContext = getUnmaskedContext(workInProgress2, Component, true);\n            context = getMaskedContext(workInProgress2, unmaskedContext);\n          }\n          var nextChildren;\n          var hasId;\n          prepareToReadContext(workInProgress2, renderLanes2);\n          {\n            markComponentRenderStarted(workInProgress2);\n          }\n          {\n            ReactCurrentOwner$1.current = workInProgress2;\n            setIsRendering(true);\n            nextChildren = renderWithHooks(current2, workInProgress2, Component, nextProps, context, renderLanes2);\n            hasId = checkDidRenderIdHook();\n            if (workInProgress2.mode & StrictLegacyMode) {\n              setIsStrictModeForDevtools(true);\n              try {\n                nextChildren = renderWithHooks(current2, workInProgress2, Component, nextProps, context, renderLanes2);\n                hasId = checkDidRenderIdHook();\n              } finally {\n                setIsStrictModeForDevtools(false);\n              }\n            }\n            setIsRendering(false);\n          }\n          {\n            markComponentRenderStopped();\n          }\n          if (current2 !== null && !didReceiveUpdate) {\n            bailoutHooks(current2, workInProgress2, renderLanes2);\n            return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);\n          }\n          if (getIsHydrating() && hasId) {\n            pushMaterializedTreeId(workInProgress2);\n          }\n          workInProgress2.flags |= PerformedWork;\n          reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);\n          return workInProgress2.child;\n        }\n        function updateClassComponent(current2, workInProgress2, Component, nextProps, renderLanes2) {\n          {\n            switch (shouldError(workInProgress2)) {\n              case false: {\n                var _instance = workInProgress2.stateNode;\n                var ctor = workInProgress2.type;\n                var tempInstance = new ctor(workInProgress2.memoizedProps, _instance.context);\n                var state = tempInstance.state;\n                _instance.updater.enqueueSetState(_instance, state, null);\n                break;\n              }\n              case true: {\n                workInProgress2.flags |= DidCapture;\n                workInProgress2.flags |= ShouldCapture;\n                var error$1 = new Error(\"Simulated error coming from DevTools\");\n                var lane = pickArbitraryLane(renderLanes2);\n                workInProgress2.lanes = mergeLanes(workInProgress2.lanes, lane);\n                var update = createClassErrorUpdate(workInProgress2, createCapturedValueAtFiber(error$1, workInProgress2), lane);\n                enqueueCapturedUpdate(workInProgress2, update);\n                break;\n              }\n            }\n            if (workInProgress2.type !== workInProgress2.elementType) {\n              var innerPropTypes = Component.propTypes;\n              if (innerPropTypes) {\n                checkPropTypes(\n                  innerPropTypes,\n                  nextProps,\n                  // Resolved props\n                  \"prop\",\n                  getComponentNameFromType(Component)\n                );\n              }\n            }\n          }\n          var hasContext;\n          if (isContextProvider(Component)) {\n            hasContext = true;\n            pushContextProvider(workInProgress2);\n          } else {\n            hasContext = false;\n          }\n          prepareToReadContext(workInProgress2, renderLanes2);\n          var instance = workInProgress2.stateNode;\n          var shouldUpdate;\n          if (instance === null) {\n            resetSuspendedCurrentOnMountInLegacyMode(current2, workInProgress2);\n            constructClassInstance(workInProgress2, Component, nextProps);\n            mountClassInstance(workInProgress2, Component, nextProps, renderLanes2);\n            shouldUpdate = true;\n          } else if (current2 === null) {\n            shouldUpdate = resumeMountClassInstance(workInProgress2, Component, nextProps, renderLanes2);\n          } else {\n            shouldUpdate = updateClassInstance(current2, workInProgress2, Component, nextProps, renderLanes2);\n          }\n          var nextUnitOfWork = finishClassComponent(current2, workInProgress2, Component, shouldUpdate, hasContext, renderLanes2);\n          {\n            var inst = workInProgress2.stateNode;\n            if (shouldUpdate && inst.props !== nextProps) {\n              if (!didWarnAboutReassigningProps) {\n                error(\"It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.\", getComponentNameFromFiber(workInProgress2) || \"a component\");\n              }\n              didWarnAboutReassigningProps = true;\n            }\n          }\n          return nextUnitOfWork;\n        }\n        function finishClassComponent(current2, workInProgress2, Component, shouldUpdate, hasContext, renderLanes2) {\n          markRef(current2, workInProgress2);\n          var didCaptureError = (workInProgress2.flags & DidCapture) !== NoFlags;\n          if (!shouldUpdate && !didCaptureError) {\n            if (hasContext) {\n              invalidateContextProvider(workInProgress2, Component, false);\n            }\n            return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);\n          }\n          var instance = workInProgress2.stateNode;\n          ReactCurrentOwner$1.current = workInProgress2;\n          var nextChildren;\n          if (didCaptureError && typeof Component.getDerivedStateFromError !== \"function\") {\n            nextChildren = null;\n            {\n              stopProfilerTimerIfRunning();\n            }\n          } else {\n            {\n              markComponentRenderStarted(workInProgress2);\n            }\n            {\n              setIsRendering(true);\n              nextChildren = instance.render();\n              if (workInProgress2.mode & StrictLegacyMode) {\n                setIsStrictModeForDevtools(true);\n                try {\n                  instance.render();\n                } finally {\n                  setIsStrictModeForDevtools(false);\n                }\n              }\n              setIsRendering(false);\n            }\n            {\n              markComponentRenderStopped();\n            }\n          }\n          workInProgress2.flags |= PerformedWork;\n          if (current2 !== null && didCaptureError) {\n            forceUnmountCurrentAndReconcile(current2, workInProgress2, nextChildren, renderLanes2);\n          } else {\n            reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);\n          }\n          workInProgress2.memoizedState = instance.state;\n          if (hasContext) {\n            invalidateContextProvider(workInProgress2, Component, true);\n          }\n          return workInProgress2.child;\n        }\n        function pushHostRootContext(workInProgress2) {\n          var root2 = workInProgress2.stateNode;\n          if (root2.pendingContext) {\n            pushTopLevelContextObject(workInProgress2, root2.pendingContext, root2.pendingContext !== root2.context);\n          } else if (root2.context) {\n            pushTopLevelContextObject(workInProgress2, root2.context, false);\n          }\n          pushHostContainer(workInProgress2, root2.containerInfo);\n        }\n        function updateHostRoot(current2, workInProgress2, renderLanes2) {\n          pushHostRootContext(workInProgress2);\n          if (current2 === null) {\n            throw new Error(\"Should have a current fiber. This is a bug in React.\");\n          }\n          var nextProps = workInProgress2.pendingProps;\n          var prevState = workInProgress2.memoizedState;\n          var prevChildren = prevState.element;\n          cloneUpdateQueue(current2, workInProgress2);\n          processUpdateQueue(workInProgress2, nextProps, null, renderLanes2);\n          var nextState = workInProgress2.memoizedState;\n          var root2 = workInProgress2.stateNode;\n          var nextChildren = nextState.element;\n          if (prevState.isDehydrated) {\n            var overrideState = {\n              element: nextChildren,\n              isDehydrated: false,\n              cache: nextState.cache,\n              pendingSuspenseBoundaries: nextState.pendingSuspenseBoundaries,\n              transitions: nextState.transitions\n            };\n            var updateQueue = workInProgress2.updateQueue;\n            updateQueue.baseState = overrideState;\n            workInProgress2.memoizedState = overrideState;\n            if (workInProgress2.flags & ForceClientRender) {\n              var recoverableError = createCapturedValueAtFiber(new Error(\"There was an error while hydrating. Because the error happened outside of a Suspense boundary, the entire root will switch to client rendering.\"), workInProgress2);\n              return mountHostRootWithoutHydrating(current2, workInProgress2, nextChildren, renderLanes2, recoverableError);\n            } else if (nextChildren !== prevChildren) {\n              var _recoverableError = createCapturedValueAtFiber(new Error(\"This root received an early update, before anything was able hydrate. Switched the entire root to client rendering.\"), workInProgress2);\n              return mountHostRootWithoutHydrating(current2, workInProgress2, nextChildren, renderLanes2, _recoverableError);\n            } else {\n              enterHydrationState(workInProgress2);\n              var child = mountChildFibers(workInProgress2, null, nextChildren, renderLanes2);\n              workInProgress2.child = child;\n              var node = child;\n              while (node) {\n                node.flags = node.flags & ~Placement | Hydrating;\n                node = node.sibling;\n              }\n            }\n          } else {\n            resetHydrationState();\n            if (nextChildren === prevChildren) {\n              return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);\n            }\n            reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);\n          }\n          return workInProgress2.child;\n        }\n        function mountHostRootWithoutHydrating(current2, workInProgress2, nextChildren, renderLanes2, recoverableError) {\n          resetHydrationState();\n          queueHydrationError(recoverableError);\n          workInProgress2.flags |= ForceClientRender;\n          reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);\n          return workInProgress2.child;\n        }\n        function updateHostComponent(current2, workInProgress2, renderLanes2) {\n          pushHostContext(workInProgress2);\n          if (current2 === null) {\n            tryToClaimNextHydratableInstance(workInProgress2);\n          }\n          var type = workInProgress2.type;\n          var nextProps = workInProgress2.pendingProps;\n          var prevProps = current2 !== null ? current2.memoizedProps : null;\n          var nextChildren = nextProps.children;\n          var isDirectTextChild = shouldSetTextContent(type, nextProps);\n          if (isDirectTextChild) {\n            nextChildren = null;\n          } else if (prevProps !== null && shouldSetTextContent(type, prevProps)) {\n            workInProgress2.flags |= ContentReset;\n          }\n          markRef(current2, workInProgress2);\n          reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);\n          return workInProgress2.child;\n        }\n        function updateHostText(current2, workInProgress2) {\n          if (current2 === null) {\n            tryToClaimNextHydratableInstance(workInProgress2);\n          }\n          return null;\n        }\n        function mountLazyComponent(_current, workInProgress2, elementType, renderLanes2) {\n          resetSuspendedCurrentOnMountInLegacyMode(_current, workInProgress2);\n          var props = workInProgress2.pendingProps;\n          var lazyComponent = elementType;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n          var Component = init(payload);\n          workInProgress2.type = Component;\n          var resolvedTag = workInProgress2.tag = resolveLazyComponentTag(Component);\n          var resolvedProps = resolveDefaultProps(Component, props);\n          var child;\n          switch (resolvedTag) {\n            case FunctionComponent: {\n              {\n                validateFunctionComponentInDev(workInProgress2, Component);\n                workInProgress2.type = Component = resolveFunctionForHotReloading(Component);\n              }\n              child = updateFunctionComponent(null, workInProgress2, Component, resolvedProps, renderLanes2);\n              return child;\n            }\n            case ClassComponent: {\n              {\n                workInProgress2.type = Component = resolveClassForHotReloading(Component);\n              }\n              child = updateClassComponent(null, workInProgress2, Component, resolvedProps, renderLanes2);\n              return child;\n            }\n            case ForwardRef: {\n              {\n                workInProgress2.type = Component = resolveForwardRefForHotReloading(Component);\n              }\n              child = updateForwardRef(null, workInProgress2, Component, resolvedProps, renderLanes2);\n              return child;\n            }\n            case MemoComponent: {\n              {\n                if (workInProgress2.type !== workInProgress2.elementType) {\n                  var outerPropTypes = Component.propTypes;\n                  if (outerPropTypes) {\n                    checkPropTypes(\n                      outerPropTypes,\n                      resolvedProps,\n                      // Resolved for outer only\n                      \"prop\",\n                      getComponentNameFromType(Component)\n                    );\n                  }\n                }\n              }\n              child = updateMemoComponent(\n                null,\n                workInProgress2,\n                Component,\n                resolveDefaultProps(Component.type, resolvedProps),\n                // The inner type can have defaults too\n                renderLanes2\n              );\n              return child;\n            }\n          }\n          var hint = \"\";\n          {\n            if (Component !== null && typeof Component === \"object\" && Component.$$typeof === REACT_LAZY_TYPE) {\n              hint = \" Did you wrap a component in React.lazy() more than once?\";\n            }\n          }\n          throw new Error(\"Element type is invalid. Received a promise that resolves to: \" + Component + \". \" + (\"Lazy element type must resolve to a class or function.\" + hint));\n        }\n        function mountIncompleteClassComponent(_current, workInProgress2, Component, nextProps, renderLanes2) {\n          resetSuspendedCurrentOnMountInLegacyMode(_current, workInProgress2);\n          workInProgress2.tag = ClassComponent;\n          var hasContext;\n          if (isContextProvider(Component)) {\n            hasContext = true;\n            pushContextProvider(workInProgress2);\n          } else {\n            hasContext = false;\n          }\n          prepareToReadContext(workInProgress2, renderLanes2);\n          constructClassInstance(workInProgress2, Component, nextProps);\n          mountClassInstance(workInProgress2, Component, nextProps, renderLanes2);\n          return finishClassComponent(null, workInProgress2, Component, true, hasContext, renderLanes2);\n        }\n        function mountIndeterminateComponent(_current, workInProgress2, Component, renderLanes2) {\n          resetSuspendedCurrentOnMountInLegacyMode(_current, workInProgress2);\n          var props = workInProgress2.pendingProps;\n          var context;\n          {\n            var unmaskedContext = getUnmaskedContext(workInProgress2, Component, false);\n            context = getMaskedContext(workInProgress2, unmaskedContext);\n          }\n          prepareToReadContext(workInProgress2, renderLanes2);\n          var value;\n          var hasId;\n          {\n            markComponentRenderStarted(workInProgress2);\n          }\n          {\n            if (Component.prototype && typeof Component.prototype.render === \"function\") {\n              var componentName = getComponentNameFromType(Component) || \"Unknown\";\n              if (!didWarnAboutBadClass[componentName]) {\n                error(\"The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.\", componentName, componentName);\n                didWarnAboutBadClass[componentName] = true;\n              }\n            }\n            if (workInProgress2.mode & StrictLegacyMode) {\n              ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress2, null);\n            }\n            setIsRendering(true);\n            ReactCurrentOwner$1.current = workInProgress2;\n            value = renderWithHooks(null, workInProgress2, Component, props, context, renderLanes2);\n            hasId = checkDidRenderIdHook();\n            setIsRendering(false);\n          }\n          {\n            markComponentRenderStopped();\n          }\n          workInProgress2.flags |= PerformedWork;\n          {\n            if (typeof value === \"object\" && value !== null && typeof value.render === \"function\" && value.$$typeof === void 0) {\n              var _componentName = getComponentNameFromType(Component) || \"Unknown\";\n              if (!didWarnAboutModulePatternComponent[_componentName]) {\n                error(\"The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.\", _componentName, _componentName, _componentName);\n                didWarnAboutModulePatternComponent[_componentName] = true;\n              }\n            }\n          }\n          if (\n            // Run these checks in production only if the flag is off.\n            // Eventually we'll delete this branch altogether.\n            typeof value === \"object\" && value !== null && typeof value.render === \"function\" && value.$$typeof === void 0\n          ) {\n            {\n              var _componentName2 = getComponentNameFromType(Component) || \"Unknown\";\n              if (!didWarnAboutModulePatternComponent[_componentName2]) {\n                error(\"The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.\", _componentName2, _componentName2, _componentName2);\n                didWarnAboutModulePatternComponent[_componentName2] = true;\n              }\n            }\n            workInProgress2.tag = ClassComponent;\n            workInProgress2.memoizedState = null;\n            workInProgress2.updateQueue = null;\n            var hasContext = false;\n            if (isContextProvider(Component)) {\n              hasContext = true;\n              pushContextProvider(workInProgress2);\n            } else {\n              hasContext = false;\n            }\n            workInProgress2.memoizedState = value.state !== null && value.state !== void 0 ? value.state : null;\n            initializeUpdateQueue(workInProgress2);\n            adoptClassInstance(workInProgress2, value);\n            mountClassInstance(workInProgress2, Component, props, renderLanes2);\n            return finishClassComponent(null, workInProgress2, Component, true, hasContext, renderLanes2);\n          } else {\n            workInProgress2.tag = FunctionComponent;\n            {\n              if (workInProgress2.mode & StrictLegacyMode) {\n                setIsStrictModeForDevtools(true);\n                try {\n                  value = renderWithHooks(null, workInProgress2, Component, props, context, renderLanes2);\n                  hasId = checkDidRenderIdHook();\n                } finally {\n                  setIsStrictModeForDevtools(false);\n                }\n              }\n            }\n            if (getIsHydrating() && hasId) {\n              pushMaterializedTreeId(workInProgress2);\n            }\n            reconcileChildren(null, workInProgress2, value, renderLanes2);\n            {\n              validateFunctionComponentInDev(workInProgress2, Component);\n            }\n            return workInProgress2.child;\n          }\n        }\n        function validateFunctionComponentInDev(workInProgress2, Component) {\n          {\n            if (Component) {\n              if (Component.childContextTypes) {\n                error(\"%s(...): childContextTypes cannot be defined on a function component.\", Component.displayName || Component.name || \"Component\");\n              }\n            }\n            if (workInProgress2.ref !== null) {\n              var info = \"\";\n              var ownerName = getCurrentFiberOwnerNameInDevOrNull();\n              if (ownerName) {\n                info += \"\\n\\nCheck the render method of `\" + ownerName + \"`.\";\n              }\n              var warningKey = ownerName || \"\";\n              var debugSource = workInProgress2._debugSource;\n              if (debugSource) {\n                warningKey = debugSource.fileName + \":\" + debugSource.lineNumber;\n              }\n              if (!didWarnAboutFunctionRefs[warningKey]) {\n                didWarnAboutFunctionRefs[warningKey] = true;\n                error(\"Function components cannot be given refs. Attempts to access this ref will fail. Did you mean to use React.forwardRef()?%s\", info);\n              }\n            }\n            if (typeof Component.getDerivedStateFromProps === \"function\") {\n              var _componentName3 = getComponentNameFromType(Component) || \"Unknown\";\n              if (!didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3]) {\n                error(\"%s: Function components do not support getDerivedStateFromProps.\", _componentName3);\n                didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3] = true;\n              }\n            }\n            if (typeof Component.contextType === \"object\" && Component.contextType !== null) {\n              var _componentName4 = getComponentNameFromType(Component) || \"Unknown\";\n              if (!didWarnAboutContextTypeOnFunctionComponent[_componentName4]) {\n                error(\"%s: Function components do not support contextType.\", _componentName4);\n                didWarnAboutContextTypeOnFunctionComponent[_componentName4] = true;\n              }\n            }\n          }\n        }\n        var SUSPENDED_MARKER = {\n          dehydrated: null,\n          treeContext: null,\n          retryLane: NoLane\n        };\n        function mountSuspenseOffscreenState(renderLanes2) {\n          return {\n            baseLanes: renderLanes2,\n            cachePool: getSuspendedCache(),\n            transitions: null\n          };\n        }\n        function updateSuspenseOffscreenState(prevOffscreenState, renderLanes2) {\n          var cachePool = null;\n          return {\n            baseLanes: mergeLanes(prevOffscreenState.baseLanes, renderLanes2),\n            cachePool,\n            transitions: prevOffscreenState.transitions\n          };\n        }\n        function shouldRemainOnFallback(suspenseContext, current2, workInProgress2, renderLanes2) {\n          if (current2 !== null) {\n            var suspenseState = current2.memoizedState;\n            if (suspenseState === null) {\n              return false;\n            }\n          }\n          return hasSuspenseContext(suspenseContext, ForceSuspenseFallback);\n        }\n        function getRemainingWorkInPrimaryTree(current2, renderLanes2) {\n          return removeLanes(current2.childLanes, renderLanes2);\n        }\n        function updateSuspenseComponent(current2, workInProgress2, renderLanes2) {\n          var nextProps = workInProgress2.pendingProps;\n          {\n            if (shouldSuspend(workInProgress2)) {\n              workInProgress2.flags |= DidCapture;\n            }\n          }\n          var suspenseContext = suspenseStackCursor.current;\n          var showFallback = false;\n          var didSuspend = (workInProgress2.flags & DidCapture) !== NoFlags;\n          if (didSuspend || shouldRemainOnFallback(suspenseContext, current2)) {\n            showFallback = true;\n            workInProgress2.flags &= ~DidCapture;\n          } else {\n            if (current2 === null || current2.memoizedState !== null) {\n              {\n                suspenseContext = addSubtreeSuspenseContext(suspenseContext, InvisibleParentSuspenseContext);\n              }\n            }\n          }\n          suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);\n          pushSuspenseContext(workInProgress2, suspenseContext);\n          if (current2 === null) {\n            tryToClaimNextHydratableInstance(workInProgress2);\n            var suspenseState = workInProgress2.memoizedState;\n            if (suspenseState !== null) {\n              var dehydrated = suspenseState.dehydrated;\n              if (dehydrated !== null) {\n                return mountDehydratedSuspenseComponent(workInProgress2, dehydrated);\n              }\n            }\n            var nextPrimaryChildren = nextProps.children;\n            var nextFallbackChildren = nextProps.fallback;\n            if (showFallback) {\n              var fallbackFragment = mountSuspenseFallbackChildren(workInProgress2, nextPrimaryChildren, nextFallbackChildren, renderLanes2);\n              var primaryChildFragment = workInProgress2.child;\n              primaryChildFragment.memoizedState = mountSuspenseOffscreenState(renderLanes2);\n              workInProgress2.memoizedState = SUSPENDED_MARKER;\n              return fallbackFragment;\n            } else {\n              return mountSuspensePrimaryChildren(workInProgress2, nextPrimaryChildren);\n            }\n          } else {\n            var prevState = current2.memoizedState;\n            if (prevState !== null) {\n              var _dehydrated = prevState.dehydrated;\n              if (_dehydrated !== null) {\n                return updateDehydratedSuspenseComponent(current2, workInProgress2, didSuspend, nextProps, _dehydrated, prevState, renderLanes2);\n              }\n            }\n            if (showFallback) {\n              var _nextFallbackChildren = nextProps.fallback;\n              var _nextPrimaryChildren = nextProps.children;\n              var fallbackChildFragment = updateSuspenseFallbackChildren(current2, workInProgress2, _nextPrimaryChildren, _nextFallbackChildren, renderLanes2);\n              var _primaryChildFragment2 = workInProgress2.child;\n              var prevOffscreenState = current2.child.memoizedState;\n              _primaryChildFragment2.memoizedState = prevOffscreenState === null ? mountSuspenseOffscreenState(renderLanes2) : updateSuspenseOffscreenState(prevOffscreenState, renderLanes2);\n              _primaryChildFragment2.childLanes = getRemainingWorkInPrimaryTree(current2, renderLanes2);\n              workInProgress2.memoizedState = SUSPENDED_MARKER;\n              return fallbackChildFragment;\n            } else {\n              var _nextPrimaryChildren2 = nextProps.children;\n              var _primaryChildFragment3 = updateSuspensePrimaryChildren(current2, workInProgress2, _nextPrimaryChildren2, renderLanes2);\n              workInProgress2.memoizedState = null;\n              return _primaryChildFragment3;\n            }\n          }\n        }\n        function mountSuspensePrimaryChildren(workInProgress2, primaryChildren, renderLanes2) {\n          var mode = workInProgress2.mode;\n          var primaryChildProps = {\n            mode: \"visible\",\n            children: primaryChildren\n          };\n          var primaryChildFragment = mountWorkInProgressOffscreenFiber(primaryChildProps, mode);\n          primaryChildFragment.return = workInProgress2;\n          workInProgress2.child = primaryChildFragment;\n          return primaryChildFragment;\n        }\n        function mountSuspenseFallbackChildren(workInProgress2, primaryChildren, fallbackChildren, renderLanes2) {\n          var mode = workInProgress2.mode;\n          var progressedPrimaryFragment = workInProgress2.child;\n          var primaryChildProps = {\n            mode: \"hidden\",\n            children: primaryChildren\n          };\n          var primaryChildFragment;\n          var fallbackChildFragment;\n          if ((mode & ConcurrentMode) === NoMode && progressedPrimaryFragment !== null) {\n            primaryChildFragment = progressedPrimaryFragment;\n            primaryChildFragment.childLanes = NoLanes;\n            primaryChildFragment.pendingProps = primaryChildProps;\n            if (workInProgress2.mode & ProfileMode) {\n              primaryChildFragment.actualDuration = 0;\n              primaryChildFragment.actualStartTime = -1;\n              primaryChildFragment.selfBaseDuration = 0;\n              primaryChildFragment.treeBaseDuration = 0;\n            }\n            fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes2, null);\n          } else {\n            primaryChildFragment = mountWorkInProgressOffscreenFiber(primaryChildProps, mode);\n            fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes2, null);\n          }\n          primaryChildFragment.return = workInProgress2;\n          fallbackChildFragment.return = workInProgress2;\n          primaryChildFragment.sibling = fallbackChildFragment;\n          workInProgress2.child = primaryChildFragment;\n          return fallbackChildFragment;\n        }\n        function mountWorkInProgressOffscreenFiber(offscreenProps, mode, renderLanes2) {\n          return createFiberFromOffscreen(offscreenProps, mode, NoLanes, null);\n        }\n        function updateWorkInProgressOffscreenFiber(current2, offscreenProps) {\n          return createWorkInProgress(current2, offscreenProps);\n        }\n        function updateSuspensePrimaryChildren(current2, workInProgress2, primaryChildren, renderLanes2) {\n          var currentPrimaryChildFragment = current2.child;\n          var currentFallbackChildFragment = currentPrimaryChildFragment.sibling;\n          var primaryChildFragment = updateWorkInProgressOffscreenFiber(currentPrimaryChildFragment, {\n            mode: \"visible\",\n            children: primaryChildren\n          });\n          if ((workInProgress2.mode & ConcurrentMode) === NoMode) {\n            primaryChildFragment.lanes = renderLanes2;\n          }\n          primaryChildFragment.return = workInProgress2;\n          primaryChildFragment.sibling = null;\n          if (currentFallbackChildFragment !== null) {\n            var deletions = workInProgress2.deletions;\n            if (deletions === null) {\n              workInProgress2.deletions = [currentFallbackChildFragment];\n              workInProgress2.flags |= ChildDeletion;\n            } else {\n              deletions.push(currentFallbackChildFragment);\n            }\n          }\n          workInProgress2.child = primaryChildFragment;\n          return primaryChildFragment;\n        }\n        function updateSuspenseFallbackChildren(current2, workInProgress2, primaryChildren, fallbackChildren, renderLanes2) {\n          var mode = workInProgress2.mode;\n          var currentPrimaryChildFragment = current2.child;\n          var currentFallbackChildFragment = currentPrimaryChildFragment.sibling;\n          var primaryChildProps = {\n            mode: \"hidden\",\n            children: primaryChildren\n          };\n          var primaryChildFragment;\n          if (\n            // In legacy mode, we commit the primary tree as if it successfully\n            // completed, even though it's in an inconsistent state.\n            (mode & ConcurrentMode) === NoMode && // Make sure we're on the second pass, i.e. the primary child fragment was\n            // already cloned. In legacy mode, the only case where this isn't true is\n            // when DevTools forces us to display a fallback; we skip the first render\n            // pass entirely and go straight to rendering the fallback. (In Concurrent\n            // Mode, SuspenseList can also trigger this scenario, but this is a legacy-\n            // only codepath.)\n            workInProgress2.child !== currentPrimaryChildFragment\n          ) {\n            var progressedPrimaryFragment = workInProgress2.child;\n            primaryChildFragment = progressedPrimaryFragment;\n            primaryChildFragment.childLanes = NoLanes;\n            primaryChildFragment.pendingProps = primaryChildProps;\n            if (workInProgress2.mode & ProfileMode) {\n              primaryChildFragment.actualDuration = 0;\n              primaryChildFragment.actualStartTime = -1;\n              primaryChildFragment.selfBaseDuration = currentPrimaryChildFragment.selfBaseDuration;\n              primaryChildFragment.treeBaseDuration = currentPrimaryChildFragment.treeBaseDuration;\n            }\n            workInProgress2.deletions = null;\n          } else {\n            primaryChildFragment = updateWorkInProgressOffscreenFiber(currentPrimaryChildFragment, primaryChildProps);\n            primaryChildFragment.subtreeFlags = currentPrimaryChildFragment.subtreeFlags & StaticMask;\n          }\n          var fallbackChildFragment;\n          if (currentFallbackChildFragment !== null) {\n            fallbackChildFragment = createWorkInProgress(currentFallbackChildFragment, fallbackChildren);\n          } else {\n            fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes2, null);\n            fallbackChildFragment.flags |= Placement;\n          }\n          fallbackChildFragment.return = workInProgress2;\n          primaryChildFragment.return = workInProgress2;\n          primaryChildFragment.sibling = fallbackChildFragment;\n          workInProgress2.child = primaryChildFragment;\n          return fallbackChildFragment;\n        }\n        function retrySuspenseComponentWithoutHydrating(current2, workInProgress2, renderLanes2, recoverableError) {\n          if (recoverableError !== null) {\n            queueHydrationError(recoverableError);\n          }\n          reconcileChildFibers(workInProgress2, current2.child, null, renderLanes2);\n          var nextProps = workInProgress2.pendingProps;\n          var primaryChildren = nextProps.children;\n          var primaryChildFragment = mountSuspensePrimaryChildren(workInProgress2, primaryChildren);\n          primaryChildFragment.flags |= Placement;\n          workInProgress2.memoizedState = null;\n          return primaryChildFragment;\n        }\n        function mountSuspenseFallbackAfterRetryWithoutHydrating(current2, workInProgress2, primaryChildren, fallbackChildren, renderLanes2) {\n          var fiberMode = workInProgress2.mode;\n          var primaryChildProps = {\n            mode: \"visible\",\n            children: primaryChildren\n          };\n          var primaryChildFragment = mountWorkInProgressOffscreenFiber(primaryChildProps, fiberMode);\n          var fallbackChildFragment = createFiberFromFragment(fallbackChildren, fiberMode, renderLanes2, null);\n          fallbackChildFragment.flags |= Placement;\n          primaryChildFragment.return = workInProgress2;\n          fallbackChildFragment.return = workInProgress2;\n          primaryChildFragment.sibling = fallbackChildFragment;\n          workInProgress2.child = primaryChildFragment;\n          if ((workInProgress2.mode & ConcurrentMode) !== NoMode) {\n            reconcileChildFibers(workInProgress2, current2.child, null, renderLanes2);\n          }\n          return fallbackChildFragment;\n        }\n        function mountDehydratedSuspenseComponent(workInProgress2, suspenseInstance, renderLanes2) {\n          if ((workInProgress2.mode & ConcurrentMode) === NoMode) {\n            {\n              error(\"Cannot hydrate Suspense in legacy mode. Switch from ReactDOM.hydrate(element, container) to ReactDOMClient.hydrateRoot(container, <App />).render(element) or remove the Suspense components from the server rendered components.\");\n            }\n            workInProgress2.lanes = laneToLanes(SyncLane);\n          } else if (isSuspenseInstanceFallback(suspenseInstance)) {\n            workInProgress2.lanes = laneToLanes(DefaultHydrationLane);\n          } else {\n            workInProgress2.lanes = laneToLanes(OffscreenLane);\n          }\n          return null;\n        }\n        function updateDehydratedSuspenseComponent(current2, workInProgress2, didSuspend, nextProps, suspenseInstance, suspenseState, renderLanes2) {\n          if (!didSuspend) {\n            warnIfHydrating();\n            if ((workInProgress2.mode & ConcurrentMode) === NoMode) {\n              return retrySuspenseComponentWithoutHydrating(\n                current2,\n                workInProgress2,\n                renderLanes2,\n                // TODO: When we delete legacy mode, we should make this error argument\n                // required  every concurrent mode path that causes hydration to\n                // de-opt to client rendering should have an error message.\n                null\n              );\n            }\n            if (isSuspenseInstanceFallback(suspenseInstance)) {\n              var digest, message, stack;\n              {\n                var _getSuspenseInstanceF = getSuspenseInstanceFallbackErrorDetails(suspenseInstance);\n                digest = _getSuspenseInstanceF.digest;\n                message = _getSuspenseInstanceF.message;\n                stack = _getSuspenseInstanceF.stack;\n              }\n              var error2;\n              if (message) {\n                error2 = new Error(message);\n              } else {\n                error2 = new Error(\"The server could not finish this Suspense boundary, likely due to an error during server rendering. Switched to client rendering.\");\n              }\n              var capturedValue = createCapturedValue(error2, digest, stack);\n              return retrySuspenseComponentWithoutHydrating(current2, workInProgress2, renderLanes2, capturedValue);\n            }\n            var hasContextChanged2 = includesSomeLane(renderLanes2, current2.childLanes);\n            if (didReceiveUpdate || hasContextChanged2) {\n              var root2 = getWorkInProgressRoot();\n              if (root2 !== null) {\n                var attemptHydrationAtLane = getBumpedLaneForHydration(root2, renderLanes2);\n                if (attemptHydrationAtLane !== NoLane && attemptHydrationAtLane !== suspenseState.retryLane) {\n                  suspenseState.retryLane = attemptHydrationAtLane;\n                  var eventTime = NoTimestamp;\n                  enqueueConcurrentRenderForLane(current2, attemptHydrationAtLane);\n                  scheduleUpdateOnFiber(root2, current2, attemptHydrationAtLane, eventTime);\n                }\n              }\n              renderDidSuspendDelayIfPossible();\n              var _capturedValue = createCapturedValue(new Error(\"This Suspense boundary received an update before it finished hydrating. This caused the boundary to switch to client rendering. The usual way to fix this is to wrap the original update in startTransition.\"));\n              return retrySuspenseComponentWithoutHydrating(current2, workInProgress2, renderLanes2, _capturedValue);\n            } else if (isSuspenseInstancePending(suspenseInstance)) {\n              workInProgress2.flags |= DidCapture;\n              workInProgress2.child = current2.child;\n              var retry = retryDehydratedSuspenseBoundary.bind(null, current2);\n              registerSuspenseInstanceRetry(suspenseInstance, retry);\n              return null;\n            } else {\n              reenterHydrationStateFromDehydratedSuspenseInstance(workInProgress2, suspenseInstance, suspenseState.treeContext);\n              var primaryChildren = nextProps.children;\n              var primaryChildFragment = mountSuspensePrimaryChildren(workInProgress2, primaryChildren);\n              primaryChildFragment.flags |= Hydrating;\n              return primaryChildFragment;\n            }\n          } else {\n            if (workInProgress2.flags & ForceClientRender) {\n              workInProgress2.flags &= ~ForceClientRender;\n              var _capturedValue2 = createCapturedValue(new Error(\"There was an error while hydrating this Suspense boundary. Switched to client rendering.\"));\n              return retrySuspenseComponentWithoutHydrating(current2, workInProgress2, renderLanes2, _capturedValue2);\n            } else if (workInProgress2.memoizedState !== null) {\n              workInProgress2.child = current2.child;\n              workInProgress2.flags |= DidCapture;\n              return null;\n            } else {\n              var nextPrimaryChildren = nextProps.children;\n              var nextFallbackChildren = nextProps.fallback;\n              var fallbackChildFragment = mountSuspenseFallbackAfterRetryWithoutHydrating(current2, workInProgress2, nextPrimaryChildren, nextFallbackChildren, renderLanes2);\n              var _primaryChildFragment4 = workInProgress2.child;\n              _primaryChildFragment4.memoizedState = mountSuspenseOffscreenState(renderLanes2);\n              workInProgress2.memoizedState = SUSPENDED_MARKER;\n              return fallbackChildFragment;\n            }\n          }\n        }\n        function scheduleSuspenseWorkOnFiber(fiber, renderLanes2, propagationRoot) {\n          fiber.lanes = mergeLanes(fiber.lanes, renderLanes2);\n          var alternate = fiber.alternate;\n          if (alternate !== null) {\n            alternate.lanes = mergeLanes(alternate.lanes, renderLanes2);\n          }\n          scheduleContextWorkOnParentPath(fiber.return, renderLanes2, propagationRoot);\n        }\n        function propagateSuspenseContextChange(workInProgress2, firstChild, renderLanes2) {\n          var node = firstChild;\n          while (node !== null) {\n            if (node.tag === SuspenseComponent) {\n              var state = node.memoizedState;\n              if (state !== null) {\n                scheduleSuspenseWorkOnFiber(node, renderLanes2, workInProgress2);\n              }\n            } else if (node.tag === SuspenseListComponent) {\n              scheduleSuspenseWorkOnFiber(node, renderLanes2, workInProgress2);\n            } else if (node.child !== null) {\n              node.child.return = node;\n              node = node.child;\n              continue;\n            }\n            if (node === workInProgress2) {\n              return;\n            }\n            while (node.sibling === null) {\n              if (node.return === null || node.return === workInProgress2) {\n                return;\n              }\n              node = node.return;\n            }\n            node.sibling.return = node.return;\n            node = node.sibling;\n          }\n        }\n        function findLastContentRow(firstChild) {\n          var row = firstChild;\n          var lastContentRow = null;\n          while (row !== null) {\n            var currentRow = row.alternate;\n            if (currentRow !== null && findFirstSuspended(currentRow) === null) {\n              lastContentRow = row;\n            }\n            row = row.sibling;\n          }\n          return lastContentRow;\n        }\n        function validateRevealOrder(revealOrder) {\n          {\n            if (revealOrder !== void 0 && revealOrder !== \"forwards\" && revealOrder !== \"backwards\" && revealOrder !== \"together\" && !didWarnAboutRevealOrder[revealOrder]) {\n              didWarnAboutRevealOrder[revealOrder] = true;\n              if (typeof revealOrder === \"string\") {\n                switch (revealOrder.toLowerCase()) {\n                  case \"together\":\n                  case \"forwards\":\n                  case \"backwards\": {\n                    error('\"%s\" is not a valid value for revealOrder on <SuspenseList />. Use lowercase \"%s\" instead.', revealOrder, revealOrder.toLowerCase());\n                    break;\n                  }\n                  case \"forward\":\n                  case \"backward\": {\n                    error('\"%s\" is not a valid value for revealOrder on <SuspenseList />. React uses the -s suffix in the spelling. Use \"%ss\" instead.', revealOrder, revealOrder.toLowerCase());\n                    break;\n                  }\n                  default:\n                    error('\"%s\" is not a supported revealOrder on <SuspenseList />. Did you mean \"together\", \"forwards\" or \"backwards\"?', revealOrder);\n                    break;\n                }\n              } else {\n                error('%s is not a supported value for revealOrder on <SuspenseList />. Did you mean \"together\", \"forwards\" or \"backwards\"?', revealOrder);\n              }\n            }\n          }\n        }\n        function validateTailOptions(tailMode, revealOrder) {\n          {\n            if (tailMode !== void 0 && !didWarnAboutTailOptions[tailMode]) {\n              if (tailMode !== \"collapsed\" && tailMode !== \"hidden\") {\n                didWarnAboutTailOptions[tailMode] = true;\n                error('\"%s\" is not a supported value for tail on <SuspenseList />. Did you mean \"collapsed\" or \"hidden\"?', tailMode);\n              } else if (revealOrder !== \"forwards\" && revealOrder !== \"backwards\") {\n                didWarnAboutTailOptions[tailMode] = true;\n                error('<SuspenseList tail=\"%s\" /> is only valid if revealOrder is \"forwards\" or \"backwards\". Did you mean to specify revealOrder=\"forwards\"?', tailMode);\n              }\n            }\n          }\n        }\n        function validateSuspenseListNestedChild(childSlot, index2) {\n          {\n            var isAnArray = isArray(childSlot);\n            var isIterable = !isAnArray && typeof getIteratorFn(childSlot) === \"function\";\n            if (isAnArray || isIterable) {\n              var type = isAnArray ? \"array\" : \"iterable\";\n              error(\"A nested %s was passed to row #%s in <SuspenseList />. Wrap it in an additional SuspenseList to configure its revealOrder: <SuspenseList revealOrder=...> ... <SuspenseList revealOrder=...>{%s}</SuspenseList> ... </SuspenseList>\", type, index2, type);\n              return false;\n            }\n          }\n          return true;\n        }\n        function validateSuspenseListChildren(children, revealOrder) {\n          {\n            if ((revealOrder === \"forwards\" || revealOrder === \"backwards\") && children !== void 0 && children !== null && children !== false) {\n              if (isArray(children)) {\n                for (var i = 0; i < children.length; i++) {\n                  if (!validateSuspenseListNestedChild(children[i], i)) {\n                    return;\n                  }\n                }\n              } else {\n                var iteratorFn = getIteratorFn(children);\n                if (typeof iteratorFn === \"function\") {\n                  var childrenIterator = iteratorFn.call(children);\n                  if (childrenIterator) {\n                    var step = childrenIterator.next();\n                    var _i = 0;\n                    for (; !step.done; step = childrenIterator.next()) {\n                      if (!validateSuspenseListNestedChild(step.value, _i)) {\n                        return;\n                      }\n                      _i++;\n                    }\n                  }\n                } else {\n                  error('A single row was passed to a <SuspenseList revealOrder=\"%s\" />. This is not useful since it needs multiple rows. Did you mean to pass multiple children or an array?', revealOrder);\n                }\n              }\n            }\n          }\n        }\n        function initSuspenseListRenderState(workInProgress2, isBackwards, tail, lastContentRow, tailMode) {\n          var renderState = workInProgress2.memoizedState;\n          if (renderState === null) {\n            workInProgress2.memoizedState = {\n              isBackwards,\n              rendering: null,\n              renderingStartTime: 0,\n              last: lastContentRow,\n              tail,\n              tailMode\n            };\n          } else {\n            renderState.isBackwards = isBackwards;\n            renderState.rendering = null;\n            renderState.renderingStartTime = 0;\n            renderState.last = lastContentRow;\n            renderState.tail = tail;\n            renderState.tailMode = tailMode;\n          }\n        }\n        function updateSuspenseListComponent(current2, workInProgress2, renderLanes2) {\n          var nextProps = workInProgress2.pendingProps;\n          var revealOrder = nextProps.revealOrder;\n          var tailMode = nextProps.tail;\n          var newChildren = nextProps.children;\n          validateRevealOrder(revealOrder);\n          validateTailOptions(tailMode, revealOrder);\n          validateSuspenseListChildren(newChildren, revealOrder);\n          reconcileChildren(current2, workInProgress2, newChildren, renderLanes2);\n          var suspenseContext = suspenseStackCursor.current;\n          var shouldForceFallback = hasSuspenseContext(suspenseContext, ForceSuspenseFallback);\n          if (shouldForceFallback) {\n            suspenseContext = setShallowSuspenseContext(suspenseContext, ForceSuspenseFallback);\n            workInProgress2.flags |= DidCapture;\n          } else {\n            var didSuspendBefore = current2 !== null && (current2.flags & DidCapture) !== NoFlags;\n            if (didSuspendBefore) {\n              propagateSuspenseContextChange(workInProgress2, workInProgress2.child, renderLanes2);\n            }\n            suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);\n          }\n          pushSuspenseContext(workInProgress2, suspenseContext);\n          if ((workInProgress2.mode & ConcurrentMode) === NoMode) {\n            workInProgress2.memoizedState = null;\n          } else {\n            switch (revealOrder) {\n              case \"forwards\": {\n                var lastContentRow = findLastContentRow(workInProgress2.child);\n                var tail;\n                if (lastContentRow === null) {\n                  tail = workInProgress2.child;\n                  workInProgress2.child = null;\n                } else {\n                  tail = lastContentRow.sibling;\n                  lastContentRow.sibling = null;\n                }\n                initSuspenseListRenderState(\n                  workInProgress2,\n                  false,\n                  // isBackwards\n                  tail,\n                  lastContentRow,\n                  tailMode\n                );\n                break;\n              }\n              case \"backwards\": {\n                var _tail = null;\n                var row = workInProgress2.child;\n                workInProgress2.child = null;\n                while (row !== null) {\n                  var currentRow = row.alternate;\n                  if (currentRow !== null && findFirstSuspended(currentRow) === null) {\n                    workInProgress2.child = row;\n                    break;\n                  }\n                  var nextRow = row.sibling;\n                  row.sibling = _tail;\n                  _tail = row;\n                  row = nextRow;\n                }\n                initSuspenseListRenderState(\n                  workInProgress2,\n                  true,\n                  // isBackwards\n                  _tail,\n                  null,\n                  // last\n                  tailMode\n                );\n                break;\n              }\n              case \"together\": {\n                initSuspenseListRenderState(\n                  workInProgress2,\n                  false,\n                  // isBackwards\n                  null,\n                  // tail\n                  null,\n                  // last\n                  void 0\n                );\n                break;\n              }\n              default: {\n                workInProgress2.memoizedState = null;\n              }\n            }\n          }\n          return workInProgress2.child;\n        }\n        function updatePortalComponent(current2, workInProgress2, renderLanes2) {\n          pushHostContainer(workInProgress2, workInProgress2.stateNode.containerInfo);\n          var nextChildren = workInProgress2.pendingProps;\n          if (current2 === null) {\n            workInProgress2.child = reconcileChildFibers(workInProgress2, null, nextChildren, renderLanes2);\n          } else {\n            reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);\n          }\n          return workInProgress2.child;\n        }\n        var hasWarnedAboutUsingNoValuePropOnContextProvider = false;\n        function updateContextProvider(current2, workInProgress2, renderLanes2) {\n          var providerType = workInProgress2.type;\n          var context = providerType._context;\n          var newProps = workInProgress2.pendingProps;\n          var oldProps = workInProgress2.memoizedProps;\n          var newValue = newProps.value;\n          {\n            if (!(\"value\" in newProps)) {\n              if (!hasWarnedAboutUsingNoValuePropOnContextProvider) {\n                hasWarnedAboutUsingNoValuePropOnContextProvider = true;\n                error(\"The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?\");\n              }\n            }\n            var providerPropTypes = workInProgress2.type.propTypes;\n            if (providerPropTypes) {\n              checkPropTypes(providerPropTypes, newProps, \"prop\", \"Context.Provider\");\n            }\n          }\n          pushProvider(workInProgress2, context, newValue);\n          {\n            if (oldProps !== null) {\n              var oldValue = oldProps.value;\n              if (objectIs(oldValue, newValue)) {\n                if (oldProps.children === newProps.children && !hasContextChanged()) {\n                  return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);\n                }\n              } else {\n                propagateContextChange(workInProgress2, context, renderLanes2);\n              }\n            }\n          }\n          var newChildren = newProps.children;\n          reconcileChildren(current2, workInProgress2, newChildren, renderLanes2);\n          return workInProgress2.child;\n        }\n        var hasWarnedAboutUsingContextAsConsumer = false;\n        function updateContextConsumer(current2, workInProgress2, renderLanes2) {\n          var context = workInProgress2.type;\n          {\n            if (context._context === void 0) {\n              if (context !== context.Consumer) {\n                if (!hasWarnedAboutUsingContextAsConsumer) {\n                  hasWarnedAboutUsingContextAsConsumer = true;\n                  error(\"Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?\");\n                }\n              }\n            } else {\n              context = context._context;\n            }\n          }\n          var newProps = workInProgress2.pendingProps;\n          var render2 = newProps.children;\n          {\n            if (typeof render2 !== \"function\") {\n              error(\"A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it.\");\n            }\n          }\n          prepareToReadContext(workInProgress2, renderLanes2);\n          var newValue = readContext(context);\n          {\n            markComponentRenderStarted(workInProgress2);\n          }\n          var newChildren;\n          {\n            ReactCurrentOwner$1.current = workInProgress2;\n            setIsRendering(true);\n            newChildren = render2(newValue);\n            setIsRendering(false);\n          }\n          {\n            markComponentRenderStopped();\n          }\n          workInProgress2.flags |= PerformedWork;\n          reconcileChildren(current2, workInProgress2, newChildren, renderLanes2);\n          return workInProgress2.child;\n        }\n        function markWorkInProgressReceivedUpdate() {\n          didReceiveUpdate = true;\n        }\n        function resetSuspendedCurrentOnMountInLegacyMode(current2, workInProgress2) {\n          if ((workInProgress2.mode & ConcurrentMode) === NoMode) {\n            if (current2 !== null) {\n              current2.alternate = null;\n              workInProgress2.alternate = null;\n              workInProgress2.flags |= Placement;\n            }\n          }\n        }\n        function bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2) {\n          if (current2 !== null) {\n            workInProgress2.dependencies = current2.dependencies;\n          }\n          {\n            stopProfilerTimerIfRunning();\n          }\n          markSkippedUpdateLanes(workInProgress2.lanes);\n          if (!includesSomeLane(renderLanes2, workInProgress2.childLanes)) {\n            {\n              return null;\n            }\n          }\n          cloneChildFibers(current2, workInProgress2);\n          return workInProgress2.child;\n        }\n        function remountFiber(current2, oldWorkInProgress, newWorkInProgress) {\n          {\n            var returnFiber = oldWorkInProgress.return;\n            if (returnFiber === null) {\n              throw new Error(\"Cannot swap the root fiber.\");\n            }\n            current2.alternate = null;\n            oldWorkInProgress.alternate = null;\n            newWorkInProgress.index = oldWorkInProgress.index;\n            newWorkInProgress.sibling = oldWorkInProgress.sibling;\n            newWorkInProgress.return = oldWorkInProgress.return;\n            newWorkInProgress.ref = oldWorkInProgress.ref;\n            if (oldWorkInProgress === returnFiber.child) {\n              returnFiber.child = newWorkInProgress;\n            } else {\n              var prevSibling = returnFiber.child;\n              if (prevSibling === null) {\n                throw new Error(\"Expected parent to have a child.\");\n              }\n              while (prevSibling.sibling !== oldWorkInProgress) {\n                prevSibling = prevSibling.sibling;\n                if (prevSibling === null) {\n                  throw new Error(\"Expected to find the previous sibling.\");\n                }\n              }\n              prevSibling.sibling = newWorkInProgress;\n            }\n            var deletions = returnFiber.deletions;\n            if (deletions === null) {\n              returnFiber.deletions = [current2];\n              returnFiber.flags |= ChildDeletion;\n            } else {\n              deletions.push(current2);\n            }\n            newWorkInProgress.flags |= Placement;\n            return newWorkInProgress;\n          }\n        }\n        function checkScheduledUpdateOrContext(current2, renderLanes2) {\n          var updateLanes = current2.lanes;\n          if (includesSomeLane(updateLanes, renderLanes2)) {\n            return true;\n          }\n          return false;\n        }\n        function attemptEarlyBailoutIfNoScheduledUpdate(current2, workInProgress2, renderLanes2) {\n          switch (workInProgress2.tag) {\n            case HostRoot:\n              pushHostRootContext(workInProgress2);\n              var root2 = workInProgress2.stateNode;\n              resetHydrationState();\n              break;\n            case HostComponent:\n              pushHostContext(workInProgress2);\n              break;\n            case ClassComponent: {\n              var Component = workInProgress2.type;\n              if (isContextProvider(Component)) {\n                pushContextProvider(workInProgress2);\n              }\n              break;\n            }\n            case HostPortal:\n              pushHostContainer(workInProgress2, workInProgress2.stateNode.containerInfo);\n              break;\n            case ContextProvider: {\n              var newValue = workInProgress2.memoizedProps.value;\n              var context = workInProgress2.type._context;\n              pushProvider(workInProgress2, context, newValue);\n              break;\n            }\n            case Profiler:\n              {\n                var hasChildWork = includesSomeLane(renderLanes2, workInProgress2.childLanes);\n                if (hasChildWork) {\n                  workInProgress2.flags |= Update;\n                }\n                {\n                  var stateNode = workInProgress2.stateNode;\n                  stateNode.effectDuration = 0;\n                  stateNode.passiveEffectDuration = 0;\n                }\n              }\n              break;\n            case SuspenseComponent: {\n              var state = workInProgress2.memoizedState;\n              if (state !== null) {\n                if (state.dehydrated !== null) {\n                  pushSuspenseContext(workInProgress2, setDefaultShallowSuspenseContext(suspenseStackCursor.current));\n                  workInProgress2.flags |= DidCapture;\n                  return null;\n                }\n                var primaryChildFragment = workInProgress2.child;\n                var primaryChildLanes = primaryChildFragment.childLanes;\n                if (includesSomeLane(renderLanes2, primaryChildLanes)) {\n                  return updateSuspenseComponent(current2, workInProgress2, renderLanes2);\n                } else {\n                  pushSuspenseContext(workInProgress2, setDefaultShallowSuspenseContext(suspenseStackCursor.current));\n                  var child = bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);\n                  if (child !== null) {\n                    return child.sibling;\n                  } else {\n                    return null;\n                  }\n                }\n              } else {\n                pushSuspenseContext(workInProgress2, setDefaultShallowSuspenseContext(suspenseStackCursor.current));\n              }\n              break;\n            }\n            case SuspenseListComponent: {\n              var didSuspendBefore = (current2.flags & DidCapture) !== NoFlags;\n              var _hasChildWork = includesSomeLane(renderLanes2, workInProgress2.childLanes);\n              if (didSuspendBefore) {\n                if (_hasChildWork) {\n                  return updateSuspenseListComponent(current2, workInProgress2, renderLanes2);\n                }\n                workInProgress2.flags |= DidCapture;\n              }\n              var renderState = workInProgress2.memoizedState;\n              if (renderState !== null) {\n                renderState.rendering = null;\n                renderState.tail = null;\n                renderState.lastEffect = null;\n              }\n              pushSuspenseContext(workInProgress2, suspenseStackCursor.current);\n              if (_hasChildWork) {\n                break;\n              } else {\n                return null;\n              }\n            }\n            case OffscreenComponent:\n            case LegacyHiddenComponent: {\n              workInProgress2.lanes = NoLanes;\n              return updateOffscreenComponent(current2, workInProgress2, renderLanes2);\n            }\n          }\n          return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);\n        }\n        function beginWork(current2, workInProgress2, renderLanes2) {\n          {\n            if (workInProgress2._debugNeedsRemount && current2 !== null) {\n              return remountFiber(current2, workInProgress2, createFiberFromTypeAndProps(workInProgress2.type, workInProgress2.key, workInProgress2.pendingProps, workInProgress2._debugOwner || null, workInProgress2.mode, workInProgress2.lanes));\n            }\n          }\n          if (current2 !== null) {\n            var oldProps = current2.memoizedProps;\n            var newProps = workInProgress2.pendingProps;\n            if (oldProps !== newProps || hasContextChanged() || // Force a re-render if the implementation changed due to hot reload:\n            workInProgress2.type !== current2.type) {\n              didReceiveUpdate = true;\n            } else {\n              var hasScheduledUpdateOrContext = checkScheduledUpdateOrContext(current2, renderLanes2);\n              if (!hasScheduledUpdateOrContext && // If this is the second pass of an error or suspense boundary, there\n              // may not be work scheduled on `current`, so we check for this flag.\n              (workInProgress2.flags & DidCapture) === NoFlags) {\n                didReceiveUpdate = false;\n                return attemptEarlyBailoutIfNoScheduledUpdate(current2, workInProgress2, renderLanes2);\n              }\n              if ((current2.flags & ForceUpdateForLegacySuspense) !== NoFlags) {\n                didReceiveUpdate = true;\n              } else {\n                didReceiveUpdate = false;\n              }\n            }\n          } else {\n            didReceiveUpdate = false;\n            if (getIsHydrating() && isForkedChild(workInProgress2)) {\n              var slotIndex = workInProgress2.index;\n              var numberOfForks = getForksAtLevel();\n              pushTreeId(workInProgress2, numberOfForks, slotIndex);\n            }\n          }\n          workInProgress2.lanes = NoLanes;\n          switch (workInProgress2.tag) {\n            case IndeterminateComponent: {\n              return mountIndeterminateComponent(current2, workInProgress2, workInProgress2.type, renderLanes2);\n            }\n            case LazyComponent: {\n              var elementType = workInProgress2.elementType;\n              return mountLazyComponent(current2, workInProgress2, elementType, renderLanes2);\n            }\n            case FunctionComponent: {\n              var Component = workInProgress2.type;\n              var unresolvedProps = workInProgress2.pendingProps;\n              var resolvedProps = workInProgress2.elementType === Component ? unresolvedProps : resolveDefaultProps(Component, unresolvedProps);\n              return updateFunctionComponent(current2, workInProgress2, Component, resolvedProps, renderLanes2);\n            }\n            case ClassComponent: {\n              var _Component = workInProgress2.type;\n              var _unresolvedProps = workInProgress2.pendingProps;\n              var _resolvedProps = workInProgress2.elementType === _Component ? _unresolvedProps : resolveDefaultProps(_Component, _unresolvedProps);\n              return updateClassComponent(current2, workInProgress2, _Component, _resolvedProps, renderLanes2);\n            }\n            case HostRoot:\n              return updateHostRoot(current2, workInProgress2, renderLanes2);\n            case HostComponent:\n              return updateHostComponent(current2, workInProgress2, renderLanes2);\n            case HostText:\n              return updateHostText(current2, workInProgress2);\n            case SuspenseComponent:\n              return updateSuspenseComponent(current2, workInProgress2, renderLanes2);\n            case HostPortal:\n              return updatePortalComponent(current2, workInProgress2, renderLanes2);\n            case ForwardRef: {\n              var type = workInProgress2.type;\n              var _unresolvedProps2 = workInProgress2.pendingProps;\n              var _resolvedProps2 = workInProgress2.elementType === type ? _unresolvedProps2 : resolveDefaultProps(type, _unresolvedProps2);\n              return updateForwardRef(current2, workInProgress2, type, _resolvedProps2, renderLanes2);\n            }\n            case Fragment:\n              return updateFragment(current2, workInProgress2, renderLanes2);\n            case Mode:\n              return updateMode(current2, workInProgress2, renderLanes2);\n            case Profiler:\n              return updateProfiler(current2, workInProgress2, renderLanes2);\n            case ContextProvider:\n              return updateContextProvider(current2, workInProgress2, renderLanes2);\n            case ContextConsumer:\n              return updateContextConsumer(current2, workInProgress2, renderLanes2);\n            case MemoComponent: {\n              var _type2 = workInProgress2.type;\n              var _unresolvedProps3 = workInProgress2.pendingProps;\n              var _resolvedProps3 = resolveDefaultProps(_type2, _unresolvedProps3);\n              {\n                if (workInProgress2.type !== workInProgress2.elementType) {\n                  var outerPropTypes = _type2.propTypes;\n                  if (outerPropTypes) {\n                    checkPropTypes(\n                      outerPropTypes,\n                      _resolvedProps3,\n                      // Resolved for outer only\n                      \"prop\",\n                      getComponentNameFromType(_type2)\n                    );\n                  }\n                }\n              }\n              _resolvedProps3 = resolveDefaultProps(_type2.type, _resolvedProps3);\n              return updateMemoComponent(current2, workInProgress2, _type2, _resolvedProps3, renderLanes2);\n            }\n            case SimpleMemoComponent: {\n              return updateSimpleMemoComponent(current2, workInProgress2, workInProgress2.type, workInProgress2.pendingProps, renderLanes2);\n            }\n            case IncompleteClassComponent: {\n              var _Component2 = workInProgress2.type;\n              var _unresolvedProps4 = workInProgress2.pendingProps;\n              var _resolvedProps4 = workInProgress2.elementType === _Component2 ? _unresolvedProps4 : resolveDefaultProps(_Component2, _unresolvedProps4);\n              return mountIncompleteClassComponent(current2, workInProgress2, _Component2, _resolvedProps4, renderLanes2);\n            }\n            case SuspenseListComponent: {\n              return updateSuspenseListComponent(current2, workInProgress2, renderLanes2);\n            }\n            case ScopeComponent: {\n              break;\n            }\n            case OffscreenComponent: {\n              return updateOffscreenComponent(current2, workInProgress2, renderLanes2);\n            }\n          }\n          throw new Error(\"Unknown unit of work tag (\" + workInProgress2.tag + \"). This error is likely caused by a bug in React. Please file an issue.\");\n        }\n        function markUpdate(workInProgress2) {\n          workInProgress2.flags |= Update;\n        }\n        function markRef$1(workInProgress2) {\n          workInProgress2.flags |= Ref;\n          {\n            workInProgress2.flags |= RefStatic;\n          }\n        }\n        var appendAllChildren;\n        var updateHostContainer;\n        var updateHostComponent$1;\n        var updateHostText$1;\n        {\n          appendAllChildren = function(parent, workInProgress2, needsVisibilityToggle, isHidden) {\n            var node = workInProgress2.child;\n            while (node !== null) {\n              if (node.tag === HostComponent || node.tag === HostText) {\n                appendInitialChild(parent, node.stateNode);\n              } else if (node.tag === HostPortal)\n                ;\n              else if (node.child !== null) {\n                node.child.return = node;\n                node = node.child;\n                continue;\n              }\n              if (node === workInProgress2) {\n                return;\n              }\n              while (node.sibling === null) {\n                if (node.return === null || node.return === workInProgress2) {\n                  return;\n                }\n                node = node.return;\n              }\n              node.sibling.return = node.return;\n              node = node.sibling;\n            }\n          };\n          updateHostContainer = function(current2, workInProgress2) {\n          };\n          updateHostComponent$1 = function(current2, workInProgress2, type, newProps, rootContainerInstance) {\n            var oldProps = current2.memoizedProps;\n            if (oldProps === newProps) {\n              return;\n            }\n            var instance = workInProgress2.stateNode;\n            var currentHostContext = getHostContext();\n            var updatePayload = prepareUpdate(instance, type, oldProps, newProps, rootContainerInstance, currentHostContext);\n            workInProgress2.updateQueue = updatePayload;\n            if (updatePayload) {\n              markUpdate(workInProgress2);\n            }\n          };\n          updateHostText$1 = function(current2, workInProgress2, oldText, newText) {\n            if (oldText !== newText) {\n              markUpdate(workInProgress2);\n            }\n          };\n        }\n        function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {\n          if (getIsHydrating()) {\n            return;\n          }\n          switch (renderState.tailMode) {\n            case \"hidden\": {\n              var tailNode = renderState.tail;\n              var lastTailNode = null;\n              while (tailNode !== null) {\n                if (tailNode.alternate !== null) {\n                  lastTailNode = tailNode;\n                }\n                tailNode = tailNode.sibling;\n              }\n              if (lastTailNode === null) {\n                renderState.tail = null;\n              } else {\n                lastTailNode.sibling = null;\n              }\n              break;\n            }\n            case \"collapsed\": {\n              var _tailNode = renderState.tail;\n              var _lastTailNode = null;\n              while (_tailNode !== null) {\n                if (_tailNode.alternate !== null) {\n                  _lastTailNode = _tailNode;\n                }\n                _tailNode = _tailNode.sibling;\n              }\n              if (_lastTailNode === null) {\n                if (!hasRenderedATailFallback && renderState.tail !== null) {\n                  renderState.tail.sibling = null;\n                } else {\n                  renderState.tail = null;\n                }\n              } else {\n                _lastTailNode.sibling = null;\n              }\n              break;\n            }\n          }\n        }\n        function bubbleProperties(completedWork) {\n          var didBailout = completedWork.alternate !== null && completedWork.alternate.child === completedWork.child;\n          var newChildLanes = NoLanes;\n          var subtreeFlags = NoFlags;\n          if (!didBailout) {\n            if ((completedWork.mode & ProfileMode) !== NoMode) {\n              var actualDuration = completedWork.actualDuration;\n              var treeBaseDuration = completedWork.selfBaseDuration;\n              var child = completedWork.child;\n              while (child !== null) {\n                newChildLanes = mergeLanes(newChildLanes, mergeLanes(child.lanes, child.childLanes));\n                subtreeFlags |= child.subtreeFlags;\n                subtreeFlags |= child.flags;\n                actualDuration += child.actualDuration;\n                treeBaseDuration += child.treeBaseDuration;\n                child = child.sibling;\n              }\n              completedWork.actualDuration = actualDuration;\n              completedWork.treeBaseDuration = treeBaseDuration;\n            } else {\n              var _child = completedWork.child;\n              while (_child !== null) {\n                newChildLanes = mergeLanes(newChildLanes, mergeLanes(_child.lanes, _child.childLanes));\n                subtreeFlags |= _child.subtreeFlags;\n                subtreeFlags |= _child.flags;\n                _child.return = completedWork;\n                _child = _child.sibling;\n              }\n            }\n            completedWork.subtreeFlags |= subtreeFlags;\n          } else {\n            if ((completedWork.mode & ProfileMode) !== NoMode) {\n              var _treeBaseDuration = completedWork.selfBaseDuration;\n              var _child2 = completedWork.child;\n              while (_child2 !== null) {\n                newChildLanes = mergeLanes(newChildLanes, mergeLanes(_child2.lanes, _child2.childLanes));\n                subtreeFlags |= _child2.subtreeFlags & StaticMask;\n                subtreeFlags |= _child2.flags & StaticMask;\n                _treeBaseDuration += _child2.treeBaseDuration;\n                _child2 = _child2.sibling;\n              }\n              completedWork.treeBaseDuration = _treeBaseDuration;\n            } else {\n              var _child3 = completedWork.child;\n              while (_child3 !== null) {\n                newChildLanes = mergeLanes(newChildLanes, mergeLanes(_child3.lanes, _child3.childLanes));\n                subtreeFlags |= _child3.subtreeFlags & StaticMask;\n                subtreeFlags |= _child3.flags & StaticMask;\n                _child3.return = completedWork;\n                _child3 = _child3.sibling;\n              }\n            }\n            completedWork.subtreeFlags |= subtreeFlags;\n          }\n          completedWork.childLanes = newChildLanes;\n          return didBailout;\n        }\n        function completeDehydratedSuspenseBoundary(current2, workInProgress2, nextState) {\n          if (hasUnhydratedTailNodes() && (workInProgress2.mode & ConcurrentMode) !== NoMode && (workInProgress2.flags & DidCapture) === NoFlags) {\n            warnIfUnhydratedTailNodes(workInProgress2);\n            resetHydrationState();\n            workInProgress2.flags |= ForceClientRender | Incomplete | ShouldCapture;\n            return false;\n          }\n          var wasHydrated = popHydrationState(workInProgress2);\n          if (nextState !== null && nextState.dehydrated !== null) {\n            if (current2 === null) {\n              if (!wasHydrated) {\n                throw new Error(\"A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React.\");\n              }\n              prepareToHydrateHostSuspenseInstance(workInProgress2);\n              bubbleProperties(workInProgress2);\n              {\n                if ((workInProgress2.mode & ProfileMode) !== NoMode) {\n                  var isTimedOutSuspense = nextState !== null;\n                  if (isTimedOutSuspense) {\n                    var primaryChildFragment = workInProgress2.child;\n                    if (primaryChildFragment !== null) {\n                      workInProgress2.treeBaseDuration -= primaryChildFragment.treeBaseDuration;\n                    }\n                  }\n                }\n              }\n              return false;\n            } else {\n              resetHydrationState();\n              if ((workInProgress2.flags & DidCapture) === NoFlags) {\n                workInProgress2.memoizedState = null;\n              }\n              workInProgress2.flags |= Update;\n              bubbleProperties(workInProgress2);\n              {\n                if ((workInProgress2.mode & ProfileMode) !== NoMode) {\n                  var _isTimedOutSuspense = nextState !== null;\n                  if (_isTimedOutSuspense) {\n                    var _primaryChildFragment = workInProgress2.child;\n                    if (_primaryChildFragment !== null) {\n                      workInProgress2.treeBaseDuration -= _primaryChildFragment.treeBaseDuration;\n                    }\n                  }\n                }\n              }\n              return false;\n            }\n          } else {\n            upgradeHydrationErrorsToRecoverable();\n            return true;\n          }\n        }\n        function completeWork(current2, workInProgress2, renderLanes2) {\n          var newProps = workInProgress2.pendingProps;\n          popTreeContext(workInProgress2);\n          switch (workInProgress2.tag) {\n            case IndeterminateComponent:\n            case LazyComponent:\n            case SimpleMemoComponent:\n            case FunctionComponent:\n            case ForwardRef:\n            case Fragment:\n            case Mode:\n            case Profiler:\n            case ContextConsumer:\n            case MemoComponent:\n              bubbleProperties(workInProgress2);\n              return null;\n            case ClassComponent: {\n              var Component = workInProgress2.type;\n              if (isContextProvider(Component)) {\n                popContext(workInProgress2);\n              }\n              bubbleProperties(workInProgress2);\n              return null;\n            }\n            case HostRoot: {\n              var fiberRoot = workInProgress2.stateNode;\n              popHostContainer(workInProgress2);\n              popTopLevelContextObject(workInProgress2);\n              resetWorkInProgressVersions();\n              if (fiberRoot.pendingContext) {\n                fiberRoot.context = fiberRoot.pendingContext;\n                fiberRoot.pendingContext = null;\n              }\n              if (current2 === null || current2.child === null) {\n                var wasHydrated = popHydrationState(workInProgress2);\n                if (wasHydrated) {\n                  markUpdate(workInProgress2);\n                } else {\n                  if (current2 !== null) {\n                    var prevState = current2.memoizedState;\n                    if (\n                      // Check if this is a client root\n                      !prevState.isDehydrated || // Check if we reverted to client rendering (e.g. due to an error)\n                      (workInProgress2.flags & ForceClientRender) !== NoFlags\n                    ) {\n                      workInProgress2.flags |= Snapshot;\n                      upgradeHydrationErrorsToRecoverable();\n                    }\n                  }\n                }\n              }\n              updateHostContainer(current2, workInProgress2);\n              bubbleProperties(workInProgress2);\n              return null;\n            }\n            case HostComponent: {\n              popHostContext(workInProgress2);\n              var rootContainerInstance = getRootHostContainer();\n              var type = workInProgress2.type;\n              if (current2 !== null && workInProgress2.stateNode != null) {\n                updateHostComponent$1(current2, workInProgress2, type, newProps, rootContainerInstance);\n                if (current2.ref !== workInProgress2.ref) {\n                  markRef$1(workInProgress2);\n                }\n              } else {\n                if (!newProps) {\n                  if (workInProgress2.stateNode === null) {\n                    throw new Error(\"We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.\");\n                  }\n                  bubbleProperties(workInProgress2);\n                  return null;\n                }\n                var currentHostContext = getHostContext();\n                var _wasHydrated = popHydrationState(workInProgress2);\n                if (_wasHydrated) {\n                  if (prepareToHydrateHostInstance(workInProgress2, rootContainerInstance, currentHostContext)) {\n                    markUpdate(workInProgress2);\n                  }\n                } else {\n                  var instance = createInstance(type, newProps, rootContainerInstance, currentHostContext, workInProgress2);\n                  appendAllChildren(instance, workInProgress2, false, false);\n                  workInProgress2.stateNode = instance;\n                  if (finalizeInitialChildren(instance, type, newProps, rootContainerInstance)) {\n                    markUpdate(workInProgress2);\n                  }\n                }\n                if (workInProgress2.ref !== null) {\n                  markRef$1(workInProgress2);\n                }\n              }\n              bubbleProperties(workInProgress2);\n              return null;\n            }\n            case HostText: {\n              var newText = newProps;\n              if (current2 && workInProgress2.stateNode != null) {\n                var oldText = current2.memoizedProps;\n                updateHostText$1(current2, workInProgress2, oldText, newText);\n              } else {\n                if (typeof newText !== \"string\") {\n                  if (workInProgress2.stateNode === null) {\n                    throw new Error(\"We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.\");\n                  }\n                }\n                var _rootContainerInstance = getRootHostContainer();\n                var _currentHostContext = getHostContext();\n                var _wasHydrated2 = popHydrationState(workInProgress2);\n                if (_wasHydrated2) {\n                  if (prepareToHydrateHostTextInstance(workInProgress2)) {\n                    markUpdate(workInProgress2);\n                  }\n                } else {\n                  workInProgress2.stateNode = createTextInstance(newText, _rootContainerInstance, _currentHostContext, workInProgress2);\n                }\n              }\n              bubbleProperties(workInProgress2);\n              return null;\n            }\n            case SuspenseComponent: {\n              popSuspenseContext(workInProgress2);\n              var nextState = workInProgress2.memoizedState;\n              if (current2 === null || current2.memoizedState !== null && current2.memoizedState.dehydrated !== null) {\n                var fallthroughToNormalSuspensePath = completeDehydratedSuspenseBoundary(current2, workInProgress2, nextState);\n                if (!fallthroughToNormalSuspensePath) {\n                  if (workInProgress2.flags & ShouldCapture) {\n                    return workInProgress2;\n                  } else {\n                    return null;\n                  }\n                }\n              }\n              if ((workInProgress2.flags & DidCapture) !== NoFlags) {\n                workInProgress2.lanes = renderLanes2;\n                if ((workInProgress2.mode & ProfileMode) !== NoMode) {\n                  transferActualDuration(workInProgress2);\n                }\n                return workInProgress2;\n              }\n              var nextDidTimeout = nextState !== null;\n              var prevDidTimeout = current2 !== null && current2.memoizedState !== null;\n              if (nextDidTimeout !== prevDidTimeout) {\n                if (nextDidTimeout) {\n                  var _offscreenFiber2 = workInProgress2.child;\n                  _offscreenFiber2.flags |= Visibility;\n                  if ((workInProgress2.mode & ConcurrentMode) !== NoMode) {\n                    var hasInvisibleChildContext = current2 === null && (workInProgress2.memoizedProps.unstable_avoidThisFallback !== true || !enableSuspenseAvoidThisFallback);\n                    if (hasInvisibleChildContext || hasSuspenseContext(suspenseStackCursor.current, InvisibleParentSuspenseContext)) {\n                      renderDidSuspend();\n                    } else {\n                      renderDidSuspendDelayIfPossible();\n                    }\n                  }\n                }\n              }\n              var wakeables = workInProgress2.updateQueue;\n              if (wakeables !== null) {\n                workInProgress2.flags |= Update;\n              }\n              bubbleProperties(workInProgress2);\n              {\n                if ((workInProgress2.mode & ProfileMode) !== NoMode) {\n                  if (nextDidTimeout) {\n                    var primaryChildFragment = workInProgress2.child;\n                    if (primaryChildFragment !== null) {\n                      workInProgress2.treeBaseDuration -= primaryChildFragment.treeBaseDuration;\n                    }\n                  }\n                }\n              }\n              return null;\n            }\n            case HostPortal:\n              popHostContainer(workInProgress2);\n              updateHostContainer(current2, workInProgress2);\n              if (current2 === null) {\n                preparePortalMount(workInProgress2.stateNode.containerInfo);\n              }\n              bubbleProperties(workInProgress2);\n              return null;\n            case ContextProvider:\n              var context = workInProgress2.type._context;\n              popProvider(context, workInProgress2);\n              bubbleProperties(workInProgress2);\n              return null;\n            case IncompleteClassComponent: {\n              var _Component = workInProgress2.type;\n              if (isContextProvider(_Component)) {\n                popContext(workInProgress2);\n              }\n              bubbleProperties(workInProgress2);\n              return null;\n            }\n            case SuspenseListComponent: {\n              popSuspenseContext(workInProgress2);\n              var renderState = workInProgress2.memoizedState;\n              if (renderState === null) {\n                bubbleProperties(workInProgress2);\n                return null;\n              }\n              var didSuspendAlready = (workInProgress2.flags & DidCapture) !== NoFlags;\n              var renderedTail = renderState.rendering;\n              if (renderedTail === null) {\n                if (!didSuspendAlready) {\n                  var cannotBeSuspended = renderHasNotSuspendedYet() && (current2 === null || (current2.flags & DidCapture) === NoFlags);\n                  if (!cannotBeSuspended) {\n                    var row = workInProgress2.child;\n                    while (row !== null) {\n                      var suspended = findFirstSuspended(row);\n                      if (suspended !== null) {\n                        didSuspendAlready = true;\n                        workInProgress2.flags |= DidCapture;\n                        cutOffTailIfNeeded(renderState, false);\n                        var newThenables = suspended.updateQueue;\n                        if (newThenables !== null) {\n                          workInProgress2.updateQueue = newThenables;\n                          workInProgress2.flags |= Update;\n                        }\n                        workInProgress2.subtreeFlags = NoFlags;\n                        resetChildFibers(workInProgress2, renderLanes2);\n                        pushSuspenseContext(workInProgress2, setShallowSuspenseContext(suspenseStackCursor.current, ForceSuspenseFallback));\n                        return workInProgress2.child;\n                      }\n                      row = row.sibling;\n                    }\n                  }\n                  if (renderState.tail !== null && now() > getRenderTargetTime()) {\n                    workInProgress2.flags |= DidCapture;\n                    didSuspendAlready = true;\n                    cutOffTailIfNeeded(renderState, false);\n                    workInProgress2.lanes = SomeRetryLane;\n                  }\n                } else {\n                  cutOffTailIfNeeded(renderState, false);\n                }\n              } else {\n                if (!didSuspendAlready) {\n                  var _suspended = findFirstSuspended(renderedTail);\n                  if (_suspended !== null) {\n                    workInProgress2.flags |= DidCapture;\n                    didSuspendAlready = true;\n                    var _newThenables = _suspended.updateQueue;\n                    if (_newThenables !== null) {\n                      workInProgress2.updateQueue = _newThenables;\n                      workInProgress2.flags |= Update;\n                    }\n                    cutOffTailIfNeeded(renderState, true);\n                    if (renderState.tail === null && renderState.tailMode === \"hidden\" && !renderedTail.alternate && !getIsHydrating()) {\n                      bubbleProperties(workInProgress2);\n                      return null;\n                    }\n                  } else if (\n                    // The time it took to render last row is greater than the remaining\n                    // time we have to render. So rendering one more row would likely\n                    // exceed it.\n                    now() * 2 - renderState.renderingStartTime > getRenderTargetTime() && renderLanes2 !== OffscreenLane\n                  ) {\n                    workInProgress2.flags |= DidCapture;\n                    didSuspendAlready = true;\n                    cutOffTailIfNeeded(renderState, false);\n                    workInProgress2.lanes = SomeRetryLane;\n                  }\n                }\n                if (renderState.isBackwards) {\n                  renderedTail.sibling = workInProgress2.child;\n                  workInProgress2.child = renderedTail;\n                } else {\n                  var previousSibling = renderState.last;\n                  if (previousSibling !== null) {\n                    previousSibling.sibling = renderedTail;\n                  } else {\n                    workInProgress2.child = renderedTail;\n                  }\n                  renderState.last = renderedTail;\n                }\n              }\n              if (renderState.tail !== null) {\n                var next = renderState.tail;\n                renderState.rendering = next;\n                renderState.tail = next.sibling;\n                renderState.renderingStartTime = now();\n                next.sibling = null;\n                var suspenseContext = suspenseStackCursor.current;\n                if (didSuspendAlready) {\n                  suspenseContext = setShallowSuspenseContext(suspenseContext, ForceSuspenseFallback);\n                } else {\n                  suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);\n                }\n                pushSuspenseContext(workInProgress2, suspenseContext);\n                return next;\n              }\n              bubbleProperties(workInProgress2);\n              return null;\n            }\n            case ScopeComponent: {\n              break;\n            }\n            case OffscreenComponent:\n            case LegacyHiddenComponent: {\n              popRenderLanes(workInProgress2);\n              var _nextState = workInProgress2.memoizedState;\n              var nextIsHidden = _nextState !== null;\n              if (current2 !== null) {\n                var _prevState = current2.memoizedState;\n                var prevIsHidden = _prevState !== null;\n                if (prevIsHidden !== nextIsHidden && // LegacyHidden doesn't do any hiding  it only pre-renders.\n                !enableLegacyHidden) {\n                  workInProgress2.flags |= Visibility;\n                }\n              }\n              if (!nextIsHidden || (workInProgress2.mode & ConcurrentMode) === NoMode) {\n                bubbleProperties(workInProgress2);\n              } else {\n                if (includesSomeLane(subtreeRenderLanes, OffscreenLane)) {\n                  bubbleProperties(workInProgress2);\n                  {\n                    if (workInProgress2.subtreeFlags & (Placement | Update)) {\n                      workInProgress2.flags |= Visibility;\n                    }\n                  }\n                }\n              }\n              return null;\n            }\n            case CacheComponent: {\n              return null;\n            }\n            case TracingMarkerComponent: {\n              return null;\n            }\n          }\n          throw new Error(\"Unknown unit of work tag (\" + workInProgress2.tag + \"). This error is likely caused by a bug in React. Please file an issue.\");\n        }\n        function unwindWork(current2, workInProgress2, renderLanes2) {\n          popTreeContext(workInProgress2);\n          switch (workInProgress2.tag) {\n            case ClassComponent: {\n              var Component = workInProgress2.type;\n              if (isContextProvider(Component)) {\n                popContext(workInProgress2);\n              }\n              var flags = workInProgress2.flags;\n              if (flags & ShouldCapture) {\n                workInProgress2.flags = flags & ~ShouldCapture | DidCapture;\n                if ((workInProgress2.mode & ProfileMode) !== NoMode) {\n                  transferActualDuration(workInProgress2);\n                }\n                return workInProgress2;\n              }\n              return null;\n            }\n            case HostRoot: {\n              var root2 = workInProgress2.stateNode;\n              popHostContainer(workInProgress2);\n              popTopLevelContextObject(workInProgress2);\n              resetWorkInProgressVersions();\n              var _flags = workInProgress2.flags;\n              if ((_flags & ShouldCapture) !== NoFlags && (_flags & DidCapture) === NoFlags) {\n                workInProgress2.flags = _flags & ~ShouldCapture | DidCapture;\n                return workInProgress2;\n              }\n              return null;\n            }\n            case HostComponent: {\n              popHostContext(workInProgress2);\n              return null;\n            }\n            case SuspenseComponent: {\n              popSuspenseContext(workInProgress2);\n              var suspenseState = workInProgress2.memoizedState;\n              if (suspenseState !== null && suspenseState.dehydrated !== null) {\n                if (workInProgress2.alternate === null) {\n                  throw new Error(\"Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue.\");\n                }\n                resetHydrationState();\n              }\n              var _flags2 = workInProgress2.flags;\n              if (_flags2 & ShouldCapture) {\n                workInProgress2.flags = _flags2 & ~ShouldCapture | DidCapture;\n                if ((workInProgress2.mode & ProfileMode) !== NoMode) {\n                  transferActualDuration(workInProgress2);\n                }\n                return workInProgress2;\n              }\n              return null;\n            }\n            case SuspenseListComponent: {\n              popSuspenseContext(workInProgress2);\n              return null;\n            }\n            case HostPortal:\n              popHostContainer(workInProgress2);\n              return null;\n            case ContextProvider:\n              var context = workInProgress2.type._context;\n              popProvider(context, workInProgress2);\n              return null;\n            case OffscreenComponent:\n            case LegacyHiddenComponent:\n              popRenderLanes(workInProgress2);\n              return null;\n            case CacheComponent:\n              return null;\n            default:\n              return null;\n          }\n        }\n        function unwindInterruptedWork(current2, interruptedWork, renderLanes2) {\n          popTreeContext(interruptedWork);\n          switch (interruptedWork.tag) {\n            case ClassComponent: {\n              var childContextTypes = interruptedWork.type.childContextTypes;\n              if (childContextTypes !== null && childContextTypes !== void 0) {\n                popContext(interruptedWork);\n              }\n              break;\n            }\n            case HostRoot: {\n              var root2 = interruptedWork.stateNode;\n              popHostContainer(interruptedWork);\n              popTopLevelContextObject(interruptedWork);\n              resetWorkInProgressVersions();\n              break;\n            }\n            case HostComponent: {\n              popHostContext(interruptedWork);\n              break;\n            }\n            case HostPortal:\n              popHostContainer(interruptedWork);\n              break;\n            case SuspenseComponent:\n              popSuspenseContext(interruptedWork);\n              break;\n            case SuspenseListComponent:\n              popSuspenseContext(interruptedWork);\n              break;\n            case ContextProvider:\n              var context = interruptedWork.type._context;\n              popProvider(context, interruptedWork);\n              break;\n            case OffscreenComponent:\n            case LegacyHiddenComponent:\n              popRenderLanes(interruptedWork);\n              break;\n          }\n        }\n        var didWarnAboutUndefinedSnapshotBeforeUpdate = null;\n        {\n          didWarnAboutUndefinedSnapshotBeforeUpdate = /* @__PURE__ */ new Set();\n        }\n        var offscreenSubtreeIsHidden = false;\n        var offscreenSubtreeWasHidden = false;\n        var PossiblyWeakSet = typeof WeakSet === \"function\" ? WeakSet : Set;\n        var nextEffect = null;\n        var inProgressLanes = null;\n        var inProgressRoot = null;\n        function reportUncaughtErrorInDEV(error2) {\n          {\n            invokeGuardedCallback(null, function() {\n              throw error2;\n            });\n            clearCaughtError();\n          }\n        }\n        var callComponentWillUnmountWithTimer = function(current2, instance) {\n          instance.props = current2.memoizedProps;\n          instance.state = current2.memoizedState;\n          if (current2.mode & ProfileMode) {\n            try {\n              startLayoutEffectTimer();\n              instance.componentWillUnmount();\n            } finally {\n              recordLayoutEffectDuration(current2);\n            }\n          } else {\n            instance.componentWillUnmount();\n          }\n        };\n        function safelyCallCommitHookLayoutEffectListMount(current2, nearestMountedAncestor) {\n          try {\n            commitHookEffectListMount(Layout, current2);\n          } catch (error2) {\n            captureCommitPhaseError(current2, nearestMountedAncestor, error2);\n          }\n        }\n        function safelyCallComponentWillUnmount(current2, nearestMountedAncestor, instance) {\n          try {\n            callComponentWillUnmountWithTimer(current2, instance);\n          } catch (error2) {\n            captureCommitPhaseError(current2, nearestMountedAncestor, error2);\n          }\n        }\n        function safelyCallComponentDidMount(current2, nearestMountedAncestor, instance) {\n          try {\n            instance.componentDidMount();\n          } catch (error2) {\n            captureCommitPhaseError(current2, nearestMountedAncestor, error2);\n          }\n        }\n        function safelyAttachRef(current2, nearestMountedAncestor) {\n          try {\n            commitAttachRef(current2);\n          } catch (error2) {\n            captureCommitPhaseError(current2, nearestMountedAncestor, error2);\n          }\n        }\n        function safelyDetachRef(current2, nearestMountedAncestor) {\n          var ref = current2.ref;\n          if (ref !== null) {\n            if (typeof ref === \"function\") {\n              var retVal;\n              try {\n                if (enableProfilerTimer && enableProfilerCommitHooks && current2.mode & ProfileMode) {\n                  try {\n                    startLayoutEffectTimer();\n                    retVal = ref(null);\n                  } finally {\n                    recordLayoutEffectDuration(current2);\n                  }\n                } else {\n                  retVal = ref(null);\n                }\n              } catch (error2) {\n                captureCommitPhaseError(current2, nearestMountedAncestor, error2);\n              }\n              {\n                if (typeof retVal === \"function\") {\n                  error(\"Unexpected return value from a callback ref in %s. A callback ref should not return a function.\", getComponentNameFromFiber(current2));\n                }\n              }\n            } else {\n              ref.current = null;\n            }\n          }\n        }\n        function safelyCallDestroy(current2, nearestMountedAncestor, destroy) {\n          try {\n            destroy();\n          } catch (error2) {\n            captureCommitPhaseError(current2, nearestMountedAncestor, error2);\n          }\n        }\n        var focusedInstanceHandle = null;\n        var shouldFireAfterActiveInstanceBlur = false;\n        function commitBeforeMutationEffects(root2, firstChild) {\n          focusedInstanceHandle = prepareForCommit(root2.containerInfo);\n          nextEffect = firstChild;\n          commitBeforeMutationEffects_begin();\n          var shouldFire = shouldFireAfterActiveInstanceBlur;\n          shouldFireAfterActiveInstanceBlur = false;\n          focusedInstanceHandle = null;\n          return shouldFire;\n        }\n        function commitBeforeMutationEffects_begin() {\n          while (nextEffect !== null) {\n            var fiber = nextEffect;\n            var child = fiber.child;\n            if ((fiber.subtreeFlags & BeforeMutationMask) !== NoFlags && child !== null) {\n              child.return = fiber;\n              nextEffect = child;\n            } else {\n              commitBeforeMutationEffects_complete();\n            }\n          }\n        }\n        function commitBeforeMutationEffects_complete() {\n          while (nextEffect !== null) {\n            var fiber = nextEffect;\n            setCurrentFiber(fiber);\n            try {\n              commitBeforeMutationEffectsOnFiber(fiber);\n            } catch (error2) {\n              captureCommitPhaseError(fiber, fiber.return, error2);\n            }\n            resetCurrentFiber();\n            var sibling = fiber.sibling;\n            if (sibling !== null) {\n              sibling.return = fiber.return;\n              nextEffect = sibling;\n              return;\n            }\n            nextEffect = fiber.return;\n          }\n        }\n        function commitBeforeMutationEffectsOnFiber(finishedWork) {\n          var current2 = finishedWork.alternate;\n          var flags = finishedWork.flags;\n          if ((flags & Snapshot) !== NoFlags) {\n            setCurrentFiber(finishedWork);\n            switch (finishedWork.tag) {\n              case FunctionComponent:\n              case ForwardRef:\n              case SimpleMemoComponent: {\n                break;\n              }\n              case ClassComponent: {\n                if (current2 !== null) {\n                  var prevProps = current2.memoizedProps;\n                  var prevState = current2.memoizedState;\n                  var instance = finishedWork.stateNode;\n                  {\n                    if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {\n                      if (instance.props !== finishedWork.memoizedProps) {\n                        error(\"Expected %s props to match memoized props before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.\", getComponentNameFromFiber(finishedWork) || \"instance\");\n                      }\n                      if (instance.state !== finishedWork.memoizedState) {\n                        error(\"Expected %s state to match memoized state before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.\", getComponentNameFromFiber(finishedWork) || \"instance\");\n                      }\n                    }\n                  }\n                  var snapshot = instance.getSnapshotBeforeUpdate(finishedWork.elementType === finishedWork.type ? prevProps : resolveDefaultProps(finishedWork.type, prevProps), prevState);\n                  {\n                    var didWarnSet = didWarnAboutUndefinedSnapshotBeforeUpdate;\n                    if (snapshot === void 0 && !didWarnSet.has(finishedWork.type)) {\n                      didWarnSet.add(finishedWork.type);\n                      error(\"%s.getSnapshotBeforeUpdate(): A snapshot value (or null) must be returned. You have returned undefined.\", getComponentNameFromFiber(finishedWork));\n                    }\n                  }\n                  instance.__reactInternalSnapshotBeforeUpdate = snapshot;\n                }\n                break;\n              }\n              case HostRoot: {\n                {\n                  var root2 = finishedWork.stateNode;\n                  clearContainer(root2.containerInfo);\n                }\n                break;\n              }\n              case HostComponent:\n              case HostText:\n              case HostPortal:\n              case IncompleteClassComponent:\n                break;\n              default: {\n                throw new Error(\"This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.\");\n              }\n            }\n            resetCurrentFiber();\n          }\n        }\n        function commitHookEffectListUnmount(flags, finishedWork, nearestMountedAncestor) {\n          var updateQueue = finishedWork.updateQueue;\n          var lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;\n          if (lastEffect !== null) {\n            var firstEffect = lastEffect.next;\n            var effect = firstEffect;\n            do {\n              if ((effect.tag & flags) === flags) {\n                var destroy = effect.destroy;\n                effect.destroy = void 0;\n                if (destroy !== void 0) {\n                  {\n                    if ((flags & Passive$1) !== NoFlags$1) {\n                      markComponentPassiveEffectUnmountStarted(finishedWork);\n                    } else if ((flags & Layout) !== NoFlags$1) {\n                      markComponentLayoutEffectUnmountStarted(finishedWork);\n                    }\n                  }\n                  {\n                    if ((flags & Insertion) !== NoFlags$1) {\n                      setIsRunningInsertionEffect(true);\n                    }\n                  }\n                  safelyCallDestroy(finishedWork, nearestMountedAncestor, destroy);\n                  {\n                    if ((flags & Insertion) !== NoFlags$1) {\n                      setIsRunningInsertionEffect(false);\n                    }\n                  }\n                  {\n                    if ((flags & Passive$1) !== NoFlags$1) {\n                      markComponentPassiveEffectUnmountStopped();\n                    } else if ((flags & Layout) !== NoFlags$1) {\n                      markComponentLayoutEffectUnmountStopped();\n                    }\n                  }\n                }\n              }\n              effect = effect.next;\n            } while (effect !== firstEffect);\n          }\n        }\n        function commitHookEffectListMount(flags, finishedWork) {\n          var updateQueue = finishedWork.updateQueue;\n          var lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;\n          if (lastEffect !== null) {\n            var firstEffect = lastEffect.next;\n            var effect = firstEffect;\n            do {\n              if ((effect.tag & flags) === flags) {\n                {\n                  if ((flags & Passive$1) !== NoFlags$1) {\n                    markComponentPassiveEffectMountStarted(finishedWork);\n                  } else if ((flags & Layout) !== NoFlags$1) {\n                    markComponentLayoutEffectMountStarted(finishedWork);\n                  }\n                }\n                var create = effect.create;\n                {\n                  if ((flags & Insertion) !== NoFlags$1) {\n                    setIsRunningInsertionEffect(true);\n                  }\n                }\n                effect.destroy = create();\n                {\n                  if ((flags & Insertion) !== NoFlags$1) {\n                    setIsRunningInsertionEffect(false);\n                  }\n                }\n                {\n                  if ((flags & Passive$1) !== NoFlags$1) {\n                    markComponentPassiveEffectMountStopped();\n                  } else if ((flags & Layout) !== NoFlags$1) {\n                    markComponentLayoutEffectMountStopped();\n                  }\n                }\n                {\n                  var destroy = effect.destroy;\n                  if (destroy !== void 0 && typeof destroy !== \"function\") {\n                    var hookName = void 0;\n                    if ((effect.tag & Layout) !== NoFlags) {\n                      hookName = \"useLayoutEffect\";\n                    } else if ((effect.tag & Insertion) !== NoFlags) {\n                      hookName = \"useInsertionEffect\";\n                    } else {\n                      hookName = \"useEffect\";\n                    }\n                    var addendum = void 0;\n                    if (destroy === null) {\n                      addendum = \" You returned null. If your effect does not require clean up, return undefined (or nothing).\";\n                    } else if (typeof destroy.then === \"function\") {\n                      addendum = \"\\n\\nIt looks like you wrote \" + hookName + \"(async () => ...) or returned a Promise. Instead, write the async function inside your effect and call it immediately:\\n\\n\" + hookName + \"(() => {\\n  async function fetchData() {\\n    // You can await here\\n    const response = await MyAPI.getData(someId);\\n    // ...\\n  }\\n  fetchData();\\n}, [someId]); // Or [] if effect doesn't need props or state\\n\\nLearn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching\";\n                    } else {\n                      addendum = \" You returned: \" + destroy;\n                    }\n                    error(\"%s must not return anything besides a function, which is used for clean-up.%s\", hookName, addendum);\n                  }\n                }\n              }\n              effect = effect.next;\n            } while (effect !== firstEffect);\n          }\n        }\n        function commitPassiveEffectDurations(finishedRoot, finishedWork) {\n          {\n            if ((finishedWork.flags & Update) !== NoFlags) {\n              switch (finishedWork.tag) {\n                case Profiler: {\n                  var passiveEffectDuration = finishedWork.stateNode.passiveEffectDuration;\n                  var _finishedWork$memoize = finishedWork.memoizedProps, id = _finishedWork$memoize.id, onPostCommit = _finishedWork$memoize.onPostCommit;\n                  var commitTime2 = getCommitTime();\n                  var phase = finishedWork.alternate === null ? \"mount\" : \"update\";\n                  {\n                    if (isCurrentUpdateNested()) {\n                      phase = \"nested-update\";\n                    }\n                  }\n                  if (typeof onPostCommit === \"function\") {\n                    onPostCommit(id, phase, passiveEffectDuration, commitTime2);\n                  }\n                  var parentFiber = finishedWork.return;\n                  outer:\n                    while (parentFiber !== null) {\n                      switch (parentFiber.tag) {\n                        case HostRoot:\n                          var root2 = parentFiber.stateNode;\n                          root2.passiveEffectDuration += passiveEffectDuration;\n                          break outer;\n                        case Profiler:\n                          var parentStateNode = parentFiber.stateNode;\n                          parentStateNode.passiveEffectDuration += passiveEffectDuration;\n                          break outer;\n                      }\n                      parentFiber = parentFiber.return;\n                    }\n                  break;\n                }\n              }\n            }\n          }\n        }\n        function commitLayoutEffectOnFiber(finishedRoot, current2, finishedWork, committedLanes) {\n          if ((finishedWork.flags & LayoutMask) !== NoFlags) {\n            switch (finishedWork.tag) {\n              case FunctionComponent:\n              case ForwardRef:\n              case SimpleMemoComponent: {\n                if (!offscreenSubtreeWasHidden) {\n                  if (finishedWork.mode & ProfileMode) {\n                    try {\n                      startLayoutEffectTimer();\n                      commitHookEffectListMount(Layout | HasEffect, finishedWork);\n                    } finally {\n                      recordLayoutEffectDuration(finishedWork);\n                    }\n                  } else {\n                    commitHookEffectListMount(Layout | HasEffect, finishedWork);\n                  }\n                }\n                break;\n              }\n              case ClassComponent: {\n                var instance = finishedWork.stateNode;\n                if (finishedWork.flags & Update) {\n                  if (!offscreenSubtreeWasHidden) {\n                    if (current2 === null) {\n                      {\n                        if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {\n                          if (instance.props !== finishedWork.memoizedProps) {\n                            error(\"Expected %s props to match memoized props before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.\", getComponentNameFromFiber(finishedWork) || \"instance\");\n                          }\n                          if (instance.state !== finishedWork.memoizedState) {\n                            error(\"Expected %s state to match memoized state before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.\", getComponentNameFromFiber(finishedWork) || \"instance\");\n                          }\n                        }\n                      }\n                      if (finishedWork.mode & ProfileMode) {\n                        try {\n                          startLayoutEffectTimer();\n                          instance.componentDidMount();\n                        } finally {\n                          recordLayoutEffectDuration(finishedWork);\n                        }\n                      } else {\n                        instance.componentDidMount();\n                      }\n                    } else {\n                      var prevProps = finishedWork.elementType === finishedWork.type ? current2.memoizedProps : resolveDefaultProps(finishedWork.type, current2.memoizedProps);\n                      var prevState = current2.memoizedState;\n                      {\n                        if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {\n                          if (instance.props !== finishedWork.memoizedProps) {\n                            error(\"Expected %s props to match memoized props before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.\", getComponentNameFromFiber(finishedWork) || \"instance\");\n                          }\n                          if (instance.state !== finishedWork.memoizedState) {\n                            error(\"Expected %s state to match memoized state before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.\", getComponentNameFromFiber(finishedWork) || \"instance\");\n                          }\n                        }\n                      }\n                      if (finishedWork.mode & ProfileMode) {\n                        try {\n                          startLayoutEffectTimer();\n                          instance.componentDidUpdate(prevProps, prevState, instance.__reactInternalSnapshotBeforeUpdate);\n                        } finally {\n                          recordLayoutEffectDuration(finishedWork);\n                        }\n                      } else {\n                        instance.componentDidUpdate(prevProps, prevState, instance.__reactInternalSnapshotBeforeUpdate);\n                      }\n                    }\n                  }\n                }\n                var updateQueue = finishedWork.updateQueue;\n                if (updateQueue !== null) {\n                  {\n                    if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {\n                      if (instance.props !== finishedWork.memoizedProps) {\n                        error(\"Expected %s props to match memoized props before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.\", getComponentNameFromFiber(finishedWork) || \"instance\");\n                      }\n                      if (instance.state !== finishedWork.memoizedState) {\n                        error(\"Expected %s state to match memoized state before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.\", getComponentNameFromFiber(finishedWork) || \"instance\");\n                      }\n                    }\n                  }\n                  commitUpdateQueue(finishedWork, updateQueue, instance);\n                }\n                break;\n              }\n              case HostRoot: {\n                var _updateQueue = finishedWork.updateQueue;\n                if (_updateQueue !== null) {\n                  var _instance = null;\n                  if (finishedWork.child !== null) {\n                    switch (finishedWork.child.tag) {\n                      case HostComponent:\n                        _instance = getPublicInstance(finishedWork.child.stateNode);\n                        break;\n                      case ClassComponent:\n                        _instance = finishedWork.child.stateNode;\n                        break;\n                    }\n                  }\n                  commitUpdateQueue(finishedWork, _updateQueue, _instance);\n                }\n                break;\n              }\n              case HostComponent: {\n                var _instance2 = finishedWork.stateNode;\n                if (current2 === null && finishedWork.flags & Update) {\n                  var type = finishedWork.type;\n                  var props = finishedWork.memoizedProps;\n                  commitMount(_instance2, type, props);\n                }\n                break;\n              }\n              case HostText: {\n                break;\n              }\n              case HostPortal: {\n                break;\n              }\n              case Profiler: {\n                {\n                  var _finishedWork$memoize2 = finishedWork.memoizedProps, onCommit = _finishedWork$memoize2.onCommit, onRender = _finishedWork$memoize2.onRender;\n                  var effectDuration = finishedWork.stateNode.effectDuration;\n                  var commitTime2 = getCommitTime();\n                  var phase = current2 === null ? \"mount\" : \"update\";\n                  {\n                    if (isCurrentUpdateNested()) {\n                      phase = \"nested-update\";\n                    }\n                  }\n                  if (typeof onRender === \"function\") {\n                    onRender(finishedWork.memoizedProps.id, phase, finishedWork.actualDuration, finishedWork.treeBaseDuration, finishedWork.actualStartTime, commitTime2);\n                  }\n                  {\n                    if (typeof onCommit === \"function\") {\n                      onCommit(finishedWork.memoizedProps.id, phase, effectDuration, commitTime2);\n                    }\n                    enqueuePendingPassiveProfilerEffect(finishedWork);\n                    var parentFiber = finishedWork.return;\n                    outer:\n                      while (parentFiber !== null) {\n                        switch (parentFiber.tag) {\n                          case HostRoot:\n                            var root2 = parentFiber.stateNode;\n                            root2.effectDuration += effectDuration;\n                            break outer;\n                          case Profiler:\n                            var parentStateNode = parentFiber.stateNode;\n                            parentStateNode.effectDuration += effectDuration;\n                            break outer;\n                        }\n                        parentFiber = parentFiber.return;\n                      }\n                  }\n                }\n                break;\n              }\n              case SuspenseComponent: {\n                commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);\n                break;\n              }\n              case SuspenseListComponent:\n              case IncompleteClassComponent:\n              case ScopeComponent:\n              case OffscreenComponent:\n              case LegacyHiddenComponent:\n              case TracingMarkerComponent: {\n                break;\n              }\n              default:\n                throw new Error(\"This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.\");\n            }\n          }\n          if (!offscreenSubtreeWasHidden) {\n            {\n              if (finishedWork.flags & Ref) {\n                commitAttachRef(finishedWork);\n              }\n            }\n          }\n        }\n        function reappearLayoutEffectsOnFiber(node) {\n          switch (node.tag) {\n            case FunctionComponent:\n            case ForwardRef:\n            case SimpleMemoComponent: {\n              if (node.mode & ProfileMode) {\n                try {\n                  startLayoutEffectTimer();\n                  safelyCallCommitHookLayoutEffectListMount(node, node.return);\n                } finally {\n                  recordLayoutEffectDuration(node);\n                }\n              } else {\n                safelyCallCommitHookLayoutEffectListMount(node, node.return);\n              }\n              break;\n            }\n            case ClassComponent: {\n              var instance = node.stateNode;\n              if (typeof instance.componentDidMount === \"function\") {\n                safelyCallComponentDidMount(node, node.return, instance);\n              }\n              safelyAttachRef(node, node.return);\n              break;\n            }\n            case HostComponent: {\n              safelyAttachRef(node, node.return);\n              break;\n            }\n          }\n        }\n        function hideOrUnhideAllChildren(finishedWork, isHidden) {\n          var hostSubtreeRoot = null;\n          {\n            var node = finishedWork;\n            while (true) {\n              if (node.tag === HostComponent) {\n                if (hostSubtreeRoot === null) {\n                  hostSubtreeRoot = node;\n                  try {\n                    var instance = node.stateNode;\n                    if (isHidden) {\n                      hideInstance(instance);\n                    } else {\n                      unhideInstance(node.stateNode, node.memoizedProps);\n                    }\n                  } catch (error2) {\n                    captureCommitPhaseError(finishedWork, finishedWork.return, error2);\n                  }\n                }\n              } else if (node.tag === HostText) {\n                if (hostSubtreeRoot === null) {\n                  try {\n                    var _instance3 = node.stateNode;\n                    if (isHidden) {\n                      hideTextInstance(_instance3);\n                    } else {\n                      unhideTextInstance(_instance3, node.memoizedProps);\n                    }\n                  } catch (error2) {\n                    captureCommitPhaseError(finishedWork, finishedWork.return, error2);\n                  }\n                }\n              } else if ((node.tag === OffscreenComponent || node.tag === LegacyHiddenComponent) && node.memoizedState !== null && node !== finishedWork)\n                ;\n              else if (node.child !== null) {\n                node.child.return = node;\n                node = node.child;\n                continue;\n              }\n              if (node === finishedWork) {\n                return;\n              }\n              while (node.sibling === null) {\n                if (node.return === null || node.return === finishedWork) {\n                  return;\n                }\n                if (hostSubtreeRoot === node) {\n                  hostSubtreeRoot = null;\n                }\n                node = node.return;\n              }\n              if (hostSubtreeRoot === node) {\n                hostSubtreeRoot = null;\n              }\n              node.sibling.return = node.return;\n              node = node.sibling;\n            }\n          }\n        }\n        function commitAttachRef(finishedWork) {\n          var ref = finishedWork.ref;\n          if (ref !== null) {\n            var instance = finishedWork.stateNode;\n            var instanceToUse;\n            switch (finishedWork.tag) {\n              case HostComponent:\n                instanceToUse = getPublicInstance(instance);\n                break;\n              default:\n                instanceToUse = instance;\n            }\n            if (typeof ref === \"function\") {\n              var retVal;\n              if (finishedWork.mode & ProfileMode) {\n                try {\n                  startLayoutEffectTimer();\n                  retVal = ref(instanceToUse);\n                } finally {\n                  recordLayoutEffectDuration(finishedWork);\n                }\n              } else {\n                retVal = ref(instanceToUse);\n              }\n              {\n                if (typeof retVal === \"function\") {\n                  error(\"Unexpected return value from a callback ref in %s. A callback ref should not return a function.\", getComponentNameFromFiber(finishedWork));\n                }\n              }\n            } else {\n              {\n                if (!ref.hasOwnProperty(\"current\")) {\n                  error(\"Unexpected ref object provided for %s. Use either a ref-setter function or React.createRef().\", getComponentNameFromFiber(finishedWork));\n                }\n              }\n              ref.current = instanceToUse;\n            }\n          }\n        }\n        function detachFiberMutation(fiber) {\n          var alternate = fiber.alternate;\n          if (alternate !== null) {\n            alternate.return = null;\n          }\n          fiber.return = null;\n        }\n        function detachFiberAfterEffects(fiber) {\n          var alternate = fiber.alternate;\n          if (alternate !== null) {\n            fiber.alternate = null;\n            detachFiberAfterEffects(alternate);\n          }\n          {\n            fiber.child = null;\n            fiber.deletions = null;\n            fiber.sibling = null;\n            if (fiber.tag === HostComponent) {\n              var hostInstance = fiber.stateNode;\n              if (hostInstance !== null) {\n                detachDeletedInstance(hostInstance);\n              }\n            }\n            fiber.stateNode = null;\n            {\n              fiber._debugOwner = null;\n            }\n            {\n              fiber.return = null;\n              fiber.dependencies = null;\n              fiber.memoizedProps = null;\n              fiber.memoizedState = null;\n              fiber.pendingProps = null;\n              fiber.stateNode = null;\n              fiber.updateQueue = null;\n            }\n          }\n        }\n        function getHostParentFiber(fiber) {\n          var parent = fiber.return;\n          while (parent !== null) {\n            if (isHostParent(parent)) {\n              return parent;\n            }\n            parent = parent.return;\n          }\n          throw new Error(\"Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.\");\n        }\n        function isHostParent(fiber) {\n          return fiber.tag === HostComponent || fiber.tag === HostRoot || fiber.tag === HostPortal;\n        }\n        function getHostSibling(fiber) {\n          var node = fiber;\n          siblings:\n            while (true) {\n              while (node.sibling === null) {\n                if (node.return === null || isHostParent(node.return)) {\n                  return null;\n                }\n                node = node.return;\n              }\n              node.sibling.return = node.return;\n              node = node.sibling;\n              while (node.tag !== HostComponent && node.tag !== HostText && node.tag !== DehydratedFragment) {\n                if (node.flags & Placement) {\n                  continue siblings;\n                }\n                if (node.child === null || node.tag === HostPortal) {\n                  continue siblings;\n                } else {\n                  node.child.return = node;\n                  node = node.child;\n                }\n              }\n              if (!(node.flags & Placement)) {\n                return node.stateNode;\n              }\n            }\n        }\n        function commitPlacement(finishedWork) {\n          var parentFiber = getHostParentFiber(finishedWork);\n          switch (parentFiber.tag) {\n            case HostComponent: {\n              var parent = parentFiber.stateNode;\n              if (parentFiber.flags & ContentReset) {\n                resetTextContent(parent);\n                parentFiber.flags &= ~ContentReset;\n              }\n              var before = getHostSibling(finishedWork);\n              insertOrAppendPlacementNode(finishedWork, before, parent);\n              break;\n            }\n            case HostRoot:\n            case HostPortal: {\n              var _parent = parentFiber.stateNode.containerInfo;\n              var _before = getHostSibling(finishedWork);\n              insertOrAppendPlacementNodeIntoContainer(finishedWork, _before, _parent);\n              break;\n            }\n            default:\n              throw new Error(\"Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.\");\n          }\n        }\n        function insertOrAppendPlacementNodeIntoContainer(node, before, parent) {\n          var tag = node.tag;\n          var isHost = tag === HostComponent || tag === HostText;\n          if (isHost) {\n            var stateNode = node.stateNode;\n            if (before) {\n              insertInContainerBefore(parent, stateNode, before);\n            } else {\n              appendChildToContainer(parent, stateNode);\n            }\n          } else if (tag === HostPortal)\n            ;\n          else {\n            var child = node.child;\n            if (child !== null) {\n              insertOrAppendPlacementNodeIntoContainer(child, before, parent);\n              var sibling = child.sibling;\n              while (sibling !== null) {\n                insertOrAppendPlacementNodeIntoContainer(sibling, before, parent);\n                sibling = sibling.sibling;\n              }\n            }\n          }\n        }\n        function insertOrAppendPlacementNode(node, before, parent) {\n          var tag = node.tag;\n          var isHost = tag === HostComponent || tag === HostText;\n          if (isHost) {\n            var stateNode = node.stateNode;\n            if (before) {\n              insertBefore(parent, stateNode, before);\n            } else {\n              appendChild(parent, stateNode);\n            }\n          } else if (tag === HostPortal)\n            ;\n          else {\n            var child = node.child;\n            if (child !== null) {\n              insertOrAppendPlacementNode(child, before, parent);\n              var sibling = child.sibling;\n              while (sibling !== null) {\n                insertOrAppendPlacementNode(sibling, before, parent);\n                sibling = sibling.sibling;\n              }\n            }\n          }\n        }\n        var hostParent = null;\n        var hostParentIsContainer = false;\n        function commitDeletionEffects(root2, returnFiber, deletedFiber) {\n          {\n            var parent = returnFiber;\n            findParent:\n              while (parent !== null) {\n                switch (parent.tag) {\n                  case HostComponent: {\n                    hostParent = parent.stateNode;\n                    hostParentIsContainer = false;\n                    break findParent;\n                  }\n                  case HostRoot: {\n                    hostParent = parent.stateNode.containerInfo;\n                    hostParentIsContainer = true;\n                    break findParent;\n                  }\n                  case HostPortal: {\n                    hostParent = parent.stateNode.containerInfo;\n                    hostParentIsContainer = true;\n                    break findParent;\n                  }\n                }\n                parent = parent.return;\n              }\n            if (hostParent === null) {\n              throw new Error(\"Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.\");\n            }\n            commitDeletionEffectsOnFiber(root2, returnFiber, deletedFiber);\n            hostParent = null;\n            hostParentIsContainer = false;\n          }\n          detachFiberMutation(deletedFiber);\n        }\n        function recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, parent) {\n          var child = parent.child;\n          while (child !== null) {\n            commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, child);\n            child = child.sibling;\n          }\n        }\n        function commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, deletedFiber) {\n          onCommitUnmount(deletedFiber);\n          switch (deletedFiber.tag) {\n            case HostComponent: {\n              if (!offscreenSubtreeWasHidden) {\n                safelyDetachRef(deletedFiber, nearestMountedAncestor);\n              }\n            }\n            case HostText: {\n              {\n                var prevHostParent = hostParent;\n                var prevHostParentIsContainer = hostParentIsContainer;\n                hostParent = null;\n                recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n                hostParent = prevHostParent;\n                hostParentIsContainer = prevHostParentIsContainer;\n                if (hostParent !== null) {\n                  if (hostParentIsContainer) {\n                    removeChildFromContainer(hostParent, deletedFiber.stateNode);\n                  } else {\n                    removeChild(hostParent, deletedFiber.stateNode);\n                  }\n                }\n              }\n              return;\n            }\n            case DehydratedFragment: {\n              {\n                if (hostParent !== null) {\n                  if (hostParentIsContainer) {\n                    clearSuspenseBoundaryFromContainer(hostParent, deletedFiber.stateNode);\n                  } else {\n                    clearSuspenseBoundary(hostParent, deletedFiber.stateNode);\n                  }\n                }\n              }\n              return;\n            }\n            case HostPortal: {\n              {\n                var _prevHostParent = hostParent;\n                var _prevHostParentIsContainer = hostParentIsContainer;\n                hostParent = deletedFiber.stateNode.containerInfo;\n                hostParentIsContainer = true;\n                recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n                hostParent = _prevHostParent;\n                hostParentIsContainer = _prevHostParentIsContainer;\n              }\n              return;\n            }\n            case FunctionComponent:\n            case ForwardRef:\n            case MemoComponent:\n            case SimpleMemoComponent: {\n              if (!offscreenSubtreeWasHidden) {\n                var updateQueue = deletedFiber.updateQueue;\n                if (updateQueue !== null) {\n                  var lastEffect = updateQueue.lastEffect;\n                  if (lastEffect !== null) {\n                    var firstEffect = lastEffect.next;\n                    var effect = firstEffect;\n                    do {\n                      var _effect = effect, destroy = _effect.destroy, tag = _effect.tag;\n                      if (destroy !== void 0) {\n                        if ((tag & Insertion) !== NoFlags$1) {\n                          safelyCallDestroy(deletedFiber, nearestMountedAncestor, destroy);\n                        } else if ((tag & Layout) !== NoFlags$1) {\n                          {\n                            markComponentLayoutEffectUnmountStarted(deletedFiber);\n                          }\n                          if (deletedFiber.mode & ProfileMode) {\n                            startLayoutEffectTimer();\n                            safelyCallDestroy(deletedFiber, nearestMountedAncestor, destroy);\n                            recordLayoutEffectDuration(deletedFiber);\n                          } else {\n                            safelyCallDestroy(deletedFiber, nearestMountedAncestor, destroy);\n                          }\n                          {\n                            markComponentLayoutEffectUnmountStopped();\n                          }\n                        }\n                      }\n                      effect = effect.next;\n                    } while (effect !== firstEffect);\n                  }\n                }\n              }\n              recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n              return;\n            }\n            case ClassComponent: {\n              if (!offscreenSubtreeWasHidden) {\n                safelyDetachRef(deletedFiber, nearestMountedAncestor);\n                var instance = deletedFiber.stateNode;\n                if (typeof instance.componentWillUnmount === \"function\") {\n                  safelyCallComponentWillUnmount(deletedFiber, nearestMountedAncestor, instance);\n                }\n              }\n              recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n              return;\n            }\n            case ScopeComponent: {\n              recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n              return;\n            }\n            case OffscreenComponent: {\n              if (\n                // TODO: Remove this dead flag\n                deletedFiber.mode & ConcurrentMode\n              ) {\n                var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;\n                offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || deletedFiber.memoizedState !== null;\n                recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n                offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;\n              } else {\n                recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n              }\n              break;\n            }\n            default: {\n              recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n              return;\n            }\n          }\n        }\n        function commitSuspenseCallback(finishedWork) {\n          var newState = finishedWork.memoizedState;\n        }\n        function commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {\n          var newState = finishedWork.memoizedState;\n          if (newState === null) {\n            var current2 = finishedWork.alternate;\n            if (current2 !== null) {\n              var prevState = current2.memoizedState;\n              if (prevState !== null) {\n                var suspenseInstance = prevState.dehydrated;\n                if (suspenseInstance !== null) {\n                  commitHydratedSuspenseInstance(suspenseInstance);\n                }\n              }\n            }\n          }\n        }\n        function attachSuspenseRetryListeners(finishedWork) {\n          var wakeables = finishedWork.updateQueue;\n          if (wakeables !== null) {\n            finishedWork.updateQueue = null;\n            var retryCache = finishedWork.stateNode;\n            if (retryCache === null) {\n              retryCache = finishedWork.stateNode = new PossiblyWeakSet();\n            }\n            wakeables.forEach(function(wakeable) {\n              var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);\n              if (!retryCache.has(wakeable)) {\n                retryCache.add(wakeable);\n                {\n                  if (isDevToolsPresent) {\n                    if (inProgressLanes !== null && inProgressRoot !== null) {\n                      restorePendingUpdaters(inProgressRoot, inProgressLanes);\n                    } else {\n                      throw Error(\"Expected finished root and lanes to be set. This is a bug in React.\");\n                    }\n                  }\n                }\n                wakeable.then(retry, retry);\n              }\n            });\n          }\n        }\n        function commitMutationEffects(root2, finishedWork, committedLanes) {\n          inProgressLanes = committedLanes;\n          inProgressRoot = root2;\n          setCurrentFiber(finishedWork);\n          commitMutationEffectsOnFiber(finishedWork, root2);\n          setCurrentFiber(finishedWork);\n          inProgressLanes = null;\n          inProgressRoot = null;\n        }\n        function recursivelyTraverseMutationEffects(root2, parentFiber, lanes) {\n          var deletions = parentFiber.deletions;\n          if (deletions !== null) {\n            for (var i = 0; i < deletions.length; i++) {\n              var childToDelete = deletions[i];\n              try {\n                commitDeletionEffects(root2, parentFiber, childToDelete);\n              } catch (error2) {\n                captureCommitPhaseError(childToDelete, parentFiber, error2);\n              }\n            }\n          }\n          var prevDebugFiber = getCurrentFiber();\n          if (parentFiber.subtreeFlags & MutationMask) {\n            var child = parentFiber.child;\n            while (child !== null) {\n              setCurrentFiber(child);\n              commitMutationEffectsOnFiber(child, root2);\n              child = child.sibling;\n            }\n          }\n          setCurrentFiber(prevDebugFiber);\n        }\n        function commitMutationEffectsOnFiber(finishedWork, root2, lanes) {\n          var current2 = finishedWork.alternate;\n          var flags = finishedWork.flags;\n          switch (finishedWork.tag) {\n            case FunctionComponent:\n            case ForwardRef:\n            case MemoComponent:\n            case SimpleMemoComponent: {\n              recursivelyTraverseMutationEffects(root2, finishedWork);\n              commitReconciliationEffects(finishedWork);\n              if (flags & Update) {\n                try {\n                  commitHookEffectListUnmount(Insertion | HasEffect, finishedWork, finishedWork.return);\n                  commitHookEffectListMount(Insertion | HasEffect, finishedWork);\n                } catch (error2) {\n                  captureCommitPhaseError(finishedWork, finishedWork.return, error2);\n                }\n                if (finishedWork.mode & ProfileMode) {\n                  try {\n                    startLayoutEffectTimer();\n                    commitHookEffectListUnmount(Layout | HasEffect, finishedWork, finishedWork.return);\n                  } catch (error2) {\n                    captureCommitPhaseError(finishedWork, finishedWork.return, error2);\n                  }\n                  recordLayoutEffectDuration(finishedWork);\n                } else {\n                  try {\n                    commitHookEffectListUnmount(Layout | HasEffect, finishedWork, finishedWork.return);\n                  } catch (error2) {\n                    captureCommitPhaseError(finishedWork, finishedWork.return, error2);\n                  }\n                }\n              }\n              return;\n            }\n            case ClassComponent: {\n              recursivelyTraverseMutationEffects(root2, finishedWork);\n              commitReconciliationEffects(finishedWork);\n              if (flags & Ref) {\n                if (current2 !== null) {\n                  safelyDetachRef(current2, current2.return);\n                }\n              }\n              return;\n            }\n            case HostComponent: {\n              recursivelyTraverseMutationEffects(root2, finishedWork);\n              commitReconciliationEffects(finishedWork);\n              if (flags & Ref) {\n                if (current2 !== null) {\n                  safelyDetachRef(current2, current2.return);\n                }\n              }\n              {\n                if (finishedWork.flags & ContentReset) {\n                  var instance = finishedWork.stateNode;\n                  try {\n                    resetTextContent(instance);\n                  } catch (error2) {\n                    captureCommitPhaseError(finishedWork, finishedWork.return, error2);\n                  }\n                }\n                if (flags & Update) {\n                  var _instance4 = finishedWork.stateNode;\n                  if (_instance4 != null) {\n                    var newProps = finishedWork.memoizedProps;\n                    var oldProps = current2 !== null ? current2.memoizedProps : newProps;\n                    var type = finishedWork.type;\n                    var updatePayload = finishedWork.updateQueue;\n                    finishedWork.updateQueue = null;\n                    if (updatePayload !== null) {\n                      try {\n                        commitUpdate(_instance4, updatePayload, type, oldProps, newProps, finishedWork);\n                      } catch (error2) {\n                        captureCommitPhaseError(finishedWork, finishedWork.return, error2);\n                      }\n                    }\n                  }\n                }\n              }\n              return;\n            }\n            case HostText: {\n              recursivelyTraverseMutationEffects(root2, finishedWork);\n              commitReconciliationEffects(finishedWork);\n              if (flags & Update) {\n                {\n                  if (finishedWork.stateNode === null) {\n                    throw new Error(\"This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.\");\n                  }\n                  var textInstance = finishedWork.stateNode;\n                  var newText = finishedWork.memoizedProps;\n                  var oldText = current2 !== null ? current2.memoizedProps : newText;\n                  try {\n                    commitTextUpdate(textInstance, oldText, newText);\n                  } catch (error2) {\n                    captureCommitPhaseError(finishedWork, finishedWork.return, error2);\n                  }\n                }\n              }\n              return;\n            }\n            case HostRoot: {\n              recursivelyTraverseMutationEffects(root2, finishedWork);\n              commitReconciliationEffects(finishedWork);\n              if (flags & Update) {\n                {\n                  if (current2 !== null) {\n                    var prevRootState = current2.memoizedState;\n                    if (prevRootState.isDehydrated) {\n                      try {\n                        commitHydratedContainer(root2.containerInfo);\n                      } catch (error2) {\n                        captureCommitPhaseError(finishedWork, finishedWork.return, error2);\n                      }\n                    }\n                  }\n                }\n              }\n              return;\n            }\n            case HostPortal: {\n              recursivelyTraverseMutationEffects(root2, finishedWork);\n              commitReconciliationEffects(finishedWork);\n              return;\n            }\n            case SuspenseComponent: {\n              recursivelyTraverseMutationEffects(root2, finishedWork);\n              commitReconciliationEffects(finishedWork);\n              var offscreenFiber = finishedWork.child;\n              if (offscreenFiber.flags & Visibility) {\n                var offscreenInstance = offscreenFiber.stateNode;\n                var newState = offscreenFiber.memoizedState;\n                var isHidden = newState !== null;\n                offscreenInstance.isHidden = isHidden;\n                if (isHidden) {\n                  var wasHidden = offscreenFiber.alternate !== null && offscreenFiber.alternate.memoizedState !== null;\n                  if (!wasHidden) {\n                    markCommitTimeOfFallback();\n                  }\n                }\n              }\n              if (flags & Update) {\n                try {\n                  commitSuspenseCallback(finishedWork);\n                } catch (error2) {\n                  captureCommitPhaseError(finishedWork, finishedWork.return, error2);\n                }\n                attachSuspenseRetryListeners(finishedWork);\n              }\n              return;\n            }\n            case OffscreenComponent: {\n              var _wasHidden = current2 !== null && current2.memoizedState !== null;\n              if (\n                // TODO: Remove this dead flag\n                finishedWork.mode & ConcurrentMode\n              ) {\n                var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;\n                offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || _wasHidden;\n                recursivelyTraverseMutationEffects(root2, finishedWork);\n                offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;\n              } else {\n                recursivelyTraverseMutationEffects(root2, finishedWork);\n              }\n              commitReconciliationEffects(finishedWork);\n              if (flags & Visibility) {\n                var _offscreenInstance = finishedWork.stateNode;\n                var _newState = finishedWork.memoizedState;\n                var _isHidden = _newState !== null;\n                var offscreenBoundary = finishedWork;\n                _offscreenInstance.isHidden = _isHidden;\n                {\n                  if (_isHidden) {\n                    if (!_wasHidden) {\n                      if ((offscreenBoundary.mode & ConcurrentMode) !== NoMode) {\n                        nextEffect = offscreenBoundary;\n                        var offscreenChild = offscreenBoundary.child;\n                        while (offscreenChild !== null) {\n                          nextEffect = offscreenChild;\n                          disappearLayoutEffects_begin(offscreenChild);\n                          offscreenChild = offscreenChild.sibling;\n                        }\n                      }\n                    }\n                  }\n                }\n                {\n                  hideOrUnhideAllChildren(offscreenBoundary, _isHidden);\n                }\n              }\n              return;\n            }\n            case SuspenseListComponent: {\n              recursivelyTraverseMutationEffects(root2, finishedWork);\n              commitReconciliationEffects(finishedWork);\n              if (flags & Update) {\n                attachSuspenseRetryListeners(finishedWork);\n              }\n              return;\n            }\n            case ScopeComponent: {\n              return;\n            }\n            default: {\n              recursivelyTraverseMutationEffects(root2, finishedWork);\n              commitReconciliationEffects(finishedWork);\n              return;\n            }\n          }\n        }\n        function commitReconciliationEffects(finishedWork) {\n          var flags = finishedWork.flags;\n          if (flags & Placement) {\n            try {\n              commitPlacement(finishedWork);\n            } catch (error2) {\n              captureCommitPhaseError(finishedWork, finishedWork.return, error2);\n            }\n            finishedWork.flags &= ~Placement;\n          }\n          if (flags & Hydrating) {\n            finishedWork.flags &= ~Hydrating;\n          }\n        }\n        function commitLayoutEffects(finishedWork, root2, committedLanes) {\n          inProgressLanes = committedLanes;\n          inProgressRoot = root2;\n          nextEffect = finishedWork;\n          commitLayoutEffects_begin(finishedWork, root2, committedLanes);\n          inProgressLanes = null;\n          inProgressRoot = null;\n        }\n        function commitLayoutEffects_begin(subtreeRoot, root2, committedLanes) {\n          var isModernRoot = (subtreeRoot.mode & ConcurrentMode) !== NoMode;\n          while (nextEffect !== null) {\n            var fiber = nextEffect;\n            var firstChild = fiber.child;\n            if (fiber.tag === OffscreenComponent && isModernRoot) {\n              var isHidden = fiber.memoizedState !== null;\n              var newOffscreenSubtreeIsHidden = isHidden || offscreenSubtreeIsHidden;\n              if (newOffscreenSubtreeIsHidden) {\n                commitLayoutMountEffects_complete(subtreeRoot, root2, committedLanes);\n                continue;\n              } else {\n                var current2 = fiber.alternate;\n                var wasHidden = current2 !== null && current2.memoizedState !== null;\n                var newOffscreenSubtreeWasHidden = wasHidden || offscreenSubtreeWasHidden;\n                var prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden;\n                var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;\n                offscreenSubtreeIsHidden = newOffscreenSubtreeIsHidden;\n                offscreenSubtreeWasHidden = newOffscreenSubtreeWasHidden;\n                if (offscreenSubtreeWasHidden && !prevOffscreenSubtreeWasHidden) {\n                  nextEffect = fiber;\n                  reappearLayoutEffects_begin(fiber);\n                }\n                var child = firstChild;\n                while (child !== null) {\n                  nextEffect = child;\n                  commitLayoutEffects_begin(\n                    child,\n                    // New root; bubble back up to here and stop.\n                    root2,\n                    committedLanes\n                  );\n                  child = child.sibling;\n                }\n                nextEffect = fiber;\n                offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;\n                offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;\n                commitLayoutMountEffects_complete(subtreeRoot, root2, committedLanes);\n                continue;\n              }\n            }\n            if ((fiber.subtreeFlags & LayoutMask) !== NoFlags && firstChild !== null) {\n              firstChild.return = fiber;\n              nextEffect = firstChild;\n            } else {\n              commitLayoutMountEffects_complete(subtreeRoot, root2, committedLanes);\n            }\n          }\n        }\n        function commitLayoutMountEffects_complete(subtreeRoot, root2, committedLanes) {\n          while (nextEffect !== null) {\n            var fiber = nextEffect;\n            if ((fiber.flags & LayoutMask) !== NoFlags) {\n              var current2 = fiber.alternate;\n              setCurrentFiber(fiber);\n              try {\n                commitLayoutEffectOnFiber(root2, current2, fiber, committedLanes);\n              } catch (error2) {\n                captureCommitPhaseError(fiber, fiber.return, error2);\n              }\n              resetCurrentFiber();\n            }\n            if (fiber === subtreeRoot) {\n              nextEffect = null;\n              return;\n            }\n            var sibling = fiber.sibling;\n            if (sibling !== null) {\n              sibling.return = fiber.return;\n              nextEffect = sibling;\n              return;\n            }\n            nextEffect = fiber.return;\n          }\n        }\n        function disappearLayoutEffects_begin(subtreeRoot) {\n          while (nextEffect !== null) {\n            var fiber = nextEffect;\n            var firstChild = fiber.child;\n            switch (fiber.tag) {\n              case FunctionComponent:\n              case ForwardRef:\n              case MemoComponent:\n              case SimpleMemoComponent: {\n                if (fiber.mode & ProfileMode) {\n                  try {\n                    startLayoutEffectTimer();\n                    commitHookEffectListUnmount(Layout, fiber, fiber.return);\n                  } finally {\n                    recordLayoutEffectDuration(fiber);\n                  }\n                } else {\n                  commitHookEffectListUnmount(Layout, fiber, fiber.return);\n                }\n                break;\n              }\n              case ClassComponent: {\n                safelyDetachRef(fiber, fiber.return);\n                var instance = fiber.stateNode;\n                if (typeof instance.componentWillUnmount === \"function\") {\n                  safelyCallComponentWillUnmount(fiber, fiber.return, instance);\n                }\n                break;\n              }\n              case HostComponent: {\n                safelyDetachRef(fiber, fiber.return);\n                break;\n              }\n              case OffscreenComponent: {\n                var isHidden = fiber.memoizedState !== null;\n                if (isHidden) {\n                  disappearLayoutEffects_complete(subtreeRoot);\n                  continue;\n                }\n                break;\n              }\n            }\n            if (firstChild !== null) {\n              firstChild.return = fiber;\n              nextEffect = firstChild;\n            } else {\n              disappearLayoutEffects_complete(subtreeRoot);\n            }\n          }\n        }\n        function disappearLayoutEffects_complete(subtreeRoot) {\n          while (nextEffect !== null) {\n            var fiber = nextEffect;\n            if (fiber === subtreeRoot) {\n              nextEffect = null;\n              return;\n            }\n            var sibling = fiber.sibling;\n            if (sibling !== null) {\n              sibling.return = fiber.return;\n              nextEffect = sibling;\n              return;\n            }\n            nextEffect = fiber.return;\n          }\n        }\n        function reappearLayoutEffects_begin(subtreeRoot) {\n          while (nextEffect !== null) {\n            var fiber = nextEffect;\n            var firstChild = fiber.child;\n            if (fiber.tag === OffscreenComponent) {\n              var isHidden = fiber.memoizedState !== null;\n              if (isHidden) {\n                reappearLayoutEffects_complete(subtreeRoot);\n                continue;\n              }\n            }\n            if (firstChild !== null) {\n              firstChild.return = fiber;\n              nextEffect = firstChild;\n            } else {\n              reappearLayoutEffects_complete(subtreeRoot);\n            }\n          }\n        }\n        function reappearLayoutEffects_complete(subtreeRoot) {\n          while (nextEffect !== null) {\n            var fiber = nextEffect;\n            setCurrentFiber(fiber);\n            try {\n              reappearLayoutEffectsOnFiber(fiber);\n            } catch (error2) {\n              captureCommitPhaseError(fiber, fiber.return, error2);\n            }\n            resetCurrentFiber();\n            if (fiber === subtreeRoot) {\n              nextEffect = null;\n              return;\n            }\n            var sibling = fiber.sibling;\n            if (sibling !== null) {\n              sibling.return = fiber.return;\n              nextEffect = sibling;\n              return;\n            }\n            nextEffect = fiber.return;\n          }\n        }\n        function commitPassiveMountEffects(root2, finishedWork, committedLanes, committedTransitions) {\n          nextEffect = finishedWork;\n          commitPassiveMountEffects_begin(finishedWork, root2, committedLanes, committedTransitions);\n        }\n        function commitPassiveMountEffects_begin(subtreeRoot, root2, committedLanes, committedTransitions) {\n          while (nextEffect !== null) {\n            var fiber = nextEffect;\n            var firstChild = fiber.child;\n            if ((fiber.subtreeFlags & PassiveMask) !== NoFlags && firstChild !== null) {\n              firstChild.return = fiber;\n              nextEffect = firstChild;\n            } else {\n              commitPassiveMountEffects_complete(subtreeRoot, root2, committedLanes, committedTransitions);\n            }\n          }\n        }\n        function commitPassiveMountEffects_complete(subtreeRoot, root2, committedLanes, committedTransitions) {\n          while (nextEffect !== null) {\n            var fiber = nextEffect;\n            if ((fiber.flags & Passive) !== NoFlags) {\n              setCurrentFiber(fiber);\n              try {\n                commitPassiveMountOnFiber(root2, fiber, committedLanes, committedTransitions);\n              } catch (error2) {\n                captureCommitPhaseError(fiber, fiber.return, error2);\n              }\n              resetCurrentFiber();\n            }\n            if (fiber === subtreeRoot) {\n              nextEffect = null;\n              return;\n            }\n            var sibling = fiber.sibling;\n            if (sibling !== null) {\n              sibling.return = fiber.return;\n              nextEffect = sibling;\n              return;\n            }\n            nextEffect = fiber.return;\n          }\n        }\n        function commitPassiveMountOnFiber(finishedRoot, finishedWork, committedLanes, committedTransitions) {\n          switch (finishedWork.tag) {\n            case FunctionComponent:\n            case ForwardRef:\n            case SimpleMemoComponent: {\n              if (finishedWork.mode & ProfileMode) {\n                startPassiveEffectTimer();\n                try {\n                  commitHookEffectListMount(Passive$1 | HasEffect, finishedWork);\n                } finally {\n                  recordPassiveEffectDuration(finishedWork);\n                }\n              } else {\n                commitHookEffectListMount(Passive$1 | HasEffect, finishedWork);\n              }\n              break;\n            }\n          }\n        }\n        function commitPassiveUnmountEffects(firstChild) {\n          nextEffect = firstChild;\n          commitPassiveUnmountEffects_begin();\n        }\n        function commitPassiveUnmountEffects_begin() {\n          while (nextEffect !== null) {\n            var fiber = nextEffect;\n            var child = fiber.child;\n            if ((nextEffect.flags & ChildDeletion) !== NoFlags) {\n              var deletions = fiber.deletions;\n              if (deletions !== null) {\n                for (var i = 0; i < deletions.length; i++) {\n                  var fiberToDelete = deletions[i];\n                  nextEffect = fiberToDelete;\n                  commitPassiveUnmountEffectsInsideOfDeletedTree_begin(fiberToDelete, fiber);\n                }\n                {\n                  var previousFiber = fiber.alternate;\n                  if (previousFiber !== null) {\n                    var detachedChild = previousFiber.child;\n                    if (detachedChild !== null) {\n                      previousFiber.child = null;\n                      do {\n                        var detachedSibling = detachedChild.sibling;\n                        detachedChild.sibling = null;\n                        detachedChild = detachedSibling;\n                      } while (detachedChild !== null);\n                    }\n                  }\n                }\n                nextEffect = fiber;\n              }\n            }\n            if ((fiber.subtreeFlags & PassiveMask) !== NoFlags && child !== null) {\n              child.return = fiber;\n              nextEffect = child;\n            } else {\n              commitPassiveUnmountEffects_complete();\n            }\n          }\n        }\n        function commitPassiveUnmountEffects_complete() {\n          while (nextEffect !== null) {\n            var fiber = nextEffect;\n            if ((fiber.flags & Passive) !== NoFlags) {\n              setCurrentFiber(fiber);\n              commitPassiveUnmountOnFiber(fiber);\n              resetCurrentFiber();\n            }\n            var sibling = fiber.sibling;\n            if (sibling !== null) {\n              sibling.return = fiber.return;\n              nextEffect = sibling;\n              return;\n            }\n            nextEffect = fiber.return;\n          }\n        }\n        function commitPassiveUnmountOnFiber(finishedWork) {\n          switch (finishedWork.tag) {\n            case FunctionComponent:\n            case ForwardRef:\n            case SimpleMemoComponent: {\n              if (finishedWork.mode & ProfileMode) {\n                startPassiveEffectTimer();\n                commitHookEffectListUnmount(Passive$1 | HasEffect, finishedWork, finishedWork.return);\n                recordPassiveEffectDuration(finishedWork);\n              } else {\n                commitHookEffectListUnmount(Passive$1 | HasEffect, finishedWork, finishedWork.return);\n              }\n              break;\n            }\n          }\n        }\n        function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(deletedSubtreeRoot, nearestMountedAncestor) {\n          while (nextEffect !== null) {\n            var fiber = nextEffect;\n            setCurrentFiber(fiber);\n            commitPassiveUnmountInsideDeletedTreeOnFiber(fiber, nearestMountedAncestor);\n            resetCurrentFiber();\n            var child = fiber.child;\n            if (child !== null) {\n              child.return = fiber;\n              nextEffect = child;\n            } else {\n              commitPassiveUnmountEffectsInsideOfDeletedTree_complete(deletedSubtreeRoot);\n            }\n          }\n        }\n        function commitPassiveUnmountEffectsInsideOfDeletedTree_complete(deletedSubtreeRoot) {\n          while (nextEffect !== null) {\n            var fiber = nextEffect;\n            var sibling = fiber.sibling;\n            var returnFiber = fiber.return;\n            {\n              detachFiberAfterEffects(fiber);\n              if (fiber === deletedSubtreeRoot) {\n                nextEffect = null;\n                return;\n              }\n            }\n            if (sibling !== null) {\n              sibling.return = returnFiber;\n              nextEffect = sibling;\n              return;\n            }\n            nextEffect = returnFiber;\n          }\n        }\n        function commitPassiveUnmountInsideDeletedTreeOnFiber(current2, nearestMountedAncestor) {\n          switch (current2.tag) {\n            case FunctionComponent:\n            case ForwardRef:\n            case SimpleMemoComponent: {\n              if (current2.mode & ProfileMode) {\n                startPassiveEffectTimer();\n                commitHookEffectListUnmount(Passive$1, current2, nearestMountedAncestor);\n                recordPassiveEffectDuration(current2);\n              } else {\n                commitHookEffectListUnmount(Passive$1, current2, nearestMountedAncestor);\n              }\n              break;\n            }\n          }\n        }\n        function invokeLayoutEffectMountInDEV(fiber) {\n          {\n            switch (fiber.tag) {\n              case FunctionComponent:\n              case ForwardRef:\n              case SimpleMemoComponent: {\n                try {\n                  commitHookEffectListMount(Layout | HasEffect, fiber);\n                } catch (error2) {\n                  captureCommitPhaseError(fiber, fiber.return, error2);\n                }\n                break;\n              }\n              case ClassComponent: {\n                var instance = fiber.stateNode;\n                try {\n                  instance.componentDidMount();\n                } catch (error2) {\n                  captureCommitPhaseError(fiber, fiber.return, error2);\n                }\n                break;\n              }\n            }\n          }\n        }\n        function invokePassiveEffectMountInDEV(fiber) {\n          {\n            switch (fiber.tag) {\n              case FunctionComponent:\n              case ForwardRef:\n              case SimpleMemoComponent: {\n                try {\n                  commitHookEffectListMount(Passive$1 | HasEffect, fiber);\n                } catch (error2) {\n                  captureCommitPhaseError(fiber, fiber.return, error2);\n                }\n                break;\n              }\n            }\n          }\n        }\n        function invokeLayoutEffectUnmountInDEV(fiber) {\n          {\n            switch (fiber.tag) {\n              case FunctionComponent:\n              case ForwardRef:\n              case SimpleMemoComponent: {\n                try {\n                  commitHookEffectListUnmount(Layout | HasEffect, fiber, fiber.return);\n                } catch (error2) {\n                  captureCommitPhaseError(fiber, fiber.return, error2);\n                }\n                break;\n              }\n              case ClassComponent: {\n                var instance = fiber.stateNode;\n                if (typeof instance.componentWillUnmount === \"function\") {\n                  safelyCallComponentWillUnmount(fiber, fiber.return, instance);\n                }\n                break;\n              }\n            }\n          }\n        }\n        function invokePassiveEffectUnmountInDEV(fiber) {\n          {\n            switch (fiber.tag) {\n              case FunctionComponent:\n              case ForwardRef:\n              case SimpleMemoComponent: {\n                try {\n                  commitHookEffectListUnmount(Passive$1 | HasEffect, fiber, fiber.return);\n                } catch (error2) {\n                  captureCommitPhaseError(fiber, fiber.return, error2);\n                }\n              }\n            }\n          }\n        }\n        var COMPONENT_TYPE = 0;\n        var HAS_PSEUDO_CLASS_TYPE = 1;\n        var ROLE_TYPE = 2;\n        var TEST_NAME_TYPE = 3;\n        var TEXT_TYPE = 4;\n        if (typeof Symbol === \"function\" && Symbol.for) {\n          var symbolFor = Symbol.for;\n          COMPONENT_TYPE = symbolFor(\"selector.component\");\n          HAS_PSEUDO_CLASS_TYPE = symbolFor(\"selector.has_pseudo_class\");\n          ROLE_TYPE = symbolFor(\"selector.role\");\n          TEST_NAME_TYPE = symbolFor(\"selector.test_id\");\n          TEXT_TYPE = symbolFor(\"selector.text\");\n        }\n        var commitHooks = [];\n        function onCommitRoot$1() {\n          {\n            commitHooks.forEach(function(commitHook) {\n              return commitHook();\n            });\n          }\n        }\n        var ReactCurrentActQueue = ReactSharedInternals.ReactCurrentActQueue;\n        function isLegacyActEnvironment(fiber) {\n          {\n            var isReactActEnvironmentGlobal = (\n              // $FlowExpectedError  Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global\n              typeof IS_REACT_ACT_ENVIRONMENT !== \"undefined\" ? IS_REACT_ACT_ENVIRONMENT : void 0\n            );\n            var jestIsDefined = typeof jest !== \"undefined\";\n            return jestIsDefined && isReactActEnvironmentGlobal !== false;\n          }\n        }\n        function isConcurrentActEnvironment() {\n          {\n            var isReactActEnvironmentGlobal = (\n              // $FlowExpectedError  Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global\n              typeof IS_REACT_ACT_ENVIRONMENT !== \"undefined\" ? IS_REACT_ACT_ENVIRONMENT : void 0\n            );\n            if (!isReactActEnvironmentGlobal && ReactCurrentActQueue.current !== null) {\n              error(\"The current testing environment is not configured to support act(...)\");\n            }\n            return isReactActEnvironmentGlobal;\n          }\n        }\n        var ceil = Math.ceil;\n        var ReactCurrentDispatcher$2 = ReactSharedInternals.ReactCurrentDispatcher, ReactCurrentOwner$2 = ReactSharedInternals.ReactCurrentOwner, ReactCurrentBatchConfig$3 = ReactSharedInternals.ReactCurrentBatchConfig, ReactCurrentActQueue$1 = ReactSharedInternals.ReactCurrentActQueue;\n        var NoContext = (\n          /*             */\n          0\n        );\n        var BatchedContext = (\n          /*               */\n          1\n        );\n        var RenderContext = (\n          /*                */\n          2\n        );\n        var CommitContext = (\n          /*                */\n          4\n        );\n        var RootInProgress = 0;\n        var RootFatalErrored = 1;\n        var RootErrored = 2;\n        var RootSuspended = 3;\n        var RootSuspendedWithDelay = 4;\n        var RootCompleted = 5;\n        var RootDidNotComplete = 6;\n        var executionContext = NoContext;\n        var workInProgressRoot = null;\n        var workInProgress = null;\n        var workInProgressRootRenderLanes = NoLanes;\n        var subtreeRenderLanes = NoLanes;\n        var subtreeRenderLanesCursor = createCursor(NoLanes);\n        var workInProgressRootExitStatus = RootInProgress;\n        var workInProgressRootFatalError = null;\n        var workInProgressRootIncludedLanes = NoLanes;\n        var workInProgressRootSkippedLanes = NoLanes;\n        var workInProgressRootInterleavedUpdatedLanes = NoLanes;\n        var workInProgressRootPingedLanes = NoLanes;\n        var workInProgressRootConcurrentErrors = null;\n        var workInProgressRootRecoverableErrors = null;\n        var globalMostRecentFallbackTime = 0;\n        var FALLBACK_THROTTLE_MS = 500;\n        var workInProgressRootRenderTargetTime = Infinity;\n        var RENDER_TIMEOUT_MS = 500;\n        var workInProgressTransitions = null;\n        function resetRenderTimer() {\n          workInProgressRootRenderTargetTime = now() + RENDER_TIMEOUT_MS;\n        }\n        function getRenderTargetTime() {\n          return workInProgressRootRenderTargetTime;\n        }\n        var hasUncaughtError = false;\n        var firstUncaughtError = null;\n        var legacyErrorBoundariesThatAlreadyFailed = null;\n        var rootDoesHavePassiveEffects = false;\n        var rootWithPendingPassiveEffects = null;\n        var pendingPassiveEffectsLanes = NoLanes;\n        var pendingPassiveProfilerEffects = [];\n        var pendingPassiveTransitions = null;\n        var NESTED_UPDATE_LIMIT = 50;\n        var nestedUpdateCount = 0;\n        var rootWithNestedUpdates = null;\n        var isFlushingPassiveEffects = false;\n        var didScheduleUpdateDuringPassiveEffects = false;\n        var NESTED_PASSIVE_UPDATE_LIMIT = 50;\n        var nestedPassiveUpdateCount = 0;\n        var rootWithPassiveNestedUpdates = null;\n        var currentEventTime = NoTimestamp;\n        var currentEventTransitionLane = NoLanes;\n        var isRunningInsertionEffect = false;\n        function getWorkInProgressRoot() {\n          return workInProgressRoot;\n        }\n        function requestEventTime() {\n          if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\n            return now();\n          }\n          if (currentEventTime !== NoTimestamp) {\n            return currentEventTime;\n          }\n          currentEventTime = now();\n          return currentEventTime;\n        }\n        function requestUpdateLane(fiber) {\n          var mode = fiber.mode;\n          if ((mode & ConcurrentMode) === NoMode) {\n            return SyncLane;\n          } else if ((executionContext & RenderContext) !== NoContext && workInProgressRootRenderLanes !== NoLanes) {\n            return pickArbitraryLane(workInProgressRootRenderLanes);\n          }\n          var isTransition = requestCurrentTransition() !== NoTransition;\n          if (isTransition) {\n            if (ReactCurrentBatchConfig$3.transition !== null) {\n              var transition = ReactCurrentBatchConfig$3.transition;\n              if (!transition._updatedFibers) {\n                transition._updatedFibers = /* @__PURE__ */ new Set();\n              }\n              transition._updatedFibers.add(fiber);\n            }\n            if (currentEventTransitionLane === NoLane) {\n              currentEventTransitionLane = claimNextTransitionLane();\n            }\n            return currentEventTransitionLane;\n          }\n          var updateLane = getCurrentUpdatePriority();\n          if (updateLane !== NoLane) {\n            return updateLane;\n          }\n          var eventLane = getCurrentEventPriority();\n          return eventLane;\n        }\n        function requestRetryLane(fiber) {\n          var mode = fiber.mode;\n          if ((mode & ConcurrentMode) === NoMode) {\n            return SyncLane;\n          }\n          return claimNextRetryLane();\n        }\n        function scheduleUpdateOnFiber(root2, fiber, lane, eventTime) {\n          checkForNestedUpdates();\n          {\n            if (isRunningInsertionEffect) {\n              error(\"useInsertionEffect must not schedule updates.\");\n            }\n          }\n          {\n            if (isFlushingPassiveEffects) {\n              didScheduleUpdateDuringPassiveEffects = true;\n            }\n          }\n          markRootUpdated(root2, lane, eventTime);\n          if ((executionContext & RenderContext) !== NoLanes && root2 === workInProgressRoot) {\n            warnAboutRenderPhaseUpdatesInDEV(fiber);\n          } else {\n            {\n              if (isDevToolsPresent) {\n                addFiberToLanesMap(root2, fiber, lane);\n              }\n            }\n            warnIfUpdatesNotWrappedWithActDEV(fiber);\n            if (root2 === workInProgressRoot) {\n              if ((executionContext & RenderContext) === NoContext) {\n                workInProgressRootInterleavedUpdatedLanes = mergeLanes(workInProgressRootInterleavedUpdatedLanes, lane);\n              }\n              if (workInProgressRootExitStatus === RootSuspendedWithDelay) {\n                markRootSuspended$1(root2, workInProgressRootRenderLanes);\n              }\n            }\n            ensureRootIsScheduled(root2, eventTime);\n            if (lane === SyncLane && executionContext === NoContext && (fiber.mode & ConcurrentMode) === NoMode && // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.\n            !ReactCurrentActQueue$1.isBatchingLegacy) {\n              resetRenderTimer();\n              flushSyncCallbacksOnlyInLegacyMode();\n            }\n          }\n        }\n        function scheduleInitialHydrationOnRoot(root2, lane, eventTime) {\n          var current2 = root2.current;\n          current2.lanes = lane;\n          markRootUpdated(root2, lane, eventTime);\n          ensureRootIsScheduled(root2, eventTime);\n        }\n        function isUnsafeClassRenderPhaseUpdate(fiber) {\n          return (\n            // TODO: Remove outdated deferRenderPhaseUpdateToNextBatch experiment. We\n            // decided not to enable it.\n            (executionContext & RenderContext) !== NoContext\n          );\n        }\n        function ensureRootIsScheduled(root2, currentTime) {\n          var existingCallbackNode = root2.callbackNode;\n          markStarvedLanesAsExpired(root2, currentTime);\n          var nextLanes = getNextLanes(root2, root2 === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes);\n          if (nextLanes === NoLanes) {\n            if (existingCallbackNode !== null) {\n              cancelCallback$1(existingCallbackNode);\n            }\n            root2.callbackNode = null;\n            root2.callbackPriority = NoLane;\n            return;\n          }\n          var newCallbackPriority = getHighestPriorityLane(nextLanes);\n          var existingCallbackPriority = root2.callbackPriority;\n          if (existingCallbackPriority === newCallbackPriority && // Special case related to `act`. If the currently scheduled task is a\n          // Scheduler task, rather than an `act` task, cancel it and re-scheduled\n          // on the `act` queue.\n          !(ReactCurrentActQueue$1.current !== null && existingCallbackNode !== fakeActCallbackNode)) {\n            {\n              if (existingCallbackNode == null && existingCallbackPriority !== SyncLane) {\n                error(\"Expected scheduled callback to exist. This error is likely caused by a bug in React. Please file an issue.\");\n              }\n            }\n            return;\n          }\n          if (existingCallbackNode != null) {\n            cancelCallback$1(existingCallbackNode);\n          }\n          var newCallbackNode;\n          if (newCallbackPriority === SyncLane) {\n            if (root2.tag === LegacyRoot) {\n              if (ReactCurrentActQueue$1.isBatchingLegacy !== null) {\n                ReactCurrentActQueue$1.didScheduleLegacyUpdate = true;\n              }\n              scheduleLegacySyncCallback(performSyncWorkOnRoot.bind(null, root2));\n            } else {\n              scheduleSyncCallback(performSyncWorkOnRoot.bind(null, root2));\n            }\n            {\n              if (ReactCurrentActQueue$1.current !== null) {\n                ReactCurrentActQueue$1.current.push(flushSyncCallbacks);\n              } else {\n                scheduleMicrotask(function() {\n                  if ((executionContext & (RenderContext | CommitContext)) === NoContext) {\n                    flushSyncCallbacks();\n                  }\n                });\n              }\n            }\n            newCallbackNode = null;\n          } else {\n            var schedulerPriorityLevel;\n            switch (lanesToEventPriority(nextLanes)) {\n              case DiscreteEventPriority:\n                schedulerPriorityLevel = ImmediatePriority;\n                break;\n              case ContinuousEventPriority:\n                schedulerPriorityLevel = UserBlockingPriority;\n                break;\n              case DefaultEventPriority:\n                schedulerPriorityLevel = NormalPriority;\n                break;\n              case IdleEventPriority:\n                schedulerPriorityLevel = IdlePriority;\n                break;\n              default:\n                schedulerPriorityLevel = NormalPriority;\n                break;\n            }\n            newCallbackNode = scheduleCallback$1(schedulerPriorityLevel, performConcurrentWorkOnRoot.bind(null, root2));\n          }\n          root2.callbackPriority = newCallbackPriority;\n          root2.callbackNode = newCallbackNode;\n        }\n        function performConcurrentWorkOnRoot(root2, didTimeout) {\n          {\n            resetNestedUpdateFlag();\n          }\n          currentEventTime = NoTimestamp;\n          currentEventTransitionLane = NoLanes;\n          if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\n            throw new Error(\"Should not already be working.\");\n          }\n          var originalCallbackNode = root2.callbackNode;\n          var didFlushPassiveEffects = flushPassiveEffects();\n          if (didFlushPassiveEffects) {\n            if (root2.callbackNode !== originalCallbackNode) {\n              return null;\n            }\n          }\n          var lanes = getNextLanes(root2, root2 === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes);\n          if (lanes === NoLanes) {\n            return null;\n          }\n          var shouldTimeSlice = !includesBlockingLane(root2, lanes) && !includesExpiredLane(root2, lanes) && !didTimeout;\n          var exitStatus = shouldTimeSlice ? renderRootConcurrent(root2, lanes) : renderRootSync(root2, lanes);\n          if (exitStatus !== RootInProgress) {\n            if (exitStatus === RootErrored) {\n              var errorRetryLanes = getLanesToRetrySynchronouslyOnError(root2);\n              if (errorRetryLanes !== NoLanes) {\n                lanes = errorRetryLanes;\n                exitStatus = recoverFromConcurrentError(root2, errorRetryLanes);\n              }\n            }\n            if (exitStatus === RootFatalErrored) {\n              var fatalError = workInProgressRootFatalError;\n              prepareFreshStack(root2, NoLanes);\n              markRootSuspended$1(root2, lanes);\n              ensureRootIsScheduled(root2, now());\n              throw fatalError;\n            }\n            if (exitStatus === RootDidNotComplete) {\n              markRootSuspended$1(root2, lanes);\n            } else {\n              var renderWasConcurrent = !includesBlockingLane(root2, lanes);\n              var finishedWork = root2.current.alternate;\n              if (renderWasConcurrent && !isRenderConsistentWithExternalStores(finishedWork)) {\n                exitStatus = renderRootSync(root2, lanes);\n                if (exitStatus === RootErrored) {\n                  var _errorRetryLanes = getLanesToRetrySynchronouslyOnError(root2);\n                  if (_errorRetryLanes !== NoLanes) {\n                    lanes = _errorRetryLanes;\n                    exitStatus = recoverFromConcurrentError(root2, _errorRetryLanes);\n                  }\n                }\n                if (exitStatus === RootFatalErrored) {\n                  var _fatalError = workInProgressRootFatalError;\n                  prepareFreshStack(root2, NoLanes);\n                  markRootSuspended$1(root2, lanes);\n                  ensureRootIsScheduled(root2, now());\n                  throw _fatalError;\n                }\n              }\n              root2.finishedWork = finishedWork;\n              root2.finishedLanes = lanes;\n              finishConcurrentRender(root2, exitStatus, lanes);\n            }\n          }\n          ensureRootIsScheduled(root2, now());\n          if (root2.callbackNode === originalCallbackNode) {\n            return performConcurrentWorkOnRoot.bind(null, root2);\n          }\n          return null;\n        }\n        function recoverFromConcurrentError(root2, errorRetryLanes) {\n          var errorsFromFirstAttempt = workInProgressRootConcurrentErrors;\n          if (isRootDehydrated(root2)) {\n            var rootWorkInProgress = prepareFreshStack(root2, errorRetryLanes);\n            rootWorkInProgress.flags |= ForceClientRender;\n            {\n              errorHydratingContainer(root2.containerInfo);\n            }\n          }\n          var exitStatus = renderRootSync(root2, errorRetryLanes);\n          if (exitStatus !== RootErrored) {\n            var errorsFromSecondAttempt = workInProgressRootRecoverableErrors;\n            workInProgressRootRecoverableErrors = errorsFromFirstAttempt;\n            if (errorsFromSecondAttempt !== null) {\n              queueRecoverableErrors(errorsFromSecondAttempt);\n            }\n          }\n          return exitStatus;\n        }\n        function queueRecoverableErrors(errors) {\n          if (workInProgressRootRecoverableErrors === null) {\n            workInProgressRootRecoverableErrors = errors;\n          } else {\n            workInProgressRootRecoverableErrors.push.apply(workInProgressRootRecoverableErrors, errors);\n          }\n        }\n        function finishConcurrentRender(root2, exitStatus, lanes) {\n          switch (exitStatus) {\n            case RootInProgress:\n            case RootFatalErrored: {\n              throw new Error(\"Root did not complete. This is a bug in React.\");\n            }\n            case RootErrored: {\n              commitRoot(root2, workInProgressRootRecoverableErrors, workInProgressTransitions);\n              break;\n            }\n            case RootSuspended: {\n              markRootSuspended$1(root2, lanes);\n              if (includesOnlyRetries(lanes) && // do not delay if we're inside an act() scope\n              !shouldForceFlushFallbacksInDEV()) {\n                var msUntilTimeout = globalMostRecentFallbackTime + FALLBACK_THROTTLE_MS - now();\n                if (msUntilTimeout > 10) {\n                  var nextLanes = getNextLanes(root2, NoLanes);\n                  if (nextLanes !== NoLanes) {\n                    break;\n                  }\n                  var suspendedLanes = root2.suspendedLanes;\n                  if (!isSubsetOfLanes(suspendedLanes, lanes)) {\n                    var eventTime = requestEventTime();\n                    markRootPinged(root2, suspendedLanes);\n                    break;\n                  }\n                  root2.timeoutHandle = scheduleTimeout(commitRoot.bind(null, root2, workInProgressRootRecoverableErrors, workInProgressTransitions), msUntilTimeout);\n                  break;\n                }\n              }\n              commitRoot(root2, workInProgressRootRecoverableErrors, workInProgressTransitions);\n              break;\n            }\n            case RootSuspendedWithDelay: {\n              markRootSuspended$1(root2, lanes);\n              if (includesOnlyTransitions(lanes)) {\n                break;\n              }\n              if (!shouldForceFlushFallbacksInDEV()) {\n                var mostRecentEventTime = getMostRecentEventTime(root2, lanes);\n                var eventTimeMs = mostRecentEventTime;\n                var timeElapsedMs = now() - eventTimeMs;\n                var _msUntilTimeout = jnd(timeElapsedMs) - timeElapsedMs;\n                if (_msUntilTimeout > 10) {\n                  root2.timeoutHandle = scheduleTimeout(commitRoot.bind(null, root2, workInProgressRootRecoverableErrors, workInProgressTransitions), _msUntilTimeout);\n                  break;\n                }\n              }\n              commitRoot(root2, workInProgressRootRecoverableErrors, workInProgressTransitions);\n              break;\n            }\n            case RootCompleted: {\n              commitRoot(root2, workInProgressRootRecoverableErrors, workInProgressTransitions);\n              break;\n            }\n            default: {\n              throw new Error(\"Unknown root exit status.\");\n            }\n          }\n        }\n        function isRenderConsistentWithExternalStores(finishedWork) {\n          var node = finishedWork;\n          while (true) {\n            if (node.flags & StoreConsistency) {\n              var updateQueue = node.updateQueue;\n              if (updateQueue !== null) {\n                var checks = updateQueue.stores;\n                if (checks !== null) {\n                  for (var i = 0; i < checks.length; i++) {\n                    var check = checks[i];\n                    var getSnapshot = check.getSnapshot;\n                    var renderedValue = check.value;\n                    try {\n                      if (!objectIs(getSnapshot(), renderedValue)) {\n                        return false;\n                      }\n                    } catch (error2) {\n                      return false;\n                    }\n                  }\n                }\n              }\n            }\n            var child = node.child;\n            if (node.subtreeFlags & StoreConsistency && child !== null) {\n              child.return = node;\n              node = child;\n              continue;\n            }\n            if (node === finishedWork) {\n              return true;\n            }\n            while (node.sibling === null) {\n              if (node.return === null || node.return === finishedWork) {\n                return true;\n              }\n              node = node.return;\n            }\n            node.sibling.return = node.return;\n            node = node.sibling;\n          }\n          return true;\n        }\n        function markRootSuspended$1(root2, suspendedLanes) {\n          suspendedLanes = removeLanes(suspendedLanes, workInProgressRootPingedLanes);\n          suspendedLanes = removeLanes(suspendedLanes, workInProgressRootInterleavedUpdatedLanes);\n          markRootSuspended(root2, suspendedLanes);\n        }\n        function performSyncWorkOnRoot(root2) {\n          {\n            syncNestedUpdateFlag();\n          }\n          if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\n            throw new Error(\"Should not already be working.\");\n          }\n          flushPassiveEffects();\n          var lanes = getNextLanes(root2, NoLanes);\n          if (!includesSomeLane(lanes, SyncLane)) {\n            ensureRootIsScheduled(root2, now());\n            return null;\n          }\n          var exitStatus = renderRootSync(root2, lanes);\n          if (root2.tag !== LegacyRoot && exitStatus === RootErrored) {\n            var errorRetryLanes = getLanesToRetrySynchronouslyOnError(root2);\n            if (errorRetryLanes !== NoLanes) {\n              lanes = errorRetryLanes;\n              exitStatus = recoverFromConcurrentError(root2, errorRetryLanes);\n            }\n          }\n          if (exitStatus === RootFatalErrored) {\n            var fatalError = workInProgressRootFatalError;\n            prepareFreshStack(root2, NoLanes);\n            markRootSuspended$1(root2, lanes);\n            ensureRootIsScheduled(root2, now());\n            throw fatalError;\n          }\n          if (exitStatus === RootDidNotComplete) {\n            throw new Error(\"Root did not complete. This is a bug in React.\");\n          }\n          var finishedWork = root2.current.alternate;\n          root2.finishedWork = finishedWork;\n          root2.finishedLanes = lanes;\n          commitRoot(root2, workInProgressRootRecoverableErrors, workInProgressTransitions);\n          ensureRootIsScheduled(root2, now());\n          return null;\n        }\n        function flushRoot(root2, lanes) {\n          if (lanes !== NoLanes) {\n            markRootEntangled(root2, mergeLanes(lanes, SyncLane));\n            ensureRootIsScheduled(root2, now());\n            if ((executionContext & (RenderContext | CommitContext)) === NoContext) {\n              resetRenderTimer();\n              flushSyncCallbacks();\n            }\n          }\n        }\n        function batchedUpdates$1(fn, a) {\n          var prevExecutionContext = executionContext;\n          executionContext |= BatchedContext;\n          try {\n            return fn(a);\n          } finally {\n            executionContext = prevExecutionContext;\n            if (executionContext === NoContext && // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.\n            !ReactCurrentActQueue$1.isBatchingLegacy) {\n              resetRenderTimer();\n              flushSyncCallbacksOnlyInLegacyMode();\n            }\n          }\n        }\n        function discreteUpdates(fn, a, b, c, d) {\n          var previousPriority = getCurrentUpdatePriority();\n          var prevTransition = ReactCurrentBatchConfig$3.transition;\n          try {\n            ReactCurrentBatchConfig$3.transition = null;\n            setCurrentUpdatePriority(DiscreteEventPriority);\n            return fn(a, b, c, d);\n          } finally {\n            setCurrentUpdatePriority(previousPriority);\n            ReactCurrentBatchConfig$3.transition = prevTransition;\n            if (executionContext === NoContext) {\n              resetRenderTimer();\n            }\n          }\n        }\n        function flushSync(fn) {\n          if (rootWithPendingPassiveEffects !== null && rootWithPendingPassiveEffects.tag === LegacyRoot && (executionContext & (RenderContext | CommitContext)) === NoContext) {\n            flushPassiveEffects();\n          }\n          var prevExecutionContext = executionContext;\n          executionContext |= BatchedContext;\n          var prevTransition = ReactCurrentBatchConfig$3.transition;\n          var previousPriority = getCurrentUpdatePriority();\n          try {\n            ReactCurrentBatchConfig$3.transition = null;\n            setCurrentUpdatePriority(DiscreteEventPriority);\n            if (fn) {\n              return fn();\n            } else {\n              return void 0;\n            }\n          } finally {\n            setCurrentUpdatePriority(previousPriority);\n            ReactCurrentBatchConfig$3.transition = prevTransition;\n            executionContext = prevExecutionContext;\n            if ((executionContext & (RenderContext | CommitContext)) === NoContext) {\n              flushSyncCallbacks();\n            }\n          }\n        }\n        function isAlreadyRendering() {\n          return (executionContext & (RenderContext | CommitContext)) !== NoContext;\n        }\n        function pushRenderLanes(fiber, lanes) {\n          push(subtreeRenderLanesCursor, subtreeRenderLanes, fiber);\n          subtreeRenderLanes = mergeLanes(subtreeRenderLanes, lanes);\n          workInProgressRootIncludedLanes = mergeLanes(workInProgressRootIncludedLanes, lanes);\n        }\n        function popRenderLanes(fiber) {\n          subtreeRenderLanes = subtreeRenderLanesCursor.current;\n          pop(subtreeRenderLanesCursor, fiber);\n        }\n        function prepareFreshStack(root2, lanes) {\n          root2.finishedWork = null;\n          root2.finishedLanes = NoLanes;\n          var timeoutHandle = root2.timeoutHandle;\n          if (timeoutHandle !== noTimeout) {\n            root2.timeoutHandle = noTimeout;\n            cancelTimeout(timeoutHandle);\n          }\n          if (workInProgress !== null) {\n            var interruptedWork = workInProgress.return;\n            while (interruptedWork !== null) {\n              var current2 = interruptedWork.alternate;\n              unwindInterruptedWork(current2, interruptedWork);\n              interruptedWork = interruptedWork.return;\n            }\n          }\n          workInProgressRoot = root2;\n          var rootWorkInProgress = createWorkInProgress(root2.current, null);\n          workInProgress = rootWorkInProgress;\n          workInProgressRootRenderLanes = subtreeRenderLanes = workInProgressRootIncludedLanes = lanes;\n          workInProgressRootExitStatus = RootInProgress;\n          workInProgressRootFatalError = null;\n          workInProgressRootSkippedLanes = NoLanes;\n          workInProgressRootInterleavedUpdatedLanes = NoLanes;\n          workInProgressRootPingedLanes = NoLanes;\n          workInProgressRootConcurrentErrors = null;\n          workInProgressRootRecoverableErrors = null;\n          finishQueueingConcurrentUpdates();\n          {\n            ReactStrictModeWarnings.discardPendingWarnings();\n          }\n          return rootWorkInProgress;\n        }\n        function handleError(root2, thrownValue) {\n          do {\n            var erroredWork = workInProgress;\n            try {\n              resetContextDependencies();\n              resetHooksAfterThrow();\n              resetCurrentFiber();\n              ReactCurrentOwner$2.current = null;\n              if (erroredWork === null || erroredWork.return === null) {\n                workInProgressRootExitStatus = RootFatalErrored;\n                workInProgressRootFatalError = thrownValue;\n                workInProgress = null;\n                return;\n              }\n              if (enableProfilerTimer && erroredWork.mode & ProfileMode) {\n                stopProfilerTimerIfRunningAndRecordDelta(erroredWork, true);\n              }\n              if (enableSchedulingProfiler) {\n                markComponentRenderStopped();\n                if (thrownValue !== null && typeof thrownValue === \"object\" && typeof thrownValue.then === \"function\") {\n                  var wakeable = thrownValue;\n                  markComponentSuspended(erroredWork, wakeable, workInProgressRootRenderLanes);\n                } else {\n                  markComponentErrored(erroredWork, thrownValue, workInProgressRootRenderLanes);\n                }\n              }\n              throwException(root2, erroredWork.return, erroredWork, thrownValue, workInProgressRootRenderLanes);\n              completeUnitOfWork(erroredWork);\n            } catch (yetAnotherThrownValue) {\n              thrownValue = yetAnotherThrownValue;\n              if (workInProgress === erroredWork && erroredWork !== null) {\n                erroredWork = erroredWork.return;\n                workInProgress = erroredWork;\n              } else {\n                erroredWork = workInProgress;\n              }\n              continue;\n            }\n            return;\n          } while (true);\n        }\n        function pushDispatcher() {\n          var prevDispatcher = ReactCurrentDispatcher$2.current;\n          ReactCurrentDispatcher$2.current = ContextOnlyDispatcher;\n          if (prevDispatcher === null) {\n            return ContextOnlyDispatcher;\n          } else {\n            return prevDispatcher;\n          }\n        }\n        function popDispatcher(prevDispatcher) {\n          ReactCurrentDispatcher$2.current = prevDispatcher;\n        }\n        function markCommitTimeOfFallback() {\n          globalMostRecentFallbackTime = now();\n        }\n        function markSkippedUpdateLanes(lane) {\n          workInProgressRootSkippedLanes = mergeLanes(lane, workInProgressRootSkippedLanes);\n        }\n        function renderDidSuspend() {\n          if (workInProgressRootExitStatus === RootInProgress) {\n            workInProgressRootExitStatus = RootSuspended;\n          }\n        }\n        function renderDidSuspendDelayIfPossible() {\n          if (workInProgressRootExitStatus === RootInProgress || workInProgressRootExitStatus === RootSuspended || workInProgressRootExitStatus === RootErrored) {\n            workInProgressRootExitStatus = RootSuspendedWithDelay;\n          }\n          if (workInProgressRoot !== null && (includesNonIdleWork(workInProgressRootSkippedLanes) || includesNonIdleWork(workInProgressRootInterleavedUpdatedLanes))) {\n            markRootSuspended$1(workInProgressRoot, workInProgressRootRenderLanes);\n          }\n        }\n        function renderDidError(error2) {\n          if (workInProgressRootExitStatus !== RootSuspendedWithDelay) {\n            workInProgressRootExitStatus = RootErrored;\n          }\n          if (workInProgressRootConcurrentErrors === null) {\n            workInProgressRootConcurrentErrors = [error2];\n          } else {\n            workInProgressRootConcurrentErrors.push(error2);\n          }\n        }\n        function renderHasNotSuspendedYet() {\n          return workInProgressRootExitStatus === RootInProgress;\n        }\n        function renderRootSync(root2, lanes) {\n          var prevExecutionContext = executionContext;\n          executionContext |= RenderContext;\n          var prevDispatcher = pushDispatcher();\n          if (workInProgressRoot !== root2 || workInProgressRootRenderLanes !== lanes) {\n            {\n              if (isDevToolsPresent) {\n                var memoizedUpdaters = root2.memoizedUpdaters;\n                if (memoizedUpdaters.size > 0) {\n                  restorePendingUpdaters(root2, workInProgressRootRenderLanes);\n                  memoizedUpdaters.clear();\n                }\n                movePendingFibersToMemoized(root2, lanes);\n              }\n            }\n            workInProgressTransitions = getTransitionsForLanes();\n            prepareFreshStack(root2, lanes);\n          }\n          {\n            markRenderStarted(lanes);\n          }\n          do {\n            try {\n              workLoopSync();\n              break;\n            } catch (thrownValue) {\n              handleError(root2, thrownValue);\n            }\n          } while (true);\n          resetContextDependencies();\n          executionContext = prevExecutionContext;\n          popDispatcher(prevDispatcher);\n          if (workInProgress !== null) {\n            throw new Error(\"Cannot commit an incomplete root. This error is likely caused by a bug in React. Please file an issue.\");\n          }\n          {\n            markRenderStopped();\n          }\n          workInProgressRoot = null;\n          workInProgressRootRenderLanes = NoLanes;\n          return workInProgressRootExitStatus;\n        }\n        function workLoopSync() {\n          while (workInProgress !== null) {\n            performUnitOfWork(workInProgress);\n          }\n        }\n        function renderRootConcurrent(root2, lanes) {\n          var prevExecutionContext = executionContext;\n          executionContext |= RenderContext;\n          var prevDispatcher = pushDispatcher();\n          if (workInProgressRoot !== root2 || workInProgressRootRenderLanes !== lanes) {\n            {\n              if (isDevToolsPresent) {\n                var memoizedUpdaters = root2.memoizedUpdaters;\n                if (memoizedUpdaters.size > 0) {\n                  restorePendingUpdaters(root2, workInProgressRootRenderLanes);\n                  memoizedUpdaters.clear();\n                }\n                movePendingFibersToMemoized(root2, lanes);\n              }\n            }\n            workInProgressTransitions = getTransitionsForLanes();\n            resetRenderTimer();\n            prepareFreshStack(root2, lanes);\n          }\n          {\n            markRenderStarted(lanes);\n          }\n          do {\n            try {\n              workLoopConcurrent();\n              break;\n            } catch (thrownValue) {\n              handleError(root2, thrownValue);\n            }\n          } while (true);\n          resetContextDependencies();\n          popDispatcher(prevDispatcher);\n          executionContext = prevExecutionContext;\n          if (workInProgress !== null) {\n            {\n              markRenderYielded();\n            }\n            return RootInProgress;\n          } else {\n            {\n              markRenderStopped();\n            }\n            workInProgressRoot = null;\n            workInProgressRootRenderLanes = NoLanes;\n            return workInProgressRootExitStatus;\n          }\n        }\n        function workLoopConcurrent() {\n          while (workInProgress !== null && !shouldYield()) {\n            performUnitOfWork(workInProgress);\n          }\n        }\n        function performUnitOfWork(unitOfWork) {\n          var current2 = unitOfWork.alternate;\n          setCurrentFiber(unitOfWork);\n          var next;\n          if ((unitOfWork.mode & ProfileMode) !== NoMode) {\n            startProfilerTimer(unitOfWork);\n            next = beginWork$1(current2, unitOfWork, subtreeRenderLanes);\n            stopProfilerTimerIfRunningAndRecordDelta(unitOfWork, true);\n          } else {\n            next = beginWork$1(current2, unitOfWork, subtreeRenderLanes);\n          }\n          resetCurrentFiber();\n          unitOfWork.memoizedProps = unitOfWork.pendingProps;\n          if (next === null) {\n            completeUnitOfWork(unitOfWork);\n          } else {\n            workInProgress = next;\n          }\n          ReactCurrentOwner$2.current = null;\n        }\n        function completeUnitOfWork(unitOfWork) {\n          var completedWork = unitOfWork;\n          do {\n            var current2 = completedWork.alternate;\n            var returnFiber = completedWork.return;\n            if ((completedWork.flags & Incomplete) === NoFlags) {\n              setCurrentFiber(completedWork);\n              var next = void 0;\n              if ((completedWork.mode & ProfileMode) === NoMode) {\n                next = completeWork(current2, completedWork, subtreeRenderLanes);\n              } else {\n                startProfilerTimer(completedWork);\n                next = completeWork(current2, completedWork, subtreeRenderLanes);\n                stopProfilerTimerIfRunningAndRecordDelta(completedWork, false);\n              }\n              resetCurrentFiber();\n              if (next !== null) {\n                workInProgress = next;\n                return;\n              }\n            } else {\n              var _next = unwindWork(current2, completedWork);\n              if (_next !== null) {\n                _next.flags &= HostEffectMask;\n                workInProgress = _next;\n                return;\n              }\n              if ((completedWork.mode & ProfileMode) !== NoMode) {\n                stopProfilerTimerIfRunningAndRecordDelta(completedWork, false);\n                var actualDuration = completedWork.actualDuration;\n                var child = completedWork.child;\n                while (child !== null) {\n                  actualDuration += child.actualDuration;\n                  child = child.sibling;\n                }\n                completedWork.actualDuration = actualDuration;\n              }\n              if (returnFiber !== null) {\n                returnFiber.flags |= Incomplete;\n                returnFiber.subtreeFlags = NoFlags;\n                returnFiber.deletions = null;\n              } else {\n                workInProgressRootExitStatus = RootDidNotComplete;\n                workInProgress = null;\n                return;\n              }\n            }\n            var siblingFiber = completedWork.sibling;\n            if (siblingFiber !== null) {\n              workInProgress = siblingFiber;\n              return;\n            }\n            completedWork = returnFiber;\n            workInProgress = completedWork;\n          } while (completedWork !== null);\n          if (workInProgressRootExitStatus === RootInProgress) {\n            workInProgressRootExitStatus = RootCompleted;\n          }\n        }\n        function commitRoot(root2, recoverableErrors, transitions) {\n          var previousUpdateLanePriority = getCurrentUpdatePriority();\n          var prevTransition = ReactCurrentBatchConfig$3.transition;\n          try {\n            ReactCurrentBatchConfig$3.transition = null;\n            setCurrentUpdatePriority(DiscreteEventPriority);\n            commitRootImpl(root2, recoverableErrors, transitions, previousUpdateLanePriority);\n          } finally {\n            ReactCurrentBatchConfig$3.transition = prevTransition;\n            setCurrentUpdatePriority(previousUpdateLanePriority);\n          }\n          return null;\n        }\n        function commitRootImpl(root2, recoverableErrors, transitions, renderPriorityLevel) {\n          do {\n            flushPassiveEffects();\n          } while (rootWithPendingPassiveEffects !== null);\n          flushRenderPhaseStrictModeWarningsInDEV();\n          if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\n            throw new Error(\"Should not already be working.\");\n          }\n          var finishedWork = root2.finishedWork;\n          var lanes = root2.finishedLanes;\n          {\n            markCommitStarted(lanes);\n          }\n          if (finishedWork === null) {\n            {\n              markCommitStopped();\n            }\n            return null;\n          } else {\n            {\n              if (lanes === NoLanes) {\n                error(\"root.finishedLanes should not be empty during a commit. This is a bug in React.\");\n              }\n            }\n          }\n          root2.finishedWork = null;\n          root2.finishedLanes = NoLanes;\n          if (finishedWork === root2.current) {\n            throw new Error(\"Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue.\");\n          }\n          root2.callbackNode = null;\n          root2.callbackPriority = NoLane;\n          var remainingLanes = mergeLanes(finishedWork.lanes, finishedWork.childLanes);\n          markRootFinished(root2, remainingLanes);\n          if (root2 === workInProgressRoot) {\n            workInProgressRoot = null;\n            workInProgress = null;\n            workInProgressRootRenderLanes = NoLanes;\n          }\n          if ((finishedWork.subtreeFlags & PassiveMask) !== NoFlags || (finishedWork.flags & PassiveMask) !== NoFlags) {\n            if (!rootDoesHavePassiveEffects) {\n              rootDoesHavePassiveEffects = true;\n              pendingPassiveTransitions = transitions;\n              scheduleCallback$1(NormalPriority, function() {\n                flushPassiveEffects();\n                return null;\n              });\n            }\n          }\n          var subtreeHasEffects = (finishedWork.subtreeFlags & (BeforeMutationMask | MutationMask | LayoutMask | PassiveMask)) !== NoFlags;\n          var rootHasEffect = (finishedWork.flags & (BeforeMutationMask | MutationMask | LayoutMask | PassiveMask)) !== NoFlags;\n          if (subtreeHasEffects || rootHasEffect) {\n            var prevTransition = ReactCurrentBatchConfig$3.transition;\n            ReactCurrentBatchConfig$3.transition = null;\n            var previousPriority = getCurrentUpdatePriority();\n            setCurrentUpdatePriority(DiscreteEventPriority);\n            var prevExecutionContext = executionContext;\n            executionContext |= CommitContext;\n            ReactCurrentOwner$2.current = null;\n            var shouldFireAfterActiveInstanceBlur2 = commitBeforeMutationEffects(root2, finishedWork);\n            {\n              recordCommitTime();\n            }\n            commitMutationEffects(root2, finishedWork, lanes);\n            resetAfterCommit(root2.containerInfo);\n            root2.current = finishedWork;\n            {\n              markLayoutEffectsStarted(lanes);\n            }\n            commitLayoutEffects(finishedWork, root2, lanes);\n            {\n              markLayoutEffectsStopped();\n            }\n            requestPaint();\n            executionContext = prevExecutionContext;\n            setCurrentUpdatePriority(previousPriority);\n            ReactCurrentBatchConfig$3.transition = prevTransition;\n          } else {\n            root2.current = finishedWork;\n            {\n              recordCommitTime();\n            }\n          }\n          var rootDidHavePassiveEffects = rootDoesHavePassiveEffects;\n          if (rootDoesHavePassiveEffects) {\n            rootDoesHavePassiveEffects = false;\n            rootWithPendingPassiveEffects = root2;\n            pendingPassiveEffectsLanes = lanes;\n          } else {\n            {\n              nestedPassiveUpdateCount = 0;\n              rootWithPassiveNestedUpdates = null;\n            }\n          }\n          remainingLanes = root2.pendingLanes;\n          if (remainingLanes === NoLanes) {\n            legacyErrorBoundariesThatAlreadyFailed = null;\n          }\n          {\n            if (!rootDidHavePassiveEffects) {\n              commitDoubleInvokeEffectsInDEV(root2.current, false);\n            }\n          }\n          onCommitRoot(finishedWork.stateNode, renderPriorityLevel);\n          {\n            if (isDevToolsPresent) {\n              root2.memoizedUpdaters.clear();\n            }\n          }\n          {\n            onCommitRoot$1();\n          }\n          ensureRootIsScheduled(root2, now());\n          if (recoverableErrors !== null) {\n            var onRecoverableError = root2.onRecoverableError;\n            for (var i = 0; i < recoverableErrors.length; i++) {\n              var recoverableError = recoverableErrors[i];\n              var componentStack = recoverableError.stack;\n              var digest = recoverableError.digest;\n              onRecoverableError(recoverableError.value, {\n                componentStack,\n                digest\n              });\n            }\n          }\n          if (hasUncaughtError) {\n            hasUncaughtError = false;\n            var error$1 = firstUncaughtError;\n            firstUncaughtError = null;\n            throw error$1;\n          }\n          if (includesSomeLane(pendingPassiveEffectsLanes, SyncLane) && root2.tag !== LegacyRoot) {\n            flushPassiveEffects();\n          }\n          remainingLanes = root2.pendingLanes;\n          if (includesSomeLane(remainingLanes, SyncLane)) {\n            {\n              markNestedUpdateScheduled();\n            }\n            if (root2 === rootWithNestedUpdates) {\n              nestedUpdateCount++;\n            } else {\n              nestedUpdateCount = 0;\n              rootWithNestedUpdates = root2;\n            }\n          } else {\n            nestedUpdateCount = 0;\n          }\n          flushSyncCallbacks();\n          {\n            markCommitStopped();\n          }\n          return null;\n        }\n        function flushPassiveEffects() {\n          if (rootWithPendingPassiveEffects !== null) {\n            var renderPriority = lanesToEventPriority(pendingPassiveEffectsLanes);\n            var priority = lowerEventPriority(DefaultEventPriority, renderPriority);\n            var prevTransition = ReactCurrentBatchConfig$3.transition;\n            var previousPriority = getCurrentUpdatePriority();\n            try {\n              ReactCurrentBatchConfig$3.transition = null;\n              setCurrentUpdatePriority(priority);\n              return flushPassiveEffectsImpl();\n            } finally {\n              setCurrentUpdatePriority(previousPriority);\n              ReactCurrentBatchConfig$3.transition = prevTransition;\n            }\n          }\n          return false;\n        }\n        function enqueuePendingPassiveProfilerEffect(fiber) {\n          {\n            pendingPassiveProfilerEffects.push(fiber);\n            if (!rootDoesHavePassiveEffects) {\n              rootDoesHavePassiveEffects = true;\n              scheduleCallback$1(NormalPriority, function() {\n                flushPassiveEffects();\n                return null;\n              });\n            }\n          }\n        }\n        function flushPassiveEffectsImpl() {\n          if (rootWithPendingPassiveEffects === null) {\n            return false;\n          }\n          var transitions = pendingPassiveTransitions;\n          pendingPassiveTransitions = null;\n          var root2 = rootWithPendingPassiveEffects;\n          var lanes = pendingPassiveEffectsLanes;\n          rootWithPendingPassiveEffects = null;\n          pendingPassiveEffectsLanes = NoLanes;\n          if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\n            throw new Error(\"Cannot flush passive effects while already rendering.\");\n          }\n          {\n            isFlushingPassiveEffects = true;\n            didScheduleUpdateDuringPassiveEffects = false;\n          }\n          {\n            markPassiveEffectsStarted(lanes);\n          }\n          var prevExecutionContext = executionContext;\n          executionContext |= CommitContext;\n          commitPassiveUnmountEffects(root2.current);\n          commitPassiveMountEffects(root2, root2.current, lanes, transitions);\n          {\n            var profilerEffects = pendingPassiveProfilerEffects;\n            pendingPassiveProfilerEffects = [];\n            for (var i = 0; i < profilerEffects.length; i++) {\n              var _fiber = profilerEffects[i];\n              commitPassiveEffectDurations(root2, _fiber);\n            }\n          }\n          {\n            markPassiveEffectsStopped();\n          }\n          {\n            commitDoubleInvokeEffectsInDEV(root2.current, true);\n          }\n          executionContext = prevExecutionContext;\n          flushSyncCallbacks();\n          {\n            if (didScheduleUpdateDuringPassiveEffects) {\n              if (root2 === rootWithPassiveNestedUpdates) {\n                nestedPassiveUpdateCount++;\n              } else {\n                nestedPassiveUpdateCount = 0;\n                rootWithPassiveNestedUpdates = root2;\n              }\n            } else {\n              nestedPassiveUpdateCount = 0;\n            }\n            isFlushingPassiveEffects = false;\n            didScheduleUpdateDuringPassiveEffects = false;\n          }\n          onPostCommitRoot(root2);\n          {\n            var stateNode = root2.current.stateNode;\n            stateNode.effectDuration = 0;\n            stateNode.passiveEffectDuration = 0;\n          }\n          return true;\n        }\n        function isAlreadyFailedLegacyErrorBoundary(instance) {\n          return legacyErrorBoundariesThatAlreadyFailed !== null && legacyErrorBoundariesThatAlreadyFailed.has(instance);\n        }\n        function markLegacyErrorBoundaryAsFailed(instance) {\n          if (legacyErrorBoundariesThatAlreadyFailed === null) {\n            legacyErrorBoundariesThatAlreadyFailed = /* @__PURE__ */ new Set([instance]);\n          } else {\n            legacyErrorBoundariesThatAlreadyFailed.add(instance);\n          }\n        }\n        function prepareToThrowUncaughtError(error2) {\n          if (!hasUncaughtError) {\n            hasUncaughtError = true;\n            firstUncaughtError = error2;\n          }\n        }\n        var onUncaughtError = prepareToThrowUncaughtError;\n        function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error2) {\n          var errorInfo = createCapturedValueAtFiber(error2, sourceFiber);\n          var update = createRootErrorUpdate(rootFiber, errorInfo, SyncLane);\n          var root2 = enqueueUpdate(rootFiber, update, SyncLane);\n          var eventTime = requestEventTime();\n          if (root2 !== null) {\n            markRootUpdated(root2, SyncLane, eventTime);\n            ensureRootIsScheduled(root2, eventTime);\n          }\n        }\n        function captureCommitPhaseError(sourceFiber, nearestMountedAncestor, error$1) {\n          {\n            reportUncaughtErrorInDEV(error$1);\n            setIsRunningInsertionEffect(false);\n          }\n          if (sourceFiber.tag === HostRoot) {\n            captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error$1);\n            return;\n          }\n          var fiber = null;\n          {\n            fiber = nearestMountedAncestor;\n          }\n          while (fiber !== null) {\n            if (fiber.tag === HostRoot) {\n              captureCommitPhaseErrorOnRoot(fiber, sourceFiber, error$1);\n              return;\n            } else if (fiber.tag === ClassComponent) {\n              var ctor = fiber.type;\n              var instance = fiber.stateNode;\n              if (typeof ctor.getDerivedStateFromError === \"function\" || typeof instance.componentDidCatch === \"function\" && !isAlreadyFailedLegacyErrorBoundary(instance)) {\n                var errorInfo = createCapturedValueAtFiber(error$1, sourceFiber);\n                var update = createClassErrorUpdate(fiber, errorInfo, SyncLane);\n                var root2 = enqueueUpdate(fiber, update, SyncLane);\n                var eventTime = requestEventTime();\n                if (root2 !== null) {\n                  markRootUpdated(root2, SyncLane, eventTime);\n                  ensureRootIsScheduled(root2, eventTime);\n                }\n                return;\n              }\n            }\n            fiber = fiber.return;\n          }\n          {\n            error(\"Internal React error: Attempted to capture a commit phase error inside a detached tree. This indicates a bug in React. Likely causes include deleting the same fiber more than once, committing an already-finished tree, or an inconsistent return pointer.\\n\\nError message:\\n\\n%s\", error$1);\n          }\n        }\n        function pingSuspendedRoot(root2, wakeable, pingedLanes) {\n          var pingCache = root2.pingCache;\n          if (pingCache !== null) {\n            pingCache.delete(wakeable);\n          }\n          var eventTime = requestEventTime();\n          markRootPinged(root2, pingedLanes);\n          warnIfSuspenseResolutionNotWrappedWithActDEV(root2);\n          if (workInProgressRoot === root2 && isSubsetOfLanes(workInProgressRootRenderLanes, pingedLanes)) {\n            if (workInProgressRootExitStatus === RootSuspendedWithDelay || workInProgressRootExitStatus === RootSuspended && includesOnlyRetries(workInProgressRootRenderLanes) && now() - globalMostRecentFallbackTime < FALLBACK_THROTTLE_MS) {\n              prepareFreshStack(root2, NoLanes);\n            } else {\n              workInProgressRootPingedLanes = mergeLanes(workInProgressRootPingedLanes, pingedLanes);\n            }\n          }\n          ensureRootIsScheduled(root2, eventTime);\n        }\n        function retryTimedOutBoundary(boundaryFiber, retryLane) {\n          if (retryLane === NoLane) {\n            retryLane = requestRetryLane(boundaryFiber);\n          }\n          var eventTime = requestEventTime();\n          var root2 = enqueueConcurrentRenderForLane(boundaryFiber, retryLane);\n          if (root2 !== null) {\n            markRootUpdated(root2, retryLane, eventTime);\n            ensureRootIsScheduled(root2, eventTime);\n          }\n        }\n        function retryDehydratedSuspenseBoundary(boundaryFiber) {\n          var suspenseState = boundaryFiber.memoizedState;\n          var retryLane = NoLane;\n          if (suspenseState !== null) {\n            retryLane = suspenseState.retryLane;\n          }\n          retryTimedOutBoundary(boundaryFiber, retryLane);\n        }\n        function resolveRetryWakeable(boundaryFiber, wakeable) {\n          var retryLane = NoLane;\n          var retryCache;\n          switch (boundaryFiber.tag) {\n            case SuspenseComponent:\n              retryCache = boundaryFiber.stateNode;\n              var suspenseState = boundaryFiber.memoizedState;\n              if (suspenseState !== null) {\n                retryLane = suspenseState.retryLane;\n              }\n              break;\n            case SuspenseListComponent:\n              retryCache = boundaryFiber.stateNode;\n              break;\n            default:\n              throw new Error(\"Pinged unknown suspense boundary type. This is probably a bug in React.\");\n          }\n          if (retryCache !== null) {\n            retryCache.delete(wakeable);\n          }\n          retryTimedOutBoundary(boundaryFiber, retryLane);\n        }\n        function jnd(timeElapsed) {\n          return timeElapsed < 120 ? 120 : timeElapsed < 480 ? 480 : timeElapsed < 1080 ? 1080 : timeElapsed < 1920 ? 1920 : timeElapsed < 3e3 ? 3e3 : timeElapsed < 4320 ? 4320 : ceil(timeElapsed / 1960) * 1960;\n        }\n        function checkForNestedUpdates() {\n          if (nestedUpdateCount > NESTED_UPDATE_LIMIT) {\n            nestedUpdateCount = 0;\n            rootWithNestedUpdates = null;\n            throw new Error(\"Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.\");\n          }\n          {\n            if (nestedPassiveUpdateCount > NESTED_PASSIVE_UPDATE_LIMIT) {\n              nestedPassiveUpdateCount = 0;\n              rootWithPassiveNestedUpdates = null;\n              error(\"Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render.\");\n            }\n          }\n        }\n        function flushRenderPhaseStrictModeWarningsInDEV() {\n          {\n            ReactStrictModeWarnings.flushLegacyContextWarning();\n            {\n              ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();\n            }\n          }\n        }\n        function commitDoubleInvokeEffectsInDEV(fiber, hasPassiveEffects) {\n          {\n            setCurrentFiber(fiber);\n            invokeEffectsInDev(fiber, MountLayoutDev, invokeLayoutEffectUnmountInDEV);\n            if (hasPassiveEffects) {\n              invokeEffectsInDev(fiber, MountPassiveDev, invokePassiveEffectUnmountInDEV);\n            }\n            invokeEffectsInDev(fiber, MountLayoutDev, invokeLayoutEffectMountInDEV);\n            if (hasPassiveEffects) {\n              invokeEffectsInDev(fiber, MountPassiveDev, invokePassiveEffectMountInDEV);\n            }\n            resetCurrentFiber();\n          }\n        }\n        function invokeEffectsInDev(firstChild, fiberFlags, invokeEffectFn) {\n          {\n            var current2 = firstChild;\n            var subtreeRoot = null;\n            while (current2 !== null) {\n              var primarySubtreeFlag = current2.subtreeFlags & fiberFlags;\n              if (current2 !== subtreeRoot && current2.child !== null && primarySubtreeFlag !== NoFlags) {\n                current2 = current2.child;\n              } else {\n                if ((current2.flags & fiberFlags) !== NoFlags) {\n                  invokeEffectFn(current2);\n                }\n                if (current2.sibling !== null) {\n                  current2 = current2.sibling;\n                } else {\n                  current2 = subtreeRoot = current2.return;\n                }\n              }\n            }\n          }\n        }\n        var didWarnStateUpdateForNotYetMountedComponent = null;\n        function warnAboutUpdateOnNotYetMountedFiberInDEV(fiber) {\n          {\n            if ((executionContext & RenderContext) !== NoContext) {\n              return;\n            }\n            if (!(fiber.mode & ConcurrentMode)) {\n              return;\n            }\n            var tag = fiber.tag;\n            if (tag !== IndeterminateComponent && tag !== HostRoot && tag !== ClassComponent && tag !== FunctionComponent && tag !== ForwardRef && tag !== MemoComponent && tag !== SimpleMemoComponent) {\n              return;\n            }\n            var componentName = getComponentNameFromFiber(fiber) || \"ReactComponent\";\n            if (didWarnStateUpdateForNotYetMountedComponent !== null) {\n              if (didWarnStateUpdateForNotYetMountedComponent.has(componentName)) {\n                return;\n              }\n              didWarnStateUpdateForNotYetMountedComponent.add(componentName);\n            } else {\n              didWarnStateUpdateForNotYetMountedComponent = /* @__PURE__ */ new Set([componentName]);\n            }\n            var previousFiber = current;\n            try {\n              setCurrentFiber(fiber);\n              error(\"Can't perform a React state update on a component that hasn't mounted yet. This indicates that you have a side-effect in your render function that asynchronously later calls tries to update the component. Move this work to useEffect instead.\");\n            } finally {\n              if (previousFiber) {\n                setCurrentFiber(fiber);\n              } else {\n                resetCurrentFiber();\n              }\n            }\n          }\n        }\n        var beginWork$1;\n        {\n          var dummyFiber = null;\n          beginWork$1 = function(current2, unitOfWork, lanes) {\n            var originalWorkInProgressCopy = assignFiberPropertiesInDEV(dummyFiber, unitOfWork);\n            try {\n              return beginWork(current2, unitOfWork, lanes);\n            } catch (originalError) {\n              if (didSuspendOrErrorWhileHydratingDEV() || originalError !== null && typeof originalError === \"object\" && typeof originalError.then === \"function\") {\n                throw originalError;\n              }\n              resetContextDependencies();\n              resetHooksAfterThrow();\n              unwindInterruptedWork(current2, unitOfWork);\n              assignFiberPropertiesInDEV(unitOfWork, originalWorkInProgressCopy);\n              if (unitOfWork.mode & ProfileMode) {\n                startProfilerTimer(unitOfWork);\n              }\n              invokeGuardedCallback(null, beginWork, null, current2, unitOfWork, lanes);\n              if (hasCaughtError()) {\n                var replayError = clearCaughtError();\n                if (typeof replayError === \"object\" && replayError !== null && replayError._suppressLogging && typeof originalError === \"object\" && originalError !== null && !originalError._suppressLogging) {\n                  originalError._suppressLogging = true;\n                }\n              }\n              throw originalError;\n            }\n          };\n        }\n        var didWarnAboutUpdateInRender = false;\n        var didWarnAboutUpdateInRenderForAnotherComponent;\n        {\n          didWarnAboutUpdateInRenderForAnotherComponent = /* @__PURE__ */ new Set();\n        }\n        function warnAboutRenderPhaseUpdatesInDEV(fiber) {\n          {\n            if (isRendering && !getIsUpdatingOpaqueValueInRenderPhaseInDEV()) {\n              switch (fiber.tag) {\n                case FunctionComponent:\n                case ForwardRef:\n                case SimpleMemoComponent: {\n                  var renderingComponentName = workInProgress && getComponentNameFromFiber(workInProgress) || \"Unknown\";\n                  var dedupeKey = renderingComponentName;\n                  if (!didWarnAboutUpdateInRenderForAnotherComponent.has(dedupeKey)) {\n                    didWarnAboutUpdateInRenderForAnotherComponent.add(dedupeKey);\n                    var setStateComponentName = getComponentNameFromFiber(fiber) || \"Unknown\";\n                    error(\"Cannot update a component (`%s`) while rendering a different component (`%s`). To locate the bad setState() call inside `%s`, follow the stack trace as described in https://reactjs.org/link/setstate-in-render\", setStateComponentName, renderingComponentName, renderingComponentName);\n                  }\n                  break;\n                }\n                case ClassComponent: {\n                  if (!didWarnAboutUpdateInRender) {\n                    error(\"Cannot update during an existing state transition (such as within `render`). Render methods should be a pure function of props and state.\");\n                    didWarnAboutUpdateInRender = true;\n                  }\n                  break;\n                }\n              }\n            }\n          }\n        }\n        function restorePendingUpdaters(root2, lanes) {\n          {\n            if (isDevToolsPresent) {\n              var memoizedUpdaters = root2.memoizedUpdaters;\n              memoizedUpdaters.forEach(function(schedulingFiber) {\n                addFiberToLanesMap(root2, schedulingFiber, lanes);\n              });\n            }\n          }\n        }\n        var fakeActCallbackNode = {};\n        function scheduleCallback$1(priorityLevel, callback) {\n          {\n            var actQueue = ReactCurrentActQueue$1.current;\n            if (actQueue !== null) {\n              actQueue.push(callback);\n              return fakeActCallbackNode;\n            } else {\n              return scheduleCallback(priorityLevel, callback);\n            }\n          }\n        }\n        function cancelCallback$1(callbackNode) {\n          if (callbackNode === fakeActCallbackNode) {\n            return;\n          }\n          return cancelCallback(callbackNode);\n        }\n        function shouldForceFlushFallbacksInDEV() {\n          return ReactCurrentActQueue$1.current !== null;\n        }\n        function warnIfUpdatesNotWrappedWithActDEV(fiber) {\n          {\n            if (fiber.mode & ConcurrentMode) {\n              if (!isConcurrentActEnvironment()) {\n                return;\n              }\n            } else {\n              if (!isLegacyActEnvironment()) {\n                return;\n              }\n              if (executionContext !== NoContext) {\n                return;\n              }\n              if (fiber.tag !== FunctionComponent && fiber.tag !== ForwardRef && fiber.tag !== SimpleMemoComponent) {\n                return;\n              }\n            }\n            if (ReactCurrentActQueue$1.current === null) {\n              var previousFiber = current;\n              try {\n                setCurrentFiber(fiber);\n                error(\"An update to %s inside a test was not wrapped in act(...).\\n\\nWhen testing, code that causes React state updates should be wrapped into act(...):\\n\\nact(() => {\\n  /* fire events that update state */\\n});\\n/* assert on the output */\\n\\nThis ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act\", getComponentNameFromFiber(fiber));\n              } finally {\n                if (previousFiber) {\n                  setCurrentFiber(fiber);\n                } else {\n                  resetCurrentFiber();\n                }\n              }\n            }\n          }\n        }\n        function warnIfSuspenseResolutionNotWrappedWithActDEV(root2) {\n          {\n            if (root2.tag !== LegacyRoot && isConcurrentActEnvironment() && ReactCurrentActQueue$1.current === null) {\n              error(\"A suspended resource finished loading inside a test, but the event was not wrapped in act(...).\\n\\nWhen testing, code that resolves suspended data should be wrapped into act(...):\\n\\nact(() => {\\n  /* finish loading suspended data */\\n});\\n/* assert on the output */\\n\\nThis ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act\");\n            }\n          }\n        }\n        function setIsRunningInsertionEffect(isRunning) {\n          {\n            isRunningInsertionEffect = isRunning;\n          }\n        }\n        var resolveFamily = null;\n        var failedBoundaries = null;\n        var setRefreshHandler = function(handler) {\n          {\n            resolveFamily = handler;\n          }\n        };\n        function resolveFunctionForHotReloading(type) {\n          {\n            if (resolveFamily === null) {\n              return type;\n            }\n            var family = resolveFamily(type);\n            if (family === void 0) {\n              return type;\n            }\n            return family.current;\n          }\n        }\n        function resolveClassForHotReloading(type) {\n          return resolveFunctionForHotReloading(type);\n        }\n        function resolveForwardRefForHotReloading(type) {\n          {\n            if (resolveFamily === null) {\n              return type;\n            }\n            var family = resolveFamily(type);\n            if (family === void 0) {\n              if (type !== null && type !== void 0 && typeof type.render === \"function\") {\n                var currentRender = resolveFunctionForHotReloading(type.render);\n                if (type.render !== currentRender) {\n                  var syntheticType = {\n                    $$typeof: REACT_FORWARD_REF_TYPE,\n                    render: currentRender\n                  };\n                  if (type.displayName !== void 0) {\n                    syntheticType.displayName = type.displayName;\n                  }\n                  return syntheticType;\n                }\n              }\n              return type;\n            }\n            return family.current;\n          }\n        }\n        function isCompatibleFamilyForHotReloading(fiber, element) {\n          {\n            if (resolveFamily === null) {\n              return false;\n            }\n            var prevType = fiber.elementType;\n            var nextType = element.type;\n            var needsCompareFamilies = false;\n            var $$typeofNextType = typeof nextType === \"object\" && nextType !== null ? nextType.$$typeof : null;\n            switch (fiber.tag) {\n              case ClassComponent: {\n                if (typeof nextType === \"function\") {\n                  needsCompareFamilies = true;\n                }\n                break;\n              }\n              case FunctionComponent: {\n                if (typeof nextType === \"function\") {\n                  needsCompareFamilies = true;\n                } else if ($$typeofNextType === REACT_LAZY_TYPE) {\n                  needsCompareFamilies = true;\n                }\n                break;\n              }\n              case ForwardRef: {\n                if ($$typeofNextType === REACT_FORWARD_REF_TYPE) {\n                  needsCompareFamilies = true;\n                } else if ($$typeofNextType === REACT_LAZY_TYPE) {\n                  needsCompareFamilies = true;\n                }\n                break;\n              }\n              case MemoComponent:\n              case SimpleMemoComponent: {\n                if ($$typeofNextType === REACT_MEMO_TYPE) {\n                  needsCompareFamilies = true;\n                } else if ($$typeofNextType === REACT_LAZY_TYPE) {\n                  needsCompareFamilies = true;\n                }\n                break;\n              }\n              default:\n                return false;\n            }\n            if (needsCompareFamilies) {\n              var prevFamily = resolveFamily(prevType);\n              if (prevFamily !== void 0 && prevFamily === resolveFamily(nextType)) {\n                return true;\n              }\n            }\n            return false;\n          }\n        }\n        function markFailedErrorBoundaryForHotReloading(fiber) {\n          {\n            if (resolveFamily === null) {\n              return;\n            }\n            if (typeof WeakSet !== \"function\") {\n              return;\n            }\n            if (failedBoundaries === null) {\n              failedBoundaries = /* @__PURE__ */ new WeakSet();\n            }\n            failedBoundaries.add(fiber);\n          }\n        }\n        var scheduleRefresh = function(root2, update) {\n          {\n            if (resolveFamily === null) {\n              return;\n            }\n            var staleFamilies = update.staleFamilies, updatedFamilies = update.updatedFamilies;\n            flushPassiveEffects();\n            flushSync(function() {\n              scheduleFibersWithFamiliesRecursively(root2.current, updatedFamilies, staleFamilies);\n            });\n          }\n        };\n        var scheduleRoot = function(root2, element) {\n          {\n            if (root2.context !== emptyContextObject) {\n              return;\n            }\n            flushPassiveEffects();\n            flushSync(function() {\n              updateContainer(element, root2, null, null);\n            });\n          }\n        };\n        function scheduleFibersWithFamiliesRecursively(fiber, updatedFamilies, staleFamilies) {\n          {\n            var alternate = fiber.alternate, child = fiber.child, sibling = fiber.sibling, tag = fiber.tag, type = fiber.type;\n            var candidateType = null;\n            switch (tag) {\n              case FunctionComponent:\n              case SimpleMemoComponent:\n              case ClassComponent:\n                candidateType = type;\n                break;\n              case ForwardRef:\n                candidateType = type.render;\n                break;\n            }\n            if (resolveFamily === null) {\n              throw new Error(\"Expected resolveFamily to be set during hot reload.\");\n            }\n            var needsRender = false;\n            var needsRemount = false;\n            if (candidateType !== null) {\n              var family = resolveFamily(candidateType);\n              if (family !== void 0) {\n                if (staleFamilies.has(family)) {\n                  needsRemount = true;\n                } else if (updatedFamilies.has(family)) {\n                  if (tag === ClassComponent) {\n                    needsRemount = true;\n                  } else {\n                    needsRender = true;\n                  }\n                }\n              }\n            }\n            if (failedBoundaries !== null) {\n              if (failedBoundaries.has(fiber) || alternate !== null && failedBoundaries.has(alternate)) {\n                needsRemount = true;\n              }\n            }\n            if (needsRemount) {\n              fiber._debugNeedsRemount = true;\n            }\n            if (needsRemount || needsRender) {\n              var _root = enqueueConcurrentRenderForLane(fiber, SyncLane);\n              if (_root !== null) {\n                scheduleUpdateOnFiber(_root, fiber, SyncLane, NoTimestamp);\n              }\n            }\n            if (child !== null && !needsRemount) {\n              scheduleFibersWithFamiliesRecursively(child, updatedFamilies, staleFamilies);\n            }\n            if (sibling !== null) {\n              scheduleFibersWithFamiliesRecursively(sibling, updatedFamilies, staleFamilies);\n            }\n          }\n        }\n        var findHostInstancesForRefresh = function(root2, families) {\n          {\n            var hostInstances = /* @__PURE__ */ new Set();\n            var types = new Set(families.map(function(family) {\n              return family.current;\n            }));\n            findHostInstancesForMatchingFibersRecursively(root2.current, types, hostInstances);\n            return hostInstances;\n          }\n        };\n        function findHostInstancesForMatchingFibersRecursively(fiber, types, hostInstances) {\n          {\n            var child = fiber.child, sibling = fiber.sibling, tag = fiber.tag, type = fiber.type;\n            var candidateType = null;\n            switch (tag) {\n              case FunctionComponent:\n              case SimpleMemoComponent:\n              case ClassComponent:\n                candidateType = type;\n                break;\n              case ForwardRef:\n                candidateType = type.render;\n                break;\n            }\n            var didMatch = false;\n            if (candidateType !== null) {\n              if (types.has(candidateType)) {\n                didMatch = true;\n              }\n            }\n            if (didMatch) {\n              findHostInstancesForFiberShallowly(fiber, hostInstances);\n            } else {\n              if (child !== null) {\n                findHostInstancesForMatchingFibersRecursively(child, types, hostInstances);\n              }\n            }\n            if (sibling !== null) {\n              findHostInstancesForMatchingFibersRecursively(sibling, types, hostInstances);\n            }\n          }\n        }\n        function findHostInstancesForFiberShallowly(fiber, hostInstances) {\n          {\n            var foundHostInstances = findChildHostInstancesForFiberShallowly(fiber, hostInstances);\n            if (foundHostInstances) {\n              return;\n            }\n            var node = fiber;\n            while (true) {\n              switch (node.tag) {\n                case HostComponent:\n                  hostInstances.add(node.stateNode);\n                  return;\n                case HostPortal:\n                  hostInstances.add(node.stateNode.containerInfo);\n                  return;\n                case HostRoot:\n                  hostInstances.add(node.stateNode.containerInfo);\n                  return;\n              }\n              if (node.return === null) {\n                throw new Error(\"Expected to reach root first.\");\n              }\n              node = node.return;\n            }\n          }\n        }\n        function findChildHostInstancesForFiberShallowly(fiber, hostInstances) {\n          {\n            var node = fiber;\n            var foundHostInstances = false;\n            while (true) {\n              if (node.tag === HostComponent) {\n                foundHostInstances = true;\n                hostInstances.add(node.stateNode);\n              } else if (node.child !== null) {\n                node.child.return = node;\n                node = node.child;\n                continue;\n              }\n              if (node === fiber) {\n                return foundHostInstances;\n              }\n              while (node.sibling === null) {\n                if (node.return === null || node.return === fiber) {\n                  return foundHostInstances;\n                }\n                node = node.return;\n              }\n              node.sibling.return = node.return;\n              node = node.sibling;\n            }\n          }\n          return false;\n        }\n        var hasBadMapPolyfill;\n        {\n          hasBadMapPolyfill = false;\n          try {\n            var nonExtensibleObject = Object.preventExtensions({});\n            /* @__PURE__ */ new Map([[nonExtensibleObject, null]]);\n            /* @__PURE__ */ new Set([nonExtensibleObject]);\n          } catch (e) {\n            hasBadMapPolyfill = true;\n          }\n        }\n        function FiberNode(tag, pendingProps, key, mode) {\n          this.tag = tag;\n          this.key = key;\n          this.elementType = null;\n          this.type = null;\n          this.stateNode = null;\n          this.return = null;\n          this.child = null;\n          this.sibling = null;\n          this.index = 0;\n          this.ref = null;\n          this.pendingProps = pendingProps;\n          this.memoizedProps = null;\n          this.updateQueue = null;\n          this.memoizedState = null;\n          this.dependencies = null;\n          this.mode = mode;\n          this.flags = NoFlags;\n          this.subtreeFlags = NoFlags;\n          this.deletions = null;\n          this.lanes = NoLanes;\n          this.childLanes = NoLanes;\n          this.alternate = null;\n          {\n            this.actualDuration = Number.NaN;\n            this.actualStartTime = Number.NaN;\n            this.selfBaseDuration = Number.NaN;\n            this.treeBaseDuration = Number.NaN;\n            this.actualDuration = 0;\n            this.actualStartTime = -1;\n            this.selfBaseDuration = 0;\n            this.treeBaseDuration = 0;\n          }\n          {\n            this._debugSource = null;\n            this._debugOwner = null;\n            this._debugNeedsRemount = false;\n            this._debugHookTypes = null;\n            if (!hasBadMapPolyfill && typeof Object.preventExtensions === \"function\") {\n              Object.preventExtensions(this);\n            }\n          }\n        }\n        var createFiber = function(tag, pendingProps, key, mode) {\n          return new FiberNode(tag, pendingProps, key, mode);\n        };\n        function shouldConstruct$1(Component) {\n          var prototype = Component.prototype;\n          return !!(prototype && prototype.isReactComponent);\n        }\n        function isSimpleFunctionComponent(type) {\n          return typeof type === \"function\" && !shouldConstruct$1(type) && type.defaultProps === void 0;\n        }\n        function resolveLazyComponentTag(Component) {\n          if (typeof Component === \"function\") {\n            return shouldConstruct$1(Component) ? ClassComponent : FunctionComponent;\n          } else if (Component !== void 0 && Component !== null) {\n            var $$typeof = Component.$$typeof;\n            if ($$typeof === REACT_FORWARD_REF_TYPE) {\n              return ForwardRef;\n            }\n            if ($$typeof === REACT_MEMO_TYPE) {\n              return MemoComponent;\n            }\n          }\n          return IndeterminateComponent;\n        }\n        function createWorkInProgress(current2, pendingProps) {\n          var workInProgress2 = current2.alternate;\n          if (workInProgress2 === null) {\n            workInProgress2 = createFiber(current2.tag, pendingProps, current2.key, current2.mode);\n            workInProgress2.elementType = current2.elementType;\n            workInProgress2.type = current2.type;\n            workInProgress2.stateNode = current2.stateNode;\n            {\n              workInProgress2._debugSource = current2._debugSource;\n              workInProgress2._debugOwner = current2._debugOwner;\n              workInProgress2._debugHookTypes = current2._debugHookTypes;\n            }\n            workInProgress2.alternate = current2;\n            current2.alternate = workInProgress2;\n          } else {\n            workInProgress2.pendingProps = pendingProps;\n            workInProgress2.type = current2.type;\n            workInProgress2.flags = NoFlags;\n            workInProgress2.subtreeFlags = NoFlags;\n            workInProgress2.deletions = null;\n            {\n              workInProgress2.actualDuration = 0;\n              workInProgress2.actualStartTime = -1;\n            }\n          }\n          workInProgress2.flags = current2.flags & StaticMask;\n          workInProgress2.childLanes = current2.childLanes;\n          workInProgress2.lanes = current2.lanes;\n          workInProgress2.child = current2.child;\n          workInProgress2.memoizedProps = current2.memoizedProps;\n          workInProgress2.memoizedState = current2.memoizedState;\n          workInProgress2.updateQueue = current2.updateQueue;\n          var currentDependencies = current2.dependencies;\n          workInProgress2.dependencies = currentDependencies === null ? null : {\n            lanes: currentDependencies.lanes,\n            firstContext: currentDependencies.firstContext\n          };\n          workInProgress2.sibling = current2.sibling;\n          workInProgress2.index = current2.index;\n          workInProgress2.ref = current2.ref;\n          {\n            workInProgress2.selfBaseDuration = current2.selfBaseDuration;\n            workInProgress2.treeBaseDuration = current2.treeBaseDuration;\n          }\n          {\n            workInProgress2._debugNeedsRemount = current2._debugNeedsRemount;\n            switch (workInProgress2.tag) {\n              case IndeterminateComponent:\n              case FunctionComponent:\n              case SimpleMemoComponent:\n                workInProgress2.type = resolveFunctionForHotReloading(current2.type);\n                break;\n              case ClassComponent:\n                workInProgress2.type = resolveClassForHotReloading(current2.type);\n                break;\n              case ForwardRef:\n                workInProgress2.type = resolveForwardRefForHotReloading(current2.type);\n                break;\n            }\n          }\n          return workInProgress2;\n        }\n        function resetWorkInProgress(workInProgress2, renderLanes2) {\n          workInProgress2.flags &= StaticMask | Placement;\n          var current2 = workInProgress2.alternate;\n          if (current2 === null) {\n            workInProgress2.childLanes = NoLanes;\n            workInProgress2.lanes = renderLanes2;\n            workInProgress2.child = null;\n            workInProgress2.subtreeFlags = NoFlags;\n            workInProgress2.memoizedProps = null;\n            workInProgress2.memoizedState = null;\n            workInProgress2.updateQueue = null;\n            workInProgress2.dependencies = null;\n            workInProgress2.stateNode = null;\n            {\n              workInProgress2.selfBaseDuration = 0;\n              workInProgress2.treeBaseDuration = 0;\n            }\n          } else {\n            workInProgress2.childLanes = current2.childLanes;\n            workInProgress2.lanes = current2.lanes;\n            workInProgress2.child = current2.child;\n            workInProgress2.subtreeFlags = NoFlags;\n            workInProgress2.deletions = null;\n            workInProgress2.memoizedProps = current2.memoizedProps;\n            workInProgress2.memoizedState = current2.memoizedState;\n            workInProgress2.updateQueue = current2.updateQueue;\n            workInProgress2.type = current2.type;\n            var currentDependencies = current2.dependencies;\n            workInProgress2.dependencies = currentDependencies === null ? null : {\n              lanes: currentDependencies.lanes,\n              firstContext: currentDependencies.firstContext\n            };\n            {\n              workInProgress2.selfBaseDuration = current2.selfBaseDuration;\n              workInProgress2.treeBaseDuration = current2.treeBaseDuration;\n            }\n          }\n          return workInProgress2;\n        }\n        function createHostRootFiber(tag, isStrictMode, concurrentUpdatesByDefaultOverride) {\n          var mode;\n          if (tag === ConcurrentRoot) {\n            mode = ConcurrentMode;\n            if (isStrictMode === true) {\n              mode |= StrictLegacyMode;\n              {\n                mode |= StrictEffectsMode;\n              }\n            }\n          } else {\n            mode = NoMode;\n          }\n          if (isDevToolsPresent) {\n            mode |= ProfileMode;\n          }\n          return createFiber(HostRoot, null, null, mode);\n        }\n        function createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, lanes) {\n          var fiberTag = IndeterminateComponent;\n          var resolvedType = type;\n          if (typeof type === \"function\") {\n            if (shouldConstruct$1(type)) {\n              fiberTag = ClassComponent;\n              {\n                resolvedType = resolveClassForHotReloading(resolvedType);\n              }\n            } else {\n              {\n                resolvedType = resolveFunctionForHotReloading(resolvedType);\n              }\n            }\n          } else if (typeof type === \"string\") {\n            fiberTag = HostComponent;\n          } else {\n            getTag:\n              switch (type) {\n                case REACT_FRAGMENT_TYPE:\n                  return createFiberFromFragment(pendingProps.children, mode, lanes, key);\n                case REACT_STRICT_MODE_TYPE:\n                  fiberTag = Mode;\n                  mode |= StrictLegacyMode;\n                  if ((mode & ConcurrentMode) !== NoMode) {\n                    mode |= StrictEffectsMode;\n                  }\n                  break;\n                case REACT_PROFILER_TYPE:\n                  return createFiberFromProfiler(pendingProps, mode, lanes, key);\n                case REACT_SUSPENSE_TYPE:\n                  return createFiberFromSuspense(pendingProps, mode, lanes, key);\n                case REACT_SUSPENSE_LIST_TYPE:\n                  return createFiberFromSuspenseList(pendingProps, mode, lanes, key);\n                case REACT_OFFSCREEN_TYPE:\n                  return createFiberFromOffscreen(pendingProps, mode, lanes, key);\n                case REACT_LEGACY_HIDDEN_TYPE:\n                case REACT_SCOPE_TYPE:\n                case REACT_CACHE_TYPE:\n                case REACT_TRACING_MARKER_TYPE:\n                case REACT_DEBUG_TRACING_MODE_TYPE:\n                default: {\n                  if (typeof type === \"object\" && type !== null) {\n                    switch (type.$$typeof) {\n                      case REACT_PROVIDER_TYPE:\n                        fiberTag = ContextProvider;\n                        break getTag;\n                      case REACT_CONTEXT_TYPE:\n                        fiberTag = ContextConsumer;\n                        break getTag;\n                      case REACT_FORWARD_REF_TYPE:\n                        fiberTag = ForwardRef;\n                        {\n                          resolvedType = resolveForwardRefForHotReloading(resolvedType);\n                        }\n                        break getTag;\n                      case REACT_MEMO_TYPE:\n                        fiberTag = MemoComponent;\n                        break getTag;\n                      case REACT_LAZY_TYPE:\n                        fiberTag = LazyComponent;\n                        resolvedType = null;\n                        break getTag;\n                    }\n                  }\n                  var info = \"\";\n                  {\n                    if (type === void 0 || typeof type === \"object\" && type !== null && Object.keys(type).length === 0) {\n                      info += \" You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.\";\n                    }\n                    var ownerName = owner ? getComponentNameFromFiber(owner) : null;\n                    if (ownerName) {\n                      info += \"\\n\\nCheck the render method of `\" + ownerName + \"`.\";\n                    }\n                  }\n                  throw new Error(\"Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) \" + (\"but got: \" + (type == null ? type : typeof type) + \".\" + info));\n                }\n              }\n          }\n          var fiber = createFiber(fiberTag, pendingProps, key, mode);\n          fiber.elementType = type;\n          fiber.type = resolvedType;\n          fiber.lanes = lanes;\n          {\n            fiber._debugOwner = owner;\n          }\n          return fiber;\n        }\n        function createFiberFromElement(element, mode, lanes) {\n          var owner = null;\n          {\n            owner = element._owner;\n          }\n          var type = element.type;\n          var key = element.key;\n          var pendingProps = element.props;\n          var fiber = createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, lanes);\n          {\n            fiber._debugSource = element._source;\n            fiber._debugOwner = element._owner;\n          }\n          return fiber;\n        }\n        function createFiberFromFragment(elements, mode, lanes, key) {\n          var fiber = createFiber(Fragment, elements, key, mode);\n          fiber.lanes = lanes;\n          return fiber;\n        }\n        function createFiberFromProfiler(pendingProps, mode, lanes, key) {\n          {\n            if (typeof pendingProps.id !== \"string\") {\n              error('Profiler must specify an \"id\" of type `string` as a prop. Received the type `%s` instead.', typeof pendingProps.id);\n            }\n          }\n          var fiber = createFiber(Profiler, pendingProps, key, mode | ProfileMode);\n          fiber.elementType = REACT_PROFILER_TYPE;\n          fiber.lanes = lanes;\n          {\n            fiber.stateNode = {\n              effectDuration: 0,\n              passiveEffectDuration: 0\n            };\n          }\n          return fiber;\n        }\n        function createFiberFromSuspense(pendingProps, mode, lanes, key) {\n          var fiber = createFiber(SuspenseComponent, pendingProps, key, mode);\n          fiber.elementType = REACT_SUSPENSE_TYPE;\n          fiber.lanes = lanes;\n          return fiber;\n        }\n        function createFiberFromSuspenseList(pendingProps, mode, lanes, key) {\n          var fiber = createFiber(SuspenseListComponent, pendingProps, key, mode);\n          fiber.elementType = REACT_SUSPENSE_LIST_TYPE;\n          fiber.lanes = lanes;\n          return fiber;\n        }\n        function createFiberFromOffscreen(pendingProps, mode, lanes, key) {\n          var fiber = createFiber(OffscreenComponent, pendingProps, key, mode);\n          fiber.elementType = REACT_OFFSCREEN_TYPE;\n          fiber.lanes = lanes;\n          var primaryChildInstance = {\n            isHidden: false\n          };\n          fiber.stateNode = primaryChildInstance;\n          return fiber;\n        }\n        function createFiberFromText(content, mode, lanes) {\n          var fiber = createFiber(HostText, content, null, mode);\n          fiber.lanes = lanes;\n          return fiber;\n        }\n        function createFiberFromHostInstanceForDeletion() {\n          var fiber = createFiber(HostComponent, null, null, NoMode);\n          fiber.elementType = \"DELETED\";\n          return fiber;\n        }\n        function createFiberFromDehydratedFragment(dehydratedNode) {\n          var fiber = createFiber(DehydratedFragment, null, null, NoMode);\n          fiber.stateNode = dehydratedNode;\n          return fiber;\n        }\n        function createFiberFromPortal(portal, mode, lanes) {\n          var pendingProps = portal.children !== null ? portal.children : [];\n          var fiber = createFiber(HostPortal, pendingProps, portal.key, mode);\n          fiber.lanes = lanes;\n          fiber.stateNode = {\n            containerInfo: portal.containerInfo,\n            pendingChildren: null,\n            // Used by persistent updates\n            implementation: portal.implementation\n          };\n          return fiber;\n        }\n        function assignFiberPropertiesInDEV(target, source) {\n          if (target === null) {\n            target = createFiber(IndeterminateComponent, null, null, NoMode);\n          }\n          target.tag = source.tag;\n          target.key = source.key;\n          target.elementType = source.elementType;\n          target.type = source.type;\n          target.stateNode = source.stateNode;\n          target.return = source.return;\n          target.child = source.child;\n          target.sibling = source.sibling;\n          target.index = source.index;\n          target.ref = source.ref;\n          target.pendingProps = source.pendingProps;\n          target.memoizedProps = source.memoizedProps;\n          target.updateQueue = source.updateQueue;\n          target.memoizedState = source.memoizedState;\n          target.dependencies = source.dependencies;\n          target.mode = source.mode;\n          target.flags = source.flags;\n          target.subtreeFlags = source.subtreeFlags;\n          target.deletions = source.deletions;\n          target.lanes = source.lanes;\n          target.childLanes = source.childLanes;\n          target.alternate = source.alternate;\n          {\n            target.actualDuration = source.actualDuration;\n            target.actualStartTime = source.actualStartTime;\n            target.selfBaseDuration = source.selfBaseDuration;\n            target.treeBaseDuration = source.treeBaseDuration;\n          }\n          target._debugSource = source._debugSource;\n          target._debugOwner = source._debugOwner;\n          target._debugNeedsRemount = source._debugNeedsRemount;\n          target._debugHookTypes = source._debugHookTypes;\n          return target;\n        }\n        function FiberRootNode(containerInfo, tag, hydrate2, identifierPrefix, onRecoverableError) {\n          this.tag = tag;\n          this.containerInfo = containerInfo;\n          this.pendingChildren = null;\n          this.current = null;\n          this.pingCache = null;\n          this.finishedWork = null;\n          this.timeoutHandle = noTimeout;\n          this.context = null;\n          this.pendingContext = null;\n          this.callbackNode = null;\n          this.callbackPriority = NoLane;\n          this.eventTimes = createLaneMap(NoLanes);\n          this.expirationTimes = createLaneMap(NoTimestamp);\n          this.pendingLanes = NoLanes;\n          this.suspendedLanes = NoLanes;\n          this.pingedLanes = NoLanes;\n          this.expiredLanes = NoLanes;\n          this.mutableReadLanes = NoLanes;\n          this.finishedLanes = NoLanes;\n          this.entangledLanes = NoLanes;\n          this.entanglements = createLaneMap(NoLanes);\n          this.identifierPrefix = identifierPrefix;\n          this.onRecoverableError = onRecoverableError;\n          {\n            this.mutableSourceEagerHydrationData = null;\n          }\n          {\n            this.effectDuration = 0;\n            this.passiveEffectDuration = 0;\n          }\n          {\n            this.memoizedUpdaters = /* @__PURE__ */ new Set();\n            var pendingUpdatersLaneMap = this.pendingUpdatersLaneMap = [];\n            for (var _i = 0; _i < TotalLanes; _i++) {\n              pendingUpdatersLaneMap.push(/* @__PURE__ */ new Set());\n            }\n          }\n          {\n            switch (tag) {\n              case ConcurrentRoot:\n                this._debugRootType = hydrate2 ? \"hydrateRoot()\" : \"createRoot()\";\n                break;\n              case LegacyRoot:\n                this._debugRootType = hydrate2 ? \"hydrate()\" : \"render()\";\n                break;\n            }\n          }\n        }\n        function createFiberRoot(containerInfo, tag, hydrate2, initialChildren, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError, transitionCallbacks) {\n          var root2 = new FiberRootNode(containerInfo, tag, hydrate2, identifierPrefix, onRecoverableError);\n          var uninitializedFiber = createHostRootFiber(tag, isStrictMode);\n          root2.current = uninitializedFiber;\n          uninitializedFiber.stateNode = root2;\n          {\n            var _initialState = {\n              element: initialChildren,\n              isDehydrated: hydrate2,\n              cache: null,\n              // not enabled yet\n              transitions: null,\n              pendingSuspenseBoundaries: null\n            };\n            uninitializedFiber.memoizedState = _initialState;\n          }\n          initializeUpdateQueue(uninitializedFiber);\n          return root2;\n        }\n        var ReactVersion = \"18.2.0\";\n        function createPortal(children, containerInfo, implementation) {\n          var key = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;\n          {\n            checkKeyStringCoercion(key);\n          }\n          return {\n            // This tag allow us to uniquely identify this as a React Portal\n            $$typeof: REACT_PORTAL_TYPE,\n            key: key == null ? null : \"\" + key,\n            children,\n            containerInfo,\n            implementation\n          };\n        }\n        var didWarnAboutNestedUpdates;\n        var didWarnAboutFindNodeInStrictMode;\n        {\n          didWarnAboutNestedUpdates = false;\n          didWarnAboutFindNodeInStrictMode = {};\n        }\n        function getContextForSubtree(parentComponent) {\n          if (!parentComponent) {\n            return emptyContextObject;\n          }\n          var fiber = get(parentComponent);\n          var parentContext = findCurrentUnmaskedContext(fiber);\n          if (fiber.tag === ClassComponent) {\n            var Component = fiber.type;\n            if (isContextProvider(Component)) {\n              return processChildContext(fiber, Component, parentContext);\n            }\n          }\n          return parentContext;\n        }\n        function findHostInstanceWithWarning(component, methodName) {\n          {\n            var fiber = get(component);\n            if (fiber === void 0) {\n              if (typeof component.render === \"function\") {\n                throw new Error(\"Unable to find node on an unmounted component.\");\n              } else {\n                var keys = Object.keys(component).join(\",\");\n                throw new Error(\"Argument appears to not be a ReactComponent. Keys: \" + keys);\n              }\n            }\n            var hostFiber = findCurrentHostFiber(fiber);\n            if (hostFiber === null) {\n              return null;\n            }\n            if (hostFiber.mode & StrictLegacyMode) {\n              var componentName = getComponentNameFromFiber(fiber) || \"Component\";\n              if (!didWarnAboutFindNodeInStrictMode[componentName]) {\n                didWarnAboutFindNodeInStrictMode[componentName] = true;\n                var previousFiber = current;\n                try {\n                  setCurrentFiber(hostFiber);\n                  if (fiber.mode & StrictLegacyMode) {\n                    error(\"%s is deprecated in StrictMode. %s was passed an instance of %s which is inside StrictMode. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node\", methodName, methodName, componentName);\n                  } else {\n                    error(\"%s is deprecated in StrictMode. %s was passed an instance of %s which renders StrictMode children. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node\", methodName, methodName, componentName);\n                  }\n                } finally {\n                  if (previousFiber) {\n                    setCurrentFiber(previousFiber);\n                  } else {\n                    resetCurrentFiber();\n                  }\n                }\n              }\n            }\n            return hostFiber.stateNode;\n          }\n        }\n        function createContainer(containerInfo, tag, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError, transitionCallbacks) {\n          var hydrate2 = false;\n          var initialChildren = null;\n          return createFiberRoot(containerInfo, tag, hydrate2, initialChildren, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError);\n        }\n        function createHydrationContainer(initialChildren, callback, containerInfo, tag, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError, transitionCallbacks) {\n          var hydrate2 = true;\n          var root2 = createFiberRoot(containerInfo, tag, hydrate2, initialChildren, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError);\n          root2.context = getContextForSubtree(null);\n          var current2 = root2.current;\n          var eventTime = requestEventTime();\n          var lane = requestUpdateLane(current2);\n          var update = createUpdate(eventTime, lane);\n          update.callback = callback !== void 0 && callback !== null ? callback : null;\n          enqueueUpdate(current2, update, lane);\n          scheduleInitialHydrationOnRoot(root2, lane, eventTime);\n          return root2;\n        }\n        function updateContainer(element, container, parentComponent, callback) {\n          {\n            onScheduleRoot(container, element);\n          }\n          var current$1 = container.current;\n          var eventTime = requestEventTime();\n          var lane = requestUpdateLane(current$1);\n          {\n            markRenderScheduled(lane);\n          }\n          var context = getContextForSubtree(parentComponent);\n          if (container.context === null) {\n            container.context = context;\n          } else {\n            container.pendingContext = context;\n          }\n          {\n            if (isRendering && current !== null && !didWarnAboutNestedUpdates) {\n              didWarnAboutNestedUpdates = true;\n              error(\"Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate.\\n\\nCheck the render method of %s.\", getComponentNameFromFiber(current) || \"Unknown\");\n            }\n          }\n          var update = createUpdate(eventTime, lane);\n          update.payload = {\n            element\n          };\n          callback = callback === void 0 ? null : callback;\n          if (callback !== null) {\n            {\n              if (typeof callback !== \"function\") {\n                error(\"render(...): Expected the last optional `callback` argument to be a function. Instead received: %s.\", callback);\n              }\n            }\n            update.callback = callback;\n          }\n          var root2 = enqueueUpdate(current$1, update, lane);\n          if (root2 !== null) {\n            scheduleUpdateOnFiber(root2, current$1, lane, eventTime);\n            entangleTransitions(root2, current$1, lane);\n          }\n          return lane;\n        }\n        function getPublicRootInstance(container) {\n          var containerFiber = container.current;\n          if (!containerFiber.child) {\n            return null;\n          }\n          switch (containerFiber.child.tag) {\n            case HostComponent:\n              return getPublicInstance(containerFiber.child.stateNode);\n            default:\n              return containerFiber.child.stateNode;\n          }\n        }\n        function attemptSynchronousHydration$1(fiber) {\n          switch (fiber.tag) {\n            case HostRoot: {\n              var root2 = fiber.stateNode;\n              if (isRootDehydrated(root2)) {\n                var lanes = getHighestPriorityPendingLanes(root2);\n                flushRoot(root2, lanes);\n              }\n              break;\n            }\n            case SuspenseComponent: {\n              flushSync(function() {\n                var root3 = enqueueConcurrentRenderForLane(fiber, SyncLane);\n                if (root3 !== null) {\n                  var eventTime = requestEventTime();\n                  scheduleUpdateOnFiber(root3, fiber, SyncLane, eventTime);\n                }\n              });\n              var retryLane = SyncLane;\n              markRetryLaneIfNotHydrated(fiber, retryLane);\n              break;\n            }\n          }\n        }\n        function markRetryLaneImpl(fiber, retryLane) {\n          var suspenseState = fiber.memoizedState;\n          if (suspenseState !== null && suspenseState.dehydrated !== null) {\n            suspenseState.retryLane = higherPriorityLane(suspenseState.retryLane, retryLane);\n          }\n        }\n        function markRetryLaneIfNotHydrated(fiber, retryLane) {\n          markRetryLaneImpl(fiber, retryLane);\n          var alternate = fiber.alternate;\n          if (alternate) {\n            markRetryLaneImpl(alternate, retryLane);\n          }\n        }\n        function attemptContinuousHydration$1(fiber) {\n          if (fiber.tag !== SuspenseComponent) {\n            return;\n          }\n          var lane = SelectiveHydrationLane;\n          var root2 = enqueueConcurrentRenderForLane(fiber, lane);\n          if (root2 !== null) {\n            var eventTime = requestEventTime();\n            scheduleUpdateOnFiber(root2, fiber, lane, eventTime);\n          }\n          markRetryLaneIfNotHydrated(fiber, lane);\n        }\n        function attemptHydrationAtCurrentPriority$1(fiber) {\n          if (fiber.tag !== SuspenseComponent) {\n            return;\n          }\n          var lane = requestUpdateLane(fiber);\n          var root2 = enqueueConcurrentRenderForLane(fiber, lane);\n          if (root2 !== null) {\n            var eventTime = requestEventTime();\n            scheduleUpdateOnFiber(root2, fiber, lane, eventTime);\n          }\n          markRetryLaneIfNotHydrated(fiber, lane);\n        }\n        function findHostInstanceWithNoPortals(fiber) {\n          var hostFiber = findCurrentHostFiberWithNoPortals(fiber);\n          if (hostFiber === null) {\n            return null;\n          }\n          return hostFiber.stateNode;\n        }\n        var shouldErrorImpl = function(fiber) {\n          return null;\n        };\n        function shouldError(fiber) {\n          return shouldErrorImpl(fiber);\n        }\n        var shouldSuspendImpl = function(fiber) {\n          return false;\n        };\n        function shouldSuspend(fiber) {\n          return shouldSuspendImpl(fiber);\n        }\n        var overrideHookState = null;\n        var overrideHookStateDeletePath = null;\n        var overrideHookStateRenamePath = null;\n        var overrideProps = null;\n        var overridePropsDeletePath = null;\n        var overridePropsRenamePath = null;\n        var scheduleUpdate = null;\n        var setErrorHandler = null;\n        var setSuspenseHandler = null;\n        {\n          var copyWithDeleteImpl = function(obj, path, index2) {\n            var key = path[index2];\n            var updated = isArray(obj) ? obj.slice() : assign({}, obj);\n            if (index2 + 1 === path.length) {\n              if (isArray(updated)) {\n                updated.splice(key, 1);\n              } else {\n                delete updated[key];\n              }\n              return updated;\n            }\n            updated[key] = copyWithDeleteImpl(obj[key], path, index2 + 1);\n            return updated;\n          };\n          var copyWithDelete = function(obj, path) {\n            return copyWithDeleteImpl(obj, path, 0);\n          };\n          var copyWithRenameImpl = function(obj, oldPath, newPath, index2) {\n            var oldKey = oldPath[index2];\n            var updated = isArray(obj) ? obj.slice() : assign({}, obj);\n            if (index2 + 1 === oldPath.length) {\n              var newKey = newPath[index2];\n              updated[newKey] = updated[oldKey];\n              if (isArray(updated)) {\n                updated.splice(oldKey, 1);\n              } else {\n                delete updated[oldKey];\n              }\n            } else {\n              updated[oldKey] = copyWithRenameImpl(\n                // $FlowFixMe number or string is fine here\n                obj[oldKey],\n                oldPath,\n                newPath,\n                index2 + 1\n              );\n            }\n            return updated;\n          };\n          var copyWithRename = function(obj, oldPath, newPath) {\n            if (oldPath.length !== newPath.length) {\n              warn(\"copyWithRename() expects paths of the same length\");\n              return;\n            } else {\n              for (var i = 0; i < newPath.length - 1; i++) {\n                if (oldPath[i] !== newPath[i]) {\n                  warn(\"copyWithRename() expects paths to be the same except for the deepest key\");\n                  return;\n                }\n              }\n            }\n            return copyWithRenameImpl(obj, oldPath, newPath, 0);\n          };\n          var copyWithSetImpl = function(obj, path, index2, value) {\n            if (index2 >= path.length) {\n              return value;\n            }\n            var key = path[index2];\n            var updated = isArray(obj) ? obj.slice() : assign({}, obj);\n            updated[key] = copyWithSetImpl(obj[key], path, index2 + 1, value);\n            return updated;\n          };\n          var copyWithSet = function(obj, path, value) {\n            return copyWithSetImpl(obj, path, 0, value);\n          };\n          var findHook = function(fiber, id) {\n            var currentHook2 = fiber.memoizedState;\n            while (currentHook2 !== null && id > 0) {\n              currentHook2 = currentHook2.next;\n              id--;\n            }\n            return currentHook2;\n          };\n          overrideHookState = function(fiber, id, path, value) {\n            var hook = findHook(fiber, id);\n            if (hook !== null) {\n              var newState = copyWithSet(hook.memoizedState, path, value);\n              hook.memoizedState = newState;\n              hook.baseState = newState;\n              fiber.memoizedProps = assign({}, fiber.memoizedProps);\n              var root2 = enqueueConcurrentRenderForLane(fiber, SyncLane);\n              if (root2 !== null) {\n                scheduleUpdateOnFiber(root2, fiber, SyncLane, NoTimestamp);\n              }\n            }\n          };\n          overrideHookStateDeletePath = function(fiber, id, path) {\n            var hook = findHook(fiber, id);\n            if (hook !== null) {\n              var newState = copyWithDelete(hook.memoizedState, path);\n              hook.memoizedState = newState;\n              hook.baseState = newState;\n              fiber.memoizedProps = assign({}, fiber.memoizedProps);\n              var root2 = enqueueConcurrentRenderForLane(fiber, SyncLane);\n              if (root2 !== null) {\n                scheduleUpdateOnFiber(root2, fiber, SyncLane, NoTimestamp);\n              }\n            }\n          };\n          overrideHookStateRenamePath = function(fiber, id, oldPath, newPath) {\n            var hook = findHook(fiber, id);\n            if (hook !== null) {\n              var newState = copyWithRename(hook.memoizedState, oldPath, newPath);\n              hook.memoizedState = newState;\n              hook.baseState = newState;\n              fiber.memoizedProps = assign({}, fiber.memoizedProps);\n              var root2 = enqueueConcurrentRenderForLane(fiber, SyncLane);\n              if (root2 !== null) {\n                scheduleUpdateOnFiber(root2, fiber, SyncLane, NoTimestamp);\n              }\n            }\n          };\n          overrideProps = function(fiber, path, value) {\n            fiber.pendingProps = copyWithSet(fiber.memoizedProps, path, value);\n            if (fiber.alternate) {\n              fiber.alternate.pendingProps = fiber.pendingProps;\n            }\n            var root2 = enqueueConcurrentRenderForLane(fiber, SyncLane);\n            if (root2 !== null) {\n              scheduleUpdateOnFiber(root2, fiber, SyncLane, NoTimestamp);\n            }\n          };\n          overridePropsDeletePath = function(fiber, path) {\n            fiber.pendingProps = copyWithDelete(fiber.memoizedProps, path);\n            if (fiber.alternate) {\n              fiber.alternate.pendingProps = fiber.pendingProps;\n            }\n            var root2 = enqueueConcurrentRenderForLane(fiber, SyncLane);\n            if (root2 !== null) {\n              scheduleUpdateOnFiber(root2, fiber, SyncLane, NoTimestamp);\n            }\n          };\n          overridePropsRenamePath = function(fiber, oldPath, newPath) {\n            fiber.pendingProps = copyWithRename(fiber.memoizedProps, oldPath, newPath);\n            if (fiber.alternate) {\n              fiber.alternate.pendingProps = fiber.pendingProps;\n            }\n            var root2 = enqueueConcurrentRenderForLane(fiber, SyncLane);\n            if (root2 !== null) {\n              scheduleUpdateOnFiber(root2, fiber, SyncLane, NoTimestamp);\n            }\n          };\n          scheduleUpdate = function(fiber) {\n            var root2 = enqueueConcurrentRenderForLane(fiber, SyncLane);\n            if (root2 !== null) {\n              scheduleUpdateOnFiber(root2, fiber, SyncLane, NoTimestamp);\n            }\n          };\n          setErrorHandler = function(newShouldErrorImpl) {\n            shouldErrorImpl = newShouldErrorImpl;\n          };\n          setSuspenseHandler = function(newShouldSuspendImpl) {\n            shouldSuspendImpl = newShouldSuspendImpl;\n          };\n        }\n        function findHostInstanceByFiber(fiber) {\n          var hostFiber = findCurrentHostFiber(fiber);\n          if (hostFiber === null) {\n            return null;\n          }\n          return hostFiber.stateNode;\n        }\n        function emptyFindFiberByHostInstance(instance) {\n          return null;\n        }\n        function getCurrentFiberForDevTools() {\n          return current;\n        }\n        function injectIntoDevTools(devToolsConfig) {\n          var findFiberByHostInstance = devToolsConfig.findFiberByHostInstance;\n          var ReactCurrentDispatcher2 = ReactSharedInternals.ReactCurrentDispatcher;\n          return injectInternals({\n            bundleType: devToolsConfig.bundleType,\n            version: devToolsConfig.version,\n            rendererPackageName: devToolsConfig.rendererPackageName,\n            rendererConfig: devToolsConfig.rendererConfig,\n            overrideHookState,\n            overrideHookStateDeletePath,\n            overrideHookStateRenamePath,\n            overrideProps,\n            overridePropsDeletePath,\n            overridePropsRenamePath,\n            setErrorHandler,\n            setSuspenseHandler,\n            scheduleUpdate,\n            currentDispatcherRef: ReactCurrentDispatcher2,\n            findHostInstanceByFiber,\n            findFiberByHostInstance: findFiberByHostInstance || emptyFindFiberByHostInstance,\n            // React Refresh\n            findHostInstancesForRefresh,\n            scheduleRefresh,\n            scheduleRoot,\n            setRefreshHandler,\n            // Enables DevTools to append owner stacks to error messages in DEV mode.\n            getCurrentFiber: getCurrentFiberForDevTools,\n            // Enables DevTools to detect reconciler version rather than renderer version\n            // which may not match for third party renderers.\n            reconcilerVersion: ReactVersion\n          });\n        }\n        var defaultOnRecoverableError = typeof reportError === \"function\" ? (\n          // In modern browsers, reportError will dispatch an error event,\n          // emulating an uncaught JavaScript error.\n          reportError\n        ) : function(error2) {\n          console[\"error\"](error2);\n        };\n        function ReactDOMRoot(internalRoot) {\n          this._internalRoot = internalRoot;\n        }\n        ReactDOMHydrationRoot.prototype.render = ReactDOMRoot.prototype.render = function(children) {\n          var root2 = this._internalRoot;\n          if (root2 === null) {\n            throw new Error(\"Cannot update an unmounted root.\");\n          }\n          {\n            if (typeof arguments[1] === \"function\") {\n              error(\"render(...): does not support the second callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().\");\n            } else if (isValidContainer(arguments[1])) {\n              error(\"You passed a container to the second argument of root.render(...). You don't need to pass it again since you already passed it to create the root.\");\n            } else if (typeof arguments[1] !== \"undefined\") {\n              error(\"You passed a second argument to root.render(...) but it only accepts one argument.\");\n            }\n            var container = root2.containerInfo;\n            if (container.nodeType !== COMMENT_NODE) {\n              var hostInstance = findHostInstanceWithNoPortals(root2.current);\n              if (hostInstance) {\n                if (hostInstance.parentNode !== container) {\n                  error(\"render(...): It looks like the React-rendered content of the root container was removed without using React. This is not supported and will cause errors. Instead, call root.unmount() to empty a root's container.\");\n                }\n              }\n            }\n          }\n          updateContainer(children, root2, null, null);\n        };\n        ReactDOMHydrationRoot.prototype.unmount = ReactDOMRoot.prototype.unmount = function() {\n          {\n            if (typeof arguments[0] === \"function\") {\n              error(\"unmount(...): does not support a callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().\");\n            }\n          }\n          var root2 = this._internalRoot;\n          if (root2 !== null) {\n            this._internalRoot = null;\n            var container = root2.containerInfo;\n            {\n              if (isAlreadyRendering()) {\n                error(\"Attempted to synchronously unmount a root while React was already rendering. React cannot finish unmounting the root until the current render has completed, which may lead to a race condition.\");\n              }\n            }\n            flushSync(function() {\n              updateContainer(null, root2, null, null);\n            });\n            unmarkContainerAsRoot(container);\n          }\n        };\n        function createRoot(container, options2) {\n          if (!isValidContainer(container)) {\n            throw new Error(\"createRoot(...): Target container is not a DOM element.\");\n          }\n          warnIfReactDOMContainerInDEV(container);\n          var isStrictMode = false;\n          var concurrentUpdatesByDefaultOverride = false;\n          var identifierPrefix = \"\";\n          var onRecoverableError = defaultOnRecoverableError;\n          var transitionCallbacks = null;\n          if (options2 !== null && options2 !== void 0) {\n            {\n              if (options2.hydrate) {\n                warn(\"hydrate through createRoot is deprecated. Use ReactDOMClient.hydrateRoot(container, <App />) instead.\");\n              } else {\n                if (typeof options2 === \"object\" && options2 !== null && options2.$$typeof === REACT_ELEMENT_TYPE) {\n                  error(\"You passed a JSX element to createRoot. You probably meant to call root.render instead. Example usage:\\n\\n  let root = createRoot(domContainer);\\n  root.render(<App />);\");\n                }\n              }\n            }\n            if (options2.unstable_strictMode === true) {\n              isStrictMode = true;\n            }\n            if (options2.identifierPrefix !== void 0) {\n              identifierPrefix = options2.identifierPrefix;\n            }\n            if (options2.onRecoverableError !== void 0) {\n              onRecoverableError = options2.onRecoverableError;\n            }\n            if (options2.transitionCallbacks !== void 0) {\n              transitionCallbacks = options2.transitionCallbacks;\n            }\n          }\n          var root2 = createContainer(container, ConcurrentRoot, null, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError);\n          markContainerAsRoot(root2.current, container);\n          var rootContainerElement = container.nodeType === COMMENT_NODE ? container.parentNode : container;\n          listenToAllSupportedEvents(rootContainerElement);\n          return new ReactDOMRoot(root2);\n        }\n        function ReactDOMHydrationRoot(internalRoot) {\n          this._internalRoot = internalRoot;\n        }\n        function scheduleHydration(target) {\n          if (target) {\n            queueExplicitHydrationTarget(target);\n          }\n        }\n        ReactDOMHydrationRoot.prototype.unstable_scheduleHydration = scheduleHydration;\n        function hydrateRoot(container, initialChildren, options2) {\n          if (!isValidContainer(container)) {\n            throw new Error(\"hydrateRoot(...): Target container is not a DOM element.\");\n          }\n          warnIfReactDOMContainerInDEV(container);\n          {\n            if (initialChildren === void 0) {\n              error(\"Must provide initial children as second argument to hydrateRoot. Example usage: hydrateRoot(domContainer, <App />)\");\n            }\n          }\n          var hydrationCallbacks = options2 != null ? options2 : null;\n          var mutableSources = options2 != null && options2.hydratedSources || null;\n          var isStrictMode = false;\n          var concurrentUpdatesByDefaultOverride = false;\n          var identifierPrefix = \"\";\n          var onRecoverableError = defaultOnRecoverableError;\n          if (options2 !== null && options2 !== void 0) {\n            if (options2.unstable_strictMode === true) {\n              isStrictMode = true;\n            }\n            if (options2.identifierPrefix !== void 0) {\n              identifierPrefix = options2.identifierPrefix;\n            }\n            if (options2.onRecoverableError !== void 0) {\n              onRecoverableError = options2.onRecoverableError;\n            }\n          }\n          var root2 = createHydrationContainer(initialChildren, null, container, ConcurrentRoot, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError);\n          markContainerAsRoot(root2.current, container);\n          listenToAllSupportedEvents(container);\n          if (mutableSources) {\n            for (var i = 0; i < mutableSources.length; i++) {\n              var mutableSource = mutableSources[i];\n              registerMutableSourceForHydration(root2, mutableSource);\n            }\n          }\n          return new ReactDOMHydrationRoot(root2);\n        }\n        function isValidContainer(node) {\n          return !!(node && (node.nodeType === ELEMENT_NODE || node.nodeType === DOCUMENT_NODE || node.nodeType === DOCUMENT_FRAGMENT_NODE || !disableCommentsAsDOMContainers));\n        }\n        function isValidContainerLegacy(node) {\n          return !!(node && (node.nodeType === ELEMENT_NODE || node.nodeType === DOCUMENT_NODE || node.nodeType === DOCUMENT_FRAGMENT_NODE || node.nodeType === COMMENT_NODE && node.nodeValue === \" react-mount-point-unstable \"));\n        }\n        function warnIfReactDOMContainerInDEV(container) {\n          {\n            if (container.nodeType === ELEMENT_NODE && container.tagName && container.tagName.toUpperCase() === \"BODY\") {\n              error(\"createRoot(): Creating roots directly with document.body is discouraged, since its children are often manipulated by third-party scripts and browser extensions. This may lead to subtle reconciliation issues. Try using a container element created for your app.\");\n            }\n            if (isContainerMarkedAsRoot(container)) {\n              if (container._reactRootContainer) {\n                error(\"You are calling ReactDOMClient.createRoot() on a container that was previously passed to ReactDOM.render(). This is not supported.\");\n              } else {\n                error(\"You are calling ReactDOMClient.createRoot() on a container that has already been passed to createRoot() before. Instead, call root.render() on the existing root instead if you want to update it.\");\n              }\n            }\n          }\n        }\n        var ReactCurrentOwner$3 = ReactSharedInternals.ReactCurrentOwner;\n        var topLevelUpdateWarnings;\n        {\n          topLevelUpdateWarnings = function(container) {\n            if (container._reactRootContainer && container.nodeType !== COMMENT_NODE) {\n              var hostInstance = findHostInstanceWithNoPortals(container._reactRootContainer.current);\n              if (hostInstance) {\n                if (hostInstance.parentNode !== container) {\n                  error(\"render(...): It looks like the React-rendered content of this container was removed without using React. This is not supported and will cause errors. Instead, call ReactDOM.unmountComponentAtNode to empty a container.\");\n                }\n              }\n            }\n            var isRootRenderedBySomeReact = !!container._reactRootContainer;\n            var rootEl = getReactRootElementInContainer(container);\n            var hasNonRootReactChild = !!(rootEl && getInstanceFromNode(rootEl));\n            if (hasNonRootReactChild && !isRootRenderedBySomeReact) {\n              error(\"render(...): Replacing React-rendered children with a new root component. If you intended to update the children of this node, you should instead have the existing children update their state and render the new components instead of calling ReactDOM.render.\");\n            }\n            if (container.nodeType === ELEMENT_NODE && container.tagName && container.tagName.toUpperCase() === \"BODY\") {\n              error(\"render(): Rendering components directly into document.body is discouraged, since its children are often manipulated by third-party scripts and browser extensions. This may lead to subtle reconciliation issues. Try rendering into a container element created for your app.\");\n            }\n          };\n        }\n        function getReactRootElementInContainer(container) {\n          if (!container) {\n            return null;\n          }\n          if (container.nodeType === DOCUMENT_NODE) {\n            return container.documentElement;\n          } else {\n            return container.firstChild;\n          }\n        }\n        function noopOnRecoverableError() {\n        }\n        function legacyCreateRootFromDOMContainer(container, initialChildren, parentComponent, callback, isHydrationContainer) {\n          if (isHydrationContainer) {\n            if (typeof callback === \"function\") {\n              var originalCallback = callback;\n              callback = function() {\n                var instance = getPublicRootInstance(root2);\n                originalCallback.call(instance);\n              };\n            }\n            var root2 = createHydrationContainer(\n              initialChildren,\n              callback,\n              container,\n              LegacyRoot,\n              null,\n              // hydrationCallbacks\n              false,\n              // isStrictMode\n              false,\n              // concurrentUpdatesByDefaultOverride,\n              \"\",\n              // identifierPrefix\n              noopOnRecoverableError\n            );\n            container._reactRootContainer = root2;\n            markContainerAsRoot(root2.current, container);\n            var rootContainerElement = container.nodeType === COMMENT_NODE ? container.parentNode : container;\n            listenToAllSupportedEvents(rootContainerElement);\n            flushSync();\n            return root2;\n          } else {\n            var rootSibling;\n            while (rootSibling = container.lastChild) {\n              container.removeChild(rootSibling);\n            }\n            if (typeof callback === \"function\") {\n              var _originalCallback = callback;\n              callback = function() {\n                var instance = getPublicRootInstance(_root);\n                _originalCallback.call(instance);\n              };\n            }\n            var _root = createContainer(\n              container,\n              LegacyRoot,\n              null,\n              // hydrationCallbacks\n              false,\n              // isStrictMode\n              false,\n              // concurrentUpdatesByDefaultOverride,\n              \"\",\n              // identifierPrefix\n              noopOnRecoverableError\n            );\n            container._reactRootContainer = _root;\n            markContainerAsRoot(_root.current, container);\n            var _rootContainerElement = container.nodeType === COMMENT_NODE ? container.parentNode : container;\n            listenToAllSupportedEvents(_rootContainerElement);\n            flushSync(function() {\n              updateContainer(initialChildren, _root, parentComponent, callback);\n            });\n            return _root;\n          }\n        }\n        function warnOnInvalidCallback$1(callback, callerName) {\n          {\n            if (callback !== null && typeof callback !== \"function\") {\n              error(\"%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.\", callerName, callback);\n            }\n          }\n        }\n        function legacyRenderSubtreeIntoContainer(parentComponent, children, container, forceHydrate, callback) {\n          {\n            topLevelUpdateWarnings(container);\n            warnOnInvalidCallback$1(callback === void 0 ? null : callback, \"render\");\n          }\n          var maybeRoot = container._reactRootContainer;\n          var root2;\n          if (!maybeRoot) {\n            root2 = legacyCreateRootFromDOMContainer(container, children, parentComponent, callback, forceHydrate);\n          } else {\n            root2 = maybeRoot;\n            if (typeof callback === \"function\") {\n              var originalCallback = callback;\n              callback = function() {\n                var instance = getPublicRootInstance(root2);\n                originalCallback.call(instance);\n              };\n            }\n            updateContainer(children, root2, parentComponent, callback);\n          }\n          return getPublicRootInstance(root2);\n        }\n        function findDOMNode(componentOrElement) {\n          {\n            var owner = ReactCurrentOwner$3.current;\n            if (owner !== null && owner.stateNode !== null) {\n              var warnedAboutRefsInRender = owner.stateNode._warnedAboutRefsInRender;\n              if (!warnedAboutRefsInRender) {\n                error(\"%s is accessing findDOMNode inside its render(). render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.\", getComponentNameFromType(owner.type) || \"A component\");\n              }\n              owner.stateNode._warnedAboutRefsInRender = true;\n            }\n          }\n          if (componentOrElement == null) {\n            return null;\n          }\n          if (componentOrElement.nodeType === ELEMENT_NODE) {\n            return componentOrElement;\n          }\n          {\n            return findHostInstanceWithWarning(componentOrElement, \"findDOMNode\");\n          }\n        }\n        function hydrate(element, container, callback) {\n          {\n            error(\"ReactDOM.hydrate is no longer supported in React 18. Use hydrateRoot instead. Until you switch to the new API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot\");\n          }\n          if (!isValidContainerLegacy(container)) {\n            throw new Error(\"Target container is not a DOM element.\");\n          }\n          {\n            var isModernRoot = isContainerMarkedAsRoot(container) && container._reactRootContainer === void 0;\n            if (isModernRoot) {\n              error(\"You are calling ReactDOM.hydrate() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call hydrateRoot(container, element)?\");\n            }\n          }\n          return legacyRenderSubtreeIntoContainer(null, element, container, true, callback);\n        }\n        function render(element, container, callback) {\n          {\n            error(\"ReactDOM.render is no longer supported in React 18. Use createRoot instead. Until you switch to the new API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot\");\n          }\n          if (!isValidContainerLegacy(container)) {\n            throw new Error(\"Target container is not a DOM element.\");\n          }\n          {\n            var isModernRoot = isContainerMarkedAsRoot(container) && container._reactRootContainer === void 0;\n            if (isModernRoot) {\n              error(\"You are calling ReactDOM.render() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call root.render(element)?\");\n            }\n          }\n          return legacyRenderSubtreeIntoContainer(null, element, container, false, callback);\n        }\n        function unstable_renderSubtreeIntoContainer(parentComponent, element, containerNode, callback) {\n          {\n            error(\"ReactDOM.unstable_renderSubtreeIntoContainer() is no longer supported in React 18. Consider using a portal instead. Until you switch to the createRoot API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot\");\n          }\n          if (!isValidContainerLegacy(containerNode)) {\n            throw new Error(\"Target container is not a DOM element.\");\n          }\n          if (parentComponent == null || !has(parentComponent)) {\n            throw new Error(\"parentComponent must be a valid React Component\");\n          }\n          return legacyRenderSubtreeIntoContainer(parentComponent, element, containerNode, false, callback);\n        }\n        function unmountComponentAtNode(container) {\n          if (!isValidContainerLegacy(container)) {\n            throw new Error(\"unmountComponentAtNode(...): Target container is not a DOM element.\");\n          }\n          {\n            var isModernRoot = isContainerMarkedAsRoot(container) && container._reactRootContainer === void 0;\n            if (isModernRoot) {\n              error(\"You are calling ReactDOM.unmountComponentAtNode() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call root.unmount()?\");\n            }\n          }\n          if (container._reactRootContainer) {\n            {\n              var rootEl = getReactRootElementInContainer(container);\n              var renderedByDifferentReact = rootEl && !getInstanceFromNode(rootEl);\n              if (renderedByDifferentReact) {\n                error(\"unmountComponentAtNode(): The node you're attempting to unmount was rendered by another copy of React.\");\n              }\n            }\n            flushSync(function() {\n              legacyRenderSubtreeIntoContainer(null, null, container, false, function() {\n                container._reactRootContainer = null;\n                unmarkContainerAsRoot(container);\n              });\n            });\n            return true;\n          } else {\n            {\n              var _rootEl = getReactRootElementInContainer(container);\n              var hasNonRootReactChild = !!(_rootEl && getInstanceFromNode(_rootEl));\n              var isContainerReactRoot = container.nodeType === ELEMENT_NODE && isValidContainerLegacy(container.parentNode) && !!container.parentNode._reactRootContainer;\n              if (hasNonRootReactChild) {\n                error(\"unmountComponentAtNode(): The node you're attempting to unmount was rendered by React and is not a top-level container. %s\", isContainerReactRoot ? \"You may have accidentally passed in a React root node instead of its container.\" : \"Instead, have the parent component update its state and rerender in order to remove this component.\");\n              }\n            }\n            return false;\n          }\n        }\n        setAttemptSynchronousHydration(attemptSynchronousHydration$1);\n        setAttemptContinuousHydration(attemptContinuousHydration$1);\n        setAttemptHydrationAtCurrentPriority(attemptHydrationAtCurrentPriority$1);\n        setGetCurrentUpdatePriority(getCurrentUpdatePriority);\n        setAttemptHydrationAtPriority(runWithPriority);\n        {\n          if (typeof Map !== \"function\" || // $FlowIssue Flow incorrectly thinks Map has no prototype\n          Map.prototype == null || typeof Map.prototype.forEach !== \"function\" || typeof Set !== \"function\" || // $FlowIssue Flow incorrectly thinks Set has no prototype\n          Set.prototype == null || typeof Set.prototype.clear !== \"function\" || typeof Set.prototype.forEach !== \"function\") {\n            error(\"React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills\");\n          }\n        }\n        setRestoreImplementation(restoreControlledState$3);\n        setBatchingImplementation(batchedUpdates$1, discreteUpdates, flushSync);\n        function createPortal$1(children, container) {\n          var key = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;\n          if (!isValidContainer(container)) {\n            throw new Error(\"Target container is not a DOM element.\");\n          }\n          return createPortal(children, container, null, key);\n        }\n        function renderSubtreeIntoContainer(parentComponent, element, containerNode, callback) {\n          return unstable_renderSubtreeIntoContainer(parentComponent, element, containerNode, callback);\n        }\n        var Internals = {\n          usingClientEntryPoint: false,\n          // Keep in sync with ReactTestUtils.js.\n          // This is an array for better minification.\n          Events: [getInstanceFromNode, getNodeFromInstance, getFiberCurrentPropsFromNode, enqueueStateRestore, restoreStateIfNeeded, batchedUpdates$1]\n        };\n        function createRoot$1(container, options2) {\n          {\n            if (!Internals.usingClientEntryPoint && true) {\n              error('You are importing createRoot from \"react-dom\" which is not supported. You should instead import it from \"react-dom/client\".');\n            }\n          }\n          return createRoot(container, options2);\n        }\n        function hydrateRoot$1(container, initialChildren, options2) {\n          {\n            if (!Internals.usingClientEntryPoint && true) {\n              error('You are importing hydrateRoot from \"react-dom\" which is not supported. You should instead import it from \"react-dom/client\".');\n            }\n          }\n          return hydrateRoot(container, initialChildren, options2);\n        }\n        function flushSync$1(fn) {\n          {\n            if (isAlreadyRendering()) {\n              error(\"flushSync was called from inside a lifecycle method. React cannot flush when React is already rendering. Consider moving this call to a scheduler task or micro task.\");\n            }\n          }\n          return flushSync(fn);\n        }\n        var foundDevTools = injectIntoDevTools({\n          findFiberByHostInstance: getClosestInstanceFromNode,\n          bundleType: 1,\n          version: ReactVersion,\n          rendererPackageName: \"react-dom\"\n        });\n        {\n          if (!foundDevTools && canUseDOM && window.top === window.self) {\n            if (navigator.userAgent.indexOf(\"Chrome\") > -1 && navigator.userAgent.indexOf(\"Edge\") === -1 || navigator.userAgent.indexOf(\"Firefox\") > -1) {\n              var protocol = window.location.protocol;\n              if (/^(https?|file):$/.test(protocol)) {\n                console.info(\"%cDownload the React DevTools for a better development experience: https://reactjs.org/link/react-devtools\" + (protocol === \"file:\" ? \"\\nYou might need to use a local HTTP server (instead of file://): https://reactjs.org/link/react-devtools-faq\" : \"\"), \"font-weight:bold\");\n              }\n            }\n          }\n        }\n        exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Internals;\n        exports.createPortal = createPortal$1;\n        exports.createRoot = createRoot$1;\n        exports.findDOMNode = findDOMNode;\n        exports.flushSync = flushSync$1;\n        exports.hydrate = hydrate;\n        exports.hydrateRoot = hydrateRoot$1;\n        exports.render = render;\n        exports.unmountComponentAtNode = unmountComponentAtNode;\n        exports.unstable_batchedUpdates = batchedUpdates$1;\n        exports.unstable_renderSubtreeIntoContainer = renderSubtreeIntoContainer;\n        exports.version = ReactVersion;\n        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== \"undefined\" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === \"function\") {\n          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());\n        }\n      })();\n    }\n  }\n});\n\n// ../../node_modules/.pnpm/react-dom@18.2.0_react@18.2.0/node_modules/react-dom/index.js\nvar require_react_dom = __commonJS({\n  \"../../node_modules/.pnpm/react-dom@18.2.0_react@18.2.0/node_modules/react-dom/index.js\"(exports, module) {\n    \"use strict\";\n    if (false) {\n      checkDCE();\n      module.exports = null;\n    } else {\n      module.exports = require_react_dom_development();\n    }\n  }\n});\n\n// ../../node_modules/.pnpm/react-dom@18.2.0_react@18.2.0/node_modules/react-dom/client.js\nvar require_client = __commonJS({\n  \"../../node_modules/.pnpm/react-dom@18.2.0_react@18.2.0/node_modules/react-dom/client.js\"(exports) {\n    var m = require_react_dom();\n    if (false) {\n      exports.createRoot = m.createRoot;\n      exports.hydrateRoot = m.hydrateRoot;\n    } else {\n      i = m.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n      exports.createRoot = function(c, o) {\n        i.usingClientEntryPoint = true;\n        try {\n          return m.createRoot(c, o);\n        } finally {\n          i.usingClientEntryPoint = false;\n        }\n      };\n      exports.hydrateRoot = function(c, h, o) {\n        i.usingClientEntryPoint = true;\n        try {\n          return m.hydrateRoot(c, h, o);\n        } finally {\n          i.usingClientEntryPoint = false;\n        }\n      };\n    }\n    var i;\n  }\n});\nexport default require_client();\n/*! Bundled license information:\n\nscheduler/cjs/scheduler.development.js:\n  (**\n   * @license React\n   * scheduler.development.js\n   *\n   * Copyright (c) Facebook, Inc. and its affiliates.\n   *\n   * This source code is licensed under the MIT license found in the\n   * LICENSE file in the root directory of this source tree.\n   *)\n\nreact-dom/cjs/react-dom.development.js:\n  (**\n   * @license React\n   * react-dom.development.js\n   *\n   * Copyright (c) Facebook, Inc. and its affiliates.\n   *\n   * This source code is licensed under the MIT license found in the\n   * LICENSE file in the root directory of this source tree.\n   *)\n  (**\n   * Checks if an event is supported in the current execution environment.\n   *\n   * NOTE: This will not work correctly for non-generic events such as `change`,\n   * `reset`, `load`, `error`, and `select`.\n   *\n   * Borrows from Modernizr.\n   *\n   * @param {string} eventNameSuffix Event name, e.g. \"click\".\n   * @return {boolean} True if the event is supported.\n   * @internal\n   * @license Modernizr 3.0.0pre (Custom Build) | MIT\n   *)\n*/\n//# sourceMappingURL=react-dom_client.js.map\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 926642,
            "count": 1
          }
        ]
      },
      {
        "functionName": "../../node_modules/.pnpm/scheduler@0.23.2/node_modules/scheduler/cjs/scheduler.development.js",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 324,
            "endOffset": 17200,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 472,
            "endOffset": 17186,
            "count": 1
          },
          {
            "startOffset": 658,
            "endOffset": 752,
            "count": 0
          },
          {
            "startOffset": 3486,
            "endOffset": 3689,
            "count": 0
          },
          {
            "startOffset": 4341,
            "endOffset": 4347,
            "count": 0
          },
          {
            "startOffset": 4431,
            "endOffset": 4437,
            "count": 0
          },
          {
            "startOffset": 4507,
            "endOffset": 4521,
            "count": 0
          },
          {
            "startOffset": 4742,
            "endOffset": 4748,
            "count": 0
          },
          {
            "startOffset": 14547,
            "endOffset": 14686,
            "count": 0
          },
          {
            "startOffset": 14997,
            "endOffset": 15143,
            "count": 0
          },
          {
            "startOffset": 17085,
            "endOffset": 17178,
            "count": 0
          }
        ]
      },
      {
        "functionName": "push",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 874,
            "endOffset": 1010,
            "count": 4
          }
        ]
      },
      {
        "functionName": "peek",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1019,
            "endOffset": 1103,
            "count": 20
          },
          {
            "startOffset": 1076,
            "endOffset": 1082,
            "count": 11
          },
          {
            "startOffset": 1083,
            "endOffset": 1092,
            "count": 9
          }
        ]
      },
      {
        "functionName": "pop",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1112,
            "endOffset": 1411,
            "count": 4
          },
          {
            "startOffset": 1166,
            "endOffset": 1204,
            "count": 0
          },
          {
            "startOffset": 1299,
            "endOffset": 1377,
            "count": 2
          }
        ]
      },
      {
        "functionName": "siftUp",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1420,
            "endOffset": 1833,
            "count": 4
          },
          {
            "startOffset": 1506,
            "endOffset": 1823,
            "count": 2
          },
          {
            "startOffset": 1642,
            "endOffset": 1768,
            "count": 0
          }
        ]
      },
      {
        "functionName": "siftDown",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1842,
            "endOffset": 2829,
            "count": 2
          },
          {
            "startOffset": 2016,
            "endOffset": 2819,
            "count": 0
          }
        ]
      },
      {
        "functionName": "compare",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 2838,
            "endOffset": 2970,
            "count": 2
          },
          {
            "startOffset": 2946,
            "endOffset": 2959,
            "count": 0
          }
        ]
      },
      {
        "functionName": "markTaskErrored",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 3143,
            "endOffset": 3189,
            "count": 0
          }
        ]
      },
      {
        "functionName": "exports.unstable_now",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 3408,
            "endOffset": 3475,
            "count": 519
          }
        ]
      },
      {
        "functionName": "exports.unstable_now",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 3604,
            "endOffset": 3678,
            "count": 0
          }
        ]
      },
      {
        "functionName": "advanceTimers",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 4758,
            "endOffset": 5241,
            "count": 7
          },
          {
            "startOffset": 4869,
            "endOffset": 5231,
            "count": 0
          }
        ]
      },
      {
        "functionName": "handleTimeout",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 5250,
            "endOffset": 5795,
            "count": 0
          }
        ]
      },
      {
        "functionName": "flushWork",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5804,
            "endOffset": 6837,
            "count": 3
          },
          {
            "startOffset": 5938,
            "endOffset": 6028,
            "count": 0
          },
          {
            "startOffset": 6173,
            "endOffset": 6581,
            "count": 0
          }
        ]
      },
      {
        "functionName": "workLoop",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 6846,
            "endOffset": 8396,
            "count": 3
          },
          {
            "startOffset": 7057,
            "endOffset": 7085,
            "count": 5
          },
          {
            "startOffset": 7087,
            "endOffset": 8081,
            "count": 5
          },
          {
            "startOffset": 7193,
            "endOffset": 7229,
            "count": 1
          },
          {
            "startOffset": 7229,
            "endOffset": 7975,
            "count": 4
          },
          {
            "startOffset": 7711,
            "endOffset": 7789,
            "count": 0
          },
          {
            "startOffset": 7975,
            "endOffset": 8026,
            "count": 0
          },
          {
            "startOffset": 8026,
            "endOffset": 8081,
            "count": 4
          },
          {
            "startOffset": 8118,
            "endOffset": 8156,
            "count": 1
          },
          {
            "startOffset": 8156,
            "endOffset": 8386,
            "count": 2
          },
          {
            "startOffset": 8248,
            "endOffset": 8348,
            "count": 0
          }
        ]
      },
      {
        "functionName": "unstable_runWithPriority",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 8405,
            "endOffset": 9034,
            "count": 0
          }
        ]
      },
      {
        "functionName": "unstable_next",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 9043,
            "endOffset": 9694,
            "count": 0
          }
        ]
      },
      {
        "functionName": "unstable_wrapCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 9703,
            "endOffset": 10144,
            "count": 0
          }
        ]
      },
      {
        "functionName": "unstable_scheduleCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10153,
            "endOffset": 12314,
            "count": 4
          },
          {
            "startOffset": 10344,
            "endOffset": 10363,
            "count": 0
          },
          {
            "startOffset": 10365,
            "endOffset": 10598,
            "count": 0
          },
          {
            "startOffset": 10726,
            "endOffset": 10822,
            "count": 0
          },
          {
            "startOffset": 10835,
            "endOffset": 10938,
            "count": 0
          },
          {
            "startOffset": 10951,
            "endOffset": 11037,
            "count": 0
          },
          {
            "startOffset": 11050,
            "endOffset": 11134,
            "count": 0
          },
          {
            "startOffset": 11574,
            "endOffset": 12002,
            "count": 0
          },
          {
            "startOffset": 12159,
            "endOffset": 12266,
            "count": 2
          }
        ]
      },
      {
        "functionName": "unstable_pauseExecution",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12323,
            "endOffset": 12369,
            "count": 0
          }
        ]
      },
      {
        "functionName": "unstable_continueExecution",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12378,
            "endOffset": 12590,
            "count": 0
          }
        ]
      },
      {
        "functionName": "unstable_getFirstCallbackNode",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12599,
            "endOffset": 12685,
            "count": 0
          }
        ]
      },
      {
        "functionName": "unstable_cancelCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12694,
            "endOffset": 12776,
            "count": 0
          }
        ]
      },
      {
        "functionName": "unstable_getCurrentPriorityLevel",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12785,
            "endOffset": 12879,
            "count": 0
          }
        ]
      },
      {
        "functionName": "shouldYieldToHost",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13074,
            "endOffset": 13284,
            "count": 5
          },
          {
            "startOffset": 13212,
            "endOffset": 13251,
            "count": 4
          },
          {
            "startOffset": 13251,
            "endOffset": 13283,
            "count": 1
          }
        ]
      },
      {
        "functionName": "requestPaint",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13293,
            "endOffset": 13328,
            "count": 2
          }
        ]
      },
      {
        "functionName": "forceFrameRate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13337,
            "endOffset": 13741,
            "count": 0
          }
        ]
      },
      {
        "functionName": "performWorkUntilDeadline",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13781,
            "endOffset": 14446,
            "count": 3
          },
          {
            "startOffset": 14165,
            "endOffset": 14234,
            "count": 1
          },
          {
            "startOffset": 14234,
            "endOffset": 14349,
            "count": 2
          },
          {
            "startOffset": 14375,
            "endOffset": 14436,
            "count": 0
          }
        ]
      },
      {
        "functionName": "schedulePerformWorkUntilDeadline",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14594,
            "endOffset": 14675,
            "count": 0
          }
        ]
      },
      {
        "functionName": "schedulePerformWorkUntilDeadline",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14926,
            "endOffset": 14986,
            "count": 3
          }
        ]
      },
      {
        "functionName": "schedulePerformWorkUntilDeadline",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15050,
            "endOffset": 15132,
            "count": 0
          }
        ]
      },
      {
        "functionName": "requestHostCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15152,
            "endOffset": 15386,
            "count": 2
          }
        ]
      },
      {
        "functionName": "requestHostTimeout",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15395,
            "endOffset": 15567,
            "count": 0
          }
        ]
      },
      {
        "functionName": "cancelHostTimeout",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15576,
            "endOffset": 15690,
            "count": 0
          }
        ]
      },
      {
        "functionName": "../../node_modules/.pnpm/scheduler@0.23.2/node_modules/scheduler/index.js",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 17322,
            "endOffset": 17559,
            "count": 1
          },
          {
            "startOffset": 17450,
            "endOffset": 17486,
            "count": 0
          }
        ]
      },
      {
        "functionName": "../../node_modules/.pnpm/react-dom@18.2.0_react@18.2.0/node_modules/react-dom/cjs/react-dom.development.js",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 17726,
            "endOffset": 924175,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 17887,
            "endOffset": 924161,
            "count": 1
          },
          {
            "startOffset": 18073,
            "endOffset": 18167,
            "count": 0
          },
          {
            "startOffset": 51049,
            "endOffset": 51054,
            "count": 0
          },
          {
            "startOffset": 142512,
            "endOffset": 142586,
            "count": 0
          },
          {
            "startOffset": 173322,
            "endOffset": 173337,
            "count": 0
          },
          {
            "startOffset": 232545,
            "endOffset": 232604,
            "count": 0
          },
          {
            "startOffset": 232788,
            "endOffset": 232807,
            "count": 0
          },
          {
            "startOffset": 232808,
            "endOffset": 232829,
            "count": 0
          },
          {
            "startOffset": 242857,
            "endOffset": 242885,
            "count": 0
          },
          {
            "startOffset": 250165,
            "endOffset": 250169,
            "count": 0
          },
          {
            "startOffset": 260317,
            "endOffset": 260347,
            "count": 0
          },
          {
            "startOffset": 264597,
            "endOffset": 264792,
            "count": 0
          },
          {
            "startOffset": 264839,
            "endOffset": 264912,
            "count": 0
          },
          {
            "startOffset": 334180,
            "endOffset": 334188,
            "count": 0
          },
          {
            "startOffset": 334268,
            "endOffset": 334276,
            "count": 0
          },
          {
            "startOffset": 334373,
            "endOffset": 334381,
            "count": 0
          },
          {
            "startOffset": 334469,
            "endOffset": 334646,
            "count": 0
          },
          {
            "startOffset": 588540,
            "endOffset": 588545,
            "count": 0
          },
          {
            "startOffset": 711181,
            "endOffset": 711186,
            "count": 0
          },
          {
            "startOffset": 859887,
            "endOffset": 859948,
            "count": 0
          },
          {
            "startOffset": 898795,
            "endOffset": 898861,
            "count": 0
          },
          {
            "startOffset": 920044,
            "endOffset": 920219,
            "count": 0
          },
          {
            "startOffset": 922780,
            "endOffset": 922826,
            "count": 0
          },
          {
            "startOffset": 923102,
            "endOffset": 923215,
            "count": 0
          },
          {
            "startOffset": 924060,
            "endOffset": 924153,
            "count": 0
          }
        ]
      },
      {
        "functionName": "setSuppressWarning",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 18388,
            "endOffset": 18521,
            "count": 0
          }
        ]
      },
      {
        "functionName": "warn",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 18530,
            "endOffset": 18877,
            "count": 0
          }
        ]
      },
      {
        "functionName": "error",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 18886,
            "endOffset": 19244,
            "count": 0
          }
        ]
      },
      {
        "functionName": "printWarning",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 19253,
            "endOffset": 19857,
            "count": 0
          }
        ]
      },
      {
        "functionName": "registerTwoPhaseEvent",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 21369,
            "endOffset": 21581,
            "count": 81
          }
        ]
      },
      {
        "functionName": "registerDirectEvent",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 21590,
            "endOffset": 22396,
            "count": 166
          },
          {
            "startOffset": 21729,
            "endOffset": 21877,
            "count": 0
          },
          {
            "startOffset": 22168,
            "endOffset": 22254,
            "count": 1
          },
          {
            "startOffset": 22323,
            "endOffset": 22386,
            "count": 236
          }
        ]
      },
      {
        "functionName": "typeName",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 22624,
            "endOffset": 22900,
            "count": 0
          }
        ]
      },
      {
        "functionName": "willCoercionThrow",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 22909,
            "endOffset": 23132,
            "count": 45
          },
          {
            "startOffset": 23058,
            "endOffset": 23110,
            "count": 0
          }
        ]
      },
      {
        "functionName": "testStringCoercion",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 23141,
            "endOffset": 23216,
            "count": 45
          }
        ]
      },
      {
        "functionName": "checkAttributeStringCoercion",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 23225,
            "endOffset": 23605,
            "count": 45
          },
          {
            "startOffset": 23341,
            "endOffset": 23583,
            "count": 0
          }
        ]
      },
      {
        "functionName": "checkKeyStringCoercion",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 23614,
            "endOffset": 23947,
            "count": 0
          }
        ]
      },
      {
        "functionName": "checkPropStringCoercion",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 23956,
            "endOffset": 24316,
            "count": 0
          }
        ]
      },
      {
        "functionName": "checkCSSPropertyStringCoercion",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 24325,
            "endOffset": 24700,
            "count": 0
          }
        ]
      },
      {
        "functionName": "checkHtmlStringCoercion",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 24709,
            "endOffset": 25061,
            "count": 0
          }
        ]
      },
      {
        "functionName": "checkFormFieldValueStringCoercion",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 25070,
            "endOffset": 25469,
            "count": 0
          }
        ]
      },
      {
        "functionName": "isAttributeNameSafe",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 26224,
            "endOffset": 26851,
            "count": 3
          },
          {
            "startOffset": 26349,
            "endOffset": 26387,
            "count": 1
          },
          {
            "startOffset": 26387,
            "endOffset": 26465,
            "count": 2
          },
          {
            "startOffset": 26465,
            "endOffset": 26504,
            "count": 0
          },
          {
            "startOffset": 26504,
            "endOffset": 26668,
            "count": 2
          },
          {
            "startOffset": 26668,
            "endOffset": 26850,
            "count": 0
          }
        ]
      },
      {
        "functionName": "shouldIgnoreAttribute",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 26860,
            "endOffset": 27296,
            "count": 45
          },
          {
            "startOffset": 26972,
            "endOffset": 27036,
            "count": 42
          },
          {
            "startOffset": 27036,
            "endOffset": 27073,
            "count": 3
          },
          {
            "startOffset": 27073,
            "endOffset": 27112,
            "count": 0
          },
          {
            "startOffset": 27112,
            "endOffset": 27182,
            "count": 3
          },
          {
            "startOffset": 27183,
            "endOffset": 27222,
            "count": 0
          },
          {
            "startOffset": 27224,
            "endOffset": 27262,
            "count": 0
          },
          {
            "startOffset": 27262,
            "endOffset": 27295,
            "count": 3
          }
        ]
      },
      {
        "functionName": "shouldRemoveAttributeWithWarning",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 27305,
            "endOffset": 28093,
            "count": 116
          },
          {
            "startOffset": 27434,
            "endOffset": 27467,
            "count": 111
          },
          {
            "startOffset": 27469,
            "endOffset": 27508,
            "count": 0
          },
          {
            "startOffset": 27555,
            "endOffset": 27571,
            "count": 0
          },
          {
            "startOffset": 27584,
            "endOffset": 27625,
            "count": 0
          },
          {
            "startOffset": 27638,
            "endOffset": 28022,
            "count": 3
          },
          {
            "startOffset": 27696,
            "endOffset": 27743,
            "count": 0
          },
          {
            "startOffset": 27785,
            "endOffset": 27856,
            "count": 0
          },
          {
            "startOffset": 27969,
            "endOffset": 27991,
            "count": 0
          },
          {
            "startOffset": 28035,
            "endOffset": 28071,
            "count": 113
          }
        ]
      },
      {
        "functionName": "shouldRemoveAttribute",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 28102,
            "endOffset": 28926,
            "count": 45
          },
          {
            "startOffset": 28246,
            "endOffset": 28284,
            "count": 0
          },
          {
            "startOffset": 28382,
            "endOffset": 28420,
            "count": 0
          },
          {
            "startOffset": 28457,
            "endOffset": 28496,
            "count": 0
          },
          {
            "startOffset": 28534,
            "endOffset": 28892,
            "count": 42
          },
          {
            "startOffset": 28591,
            "endOffset": 28635,
            "count": 0
          },
          {
            "startOffset": 28650,
            "endOffset": 28714,
            "count": 0
          },
          {
            "startOffset": 28729,
            "endOffset": 28779,
            "count": 0
          },
          {
            "startOffset": 28794,
            "endOffset": 28866,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getPropertyInfo",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 28935,
            "endOffset": 29053,
            "count": 179
          },
          {
            "startOffset": 29017,
            "endOffset": 29035,
            "count": 175
          },
          {
            "startOffset": 29036,
            "endOffset": 29042,
            "count": 4
          }
        ]
      },
      {
        "functionName": "PropertyInfoRecord",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 29062,
            "endOffset": 29623,
            "count": 144
          },
          {
            "startOffset": 29249,
            "endOffset": 29268,
            "count": 136
          },
          {
            "startOffset": 29269,
            "endOffset": 29299,
            "count": 109
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 30169,
            "endOffset": 30514,
            "count": 8
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 30644,
            "endOffset": 31051,
            "count": 4
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 31126,
            "endOffset": 31494,
            "count": 4
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 31588,
            "endOffset": 31942,
            "count": 4
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 32716,
            "endOffset": 33074,
            "count": 23
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 33527,
            "endOffset": 33870,
            "count": 4
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 34119,
            "endOffset": 34474,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 34752,
            "endOffset": 35105,
            "count": 4
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 35145,
            "endOffset": 35503,
            "count": 2
          }
        ]
      },
      {
        "functionName": "capitalize",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 35572,
            "endOffset": 35640,
            "count": 91
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 37874,
            "endOffset": 38272,
            "count": 73
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 38629,
            "endOffset": 39019,
            "count": 6
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 39292,
            "endOffset": 39690,
            "count": 3
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 39737,
            "endOffset": 40130,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 40503,
            "endOffset": 40894,
            "count": 4
          }
        ]
      },
      {
        "functionName": "sanitizeURL",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 41094,
            "endOffset": 41525,
            "count": 2
          },
          {
            "startOffset": 41194,
            "endOffset": 41503,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getValueForProperty",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 41534,
            "endOffset": 43407,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getValueForAttribute",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 43416,
            "endOffset": 43974,
            "count": 0
          }
        ]
      },
      {
        "functionName": "setValueForProperty",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 43983,
            "endOffset": 46225,
            "count": 45
          },
          {
            "startOffset": 44186,
            "endOffset": 44219,
            "count": 0
          },
          {
            "startOffset": 44306,
            "endOffset": 44345,
            "count": 0
          },
          {
            "startOffset": 44407,
            "endOffset": 44829,
            "count": 3
          },
          {
            "startOffset": 44529,
            "endOffset": 44600,
            "count": 0
          },
          {
            "startOffset": 44829,
            "endOffset": 44923,
            "count": 42
          },
          {
            "startOffset": 44923,
            "endOffset": 45235,
            "count": 0
          },
          {
            "startOffset": 45235,
            "endOffset": 45378,
            "count": 42
          },
          {
            "startOffset": 45378,
            "endOffset": 45440,
            "count": 0
          },
          {
            "startOffset": 45440,
            "endOffset": 46215,
            "count": 42
          },
          {
            "startOffset": 45589,
            "endOffset": 45606,
            "count": 0
          },
          {
            "startOffset": 45608,
            "endOffset": 45658,
            "count": 0
          },
          {
            "startOffset": 45893,
            "endOffset": 45966,
            "count": 2
          },
          {
            "startOffset": 46017,
            "endOffset": 46118,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getIteratorFn",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 47516,
            "endOffset": 47933,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disabledLog",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 48178,
            "endOffset": 48212,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disableLogs",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 48268,
            "endOffset": 49177,
            "count": 0
          }
        ]
      },
      {
        "functionName": "reenableLogs",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 49186,
            "endOffset": 50393,
            "count": 0
          }
        ]
      },
      {
        "functionName": "describeBuiltInComponentFrame",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 50504,
            "endOffset": 50904,
            "count": 0
          }
        ]
      },
      {
        "functionName": "describeNativeComponentFrame",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 51129,
            "endOffset": 54713,
            "count": 0
          }
        ]
      },
      {
        "functionName": "describeClassComponentFrame",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 54722,
            "endOffset": 54878,
            "count": 0
          }
        ]
      },
      {
        "functionName": "describeFunctionComponentFrame",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 54887,
            "endOffset": 55043,
            "count": 0
          }
        ]
      },
      {
        "functionName": "shouldConstruct",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 55052,
            "endOffset": 55208,
            "count": 0
          }
        ]
      },
      {
        "functionName": "describeUnknownElementTypeFrameInDEV",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 55217,
            "endOffset": 56612,
            "count": 0
          }
        ]
      },
      {
        "functionName": "describeFiber",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 56621,
            "endOffset": 57639,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getStackByFiberInDevAndProd",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 57648,
            "endOffset": 58057,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getWrappedName",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 58066,
            "endOffset": 58429,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getContextName",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 58438,
            "endOffset": 58527,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getComponentNameFromType",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 58536,
            "endOffset": 60699,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getWrappedName$1",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 60708,
            "endOffset": 60976,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getContextName$1",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 60985,
            "endOffset": 61076,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getComponentNameFromFiber",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 61085,
            "endOffset": 63177,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getCurrentFiberOwnerNameInDevOrNull",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 63329,
            "endOffset": 63691,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getCurrentFiberStackInDev",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 63700,
            "endOffset": 63904,
            "count": 0
          }
        ]
      },
      {
        "functionName": "resetCurrentFiber",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 63913,
            "endOffset": 64097,
            "count": 222
          }
        ]
      },
      {
        "functionName": "setCurrentFiber",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 64106,
            "endOffset": 64339,
            "count": 270
          },
          {
            "startOffset": 64220,
            "endOffset": 64226,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getCurrentFiber",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 64348,
            "endOffset": 64438,
            "count": 23
          }
        ]
      },
      {
        "functionName": "setIsRendering",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 64447,
            "endOffset": 64554,
            "count": 14
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 64563,
            "endOffset": 64628,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getToStringValue",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 64637,
            "endOffset": 65058,
            "count": 0
          }
        ]
      },
      {
        "functionName": "checkControlledValueProps",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 65277,
            "endOffset": 66106,
            "count": 0
          }
        ]
      },
      {
        "functionName": "isCheckable",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 66115,
            "endOffset": 66335,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getTracker",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 66344,
            "endOffset": 66418,
            "count": 0
          }
        ]
      },
      {
        "functionName": "detachTracker",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 66427,
            "endOffset": 66504,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getValueFromNode",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 66513,
            "endOffset": 66818,
            "count": 0
          }
        ]
      },
      {
        "functionName": "trackValueOnNode",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 66827,
            "endOffset": 68411,
            "count": 0
          }
        ]
      },
      {
        "functionName": "track",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 68420,
            "endOffset": 68573,
            "count": 0
          }
        ]
      },
      {
        "functionName": "updateValueIfChanged",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 68582,
            "endOffset": 69034,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getActiveElement",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 69043,
            "endOffset": 69375,
            "count": 4
          },
          {
            "startOffset": 69143,
            "endOffset": 69151,
            "count": 0
          },
          {
            "startOffset": 69196,
            "endOffset": 69234,
            "count": 0
          },
          {
            "startOffset": 69288,
            "endOffset": 69299,
            "count": 0
          },
          {
            "startOffset": 69313,
            "endOffset": 69365,
            "count": 0
          }
        ]
      },
      {
        "functionName": "isControlled",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 69586,
            "endOffset": 69783,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getHostProps",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 69792,
            "endOffset": 70178,
            "count": 0
          }
        ]
      },
      {
        "functionName": "initWrapperState",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 70187,
            "endOffset": 71950,
            "count": 0
          }
        ]
      },
      {
        "functionName": "updateChecked",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 71959,
            "endOffset": 72189,
            "count": 0
          }
        ]
      },
      {
        "functionName": "updateWrapper",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 72198,
            "endOffset": 74545,
            "count": 0
          }
        ]
      },
      {
        "functionName": "postMountWrapper",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 74554,
            "endOffset": 75633,
            "count": 0
          }
        ]
      },
      {
        "functionName": "restoreControlledState",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 75642,
            "endOffset": 75812,
            "count": 0
          }
        ]
      },
      {
        "functionName": "updateNamedCousins",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 75821,
            "endOffset": 76901,
            "count": 0
          }
        ]
      },
      {
        "functionName": "setDefaultValue",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 76910,
            "endOffset": 77407,
            "count": 0
          }
        ]
      },
      {
        "functionName": "validateProps",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 77550,
            "endOffset": 78910,
            "count": 0
          }
        ]
      },
      {
        "functionName": "postMountWrapper$1",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 78919,
            "endOffset": 79107,
            "count": 0
          }
        ]
      },
      {
        "functionName": "isArray",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 79157,
            "endOffset": 79221,
            "count": 30
          }
        ]
      },
      {
        "functionName": "getDeclarationErrorAddendum",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 79336,
            "endOffset": 79585,
            "count": 0
          }
        ]
      },
      {
        "functionName": "checkSelectPropTypes",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 79650,
            "endOffset": 80481,
            "count": 0
          }
        ]
      },
      {
        "functionName": "updateOptions",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 80490,
            "endOffset": 81979,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getHostProps$1",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 81988,
            "endOffset": 82116,
            "count": 0
          }
        ]
      },
      {
        "functionName": "initWrapperState$1",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 82125,
            "endOffset": 82865,
            "count": 0
          }
        ]
      },
      {
        "functionName": "postMountWrapper$2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 82874,
            "endOffset": 83274,
            "count": 0
          }
        ]
      },
      {
        "functionName": "postUpdateWrapper",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 83283,
            "endOffset": 83934,
            "count": 0
          }
        ]
      },
      {
        "functionName": "restoreControlledState$1",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 83943,
            "endOffset": 84177,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getHostProps$2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 84228,
            "endOffset": 84682,
            "count": 0
          }
        ]
      },
      {
        "functionName": "initWrapperState$2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 84691,
            "endOffset": 86522,
            "count": 0
          }
        ]
      },
      {
        "functionName": "updateWrapper$1",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 86531,
            "endOffset": 87158,
            "count": 0
          }
        ]
      },
      {
        "functionName": "postMountWrapper$3",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 87167,
            "endOffset": 87491,
            "count": 0
          }
        ]
      },
      {
        "functionName": "restoreControlledState$2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 87500,
            "endOffset": 87604,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getIntrinsicNamespace",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 87799,
            "endOffset": 88065,
            "count": 120
          },
          {
            "startOffset": 87876,
            "endOffset": 87923,
            "count": 0
          },
          {
            "startOffset": 87936,
            "endOffset": 87985,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getChildNamespace",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 88074,
            "endOffset": 88434,
            "count": 79
          },
          {
            "startOffset": 88264,
            "endOffset": 88340,
            "count": 0
          },
          {
            "startOffset": 88342,
            "endOffset": 88433,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createMicrosoftUnsafeLocalFunction",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 88484,
            "endOffset": 88842,
            "count": 1
          },
          {
            "startOffset": 88544,
            "endOffset": 88576,
            "count": 0
          },
          {
            "startOffset": 88578,
            "endOffset": 88788,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 88599,
            "endOffset": 88775,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 88940,
            "endOffset": 89616,
            "count": 0
          }
        ]
      },
      {
        "functionName": "setTextContent",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 89807,
            "endOffset": 90133,
            "count": 19
          },
          {
            "startOffset": 89925,
            "endOffset": 89957,
            "count": 0
          },
          {
            "startOffset": 89958,
            "endOffset": 89994,
            "count": 0
          },
          {
            "startOffset": 89996,
            "endOffset": 90076,
            "count": 0
          }
        ]
      },
      {
        "functionName": "prefixKey",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 96076,
            "endOffset": 96195,
            "count": 172
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 96295,
            "endOffset": 96463,
            "count": 43
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 96339,
            "endOffset": 96451,
            "count": 172
          }
        ]
      },
      {
        "functionName": "dangerousStyleValue",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 96474,
            "endOffset": 97003,
            "count": 0
          }
        ]
      },
      {
        "functionName": "hyphenateStyleName",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 97087,
            "endOffset": 97229,
            "count": 0
          }
        ]
      },
      {
        "functionName": "warnValidStyle",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 97259,
            "endOffset": 97281,
            "count": 0
          }
        ]
      },
      {
        "functionName": "camelize",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 97685,
            "endOffset": 97851,
            "count": 0
          }
        ]
      },
      {
        "functionName": "warnHyphenatedStyleName",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 97893,
            "endOffset": 98442,
            "count": 0
          }
        ]
      },
      {
        "functionName": "warnBadVendoredStyleName",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 98485,
            "endOffset": 98813,
            "count": 0
          }
        ]
      },
      {
        "functionName": "warnStyleValueWithSemicolon",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 98859,
            "endOffset": 99219,
            "count": 0
          }
        ]
      },
      {
        "functionName": "warnStyleValueIsNaN",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 99257,
            "endOffset": 99490,
            "count": 0
          }
        ]
      },
      {
        "functionName": "warnStyleValueIsInfinity",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 99533,
            "endOffset": 99781,
            "count": 0
          }
        ]
      },
      {
        "functionName": "warnValidStyle",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 99810,
            "endOffset": 100444,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createDangerousStringForStyles",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 100511,
            "endOffset": 101266,
            "count": 0
          }
        ]
      },
      {
        "functionName": "setValueForStyles",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 101275,
            "endOffset": 102085,
            "count": 0
          }
        ]
      },
      {
        "functionName": "isValueEmpty",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 102094,
            "endOffset": 102212,
            "count": 0
          }
        ]
      },
      {
        "functionName": "expandShorthandMap",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 102221,
            "endOffset": 102550,
            "count": 0
          }
        ]
      },
      {
        "functionName": "validateShorthandPropertyCollisionInDev",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 102559,
            "endOffset": 103756,
            "count": 0
          }
        ]
      },
      {
        "functionName": "assertValidProps",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 104347,
            "endOffset": 105924,
            "count": 67
          },
          {
            "startOffset": 104409,
            "endOffset": 104442,
            "count": 0
          },
          {
            "startOffset": 104479,
            "endOffset": 104720,
            "count": 0
          },
          {
            "startOffset": 104774,
            "endOffset": 105261,
            "count": 0
          },
          {
            "startOffset": 105353,
            "endOffset": 105378,
            "count": 0
          },
          {
            "startOffset": 105380,
            "endOffset": 105637,
            "count": 0
          },
          {
            "startOffset": 105684,
            "endOffset": 105718,
            "count": 0
          },
          {
            "startOffset": 105720,
            "endOffset": 105914,
            "count": 0
          }
        ]
      },
      {
        "functionName": "isCustomComponent",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 105933,
            "endOffset": 106483,
            "count": 216
          },
          {
            "startOffset": 106083,
            "endOffset": 106147,
            "count": 0
          },
          {
            "startOffset": 106160,
            "endOffset": 106181,
            "count": 0
          },
          {
            "startOffset": 106194,
            "endOffset": 106211,
            "count": 0
          },
          {
            "startOffset": 106224,
            "endOffset": 106245,
            "count": 0
          },
          {
            "startOffset": 106258,
            "endOffset": 106279,
            "count": 0
          },
          {
            "startOffset": 106292,
            "endOffset": 106316,
            "count": 0
          },
          {
            "startOffset": 106329,
            "endOffset": 106351,
            "count": 0
          },
          {
            "startOffset": 106364,
            "endOffset": 106413,
            "count": 0
          },
          {
            "startOffset": 106426,
            "endOffset": 106461,
            "count": 0
          }
        ]
      },
      {
        "functionName": "validateProperty",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 125635,
            "endOffset": 127137,
            "count": 136
          },
          {
            "startOffset": 125750,
            "endOffset": 125775,
            "count": 0
          },
          {
            "startOffset": 125777,
            "endOffset": 125819,
            "count": 0
          },
          {
            "startOffset": 125859,
            "endOffset": 126519,
            "count": 0
          },
          {
            "startOffset": 126554,
            "endOffset": 127092,
            "count": 2
          },
          {
            "startOffset": 126707,
            "endOffset": 126713,
            "count": 0
          },
          {
            "startOffset": 126755,
            "endOffset": 126849,
            "count": 0
          },
          {
            "startOffset": 126891,
            "endOffset": 127078,
            "count": 0
          }
        ]
      },
      {
        "functionName": "warnInvalidARIAProps",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 127146,
            "endOffset": 127987,
            "count": 67
          },
          {
            "startOffset": 127273,
            "endOffset": 127431,
            "count": 136
          },
          {
            "startOffset": 127360,
            "endOffset": 127417,
            "count": 0
          },
          {
            "startOffset": 127611,
            "endOffset": 127770,
            "count": 0
          },
          {
            "startOffset": 127805,
            "endOffset": 127965,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 127485,
            "endOffset": 127554,
            "count": 0
          }
        ]
      },
      {
        "functionName": "validateProperties",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 127996,
            "endOffset": 128173,
            "count": 67
          },
          {
            "startOffset": 128085,
            "endOffset": 128118,
            "count": 0
          }
        ]
      },
      {
        "functionName": "validateProperties$1",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 128220,
            "endOffset": 129015,
            "count": 67
          },
          {
            "startOffset": 128392,
            "endOffset": 128446,
            "count": 0
          },
          {
            "startOffset": 128447,
            "endOffset": 128467,
            "count": 0
          },
          {
            "startOffset": 128469,
            "endOffset": 128993,
            "count": 0
          }
        ]
      },
      {
        "functionName": "validateProperty$1",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 129049,
            "endOffset": 129071,
            "count": 0
          }
        ]
      },
      {
        "functionName": "validateProperty$1",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 129415,
            "endOffset": 135123,
            "count": 136
          },
          {
            "startOffset": 129525,
            "endOffset": 129552,
            "count": 0
          },
          {
            "startOffset": 129554,
            "endOffset": 129596,
            "count": 0
          },
          {
            "startOffset": 129733,
            "endOffset": 130019,
            "count": 0
          },
          {
            "startOffset": 130295,
            "endOffset": 130341,
            "count": 0
          },
          {
            "startOffset": 130437,
            "endOffset": 130481,
            "count": 0
          },
          {
            "startOffset": 130534,
            "endOffset": 130735,
            "count": 0
          },
          {
            "startOffset": 130783,
            "endOffset": 130967,
            "count": 0
          },
          {
            "startOffset": 130981,
            "endOffset": 131324,
            "count": 0
          },
          {
            "startOffset": 131360,
            "endOffset": 131386,
            "count": 134
          },
          {
            "startOffset": 131388,
            "endOffset": 131430,
            "count": 2
          },
          {
            "startOffset": 131430,
            "endOffset": 131479,
            "count": 134
          },
          {
            "startOffset": 131479,
            "endOffset": 131721,
            "count": 0
          },
          {
            "startOffset": 131721,
            "endOffset": 131765,
            "count": 134
          },
          {
            "startOffset": 131765,
            "endOffset": 131980,
            "count": 0
          },
          {
            "startOffset": 131980,
            "endOffset": 132021,
            "count": 134
          },
          {
            "startOffset": 132021,
            "endOffset": 132038,
            "count": 0
          },
          {
            "startOffset": 132039,
            "endOffset": 132058,
            "count": 0
          },
          {
            "startOffset": 132059,
            "endOffset": 132087,
            "count": 0
          },
          {
            "startOffset": 132089,
            "endOffset": 132310,
            "count": 0
          },
          {
            "startOffset": 132310,
            "endOffset": 132353,
            "count": 134
          },
          {
            "startOffset": 132353,
            "endOffset": 132368,
            "count": 0
          },
          {
            "startOffset": 132370,
            "endOffset": 132575,
            "count": 0
          },
          {
            "startOffset": 132575,
            "endOffset": 132681,
            "count": 134
          },
          {
            "startOffset": 132681,
            "endOffset": 132714,
            "count": 133
          },
          {
            "startOffset": 132786,
            "endOffset": 133102,
            "count": 133
          },
          {
            "startOffset": 132901,
            "endOffset": 133088,
            "count": 0
          },
          {
            "startOffset": 133102,
            "endOffset": 133540,
            "count": 1
          },
          {
            "startOffset": 133152,
            "endOffset": 133540,
            "count": 0
          },
          {
            "startOffset": 133540,
            "endOffset": 133584,
            "count": 134
          },
          {
            "startOffset": 133584,
            "endOffset": 133653,
            "count": 1
          },
          {
            "startOffset": 133655,
            "endOffset": 134345,
            "count": 0
          },
          {
            "startOffset": 134345,
            "endOffset": 134374,
            "count": 134
          },
          {
            "startOffset": 134374,
            "endOffset": 134416,
            "count": 64
          },
          {
            "startOffset": 134416,
            "endOffset": 134501,
            "count": 70
          },
          {
            "startOffset": 134501,
            "endOffset": 134591,
            "count": 0
          },
          {
            "startOffset": 134591,
            "endOffset": 134646,
            "count": 70
          },
          {
            "startOffset": 134648,
            "endOffset": 134672,
            "count": 0
          },
          {
            "startOffset": 134673,
            "endOffset": 134705,
            "count": 0
          },
          {
            "startOffset": 134707,
            "endOffset": 135086,
            "count": 0
          },
          {
            "startOffset": 135086,
            "endOffset": 135122,
            "count": 70
          }
        ]
      },
      {
        "functionName": "warnUnknownProperties",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 135171,
            "endOffset": 136234,
            "count": 67
          },
          {
            "startOffset": 135292,
            "endOffset": 135479,
            "count": 136
          },
          {
            "startOffset": 135408,
            "endOffset": 135465,
            "count": 0
          },
          {
            "startOffset": 135659,
            "endOffset": 135915,
            "count": 0
          },
          {
            "startOffset": 135950,
            "endOffset": 136212,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 135533,
            "endOffset": 135602,
            "count": 0
          }
        ]
      },
      {
        "functionName": "validateProperties$2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 136244,
            "endOffset": 136454,
            "count": 67
          },
          {
            "startOffset": 136350,
            "endOffset": 136383,
            "count": 0
          }
        ]
      },
      {
        "functionName": "setReplayingEvent",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 136761,
            "endOffset": 137075,
            "count": 0
          }
        ]
      },
      {
        "functionName": "resetReplayingEvent",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 137084,
            "endOffset": 137398,
            "count": 0
          }
        ]
      },
      {
        "functionName": "isReplayingEvent",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 137407,
            "endOffset": 137501,
            "count": 2
          }
        ]
      },
      {
        "functionName": "getEventTarget",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 137510,
            "endOffset": 137827,
            "count": 28
          },
          {
            "startOffset": 137591,
            "endOffset": 137616,
            "count": 0
          },
          {
            "startOffset": 137617,
            "endOffset": 137626,
            "count": 0
          },
          {
            "startOffset": 137674,
            "endOffset": 137740,
            "count": 0
          },
          {
            "startOffset": 137788,
            "endOffset": 137807,
            "count": 0
          }
        ]
      },
      {
        "functionName": "restoreStateOfTarget",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 137935,
            "endOffset": 138608,
            "count": 0
          }
        ]
      },
      {
        "functionName": "setRestoreImplementation",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 138617,
            "endOffset": 138698,
            "count": 1
          }
        ]
      },
      {
        "functionName": "enqueueStateRestore",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 138707,
            "endOffset": 139000,
            "count": 0
          }
        ]
      },
      {
        "functionName": "needsStateRestore",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 139009,
            "endOffset": 139115,
            "count": 14
          }
        ]
      },
      {
        "functionName": "restoreStateIfNeeded",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 139124,
            "endOffset": 139588,
            "count": 0
          }
        ]
      },
      {
        "functionName": "batchedUpdatesImpl",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 139622,
            "endOffset": 139693,
            "count": 0
          }
        ]
      },
      {
        "functionName": "flushSyncImpl",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 139723,
            "endOffset": 139745,
            "count": 0
          }
        ]
      },
      {
        "functionName": "finishEventHandler",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 139797,
            "endOffset": 140047,
            "count": 14
          },
          {
            "startOffset": 139959,
            "endOffset": 140037,
            "count": 0
          }
        ]
      },
      {
        "functionName": "batchedUpdates",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 140056,
            "endOffset": 140394,
            "count": 14
          },
          {
            "startOffset": 140128,
            "endOffset": 140170,
            "count": 0
          }
        ]
      },
      {
        "functionName": "setBatchingImplementation",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 140403,
            "endOffset": 140602,
            "count": 1
          }
        ]
      },
      {
        "functionName": "isInteractive",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 140611,
            "endOffset": 140746,
            "count": 0
          }
        ]
      },
      {
        "functionName": "shouldPreventMouseEvent",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 140755,
            "endOffset": 141349,
            "count": 48
          },
          {
            "startOffset": 140847,
            "endOffset": 140862,
            "count": 0
          },
          {
            "startOffset": 140875,
            "endOffset": 140897,
            "count": 0
          },
          {
            "startOffset": 140910,
            "endOffset": 140931,
            "count": 0
          },
          {
            "startOffset": 140944,
            "endOffset": 140972,
            "count": 0
          },
          {
            "startOffset": 140985,
            "endOffset": 141004,
            "count": 0
          },
          {
            "startOffset": 141017,
            "endOffset": 141043,
            "count": 0
          },
          {
            "startOffset": 141056,
            "endOffset": 141075,
            "count": 0
          },
          {
            "startOffset": 141088,
            "endOffset": 141114,
            "count": 0
          },
          {
            "startOffset": 141127,
            "endOffset": 141144,
            "count": 0
          },
          {
            "startOffset": 141157,
            "endOffset": 141181,
            "count": 0
          },
          {
            "startOffset": 141194,
            "endOffset": 141278,
            "count": 2
          },
          {
            "startOffset": 141254,
            "endOffset": 141276,
            "count": 0
          },
          {
            "startOffset": 141291,
            "endOffset": 141327,
            "count": 46
          }
        ]
      },
      {
        "functionName": "getListener",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 141358,
            "endOffset": 142074,
            "count": 48
          },
          {
            "startOffset": 141481,
            "endOffset": 141519,
            "count": 0
          },
          {
            "startOffset": 141613,
            "endOffset": 141651,
            "count": 0
          },
          {
            "startOffset": 141777,
            "endOffset": 141815,
            "count": 0
          },
          {
            "startOffset": 141839,
            "endOffset": 141872,
            "count": 0
          },
          {
            "startOffset": 141874,
            "endOffset": 142037,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 142272,
            "endOffset": 142354,
            "count": 1
          }
        ]
      },
      {
        "functionName": "invokeGuardedCallbackProd",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 142605,
            "endOffset": 142891,
            "count": 0
          }
        ]
      },
      {
        "functionName": "invokeGuardedCallbackDev",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 143243,
            "endOffset": 147040,
            "count": 0
          }
        ]
      },
      {
        "functionName": "onError",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 147309,
            "endOffset": 147402,
            "count": 0
          }
        ]
      },
      {
        "functionName": "invokeGuardedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 147422,
            "endOffset": 147627,
            "count": 0
          }
        ]
      },
      {
        "functionName": "invokeGuardedCallbackAndCatchFirstError",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 147636,
            "endOffset": 147999,
            "count": 0
          }
        ]
      },
      {
        "functionName": "rethrowCaughtError",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 148008,
            "endOffset": 148229,
            "count": 14
          },
          {
            "startOffset": 148071,
            "endOffset": 148219,
            "count": 0
          }
        ]
      },
      {
        "functionName": "hasCaughtError",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 148238,
            "endOffset": 148302,
            "count": 0
          }
        ]
      },
      {
        "functionName": "clearCaughtError",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 148311,
            "endOffset": 148690,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 148699,
            "endOffset": 148766,
            "count": 0
          }
        ]
      },
      {
        "functionName": "has",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 148775,
            "endOffset": 148853,
            "count": 0
          }
        ]
      },
      {
        "functionName": "set",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 148862,
            "endOffset": 148937,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getNearestMountedFiber",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 151792,
            "endOffset": 152449,
            "count": 15
          },
          {
            "startOffset": 151981,
            "endOffset": 152199,
            "count": 129
          },
          {
            "startOffset": 152084,
            "endOffset": 152147,
            "count": 0
          },
          {
            "startOffset": 152229,
            "endOffset": 152330,
            "count": 0
          },
          {
            "startOffset": 152416,
            "endOffset": 152448,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getSuspenseInstanceFromFiber",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 152458,
            "endOffset": 152967,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getContainerFromFiber",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 152976,
            "endOffset": 153105,
            "count": 0
          }
        ]
      },
      {
        "functionName": "isFiberMounted",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 153114,
            "endOffset": 153214,
            "count": 0
          }
        ]
      },
      {
        "functionName": "isMounted",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 153223,
            "endOffset": 154154,
            "count": 0
          }
        ]
      },
      {
        "functionName": "assertIsMounted",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 154163,
            "endOffset": 154354,
            "count": 0
          }
        ]
      },
      {
        "functionName": "findCurrentFiberUsingSlowPath",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 154363,
            "endOffset": 157723,
            "count": 1
          },
          {
            "startOffset": 154587,
            "endOffset": 154683,
            "count": 0
          },
          {
            "startOffset": 154726,
            "endOffset": 154768,
            "count": 0
          },
          {
            "startOffset": 154806,
            "endOffset": 157722,
            "count": 0
          }
        ]
      },
      {
        "functionName": "findCurrentHostFiber",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 157732,
            "endOffset": 157940,
            "count": 0
          }
        ]
      },
      {
        "functionName": "findCurrentHostFiberImpl",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 157949,
            "endOffset": 158378,
            "count": 0
          }
        ]
      },
      {
        "functionName": "findCurrentHostFiberWithNoPortals",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 158387,
            "endOffset": 158621,
            "count": 1
          },
          {
            "startOffset": 158604,
            "endOffset": 158610,
            "count": 0
          }
        ]
      },
      {
        "functionName": "findCurrentHostFiberWithNoPortalsImpl",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 158630,
            "endOffset": 159151,
            "count": 1
          },
          {
            "startOffset": 158752,
            "endOffset": 158790,
            "count": 0
          },
          {
            "startOffset": 158858,
            "endOffset": 159118,
            "count": 0
          }
        ]
      },
      {
        "functionName": "injectInternals",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 160242,
            "endOffset": 161371,
            "count": 1
          },
          {
            "startOffset": 160349,
            "endOffset": 160388,
            "count": 0
          },
          {
            "startOffset": 160473,
            "endOffset": 160511,
            "count": 0
          },
          {
            "startOffset": 160547,
            "endOffset": 160811,
            "count": 0
          },
          {
            "startOffset": 161118,
            "endOffset": 161248,
            "count": 0
          },
          {
            "startOffset": 161278,
            "endOffset": 161316,
            "count": 0
          }
        ]
      },
      {
        "functionName": "onScheduleRoot",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 161380,
            "endOffset": 161883,
            "count": 1
          },
          {
            "startOffset": 161640,
            "endOffset": 161847,
            "count": 0
          }
        ]
      },
      {
        "functionName": "onCommitRoot",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 161892,
            "endOffset": 163384,
            "count": 2
          },
          {
            "startOffset": 162261,
            "endOffset": 162374,
            "count": 0
          },
          {
            "startOffset": 162393,
            "endOffset": 162511,
            "count": 0
          },
          {
            "startOffset": 162530,
            "endOffset": 162639,
            "count": 0
          },
          {
            "startOffset": 162658,
            "endOffset": 162762,
            "count": 0
          },
          {
            "startOffset": 163002,
            "endOffset": 163110,
            "count": 0
          },
          {
            "startOffset": 163125,
            "endOffset": 163362,
            "count": 0
          }
        ]
      },
      {
        "functionName": "onPostCommitRoot",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 163393,
            "endOffset": 163878,
            "count": 2
          },
          {
            "startOffset": 163516,
            "endOffset": 163868,
            "count": 0
          }
        ]
      },
      {
        "functionName": "onCommitUnmount",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 163887,
            "endOffset": 164369,
            "count": 0
          }
        ]
      },
      {
        "functionName": "setIsStrictModeForDevtools",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 164378,
            "endOffset": 165113,
            "count": 14
          },
          {
            "startOffset": 164504,
            "endOffset": 164632,
            "count": 0
          },
          {
            "startOffset": 164715,
            "endOffset": 165091,
            "count": 0
          }
        ]
      },
      {
        "functionName": "injectProfilingHooks",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 165122,
            "endOffset": 165230,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getLaneLabelMap",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 165239,
            "endOffset": 165590,
            "count": 0
          }
        ]
      },
      {
        "functionName": "markCommitStarted",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 165599,
            "endOffset": 165862,
            "count": 2
          },
          {
            "startOffset": 165695,
            "endOffset": 165760,
            "count": 0
          },
          {
            "startOffset": 165762,
            "endOffset": 165840,
            "count": 0
          }
        ]
      },
      {
        "functionName": "markCommitStopped",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 165871,
            "endOffset": 166124,
            "count": 2
          },
          {
            "startOffset": 165962,
            "endOffset": 166027,
            "count": 0
          },
          {
            "startOffset": 166029,
            "endOffset": 166102,
            "count": 0
          }
        ]
      },
      {
        "functionName": "markComponentRenderStarted",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 166133,
            "endOffset": 166423,
            "count": 7
          },
          {
            "startOffset": 166238,
            "endOffset": 166312,
            "count": 0
          },
          {
            "startOffset": 166314,
            "endOffset": 166401,
            "count": 0
          }
        ]
      },
      {
        "functionName": "markComponentRenderStopped",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 166432,
            "endOffset": 166712,
            "count": 7
          },
          {
            "startOffset": 166532,
            "endOffset": 166606,
            "count": 0
          },
          {
            "startOffset": 166608,
            "endOffset": 166690,
            "count": 0
          }
        ]
      },
      {
        "functionName": "markComponentPassiveEffectMountStarted",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 166721,
            "endOffset": 167047,
            "count": 15
          },
          {
            "startOffset": 166838,
            "endOffset": 166924,
            "count": 0
          },
          {
            "startOffset": 166926,
            "endOffset": 167025,
            "count": 0
          }
        ]
      },
      {
        "functionName": "markComponentPassiveEffectMountStopped",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 167056,
            "endOffset": 167372,
            "count": 15
          },
          {
            "startOffset": 167168,
            "endOffset": 167254,
            "count": 0
          },
          {
            "startOffset": 167256,
            "endOffset": 167350,
            "count": 0
          }
        ]
      },
      {
        "functionName": "markComponentPassiveEffectUnmountStarted",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 167381,
            "endOffset": 167713,
            "count": 3
          },
          {
            "startOffset": 167500,
            "endOffset": 167588,
            "count": 0
          },
          {
            "startOffset": 167590,
            "endOffset": 167691,
            "count": 0
          }
        ]
      },
      {
        "functionName": "markComponentPassiveEffectUnmountStopped",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 167722,
            "endOffset": 168044,
            "count": 3
          },
          {
            "startOffset": 167836,
            "endOffset": 167924,
            "count": 0
          },
          {
            "startOffset": 167926,
            "endOffset": 168022,
            "count": 0
          }
        ]
      },
      {
        "functionName": "markComponentLayoutEffectMountStarted",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 168053,
            "endOffset": 168376,
            "count": 4
          },
          {
            "startOffset": 168169,
            "endOffset": 168254,
            "count": 0
          },
          {
            "startOffset": 168256,
            "endOffset": 168354,
            "count": 0
          }
        ]
      },
      {
        "functionName": "markComponentLayoutEffectMountStopped",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 168385,
            "endOffset": 168698,
            "count": 4
          },
          {
            "startOffset": 168496,
            "endOffset": 168581,
            "count": 0
          },
          {
            "startOffset": 168583,
            "endOffset": 168676,
            "count": 0
          }
        ]
      },
      {
        "functionName": "markComponentLayoutEffectUnmountStarted",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 168707,
            "endOffset": 169036,
            "count": 1
          },
          {
            "startOffset": 168825,
            "endOffset": 168912,
            "count": 0
          },
          {
            "startOffset": 168914,
            "endOffset": 169014,
            "count": 0
          }
        ]
      },
      {
        "functionName": "markComponentLayoutEffectUnmountStopped",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 169045,
            "endOffset": 169364,
            "count": 1
          },
          {
            "startOffset": 169158,
            "endOffset": 169245,
            "count": 0
          },
          {
            "startOffset": 169247,
            "endOffset": 169342,
            "count": 0
          }
        ]
      },
      {
        "functionName": "markComponentErrored",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 169373,
            "endOffset": 169685,
            "count": 0
          }
        ]
      },
      {
        "functionName": "markComponentSuspended",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 169694,
            "endOffset": 170006,
            "count": 0
          }
        ]
      },
      {
        "functionName": "markLayoutEffectsStarted",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 170015,
            "endOffset": 170299,
            "count": 2
          },
          {
            "startOffset": 170118,
            "endOffset": 170190,
            "count": 0
          },
          {
            "startOffset": 170192,
            "endOffset": 170277,
            "count": 0
          }
        ]
      },
      {
        "functionName": "markLayoutEffectsStopped",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 170308,
            "endOffset": 170582,
            "count": 2
          },
          {
            "startOffset": 170406,
            "endOffset": 170478,
            "count": 0
          },
          {
            "startOffset": 170480,
            "endOffset": 170560,
            "count": 0
          }
        ]
      },
      {
        "functionName": "markPassiveEffectsStarted",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 170591,
            "endOffset": 170878,
            "count": 2
          },
          {
            "startOffset": 170695,
            "endOffset": 170768,
            "count": 0
          },
          {
            "startOffset": 170770,
            "endOffset": 170856,
            "count": 0
          }
        ]
      },
      {
        "functionName": "markPassiveEffectsStopped",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 170887,
            "endOffset": 171164,
            "count": 2
          },
          {
            "startOffset": 170986,
            "endOffset": 171059,
            "count": 0
          },
          {
            "startOffset": 171061,
            "endOffset": 171142,
            "count": 0
          }
        ]
      },
      {
        "functionName": "markRenderStarted",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 171173,
            "endOffset": 171436,
            "count": 2
          },
          {
            "startOffset": 171269,
            "endOffset": 171334,
            "count": 0
          },
          {
            "startOffset": 171336,
            "endOffset": 171414,
            "count": 0
          }
        ]
      },
      {
        "functionName": "markRenderYielded",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 171445,
            "endOffset": 171698,
            "count": 0
          }
        ]
      },
      {
        "functionName": "markRenderStopped",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 171707,
            "endOffset": 171960,
            "count": 2
          },
          {
            "startOffset": 171798,
            "endOffset": 171863,
            "count": 0
          },
          {
            "startOffset": 171865,
            "endOffset": 171938,
            "count": 0
          }
        ]
      },
      {
        "functionName": "markRenderScheduled",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 171969,
            "endOffset": 172236,
            "count": 1
          },
          {
            "startOffset": 172066,
            "endOffset": 172133,
            "count": 0
          },
          {
            "startOffset": 172135,
            "endOffset": 172214,
            "count": 0
          }
        ]
      },
      {
        "functionName": "markForceUpdateScheduled",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 172245,
            "endOffset": 172541,
            "count": 0
          }
        ]
      },
      {
        "functionName": "markStateUpdateScheduled",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 172550,
            "endOffset": 172846,
            "count": 1
          },
          {
            "startOffset": 172659,
            "endOffset": 172731,
            "count": 0
          },
          {
            "startOffset": 172733,
            "endOffset": 172824,
            "count": 0
          }
        ]
      },
      {
        "functionName": "clz32Fallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 173403,
            "endOffset": 173588,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getLabelForLane",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 177117,
            "endOffset": 178313,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getHighestPriorityLanes",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 178442,
            "endOffset": 180262,
            "count": 4
          },
          {
            "startOffset": 178547,
            "endOffset": 178592,
            "count": 0
          },
          {
            "startOffset": 178605,
            "endOffset": 178690,
            "count": 0
          },
          {
            "startOffset": 178703,
            "endOffset": 178770,
            "count": 0
          },
          {
            "startOffset": 178783,
            "endOffset": 178852,
            "count": 0
          },
          {
            "startOffset": 178929,
            "endOffset": 179004,
            "count": 0
          },
          {
            "startOffset": 179017,
            "endOffset": 179038,
            "count": 0
          },
          {
            "startOffset": 179051,
            "endOffset": 179072,
            "count": 0
          },
          {
            "startOffset": 179085,
            "endOffset": 179106,
            "count": 0
          },
          {
            "startOffset": 179119,
            "endOffset": 179140,
            "count": 0
          },
          {
            "startOffset": 179153,
            "endOffset": 179174,
            "count": 0
          },
          {
            "startOffset": 179187,
            "endOffset": 179208,
            "count": 0
          },
          {
            "startOffset": 179221,
            "endOffset": 179242,
            "count": 0
          },
          {
            "startOffset": 179255,
            "endOffset": 179276,
            "count": 0
          },
          {
            "startOffset": 179289,
            "endOffset": 179310,
            "count": 0
          },
          {
            "startOffset": 179323,
            "endOffset": 179345,
            "count": 0
          },
          {
            "startOffset": 179358,
            "endOffset": 179380,
            "count": 0
          },
          {
            "startOffset": 179393,
            "endOffset": 179415,
            "count": 0
          },
          {
            "startOffset": 179428,
            "endOffset": 179450,
            "count": 0
          },
          {
            "startOffset": 179463,
            "endOffset": 179485,
            "count": 0
          },
          {
            "startOffset": 179498,
            "endOffset": 179520,
            "count": 0
          },
          {
            "startOffset": 179533,
            "endOffset": 179601,
            "count": 0
          },
          {
            "startOffset": 179614,
            "endOffset": 179630,
            "count": 0
          },
          {
            "startOffset": 179643,
            "endOffset": 179659,
            "count": 0
          },
          {
            "startOffset": 179672,
            "endOffset": 179688,
            "count": 0
          },
          {
            "startOffset": 179701,
            "endOffset": 179717,
            "count": 0
          },
          {
            "startOffset": 179730,
            "endOffset": 179787,
            "count": 0
          },
          {
            "startOffset": 179800,
            "endOffset": 179873,
            "count": 0
          },
          {
            "startOffset": 179886,
            "endOffset": 179949,
            "count": 0
          },
          {
            "startOffset": 179962,
            "endOffset": 180007,
            "count": 0
          },
          {
            "startOffset": 180020,
            "endOffset": 180075,
            "count": 0
          },
          {
            "startOffset": 180088,
            "endOffset": 180240,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getNextLanes",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 180271,
            "endOffset": 183179,
            "count": 8
          },
          {
            "startOffset": 180401,
            "endOffset": 181159,
            "count": 4
          },
          {
            "startOffset": 180911,
            "endOffset": 181147,
            "count": 0
          },
          {
            "startOffset": 181159,
            "endOffset": 181518,
            "count": 0
          },
          {
            "startOffset": 181518,
            "endOffset": 181556,
            "count": 4
          },
          {
            "startOffset": 181556,
            "endOffset": 181597,
            "count": 0
          },
          {
            "startOffset": 181597,
            "endOffset": 181633,
            "count": 4
          },
          {
            "startOffset": 181633,
            "endOffset": 181658,
            "count": 0
          },
          {
            "startOffset": 181659,
            "endOffset": 181841,
            "count": 0
          },
          {
            "startOffset": 181843,
            "endOffset": 182577,
            "count": 0
          },
          {
            "startOffset": 182577,
            "endOffset": 182639,
            "count": 4
          },
          {
            "startOffset": 182639,
            "endOffset": 182705,
            "count": 0
          },
          {
            "startOffset": 182705,
            "endOffset": 182801,
            "count": 4
          },
          {
            "startOffset": 182801,
            "endOffset": 183141,
            "count": 0
          },
          {
            "startOffset": 183141,
            "endOffset": 183178,
            "count": 4
          }
        ]
      },
      {
        "functionName": "getMostRecentEventTime",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 183188,
            "endOffset": 183699,
            "count": 0
          }
        ]
      },
      {
        "functionName": "computeExpirationTime",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 183708,
            "endOffset": 185181,
            "count": 2
          },
          {
            "startOffset": 183798,
            "endOffset": 183812,
            "count": 0
          },
          {
            "startOffset": 183825,
            "endOffset": 183859,
            "count": 0
          },
          {
            "startOffset": 183872,
            "endOffset": 183937,
            "count": 0
          },
          {
            "startOffset": 183950,
            "endOffset": 183976,
            "count": 0
          },
          {
            "startOffset": 184652,
            "endOffset": 184668,
            "count": 0
          },
          {
            "startOffset": 184681,
            "endOffset": 184697,
            "count": 0
          },
          {
            "startOffset": 184710,
            "endOffset": 184726,
            "count": 0
          },
          {
            "startOffset": 184739,
            "endOffset": 184755,
            "count": 0
          },
          {
            "startOffset": 184768,
            "endOffset": 184818,
            "count": 0
          },
          {
            "startOffset": 184831,
            "endOffset": 184859,
            "count": 0
          },
          {
            "startOffset": 184872,
            "endOffset": 184895,
            "count": 0
          },
          {
            "startOffset": 184908,
            "endOffset": 184922,
            "count": 0
          },
          {
            "startOffset": 184935,
            "endOffset": 184988,
            "count": 0
          },
          {
            "startOffset": 185001,
            "endOffset": 185159,
            "count": 0
          }
        ]
      },
      {
        "functionName": "markStarvedLanesAsExpired",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 185190,
            "endOffset": 186071,
            "count": 6
          },
          {
            "startOffset": 185515,
            "endOffset": 186061,
            "count": 2
          },
          {
            "startOffset": 185771,
            "endOffset": 185806,
            "count": 0
          },
          {
            "startOffset": 185923,
            "endOffset": 186021,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getHighestPriorityPendingLanes",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 186080,
            "endOffset": 186200,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getLanesToRetrySynchronouslyOnError",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 186209,
            "endOffset": 186583,
            "count": 0
          }
        ]
      },
      {
        "functionName": "includesSyncLane",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 186592,
            "endOffset": 186685,
            "count": 0
          }
        ]
      },
      {
        "functionName": "includesNonIdleWork",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 186694,
            "endOffset": 186794,
            "count": 4
          }
        ]
      },
      {
        "functionName": "includesOnlyRetries",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 186803,
            "endOffset": 186899,
            "count": 0
          }
        ]
      },
      {
        "functionName": "includesOnlyNonUrgentLanes",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 186908,
            "endOffset": 187088,
            "count": 0
          }
        ]
      },
      {
        "functionName": "includesOnlyTransitions",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 187097,
            "endOffset": 187202,
            "count": 0
          }
        ]
      },
      {
        "functionName": "includesBlockingLane",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 187211,
            "endOffset": 187445,
            "count": 4
          }
        ]
      },
      {
        "functionName": "includesExpiredLane",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 187454,
            "endOffset": 187567,
            "count": 0
          }
        ]
      },
      {
        "functionName": "isTransitionLane",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 187576,
            "endOffset": 187674,
            "count": 2
          }
        ]
      },
      {
        "functionName": "claimNextTransitionLane",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 187683,
            "endOffset": 187959,
            "count": 0
          }
        ]
      },
      {
        "functionName": "claimNextRetryLane",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 187968,
            "endOffset": 188209,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getHighestPriorityLane",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 188218,
            "endOffset": 188301,
            "count": 10
          }
        ]
      },
      {
        "functionName": "pickArbitraryLane",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 188310,
            "endOffset": 188403,
            "count": 0
          }
        ]
      },
      {
        "functionName": "pickArbitraryLaneIndex",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 188412,
            "endOffset": 188498,
            "count": 10
          }
        ]
      },
      {
        "functionName": "laneToIndex",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 188507,
            "endOffset": 188592,
            "count": 6
          }
        ]
      },
      {
        "functionName": "includesSomeLane",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 188601,
            "endOffset": 188682,
            "count": 42
          }
        ]
      },
      {
        "functionName": "isSubsetOfLanes",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 188691,
            "endOffset": 188786,
            "count": 3
          }
        ]
      },
      {
        "functionName": "mergeLanes",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 188795,
            "endOffset": 188856,
            "count": 230
          }
        ]
      },
      {
        "functionName": "removeLanes",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 188865,
            "endOffset": 188944,
            "count": 0
          }
        ]
      },
      {
        "functionName": "intersectLanes",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 188953,
            "endOffset": 189018,
            "count": 0
          }
        ]
      },
      {
        "functionName": "laneToLanes",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 189027,
            "endOffset": 189088,
            "count": 0
          }
        ]
      },
      {
        "functionName": "higherPriorityLane",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 189097,
            "endOffset": 189190,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createLaneMap",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 189199,
            "endOffset": 189392,
            "count": 3
          },
          {
            "startOffset": 189308,
            "endOffset": 189356,
            "count": 93
          }
        ]
      },
      {
        "functionName": "markRootUpdated",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 189401,
            "endOffset": 189784,
            "count": 2
          }
        ]
      },
      {
        "functionName": "markRootSuspended",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 189793,
            "endOffset": 190258,
            "count": 0
          }
        ]
      },
      {
        "functionName": "markRootPinged",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 190267,
            "endOffset": 190400,
            "count": 0
          }
        ]
      },
      {
        "functionName": "markRootFinished",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 190409,
            "endOffset": 191321,
            "count": 2
          }
        ]
      },
      {
        "functionName": "markRootEntangled",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 191330,
            "endOffset": 192040,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getBumpedLaneForHydration",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 192049,
            "endOffset": 193508,
            "count": 0
          }
        ]
      },
      {
        "functionName": "addFiberToLanesMap",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 193517,
            "endOffset": 193957,
            "count": 2
          },
          {
            "startOffset": 193602,
            "endOffset": 193635,
            "count": 0
          }
        ]
      },
      {
        "functionName": "movePendingFibersToMemoized",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 193966,
            "endOffset": 194774,
            "count": 2
          },
          {
            "startOffset": 194053,
            "endOffset": 194086,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 194451,
            "endOffset": 194676,
            "count": 2
          },
          {
            "startOffset": 194557,
            "endOffset": 194592,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getTransitionsForLanes",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 194783,
            "endOffset": 194889,
            "count": 2
          }
        ]
      },
      {
        "functionName": "getCurrentUpdatePriority",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 195137,
            "endOffset": 195224,
            "count": 12
          }
        ]
      },
      {
        "functionName": "setCurrentUpdatePriority",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 195233,
            "endOffset": 195338,
            "count": 20
          }
        ]
      },
      {
        "functionName": "runWithPriority",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 195347,
            "endOffset": 195628,
            "count": 0
          }
        ]
      },
      {
        "functionName": "higherEventPriority",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 195637,
            "endOffset": 195726,
            "count": 0
          }
        ]
      },
      {
        "functionName": "lowerEventPriority",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 195735,
            "endOffset": 195823,
            "count": 2
          },
          {
            "startOffset": 195805,
            "endOffset": 195808,
            "count": 0
          }
        ]
      },
      {
        "functionName": "isHigherEventPriority",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 195832,
            "endOffset": 195915,
            "count": 8
          }
        ]
      },
      {
        "functionName": "lanesToEventPriority",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 195924,
            "endOffset": 196406,
            "count": 4
          },
          {
            "startOffset": 196082,
            "endOffset": 196137,
            "count": 0
          },
          {
            "startOffset": 196207,
            "endOffset": 196264,
            "count": 0
          },
          {
            "startOffset": 196360,
            "endOffset": 196405,
            "count": 0
          }
        ]
      },
      {
        "functionName": "isRootDehydrated",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 196415,
            "endOffset": 196561,
            "count": 0
          }
        ]
      },
      {
        "functionName": "setAttemptSynchronousHydration",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 196612,
            "endOffset": 196712,
            "count": 1
          }
        ]
      },
      {
        "functionName": "attemptSynchronousHydration",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 196721,
            "endOffset": 196823,
            "count": 0
          }
        ]
      },
      {
        "functionName": "setAttemptContinuousHydration",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 196872,
            "endOffset": 196969,
            "count": 1
          }
        ]
      },
      {
        "functionName": "setAttemptHydrationAtCurrentPriority",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 197025,
            "endOffset": 197136,
            "count": 1
          }
        ]
      },
      {
        "functionName": "setGetCurrentUpdatePriority",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 197185,
            "endOffset": 197280,
            "count": 1
          }
        ]
      },
      {
        "functionName": "setAttemptHydrationAtPriority",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 197329,
            "endOffset": 197426,
            "count": 1
          }
        ]
      },
      {
        "functionName": "isDiscreteEventThatRequiresHydration",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 198487,
            "endOffset": 198622,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createQueuedReplayableEvent",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 198631,
            "endOffset": 198936,
            "count": 0
          }
        ]
      },
      {
        "functionName": "clearIfContinuousEvent",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 198945,
            "endOffset": 199826,
            "count": 14
          },
          {
            "startOffset": 199052,
            "endOffset": 199067,
            "count": 0
          },
          {
            "startOffset": 199080,
            "endOffset": 199151,
            "count": 0
          },
          {
            "startOffset": 199164,
            "endOffset": 199181,
            "count": 0
          },
          {
            "startOffset": 199194,
            "endOffset": 199265,
            "count": 0
          },
          {
            "startOffset": 199278,
            "endOffset": 199295,
            "count": 2
          },
          {
            "startOffset": 199308,
            "endOffset": 199379,
            "count": 2
          },
          {
            "startOffset": 199392,
            "endOffset": 199411,
            "count": 2
          },
          {
            "startOffset": 199424,
            "endOffset": 199580,
            "count": 2
          },
          {
            "startOffset": 199593,
            "endOffset": 199618,
            "count": 0
          },
          {
            "startOffset": 199631,
            "endOffset": 199804,
            "count": 0
          }
        ]
      },
      {
        "functionName": "accumulateOrCreateContinuousQueuedReplayableEvent",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 199835,
            "endOffset": 200826,
            "count": 0
          }
        ]
      },
      {
        "functionName": "queueIfContinuousEvent",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 200835,
            "endOffset": 202655,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attemptExplicitHydrationTarget",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 202664,
            "endOffset": 203789,
            "count": 0
          }
        ]
      },
      {
        "functionName": "queueExplicitHydrationTarget",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 203798,
            "endOffset": 204447,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attemptReplayContinuousQueuedEvent",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 204456,
            "endOffset": 205685,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attemptReplayContinuousQueuedEventInMap",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 205694,
            "endOffset": 205883,
            "count": 0
          }
        ]
      },
      {
        "functionName": "replayUnblockedEvents",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 205892,
            "endOffset": 206534,
            "count": 0
          }
        ]
      },
      {
        "functionName": "scheduleCallbackIfUnblocked",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 206543,
            "endOffset": 206939,
            "count": 0
          }
        ]
      },
      {
        "functionName": "retryIfBlockedOn",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 206948,
            "endOffset": 208692,
            "count": 0
          }
        ]
      },
      {
        "functionName": "setEnabled",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 208814,
            "endOffset": 208886,
            "count": 4
          }
        ]
      },
      {
        "functionName": "isEnabled",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 208895,
            "endOffset": 208954,
            "count": 2
          }
        ]
      },
      {
        "functionName": "createEventListenerWrapperWithPriority",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 208963,
            "endOffset": 209669,
            "count": 131
          },
          {
            "startOffset": 209202,
            "endOffset": 209305,
            "count": 72
          },
          {
            "startOffset": 209318,
            "endOffset": 209425,
            "count": 28
          },
          {
            "startOffset": 209438,
            "endOffset": 209464,
            "count": 31
          },
          {
            "startOffset": 209477,
            "endOffset": 209553,
            "count": 31
          }
        ]
      },
      {
        "functionName": "dispatchDiscreteEvent",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 209678,
            "endOffset": 210272,
            "count": 0
          }
        ]
      },
      {
        "functionName": "dispatchContinuousEvent",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 210281,
            "endOffset": 210879,
            "count": 4
          }
        ]
      },
      {
        "functionName": "dispatchEvent",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 210888,
            "endOffset": 211222,
            "count": 14
          },
          {
            "startOffset": 211000,
            "endOffset": 211033,
            "count": 0
          }
        ]
      },
      {
        "functionName": "dispatchEventWithEnableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 211231,
            "endOffset": 213026,
            "count": 14
          },
          {
            "startOffset": 211757,
            "endOffset": 212110,
            "count": 0
          },
          {
            "startOffset": 212112,
            "endOffset": 213025,
            "count": 0
          }
        ]
      },
      {
        "functionName": "findInstanceBlockingEvent",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 213073,
            "endOffset": 214317,
            "count": 14
          },
          {
            "startOffset": 213492,
            "endOffset": 213540,
            "count": 0
          },
          {
            "startOffset": 213637,
            "endOffset": 213860,
            "count": 0
          },
          {
            "startOffset": 213888,
            "endOffset": 214123,
            "count": 0
          },
          {
            "startOffset": 214164,
            "endOffset": 214216,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getEventPriority",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 214326,
            "endOffset": 217252,
            "count": 131
          },
          {
            "startOffset": 214414,
            "endOffset": 214428,
            "count": 1
          },
          {
            "startOffset": 214441,
            "endOffset": 214454,
            "count": 3
          },
          {
            "startOffset": 214467,
            "endOffset": 214480,
            "count": 4
          },
          {
            "startOffset": 214493,
            "endOffset": 214512,
            "count": 6
          },
          {
            "startOffset": 214525,
            "endOffset": 214537,
            "count": 8
          },
          {
            "startOffset": 214550,
            "endOffset": 214561,
            "count": 10
          },
          {
            "startOffset": 214574,
            "endOffset": 214590,
            "count": 12
          },
          {
            "startOffset": 214603,
            "endOffset": 214619,
            "count": 14
          },
          {
            "startOffset": 214632,
            "endOffset": 214647,
            "count": 16
          },
          {
            "startOffset": 214660,
            "endOffset": 214677,
            "count": 18
          },
          {
            "startOffset": 214690,
            "endOffset": 214702,
            "count": 20
          },
          {
            "startOffset": 214715,
            "endOffset": 214730,
            "count": 22
          },
          {
            "startOffset": 214743,
            "endOffset": 214759,
            "count": 24
          },
          {
            "startOffset": 214772,
            "endOffset": 214785,
            "count": 26
          },
          {
            "startOffset": 214798,
            "endOffset": 214813,
            "count": 27
          },
          {
            "startOffset": 214826,
            "endOffset": 214841,
            "count": 29
          },
          {
            "startOffset": 214854,
            "endOffset": 214870,
            "count": 31
          },
          {
            "startOffset": 214883,
            "endOffset": 214896,
            "count": 33
          },
          {
            "startOffset": 214909,
            "endOffset": 214926,
            "count": 35
          },
          {
            "startOffset": 214939,
            "endOffset": 214954,
            "count": 37
          },
          {
            "startOffset": 214967,
            "endOffset": 214980,
            "count": 39
          },
          {
            "startOffset": 214993,
            "endOffset": 215006,
            "count": 40
          },
          {
            "startOffset": 215019,
            "endOffset": 215031,
            "count": 41
          },
          {
            "startOffset": 215044,
            "endOffset": 215065,
            "count": 43
          },
          {
            "startOffset": 215078,
            "endOffset": 215097,
            "count": 45
          },
          {
            "startOffset": 215110,
            "endOffset": 215127,
            "count": 47
          },
          {
            "startOffset": 215140,
            "endOffset": 215158,
            "count": 48
          },
          {
            "startOffset": 215171,
            "endOffset": 215184,
            "count": 50
          },
          {
            "startOffset": 215197,
            "endOffset": 215211,
            "count": 51
          },
          {
            "startOffset": 215224,
            "endOffset": 215238,
            "count": 52
          },
          {
            "startOffset": 215251,
            "endOffset": 215265,
            "count": 54
          },
          {
            "startOffset": 215278,
            "endOffset": 215297,
            "count": 56
          },
          {
            "startOffset": 215310,
            "endOffset": 215326,
            "count": 58
          },
          {
            "startOffset": 215339,
            "endOffset": 215357,
            "count": 60
          },
          {
            "startOffset": 215370,
            "endOffset": 215390,
            "count": 61
          },
          {
            "startOffset": 215403,
            "endOffset": 215417,
            "count": 63
          },
          {
            "startOffset": 215430,
            "endOffset": 215453,
            "count": 64
          },
          {
            "startOffset": 215466,
            "endOffset": 215483,
            "count": 66
          },
          {
            "startOffset": 215496,
            "endOffset": 215520,
            "count": 68
          },
          {
            "startOffset": 215533,
            "endOffset": 215555,
            "count": 70
          },
          {
            "startOffset": 215568,
            "endOffset": 215593,
            "count": 72
          },
          {
            "startOffset": 215606,
            "endOffset": 215624,
            "count": 72
          },
          {
            "startOffset": 215637,
            "endOffset": 215654,
            "count": 72
          },
          {
            "startOffset": 215667,
            "endOffset": 215686,
            "count": 72
          },
          {
            "startOffset": 215699,
            "endOffset": 215711,
            "count": 72
          },
          {
            "startOffset": 215724,
            "endOffset": 215748,
            "count": 72
          },
          {
            "startOffset": 215761,
            "endOffset": 215774,
            "count": 72
          },
          {
            "startOffset": 215787,
            "endOffset": 215805,
            "count": 72
          },
          {
            "startOffset": 215818,
            "endOffset": 215834,
            "count": 72
          },
          {
            "startOffset": 215847,
            "endOffset": 215861,
            "count": 72
          },
          {
            "startOffset": 215874,
            "endOffset": 215937,
            "count": 72
          },
          {
            "startOffset": 215950,
            "endOffset": 215962,
            "count": 2
          },
          {
            "startOffset": 215975,
            "endOffset": 215992,
            "count": 4
          },
          {
            "startOffset": 216005,
            "endOffset": 216021,
            "count": 6
          },
          {
            "startOffset": 216034,
            "endOffset": 216051,
            "count": 8
          },
          {
            "startOffset": 216064,
            "endOffset": 216080,
            "count": 10
          },
          {
            "startOffset": 216093,
            "endOffset": 216110,
            "count": 12
          },
          {
            "startOffset": 216123,
            "endOffset": 216139,
            "count": 14
          },
          {
            "startOffset": 216152,
            "endOffset": 216169,
            "count": 16
          },
          {
            "startOffset": 216182,
            "endOffset": 216201,
            "count": 18
          },
          {
            "startOffset": 216214,
            "endOffset": 216232,
            "count": 20
          },
          {
            "startOffset": 216245,
            "endOffset": 216264,
            "count": 22
          },
          {
            "startOffset": 216277,
            "endOffset": 216291,
            "count": 23
          },
          {
            "startOffset": 216304,
            "endOffset": 216318,
            "count": 24
          },
          {
            "startOffset": 216331,
            "endOffset": 216348,
            "count": 26
          },
          {
            "startOffset": 216361,
            "endOffset": 216374,
            "count": 28
          },
          {
            "startOffset": 216387,
            "endOffset": 216405,
            "count": 28
          },
          {
            "startOffset": 216418,
            "endOffset": 216436,
            "count": 28
          },
          {
            "startOffset": 216449,
            "endOffset": 216469,
            "count": 28
          },
          {
            "startOffset": 216482,
            "endOffset": 216548,
            "count": 28
          },
          {
            "startOffset": 216561,
            "endOffset": 217166,
            "count": 0
          },
          {
            "startOffset": 217179,
            "endOffset": 217230,
            "count": 31
          }
        ]
      },
      {
        "functionName": "addEventBubbleListener",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 217261,
            "endOffset": 217423,
            "count": 48
          }
        ]
      },
      {
        "functionName": "addEventCaptureListener",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 217432,
            "endOffset": 217594,
            "count": 77
          }
        ]
      },
      {
        "functionName": "addEventCaptureListenerWithPassiveFlag",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 217603,
            "endOffset": 217845,
            "count": 3
          }
        ]
      },
      {
        "functionName": "addEventBubbleListenerWithPassiveFlag",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 217854,
            "endOffset": 218068,
            "count": 3
          }
        ]
      },
      {
        "functionName": "initialize",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 218165,
            "endOffset": 218307,
            "count": 0
          }
        ]
      },
      {
        "functionName": "reset",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 218316,
            "endOffset": 218426,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getData",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 218435,
            "endOffset": 219268,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getText",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 219277,
            "endOffset": 219418,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getEventCharCode",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 219427,
            "endOffset": 219976,
            "count": 0
          }
        ]
      },
      {
        "functionName": "functionThatReturnsTrue",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 219985,
            "endOffset": 220054,
            "count": 0
          }
        ]
      },
      {
        "functionName": "functionThatReturnsFalse",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 220063,
            "endOffset": 220134,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createSyntheticEvent",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 220143,
            "endOffset": 223001,
            "count": 13
          }
        ]
      },
      {
        "functionName": "SyntheticBaseEvent",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 220196,
            "endOffset": 221392,
            "count": 4
          },
          {
            "startOffset": 220594,
            "endOffset": 220947,
            "count": 116
          },
          {
            "startOffset": 220652,
            "endOffset": 220695,
            "count": 0
          },
          {
            "startOffset": 220777,
            "endOffset": 220852,
            "count": 20
          },
          {
            "startOffset": 220852,
            "endOffset": 220933,
            "count": 96
          },
          {
            "startOffset": 221051,
            "endOffset": 221086,
            "count": 0
          },
          {
            "startOffset": 221122,
            "endOffset": 221202,
            "count": 0
          }
        ]
      },
      {
        "functionName": "preventDefault",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 221470,
            "endOffset": 221925,
            "count": 0
          }
        ]
      },
      {
        "functionName": "stopPropagation",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 221956,
            "endOffset": 222372,
            "count": 0
          }
        ]
      },
      {
        "functionName": "persist",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 222654,
            "endOffset": 222680,
            "count": 0
          }
        ]
      },
      {
        "functionName": "timeStamp",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 223126,
            "endOffset": 223205,
            "count": 4
          },
          {
            "startOffset": 223179,
            "endOffset": 223192,
            "count": 0
          }
        ]
      },
      {
        "functionName": "updateMouseMovementPolyfillState",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 223611,
            "endOffset": 224066,
            "count": 0
          }
        ]
      },
      {
        "functionName": "relatedTarget",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 224467,
            "endOffset": 224683,
            "count": 4
          },
          {
            "startOffset": 224547,
            "endOffset": 224631,
            "count": 0
          }
        ]
      },
      {
        "functionName": "movementX",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 224706,
            "endOffset": 224914,
            "count": 4
          },
          {
            "startOffset": 224815,
            "endOffset": 224913,
            "count": 0
          }
        ]
      },
      {
        "functionName": "movementY",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 224937,
            "endOffset": 225092,
            "count": 4
          },
          {
            "startOffset": 225046,
            "endOffset": 225091,
            "count": 0
          }
        ]
      },
      {
        "functionName": "clipboardData",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 225880,
            "endOffset": 225999,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getEventKey",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 227687,
            "endOffset": 228315,
            "count": 0
          }
        ]
      },
      {
        "functionName": "modifierStateGetter",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 228479,
            "endOffset": 228845,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getEventModifierState",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 228854,
            "endOffset": 228947,
            "count": 4
          }
        ]
      },
      {
        "functionName": "charCode",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 229317,
            "endOffset": 229473,
            "count": 0
          }
        ]
      },
      {
        "functionName": "keyCode",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 229494,
            "endOffset": 229665,
            "count": 0
          }
        ]
      },
      {
        "functionName": "which",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 229684,
            "endOffset": 229960,
            "count": 0
          }
        ]
      },
      {
        "functionName": "deltaX",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 231153,
            "endOffset": 231404,
            "count": 0
          }
        ]
      },
      {
        "functionName": "deltaY",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 231424,
            "endOffset": 231839,
            "count": 0
          }
        ]
      },
      {
        "functionName": "registerEvents",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 232936,
            "endOffset": 233477,
            "count": 1
          }
        ]
      },
      {
        "functionName": "isKeypressCommand",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 233524,
            "endOffset": 233785,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getCompositionEventType",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 233794,
            "endOffset": 234136,
            "count": 7
          },
          {
            "startOffset": 233889,
            "endOffset": 233956,
            "count": 0
          },
          {
            "startOffset": 233969,
            "endOffset": 234032,
            "count": 0
          },
          {
            "startOffset": 234045,
            "endOffset": 234114,
            "count": 0
          }
        ]
      },
      {
        "functionName": "isFallbackCompositionStart",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 234145,
            "endOffset": 234305,
            "count": 0
          }
        ]
      },
      {
        "functionName": "isFallbackCompositionEnd",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 234314,
            "endOffset": 234781,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getDataFromCustomEvent",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 234790,
            "endOffset": 235020,
            "count": 0
          }
        ]
      },
      {
        "functionName": "isUsingKoreanIME",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 235029,
            "endOffset": 235125,
            "count": 0
          }
        ]
      },
      {
        "functionName": "extractCompositionEvent",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 235167,
            "endOffset": 236806,
            "count": 7
          },
          {
            "startOffset": 235442,
            "endOffset": 235734,
            "count": 0
          },
          {
            "startOffset": 235799,
            "endOffset": 235874,
            "count": 0
          },
          {
            "startOffset": 235876,
            "endOffset": 236796,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getNativeBeforeInputChars",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 236815,
            "endOffset": 237526,
            "count": 7
          },
          {
            "startOffset": 236925,
            "endOffset": 237005,
            "count": 0
          },
          {
            "startOffset": 237018,
            "endOffset": 237244,
            "count": 0
          },
          {
            "startOffset": 237257,
            "endOffset": 237456,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getFallbackBeforeInputChars",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 237535,
            "endOffset": 238609,
            "count": 0
          }
        ]
      },
      {
        "functionName": "extractBeforeInputEvent",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 238618,
            "endOffset": 239415,
            "count": 7
          },
          {
            "startOffset": 238870,
            "endOffset": 238965,
            "count": 0
          },
          {
            "startOffset": 239026,
            "endOffset": 239405,
            "count": 0
          }
        ]
      },
      {
        "functionName": "extractEvents",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 239424,
            "endOffset": 239782,
            "count": 7
          }
        ]
      },
      {
        "functionName": "isTextInputElement",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 240193,
            "endOffset": 240522,
            "count": 7
          },
          {
            "startOffset": 240344,
            "endOffset": 240410,
            "count": 0
          },
          {
            "startOffset": 240450,
            "endOffset": 240488,
            "count": 0
          }
        ]
      },
      {
        "functionName": "isEventSupported",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 240531,
            "endOffset": 241005,
            "count": 1
          },
          {
            "startOffset": 240602,
            "endOffset": 240641,
            "count": 0
          },
          {
            "startOffset": 240771,
            "endOffset": 240965,
            "count": 0
          }
        ]
      },
      {
        "functionName": "registerEvents$1",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 241014,
            "endOffset": 241190,
            "count": 1
          }
        ]
      },
      {
        "functionName": "createAndAccumulateChangeEvent",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 241199,
            "endOffset": 241641,
            "count": 0
          }
        ]
      },
      {
        "functionName": "shouldUseChangeEvent",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 241722,
            "endOffset": 241928,
            "count": 7
          },
          {
            "startOffset": 241894,
            "endOffset": 241917,
            "count": 0
          }
        ]
      },
      {
        "functionName": "manualDispatchChangeEvent",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 241937,
            "endOffset": 242206,
            "count": 0
          }
        ]
      },
      {
        "functionName": "runEventInBatch",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 242215,
            "endOffset": 242316,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getInstIfValueChanged",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 242325,
            "endOffset": 242532,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getTargetInstForChangeEvent",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 242541,
            "endOffset": 242701,
            "count": 0
          }
        ]
      },
      {
        "functionName": "startWatchingForValueChange",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 242906,
            "endOffset": 243129,
            "count": 0
          }
        ]
      },
      {
        "functionName": "stopWatchingForValueChange",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 243138,
            "endOffset": 243398,
            "count": 0
          }
        ]
      },
      {
        "functionName": "handlePropertyChange",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 243407,
            "endOffset": 243669,
            "count": 0
          }
        ]
      },
      {
        "functionName": "handleEventsForInputEventPolyfill",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 243678,
            "endOffset": 244019,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getTargetInstForInputEventPolyfill",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 244028,
            "endOffset": 244292,
            "count": 0
          }
        ]
      },
      {
        "functionName": "shouldUseClickEvent",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 244301,
            "endOffset": 244507,
            "count": 7
          },
          {
            "startOffset": 244442,
            "endOffset": 244496,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getTargetInstForClickEvent",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 244516,
            "endOffset": 244697,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getTargetInstForInputOrChangeEvent",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 244706,
            "endOffset": 244924,
            "count": 0
          }
        ]
      },
      {
        "functionName": "handleControlledInputBlur",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 244933,
            "endOffset": 245211,
            "count": 0
          }
        ]
      },
      {
        "functionName": "extractEvents$1",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 245220,
            "endOffset": 246567,
            "count": 7
          },
          {
            "startOffset": 245427,
            "endOffset": 245435,
            "count": 0
          },
          {
            "startOffset": 245535,
            "endOffset": 245609,
            "count": 0
          },
          {
            "startOffset": 245651,
            "endOffset": 245947,
            "count": 0
          },
          {
            "startOffset": 245990,
            "endOffset": 246063,
            "count": 0
          },
          {
            "startOffset": 246097,
            "endOffset": 246337,
            "count": 0
          },
          {
            "startOffset": 246369,
            "endOffset": 246449,
            "count": 0
          },
          {
            "startOffset": 246493,
            "endOffset": 246557,
            "count": 0
          }
        ]
      },
      {
        "functionName": "registerEvents$2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 246576,
            "endOffset": 246923,
            "count": 1
          }
        ]
      },
      {
        "functionName": "extractEvents$2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 246932,
            "endOffset": 249979,
            "count": 7
          },
          {
            "startOffset": 247124,
            "endOffset": 247157,
            "count": 6
          },
          {
            "startOffset": 247274,
            "endOffset": 247307,
            "count": 2
          },
          {
            "startOffset": 247309,
            "endOffset": 247576,
            "count": 2
          },
          {
            "startOffset": 247363,
            "endOffset": 247389,
            "count": 0
          },
          {
            "startOffset": 247509,
            "endOffset": 247550,
            "count": 0
          },
          {
            "startOffset": 247620,
            "endOffset": 247653,
            "count": 5
          },
          {
            "startOffset": 247653,
            "endOffset": 247735,
            "count": 2
          },
          {
            "startOffset": 247735,
            "endOffset": 247785,
            "count": 0
          },
          {
            "startOffset": 247785,
            "endOffset": 248002,
            "count": 2
          },
          {
            "startOffset": 247907,
            "endOffset": 247926,
            "count": 0
          },
          {
            "startOffset": 247941,
            "endOffset": 247990,
            "count": 0
          },
          {
            "startOffset": 248002,
            "endOffset": 248067,
            "count": 2
          },
          {
            "startOffset": 248067,
            "endOffset": 248508,
            "count": 0
          },
          {
            "startOffset": 248508,
            "endOffset": 248609,
            "count": 2
          },
          {
            "startOffset": 248609,
            "endOffset": 248642,
            "count": 0
          },
          {
            "startOffset": 248642,
            "endOffset": 248911,
            "count": 2
          },
          {
            "startOffset": 248913,
            "endOffset": 249117,
            "count": 1
          },
          {
            "startOffset": 249117,
            "endOffset": 249161,
            "count": 2
          },
          {
            "startOffset": 249162,
            "endOffset": 249189,
            "count": 0
          },
          {
            "startOffset": 249225,
            "endOffset": 249230,
            "count": 0
          },
          {
            "startOffset": 249231,
            "endOffset": 249256,
            "count": 2
          },
          {
            "startOffset": 249615,
            "endOffset": 249978,
            "count": 2
          }
        ]
      },
      {
        "functionName": "is",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 249988,
            "endOffset": 250097,
            "count": 0
          }
        ]
      },
      {
        "functionName": "shallowEqual",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 250179,
            "endOffset": 250882,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getLeafNode",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 250891,
            "endOffset": 251044,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getSiblingNode",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 251053,
            "endOffset": 251256,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getNodeForCharacterOffset",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 251265,
            "endOffset": 251862,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getOffsets",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 251871,
            "endOffset": 252609,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getModernOffsetsFromPoints",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 252618,
            "endOffset": 254453,
            "count": 0
          }
        ]
      },
      {
        "functionName": "setOffsets",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 254462,
            "endOffset": 255931,
            "count": 0
          }
        ]
      },
      {
        "functionName": "isTextNode",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 255940,
            "endOffset": 256031,
            "count": 0
          }
        ]
      },
      {
        "functionName": "containsNode",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 256040,
            "endOffset": 256707,
            "count": 0
          }
        ]
      },
      {
        "functionName": "isInDocument",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 256716,
            "endOffset": 256858,
            "count": 0
          }
        ]
      },
      {
        "functionName": "isSameOriginFrame",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 256867,
            "endOffset": 257068,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getActiveElementDeep",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 257077,
            "endOffset": 257499,
            "count": 4
          },
          {
            "startOffset": 257242,
            "endOffset": 257463,
            "count": 0
          }
        ]
      },
      {
        "functionName": "hasSelectionCapabilities",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 257508,
            "endOffset": 257879,
            "count": 2
          },
          {
            "startOffset": 257680,
            "endOffset": 257805,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getSelectionInformation",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 257888,
            "endOffset": 258144,
            "count": 2
          },
          {
            "startOffset": 258087,
            "endOffset": 258114,
            "count": 0
          }
        ]
      },
      {
        "functionName": "restoreSelection",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 258153,
            "endOffset": 259417,
            "count": 2
          },
          {
            "startOffset": 258463,
            "endOffset": 258496,
            "count": 0
          },
          {
            "startOffset": 258498,
            "endOffset": 259407,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getSelection",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 259426,
            "endOffset": 259816,
            "count": 0
          }
        ]
      },
      {
        "functionName": "setSelection",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 259825,
            "endOffset": 260237,
            "count": 0
          }
        ]
      },
      {
        "functionName": "registerEvents$3",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 260357,
            "endOffset": 260555,
            "count": 1
          }
        ]
      },
      {
        "functionName": "getSelection$1",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 260705,
            "endOffset": 261333,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getEventTargetDocument",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 261342,
            "endOffset": 261557,
            "count": 0
          }
        ]
      },
      {
        "functionName": "constructSelectEvent",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 261566,
            "endOffset": 262452,
            "count": 0
          }
        ]
      },
      {
        "functionName": "extractEvents$3",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 262461,
            "endOffset": 263757,
            "count": 7
          },
          {
            "startOffset": 262668,
            "endOffset": 262676,
            "count": 0
          },
          {
            "startOffset": 262724,
            "endOffset": 263003,
            "count": 0
          },
          {
            "startOffset": 263016,
            "endOffset": 263169,
            "count": 0
          },
          {
            "startOffset": 263182,
            "endOffset": 263252,
            "count": 0
          },
          {
            "startOffset": 263265,
            "endOffset": 263284,
            "count": 0
          },
          {
            "startOffset": 263297,
            "endOffset": 263312,
            "count": 0
          },
          {
            "startOffset": 263325,
            "endOffset": 263477,
            "count": 0
          },
          {
            "startOffset": 263490,
            "endOffset": 263598,
            "count": 0
          },
          {
            "startOffset": 263611,
            "endOffset": 263626,
            "count": 0
          },
          {
            "startOffset": 263639,
            "endOffset": 263735,
            "count": 0
          }
        ]
      },
      {
        "functionName": "makePrefixMap",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 263766,
            "endOffset": 264078,
            "count": 4
          }
        ]
      },
      {
        "functionName": "getVendorPrefixedEventName",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 264931,
            "endOffset": 265483,
            "count": 4
          },
          {
            "startOffset": 265025,
            "endOffset": 265088,
            "count": 0
          },
          {
            "startOffset": 265126,
            "endOffset": 265169,
            "count": 0
          },
          {
            "startOffset": 265445,
            "endOffset": 265482,
            "count": 0
          }
        ]
      },
      {
        "functionName": "registerSimpleEvent",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 266722,
            "endOffset": 266914,
            "count": 75
          }
        ]
      },
      {
        "functionName": "registerSimpleEvents",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 266923,
            "endOffset": 267755,
            "count": 1
          },
          {
            "startOffset": 267024,
            "endOffset": 267305,
            "count": 68
          }
        ]
      },
      {
        "functionName": "extractEvents$4",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 267764,
            "endOffset": 271686,
            "count": 14
          },
          {
            "startOffset": 268007,
            "endOffset": 268040,
            "count": 0
          },
          {
            "startOffset": 268183,
            "endOffset": 268296,
            "count": 0
          },
          {
            "startOffset": 268309,
            "endOffset": 268324,
            "count": 0
          },
          {
            "startOffset": 268337,
            "endOffset": 268430,
            "count": 0
          },
          {
            "startOffset": 268443,
            "endOffset": 268575,
            "count": 0
          },
          {
            "startOffset": 268588,
            "endOffset": 268720,
            "count": 0
          },
          {
            "startOffset": 268733,
            "endOffset": 268751,
            "count": 0
          },
          {
            "startOffset": 268764,
            "endOffset": 268858,
            "count": 0
          },
          {
            "startOffset": 268871,
            "endOffset": 268970,
            "count": 0
          },
          {
            "startOffset": 268983,
            "endOffset": 268999,
            "count": 0
          },
          {
            "startOffset": 269012,
            "endOffset": 269028,
            "count": 0
          },
          {
            "startOffset": 269041,
            "endOffset": 269058,
            "count": 0
          },
          {
            "startOffset": 269071,
            "endOffset": 269088,
            "count": 0
          },
          {
            "startOffset": 269101,
            "endOffset": 269116,
            "count": 0
          },
          {
            "startOffset": 269129,
            "endOffset": 269145,
            "count": 0
          },
          {
            "startOffset": 269158,
            "endOffset": 269175,
            "count": 2
          },
          {
            "startOffset": 269188,
            "endOffset": 269284,
            "count": 2
          },
          {
            "startOffset": 269297,
            "endOffset": 269309,
            "count": 0
          },
          {
            "startOffset": 269322,
            "endOffset": 269337,
            "count": 0
          },
          {
            "startOffset": 269350,
            "endOffset": 269367,
            "count": 0
          },
          {
            "startOffset": 269380,
            "endOffset": 269396,
            "count": 0
          },
          {
            "startOffset": 269409,
            "endOffset": 269426,
            "count": 0
          },
          {
            "startOffset": 269439,
            "endOffset": 269455,
            "count": 0
          },
          {
            "startOffset": 269468,
            "endOffset": 269485,
            "count": 0
          },
          {
            "startOffset": 269498,
            "endOffset": 269586,
            "count": 0
          },
          {
            "startOffset": 269599,
            "endOffset": 269618,
            "count": 0
          },
          {
            "startOffset": 269631,
            "endOffset": 269647,
            "count": 0
          },
          {
            "startOffset": 269660,
            "endOffset": 269677,
            "count": 0
          },
          {
            "startOffset": 269690,
            "endOffset": 269785,
            "count": 0
          },
          {
            "startOffset": 269798,
            "endOffset": 269817,
            "count": 0
          },
          {
            "startOffset": 269830,
            "endOffset": 269855,
            "count": 4
          },
          {
            "startOffset": 269868,
            "endOffset": 269970,
            "count": 6
          },
          {
            "startOffset": 269983,
            "endOffset": 270085,
            "count": 4
          },
          {
            "startOffset": 270098,
            "endOffset": 270186,
            "count": 0
          },
          {
            "startOffset": 270199,
            "endOffset": 270289,
            "count": 0
          },
          {
            "startOffset": 270302,
            "endOffset": 270314,
            "count": 0
          },
          {
            "startOffset": 270327,
            "endOffset": 270338,
            "count": 0
          },
          {
            "startOffset": 270351,
            "endOffset": 270445,
            "count": 0
          },
          {
            "startOffset": 270458,
            "endOffset": 270483,
            "count": 0
          },
          {
            "startOffset": 270496,
            "endOffset": 270522,
            "count": 0
          },
          {
            "startOffset": 270535,
            "endOffset": 270556,
            "count": 0
          },
          {
            "startOffset": 270569,
            "endOffset": 270588,
            "count": 0
          },
          {
            "startOffset": 270601,
            "endOffset": 270620,
            "count": 0
          },
          {
            "startOffset": 270633,
            "endOffset": 270651,
            "count": 0
          },
          {
            "startOffset": 270664,
            "endOffset": 270683,
            "count": 2
          },
          {
            "startOffset": 270696,
            "endOffset": 270792,
            "count": 2
          },
          {
            "startOffset": 270948,
            "endOffset": 271230,
            "count": 7
          },
          {
            "startOffset": 271411,
            "endOffset": 271664,
            "count": 0
          }
        ]
      },
      {
        "functionName": "extractEvents$5",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 271837,
            "endOffset": 272678,
            "count": 14
          },
          {
            "startOffset": 272249,
            "endOffset": 272668,
            "count": 7
          }
        ]
      },
      {
        "functionName": "executeDispatch",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 273136,
            "endOffset": 273423,
            "count": 0
          }
        ]
      },
      {
        "functionName": "processDispatchQueueItemsInOrder",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 273432,
            "endOffset": 274656,
            "count": 0
          }
        ]
      },
      {
        "functionName": "processDispatchQueue",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 274665,
            "endOffset": 275123,
            "count": 14
          },
          {
            "startOffset": 274863,
            "endOffset": 275081,
            "count": 0
          }
        ]
      },
      {
        "functionName": "dispatchEventsForPlugins",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 275132,
            "endOffset": 275531,
            "count": 14
          }
        ]
      },
      {
        "functionName": "listenToNonDelegatedEvent",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 275540,
            "endOffset": 276267,
            "count": 0
          }
        ]
      },
      {
        "functionName": "listenToNativeEvent",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 276276,
            "endOffset": 276878,
            "count": 131
          },
          {
            "startOffset": 276418,
            "endOffset": 276444,
            "count": 30
          },
          {
            "startOffset": 276446,
            "endOffset": 276619,
            "count": 0
          },
          {
            "startOffset": 276706,
            "endOffset": 276769,
            "count": 80
          }
        ]
      },
      {
        "functionName": "listenToAllSupportedEvents",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 276974,
            "endOffset": 277957,
            "count": 1
          },
          {
            "startOffset": 277617,
            "endOffset": 277639,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 277184,
            "endOffset": 277534,
            "count": 81
          },
          {
            "startOffset": 277263,
            "endOffset": 277520,
            "count": 80
          },
          {
            "startOffset": 277324,
            "endOffset": 277425,
            "count": 50
          }
        ]
      },
      {
        "functionName": "addTrappedEventListener",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 277966,
            "endOffset": 279290,
            "count": 131
          },
          {
            "startOffset": 278361,
            "endOffset": 278392,
            "count": 129
          },
          {
            "startOffset": 278393,
            "endOffset": 278420,
            "count": 127
          },
          {
            "startOffset": 278422,
            "endOffset": 278477,
            "count": 6
          },
          {
            "startOffset": 278608,
            "endOffset": 278942,
            "count": 80
          },
          {
            "startOffset": 278656,
            "endOffset": 278807,
            "count": 3
          },
          {
            "startOffset": 278807,
            "endOffset": 278930,
            "count": 77
          },
          {
            "startOffset": 278942,
            "endOffset": 279280,
            "count": 51
          },
          {
            "startOffset": 278996,
            "endOffset": 279146,
            "count": 3
          },
          {
            "startOffset": 279146,
            "endOffset": 279268,
            "count": 48
          }
        ]
      },
      {
        "functionName": "isMatchingRootContainer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 279299,
            "endOffset": 279522,
            "count": 14
          },
          {
            "startOffset": 279419,
            "endOffset": 279511,
            "count": 0
          }
        ]
      },
      {
        "functionName": "dispatchEventForPluginEventSystem",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 279531,
            "endOffset": 281893,
            "count": 14
          },
          {
            "startOffset": 279999,
            "endOffset": 281701,
            "count": 128
          },
          {
            "startOffset": 280038,
            "endOffset": 280087,
            "count": 0
          },
          {
            "startOffset": 280173,
            "endOffset": 280198,
            "count": 114
          },
          {
            "startOffset": 280200,
            "endOffset": 281645,
            "count": 14
          },
          {
            "startOffset": 280401,
            "endOffset": 281625,
            "count": 0
          },
          {
            "startOffset": 281645,
            "endOffset": 281701,
            "count": 114
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 281753,
            "endOffset": 281881,
            "count": 14
          }
        ]
      },
      {
        "functionName": "createDispatchListener",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 281902,
            "endOffset": 282082,
            "count": 0
          }
        ]
      },
      {
        "functionName": "accumulateSinglePhaseListeners",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 282091,
            "endOffset": 283190,
            "count": 14
          },
          {
            "startOffset": 282296,
            "endOffset": 282302,
            "count": 0
          },
          {
            "startOffset": 282350,
            "endOffset": 282363,
            "count": 7
          },
          {
            "startOffset": 282364,
            "endOffset": 282375,
            "count": 7
          },
          {
            "startOffset": 282521,
            "endOffset": 283152,
            "count": 128
          },
          {
            "startOffset": 282656,
            "endOffset": 282677,
            "count": 44
          },
          {
            "startOffset": 282679,
            "endOffset": 283025,
            "count": 44
          },
          {
            "startOffset": 282879,
            "endOffset": 282995,
            "count": 0
          },
          {
            "startOffset": 283064,
            "endOffset": 283100,
            "count": 0
          }
        ]
      },
      {
        "functionName": "accumulateTwoPhaseListeners",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 283199,
            "endOffset": 284185,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getParent",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 284194,
            "endOffset": 284483,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getLowestCommonAncestor",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 284492,
            "endOffset": 285383,
            "count": 0
          }
        ]
      },
      {
        "functionName": "accumulateEnterLeaveListenersForEvent",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 285392,
            "endOffset": 286860,
            "count": 2
          },
          {
            "startOffset": 285645,
            "endOffset": 286704,
            "count": 16
          },
          {
            "startOffset": 285684,
            "endOffset": 285720,
            "count": 0
          },
          {
            "startOffset": 285885,
            "endOffset": 285908,
            "count": 2
          },
          {
            "startOffset": 285910,
            "endOffset": 285946,
            "count": 0
          },
          {
            "startOffset": 285985,
            "endOffset": 286006,
            "count": 4
          },
          {
            "startOffset": 286008,
            "endOffset": 286652,
            "count": 4
          },
          {
            "startOffset": 286215,
            "endOffset": 286337,
            "count": 0
          },
          {
            "startOffset": 286353,
            "endOffset": 286638,
            "count": 0
          },
          {
            "startOffset": 286743,
            "endOffset": 286850,
            "count": 0
          }
        ]
      },
      {
        "functionName": "accumulateEnterLeaveTwoPhaseListeners",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 286869,
            "endOffset": 287356,
            "count": 2
          },
          {
            "startOffset": 286995,
            "endOffset": 287000,
            "count": 0
          },
          {
            "startOffset": 287001,
            "endOffset": 287036,
            "count": 0
          },
          {
            "startOffset": 287074,
            "endOffset": 287186,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getListenerSetKey",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 287365,
            "endOffset": 287499,
            "count": 0
          }
        ]
      },
      {
        "functionName": "validatePropertiesInDevelopment",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 288720,
            "endOffset": 288995,
            "count": 67
          }
        ]
      },
      {
        "functionName": "warnForPropDifference",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 289112,
            "endOffset": 289729,
            "count": 0
          }
        ]
      },
      {
        "functionName": "warnForExtraAttributes",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 289766,
            "endOffset": 290121,
            "count": 0
          }
        ]
      },
      {
        "functionName": "warnForInvalidEventListener",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 290163,
            "endOffset": 290679,
            "count": 0
          }
        ]
      },
      {
        "functionName": "normalizeHTML",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 290707,
            "endOffset": 291026,
            "count": 0
          }
        ]
      },
      {
        "functionName": "normalizeMarkupForTextOrAttribute",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 291164,
            "endOffset": 291496,
            "count": 0
          }
        ]
      },
      {
        "functionName": "checkForUnmatchedText",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 291505,
            "endOffset": 292344,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getOwnerDocumentFromRootContainer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 292353,
            "endOffset": 292555,
            "count": 41
          },
          {
            "startOffset": 292485,
            "endOffset": 292507,
            "count": 0
          }
        ]
      },
      {
        "functionName": "noop",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 292564,
            "endOffset": 292591,
            "count": 0
          }
        ]
      },
      {
        "functionName": "trapClickOnNonInteractiveElement",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 292600,
            "endOffset": 292690,
            "count": 1
          }
        ]
      },
      {
        "functionName": "setInitialDOMProperties",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 292699,
            "endOffset": 294620,
            "count": 41
          },
          {
            "startOffset": 292847,
            "endOffset": 294610,
            "count": 83
          },
          {
            "startOffset": 292901,
            "endOffset": 292940,
            "count": 0
          },
          {
            "startOffset": 293023,
            "endOffset": 293218,
            "count": 0
          },
          {
            "startOffset": 293268,
            "endOffset": 293456,
            "count": 0
          },
          {
            "startOffset": 293488,
            "endOffset": 293879,
            "count": 38
          },
          {
            "startOffset": 293538,
            "endOffset": 293749,
            "count": 19
          },
          {
            "startOffset": 293599,
            "endOffset": 293617,
            "count": 0
          },
          {
            "startOffset": 293749,
            "endOffset": 293865,
            "count": 19
          },
          {
            "startOffset": 293789,
            "endOffset": 293865,
            "count": 0
          },
          {
            "startOffset": 293879,
            "endOffset": 294598,
            "count": 45
          },
          {
            "startOffset": 293992,
            "endOffset": 293993,
            "count": 0
          },
          {
            "startOffset": 294052,
            "endOffset": 294053,
            "count": 0
          },
          {
            "startOffset": 294129,
            "endOffset": 294467,
            "count": 0
          }
        ]
      },
      {
        "functionName": "updateDOMProperties",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 294629,
            "endOffset": 295342,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createElement",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 295351,
            "endOffset": 297529,
            "count": 41
          },
          {
            "startOffset": 295944,
            "endOffset": 296096,
            "count": 0
          },
          {
            "startOffset": 296146,
            "endOffset": 296376,
            "count": 0
          },
          {
            "startOffset": 296416,
            "endOffset": 296541,
            "count": 0
          },
          {
            "startOffset": 296648,
            "endOffset": 296883,
            "count": 0
          },
          {
            "startOffset": 296909,
            "endOffset": 297004,
            "count": 0
          },
          {
            "startOffset": 297188,
            "endOffset": 297236,
            "count": 0
          },
          {
            "startOffset": 297238,
            "endOffset": 297464,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createTextNode",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 297538,
            "endOffset": 297696,
            "count": 0
          }
        ]
      },
      {
        "functionName": "setInitialProperties",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 297705,
            "endOffset": 300905,
            "count": 41
          },
          {
            "startOffset": 297999,
            "endOffset": 298191,
            "count": 0
          },
          {
            "startOffset": 298204,
            "endOffset": 298218,
            "count": 0
          },
          {
            "startOffset": 298231,
            "endOffset": 298245,
            "count": 0
          },
          {
            "startOffset": 298258,
            "endOffset": 298385,
            "count": 0
          },
          {
            "startOffset": 298398,
            "endOffset": 298411,
            "count": 0
          },
          {
            "startOffset": 298424,
            "endOffset": 298646,
            "count": 0
          },
          {
            "startOffset": 298659,
            "endOffset": 298788,
            "count": 0
          },
          {
            "startOffset": 298801,
            "endOffset": 298812,
            "count": 0
          },
          {
            "startOffset": 298825,
            "endOffset": 298838,
            "count": 0
          },
          {
            "startOffset": 298851,
            "endOffset": 299039,
            "count": 0
          },
          {
            "startOffset": 299052,
            "endOffset": 299183,
            "count": 0
          },
          {
            "startOffset": 299196,
            "endOffset": 299406,
            "count": 0
          },
          {
            "startOffset": 299419,
            "endOffset": 299537,
            "count": 0
          },
          {
            "startOffset": 299550,
            "endOffset": 299765,
            "count": 0
          },
          {
            "startOffset": 299778,
            "endOffset": 299995,
            "count": 0
          },
          {
            "startOffset": 300241,
            "endOffset": 300369,
            "count": 0
          },
          {
            "startOffset": 300382,
            "endOffset": 300498,
            "count": 0
          },
          {
            "startOffset": 300511,
            "endOffset": 300602,
            "count": 0
          },
          {
            "startOffset": 300615,
            "endOffset": 300706,
            "count": 0
          },
          {
            "startOffset": 300783,
            "endOffset": 300862,
            "count": 0
          }
        ]
      },
      {
        "functionName": "diffProperties",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 300914,
            "endOffset": 306630,
            "count": 26
          },
          {
            "startOffset": 301218,
            "endOffset": 301418,
            "count": 0
          },
          {
            "startOffset": 301431,
            "endOffset": 301636,
            "count": 0
          },
          {
            "startOffset": 301649,
            "endOffset": 301856,
            "count": 0
          },
          {
            "startOffset": 302060,
            "endOffset": 302139,
            "count": 0
          },
          {
            "startOffset": 302337,
            "endOffset": 303442,
            "count": 53
          },
          {
            "startOffset": 302389,
            "endOffset": 302426,
            "count": 0
          },
          {
            "startOffset": 302427,
            "endOffset": 302456,
            "count": 0
          },
          {
            "startOffset": 302497,
            "endOffset": 303430,
            "count": 0
          },
          {
            "startOffset": 303480,
            "endOffset": 306354,
            "count": 53
          },
          {
            "startOffset": 303595,
            "endOffset": 303603,
            "count": 0
          },
          {
            "startOffset": 303681,
            "endOffset": 303720,
            "count": 14
          },
          {
            "startOffset": 303701,
            "endOffset": 303720,
            "count": 0
          },
          {
            "startOffset": 303722,
            "endOffset": 303761,
            "count": 39
          },
          {
            "startOffset": 303761,
            "endOffset": 303797,
            "count": 14
          },
          {
            "startOffset": 303797,
            "endOffset": 304977,
            "count": 0
          },
          {
            "startOffset": 304977,
            "endOffset": 306342,
            "count": 14
          },
          {
            "startOffset": 305027,
            "endOffset": 305374,
            "count": 0
          },
          {
            "startOffset": 305488,
            "endOffset": 305589,
            "count": 0
          },
          {
            "startOffset": 305603,
            "endOffset": 306342,
            "count": 0
          },
          {
            "startOffset": 306383,
            "endOffset": 306588,
            "count": 0
          }
        ]
      },
      {
        "functionName": "updateProperties",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 306639,
            "endOffset": 307503,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getPossibleStandardName",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 307512,
            "endOffset": 307827,
            "count": 0
          }
        ]
      },
      {
        "functionName": "diffHydratedProperties",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 307836,
            "endOffset": 316541,
            "count": 0
          }
        ]
      },
      {
        "functionName": "diffHydratedText",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 316550,
            "endOffset": 316708,
            "count": 0
          }
        ]
      },
      {
        "functionName": "warnForDeletedHydratableElement",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 316717,
            "endOffset": 317076,
            "count": 0
          }
        ]
      },
      {
        "functionName": "warnForDeletedHydratableText",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 317085,
            "endOffset": 317440,
            "count": 0
          }
        ]
      },
      {
        "functionName": "warnForInsertedHydratedElement",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 317449,
            "endOffset": 317790,
            "count": 0
          }
        ]
      },
      {
        "functionName": "warnForInsertedHydratedText",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 317799,
            "endOffset": 318213,
            "count": 0
          }
        ]
      },
      {
        "functionName": "restoreControlledState$3",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 318222,
            "endOffset": 318651,
            "count": 0
          }
        ]
      },
      {
        "functionName": "validateDOMNesting",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 318685,
            "endOffset": 318707,
            "count": 0
          }
        ]
      },
      {
        "functionName": "updatedAncestorInfo",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 318743,
            "endOffset": 318765,
            "count": 0
          }
        ]
      },
      {
        "functionName": "updatedAncestorInfo",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 320583,
            "endOffset": 322095,
            "count": 98
          },
          {
            "startOffset": 320658,
            "endOffset": 320678,
            "count": 2
          },
          {
            "startOffset": 320788,
            "endOffset": 320952,
            "count": 0
          },
          {
            "startOffset": 321006,
            "endOffset": 321074,
            "count": 0
          },
          {
            "startOffset": 321123,
            "endOffset": 321143,
            "count": 26
          },
          {
            "startOffset": 321144,
            "endOffset": 321160,
            "count": 26
          },
          {
            "startOffset": 321161,
            "endOffset": 321175,
            "count": 11
          },
          {
            "startOffset": 321177,
            "endOffset": 321306,
            "count": 5
          },
          {
            "startOffset": 321380,
            "endOffset": 321438,
            "count": 0
          },
          {
            "startOffset": 321468,
            "endOffset": 321530,
            "count": 5
          },
          {
            "startOffset": 321565,
            "endOffset": 321632,
            "count": 0
          },
          {
            "startOffset": 321665,
            "endOffset": 321730,
            "count": 0
          },
          {
            "startOffset": 321760,
            "endOffset": 321828,
            "count": 6
          },
          {
            "startOffset": 321859,
            "endOffset": 321932,
            "count": 0
          },
          {
            "startOffset": 321979,
            "endOffset": 322050,
            "count": 0
          }
        ]
      },
      {
        "functionName": "isTagValidWithParent",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 322134,
            "endOffset": 324541,
            "count": 60
          },
          {
            "startOffset": 322208,
            "endOffset": 322304,
            "count": 0
          },
          {
            "startOffset": 322319,
            "endOffset": 322395,
            "count": 0
          },
          {
            "startOffset": 322410,
            "endOffset": 322464,
            "count": 0
          },
          {
            "startOffset": 322479,
            "endOffset": 322603,
            "count": 0
          },
          {
            "startOffset": 322618,
            "endOffset": 322631,
            "count": 0
          },
          {
            "startOffset": 322646,
            "endOffset": 322659,
            "count": 0
          },
          {
            "startOffset": 322674,
            "endOffset": 322785,
            "count": 0
          },
          {
            "startOffset": 322800,
            "endOffset": 322876,
            "count": 0
          },
          {
            "startOffset": 322891,
            "endOffset": 323086,
            "count": 0
          },
          {
            "startOffset": 323101,
            "endOffset": 323355,
            "count": 0
          },
          {
            "startOffset": 323370,
            "endOffset": 323461,
            "count": 0
          },
          {
            "startOffset": 323476,
            "endOffset": 323532,
            "count": 0
          },
          {
            "startOffset": 323547,
            "endOffset": 323603,
            "count": 0
          },
          {
            "startOffset": 323659,
            "endOffset": 323669,
            "count": 1
          },
          {
            "startOffset": 323684,
            "endOffset": 323694,
            "count": 1
          },
          {
            "startOffset": 323709,
            "endOffset": 323719,
            "count": 1
          },
          {
            "startOffset": 323734,
            "endOffset": 323744,
            "count": 1
          },
          {
            "startOffset": 323759,
            "endOffset": 323769,
            "count": 1
          },
          {
            "startOffset": 323784,
            "endOffset": 323947,
            "count": 1
          },
          {
            "startOffset": 323962,
            "endOffset": 323972,
            "count": 0
          },
          {
            "startOffset": 323987,
            "endOffset": 324062,
            "count": 0
          },
          {
            "startOffset": 324077,
            "endOffset": 324089,
            "count": 0
          },
          {
            "startOffset": 324104,
            "endOffset": 324119,
            "count": 0
          },
          {
            "startOffset": 324134,
            "endOffset": 324145,
            "count": 0
          },
          {
            "startOffset": 324160,
            "endOffset": 324176,
            "count": 0
          },
          {
            "startOffset": 324191,
            "endOffset": 324207,
            "count": 0
          },
          {
            "startOffset": 324222,
            "endOffset": 324235,
            "count": 0
          },
          {
            "startOffset": 324250,
            "endOffset": 324262,
            "count": 0
          },
          {
            "startOffset": 324277,
            "endOffset": 324289,
            "count": 0
          },
          {
            "startOffset": 324304,
            "endOffset": 324317,
            "count": 0
          },
          {
            "startOffset": 324332,
            "endOffset": 324342,
            "count": 0
          },
          {
            "startOffset": 324357,
            "endOffset": 324370,
            "count": 0
          },
          {
            "startOffset": 324385,
            "endOffset": 324395,
            "count": 0
          },
          {
            "startOffset": 324410,
            "endOffset": 324423,
            "count": 0
          },
          {
            "startOffset": 324438,
            "endOffset": 324490,
            "count": 0
          },
          {
            "startOffset": 324504,
            "endOffset": 324540,
            "count": 59
          }
        ]
      },
      {
        "functionName": "findInvalidAncestorForTag",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 324585,
            "endOffset": 326246,
            "count": 60
          },
          {
            "startOffset": 324656,
            "endOffset": 324671,
            "count": 0
          },
          {
            "startOffset": 324686,
            "endOffset": 324701,
            "count": 0
          },
          {
            "startOffset": 324716,
            "endOffset": 324729,
            "count": 0
          },
          {
            "startOffset": 324744,
            "endOffset": 324762,
            "count": 0
          },
          {
            "startOffset": 324777,
            "endOffset": 324791,
            "count": 0
          },
          {
            "startOffset": 324806,
            "endOffset": 324821,
            "count": 0
          },
          {
            "startOffset": 324836,
            "endOffset": 324850,
            "count": 0
          },
          {
            "startOffset": 324865,
            "endOffset": 324876,
            "count": 0
          },
          {
            "startOffset": 324891,
            "endOffset": 324902,
            "count": 8
          },
          {
            "startOffset": 324917,
            "endOffset": 324927,
            "count": 8
          },
          {
            "startOffset": 324942,
            "endOffset": 324958,
            "count": 8
          },
          {
            "startOffset": 324973,
            "endOffset": 324991,
            "count": 8
          },
          {
            "startOffset": 325006,
            "endOffset": 325020,
            "count": 8
          },
          {
            "startOffset": 325035,
            "endOffset": 325049,
            "count": 8
          },
          {
            "startOffset": 325064,
            "endOffset": 325078,
            "count": 8
          },
          {
            "startOffset": 325093,
            "endOffset": 325107,
            "count": 8
          },
          {
            "startOffset": 325122,
            "endOffset": 325134,
            "count": 9
          },
          {
            "startOffset": 325149,
            "endOffset": 325161,
            "count": 9
          },
          {
            "startOffset": 325176,
            "endOffset": 325187,
            "count": 9
          },
          {
            "startOffset": 325202,
            "endOffset": 325212,
            "count": 9
          },
          {
            "startOffset": 325227,
            "endOffset": 325236,
            "count": 11
          },
          {
            "startOffset": 325251,
            "endOffset": 325266,
            "count": 11
          },
          {
            "startOffset": 325281,
            "endOffset": 325296,
            "count": 11
          },
          {
            "startOffset": 325311,
            "endOffset": 325321,
            "count": 11
          },
          {
            "startOffset": 325336,
            "endOffset": 325347,
            "count": 11
          },
          {
            "startOffset": 325362,
            "endOffset": 325377,
            "count": 11
          },
          {
            "startOffset": 325392,
            "endOffset": 325405,
            "count": 11
          },
          {
            "startOffset": 325420,
            "endOffset": 325430,
            "count": 11
          },
          {
            "startOffset": 325445,
            "endOffset": 325456,
            "count": 11
          },
          {
            "startOffset": 325471,
            "endOffset": 325481,
            "count": 12
          },
          {
            "startOffset": 325496,
            "endOffset": 325506,
            "count": 12
          },
          {
            "startOffset": 325521,
            "endOffset": 325531,
            "count": 12
          },
          {
            "startOffset": 325546,
            "endOffset": 325556,
            "count": 12
          },
          {
            "startOffset": 325571,
            "endOffset": 325581,
            "count": 12
          },
          {
            "startOffset": 325596,
            "endOffset": 325661,
            "count": 12
          },
          {
            "startOffset": 325676,
            "endOffset": 325767,
            "count": 0
          },
          {
            "startOffset": 325782,
            "endOffset": 325852,
            "count": 0
          },
          {
            "startOffset": 325867,
            "endOffset": 325877,
            "count": 0
          },
          {
            "startOffset": 325892,
            "endOffset": 325960,
            "count": 0
          },
          {
            "startOffset": 325975,
            "endOffset": 326043,
            "count": 0
          },
          {
            "startOffset": 326058,
            "endOffset": 326116,
            "count": 2
          },
          {
            "startOffset": 326131,
            "endOffset": 326195,
            "count": 0
          },
          {
            "startOffset": 326209,
            "endOffset": 326245,
            "count": 46
          }
        ]
      },
      {
        "functionName": "validateDOMNesting",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 326309,
            "endOffset": 328470,
            "count": 60
          },
          {
            "startOffset": 326395,
            "endOffset": 326415,
            "count": 0
          },
          {
            "startOffset": 326561,
            "endOffset": 326760,
            "count": 19
          },
          {
            "startOffset": 326599,
            "endOffset": 326712,
            "count": 0
          },
          {
            "startOffset": 326842,
            "endOffset": 326854,
            "count": 0
          },
          {
            "startOffset": 326904,
            "endOffset": 326910,
            "count": 0
          },
          {
            "startOffset": 327119,
            "endOffset": 328458,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getRootHostContext",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 328841,
            "endOffset": 329962,
            "count": 2
          },
          {
            "startOffset": 329038,
            "endOffset": 329057,
            "count": 0
          },
          {
            "startOffset": 329070,
            "endOffset": 329361,
            "count": 0
          },
          {
            "startOffset": 329441,
            "endOffset": 329475,
            "count": 0
          },
          {
            "startOffset": 329557,
            "endOffset": 329564,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getChildHostContext",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 329971,
            "endOffset": 330407,
            "count": 77
          }
        ]
      },
      {
        "functionName": "getPublicInstance",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 330416,
            "endOffset": 330491,
            "count": 9
          }
        ]
      },
      {
        "functionName": "prepareForCommit",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 330500,
            "endOffset": 330750,
            "count": 2
          }
        ]
      },
      {
        "functionName": "resetAfterCommit",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 330759,
            "endOffset": 330969,
            "count": 2
          }
        ]
      },
      {
        "functionName": "createInstance",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 330978,
            "endOffset": 331863,
            "count": 41
          },
          {
            "startOffset": 331290,
            "endOffset": 331327,
            "count": 22
          },
          {
            "startOffset": 331329,
            "endOffset": 331549,
            "count": 19
          }
        ]
      },
      {
        "functionName": "appendInitialChild",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 331872,
            "endOffset": 331979,
            "count": 38
          }
        ]
      },
      {
        "functionName": "finalizeInitialChildren",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 331988,
            "endOffset": 332460,
            "count": 41
          },
          {
            "startOffset": 332202,
            "endOffset": 332216,
            "count": 0
          },
          {
            "startOffset": 332229,
            "endOffset": 332242,
            "count": 0
          },
          {
            "startOffset": 332255,
            "endOffset": 332269,
            "count": 0
          },
          {
            "startOffset": 332282,
            "endOffset": 332338,
            "count": 0
          },
          {
            "startOffset": 332351,
            "endOffset": 332389,
            "count": 0
          }
        ]
      },
      {
        "functionName": "prepareUpdate",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 332469,
            "endOffset": 333097,
            "count": 26
          },
          {
            "startOffset": 332696,
            "endOffset": 332779,
            "count": 0
          },
          {
            "startOffset": 332781,
            "endOffset": 333004,
            "count": 0
          }
        ]
      },
      {
        "functionName": "shouldSetTextContent",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 333106,
            "endOffset": 333440,
            "count": 81
          },
          {
            "startOffset": 333249,
            "endOffset": 333286,
            "count": 50
          },
          {
            "startOffset": 333287,
            "endOffset": 333429,
            "count": 50
          },
          {
            "startOffset": 333340,
            "endOffset": 333381,
            "count": 0
          },
          {
            "startOffset": 333382,
            "endOffset": 333429,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createTextInstance",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 333449,
            "endOffset": 333857,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getCurrentEventPriority",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 333866,
            "endOffset": 334103,
            "count": 2
          },
          {
            "startOffset": 334039,
            "endOffset": 334102,
            "count": 0
          }
        ]
      },
      {
        "functionName": "scheduleMicrotask",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 334509,
            "endOffset": 334628,
            "count": 0
          }
        ]
      },
      {
        "functionName": "handleErrorInNextTick",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 334656,
            "endOffset": 334780,
            "count": 0
          }
        ]
      },
      {
        "functionName": "commitMount",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 334789,
            "endOffset": 335293,
            "count": 0
          }
        ]
      },
      {
        "functionName": "commitUpdate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 335302,
            "endOffset": 335543,
            "count": 0
          }
        ]
      },
      {
        "functionName": "resetTextContent",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 335552,
            "endOffset": 335643,
            "count": 0
          }
        ]
      },
      {
        "functionName": "commitTextUpdate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 335652,
            "endOffset": 335765,
            "count": 0
          }
        ]
      },
      {
        "functionName": "appendChild",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 335774,
            "endOffset": 335874,
            "count": 0
          }
        ]
      },
      {
        "functionName": "appendChildToContainer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 335883,
            "endOffset": 336482,
            "count": 3
          },
          {
            "startOffset": 336012,
            "endOffset": 336127,
            "count": 0
          },
          {
            "startOffset": 336401,
            "endOffset": 336472,
            "count": 1
          }
        ]
      },
      {
        "functionName": "insertBefore",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 336491,
            "endOffset": 336619,
            "count": 0
          }
        ]
      },
      {
        "functionName": "insertInContainerBefore",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 336628,
            "endOffset": 336910,
            "count": 0
          }
        ]
      },
      {
        "functionName": "removeChild",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 336919,
            "endOffset": 337019,
            "count": 0
          }
        ]
      },
      {
        "functionName": "removeChildFromContainer",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 337028,
            "endOffset": 337270,
            "count": 0
          }
        ]
      },
      {
        "functionName": "clearSuspenseBoundary",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 337279,
            "endOffset": 338214,
            "count": 0
          }
        ]
      },
      {
        "functionName": "clearSuspenseBoundaryFromContainer",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 338223,
            "endOffset": 338610,
            "count": 0
          }
        ]
      },
      {
        "functionName": "hideInstance",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 338619,
            "endOffset": 338922,
            "count": 0
          }
        ]
      },
      {
        "functionName": "hideTextInstance",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 338931,
            "endOffset": 339021,
            "count": 0
          }
        ]
      },
      {
        "functionName": "unhideInstance",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 339030,
            "endOffset": 339365,
            "count": 0
          }
        ]
      },
      {
        "functionName": "unhideTextInstance",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 339374,
            "endOffset": 339474,
            "count": 0
          }
        ]
      },
      {
        "functionName": "clearContainer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 339483,
            "endOffset": 339818,
            "count": 1
          },
          {
            "startOffset": 339624,
            "endOffset": 339808,
            "count": 0
          }
        ]
      },
      {
        "functionName": "canHydrateInstance",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 339827,
            "endOffset": 340063,
            "count": 0
          }
        ]
      },
      {
        "functionName": "canHydrateTextInstance",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 340072,
            "endOffset": 340259,
            "count": 0
          }
        ]
      },
      {
        "functionName": "canHydrateSuspenseInstance",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 340268,
            "endOffset": 340441,
            "count": 0
          }
        ]
      },
      {
        "functionName": "isSuspenseInstancePending",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 340450,
            "endOffset": 340570,
            "count": 0
          }
        ]
      },
      {
        "functionName": "isSuspenseInstanceFallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 340579,
            "endOffset": 340701,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getSuspenseInstanceFallbackErrorDetails",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 340710,
            "endOffset": 341194,
            "count": 0
          }
        ]
      },
      {
        "functionName": "registerSuspenseInstanceRetry",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 341203,
            "endOffset": 341316,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getNextHydratable",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 341325,
            "endOffset": 341988,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getNextHydratableSibling",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 341997,
            "endOffset": 342110,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getFirstHydratableChild",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 342119,
            "endOffset": 342242,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getFirstHydratableChildWithinContainer",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 342251,
            "endOffset": 342391,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getFirstHydratableChildWithinSuspenseInstance",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 342400,
            "endOffset": 342546,
            "count": 0
          }
        ]
      },
      {
        "functionName": "hydrateInstance",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 342555,
            "endOffset": 343183,
            "count": 0
          }
        ]
      },
      {
        "functionName": "hydrateTextInstance",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 343192,
            "endOffset": 343505,
            "count": 0
          }
        ]
      },
      {
        "functionName": "hydrateSuspenseInstance",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 343514,
            "endOffset": 343671,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getNextHydratableInstanceAfterSuspenseInstance",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 343680,
            "endOffset": 344427,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getParentSuspenseInstance",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 344436,
            "endOffset": 345140,
            "count": 0
          }
        ]
      },
      {
        "functionName": "commitHydratedContainer",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 345149,
            "endOffset": 345243,
            "count": 0
          }
        ]
      },
      {
        "functionName": "commitHydratedSuspenseInstance",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 345252,
            "endOffset": 345367,
            "count": 0
          }
        ]
      },
      {
        "functionName": "shouldDeleteUnhydratedTailInstances",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 345376,
            "endOffset": 345509,
            "count": 0
          }
        ]
      },
      {
        "functionName": "didNotMatchHydratedContainerTextInstance",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 345518,
            "endOffset": 345766,
            "count": 0
          }
        ]
      },
      {
        "functionName": "didNotMatchHydratedTextInstance",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 345775,
            "endOffset": 346122,
            "count": 0
          }
        ]
      },
      {
        "functionName": "didNotHydrateInstanceWithinContainer",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 346131,
            "endOffset": 346546,
            "count": 0
          }
        ]
      },
      {
        "functionName": "didNotHydrateInstanceWithinSuspenseInstance",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 346555,
            "endOffset": 347089,
            "count": 0
          }
        ]
      },
      {
        "functionName": "didNotHydrateInstance",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 347098,
            "endOffset": 347656,
            "count": 0
          }
        ]
      },
      {
        "functionName": "didNotFindHydratableInstanceWithinContainer",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 347665,
            "endOffset": 347850,
            "count": 0
          }
        ]
      },
      {
        "functionName": "didNotFindHydratableTextInstanceWithinContainer",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 347859,
            "endOffset": 348038,
            "count": 0
          }
        ]
      },
      {
        "functionName": "didNotFindHydratableInstanceWithinSuspenseInstance",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 348047,
            "endOffset": 348328,
            "count": 0
          }
        ]
      },
      {
        "functionName": "didNotFindHydratableTextInstanceWithinSuspenseInstance",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 348337,
            "endOffset": 348612,
            "count": 0
          }
        ]
      },
      {
        "functionName": "didNotFindHydratableInstance",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 348621,
            "endOffset": 348938,
            "count": 0
          }
        ]
      },
      {
        "functionName": "didNotFindHydratableTextInstance",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 348947,
            "endOffset": 349258,
            "count": 0
          }
        ]
      },
      {
        "functionName": "errorHydratingContainer",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 349267,
            "endOffset": 349508,
            "count": 0
          }
        ]
      },
      {
        "functionName": "preparePortalMount",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 349517,
            "endOffset": 349626,
            "count": 0
          }
        ]
      },
      {
        "functionName": "detachDeletedInstance",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 350116,
            "endOffset": 350406,
            "count": 0
          }
        ]
      },
      {
        "functionName": "precacheFiberNode",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 350415,
            "endOffset": 350517,
            "count": 41
          }
        ]
      },
      {
        "functionName": "markContainerAsRoot",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 350526,
            "endOffset": 350639,
            "count": 1
          }
        ]
      },
      {
        "functionName": "unmarkContainerAsRoot",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 350648,
            "endOffset": 350749,
            "count": 0
          }
        ]
      },
      {
        "functionName": "isContainerMarkedAsRoot",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 350758,
            "endOffset": 350863,
            "count": 3
          }
        ]
      },
      {
        "functionName": "getClosestInstanceFromNode",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 350872,
            "endOffset": 352030,
            "count": 18
          },
          {
            "startOffset": 351008,
            "endOffset": 351052,
            "count": 16
          },
          {
            "startOffset": 351052,
            "endOffset": 351132,
            "count": 2
          },
          {
            "startOffset": 351132,
            "endOffset": 351997,
            "count": 4
          },
          {
            "startOffset": 351264,
            "endOffset": 351900,
            "count": 0
          },
          {
            "startOffset": 351997,
            "endOffset": 352029,
            "count": 2
          }
        ]
      },
      {
        "functionName": "getInstanceFromNode",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 352039,
            "endOffset": 352447,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getNodeFromInstance",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 352456,
            "endOffset": 352687,
            "count": 16
          },
          {
            "startOffset": 352534,
            "endOffset": 352558,
            "count": 0
          },
          {
            "startOffset": 352608,
            "endOffset": 352686,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getFiberCurrentPropsFromNode",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 352696,
            "endOffset": 352800,
            "count": 48
          },
          {
            "startOffset": 352782,
            "endOffset": 352789,
            "count": 0
          }
        ]
      },
      {
        "functionName": "updateFiberProps",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 352809,
            "endOffset": 352901,
            "count": 41
          }
        ]
      },
      {
        "functionName": "getEventListenerSet",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 352910,
            "endOffset": 353212,
            "count": 0
          }
        ]
      },
      {
        "functionName": "setCurrentlyValidatingElement",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 353342,
            "endOffset": 353782,
            "count": 0
          }
        ]
      },
      {
        "functionName": "checkPropTypes",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 353791,
            "endOffset": 355841,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createCursor",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 355974,
            "endOffset": 356087,
            "count": 8
          }
        ]
      },
      {
        "functionName": "pop",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 356096,
            "endOffset": 356559,
            "count": 168
          },
          {
            "startOffset": 356151,
            "endOffset": 356252,
            "count": 0
          },
          {
            "startOffset": 356310,
            "endOffset": 356374,
            "count": 0
          }
        ]
      },
      {
        "functionName": "push",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 356568,
            "endOffset": 356777,
            "count": 168
          }
        ]
      },
      {
        "functionName": "getUnmaskedContext",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 357183,
            "endOffset": 357481,
            "count": 7
          },
          {
            "startOffset": 357326,
            "endOffset": 357357,
            "count": 1
          },
          {
            "startOffset": 357359,
            "endOffset": 357412,
            "count": 0
          }
        ]
      },
      {
        "functionName": "cacheContext",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 357490,
            "endOffset": 357814,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getMaskedContext",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 357823,
            "endOffset": 358806,
            "count": 7
          },
          {
            "startOffset": 358079,
            "endOffset": 358234,
            "count": 0
          },
          {
            "startOffset": 358236,
            "endOffset": 358558,
            "count": 0
          },
          {
            "startOffset": 358643,
            "endOffset": 358805,
            "count": 0
          }
        ]
      },
      {
        "functionName": "hasContextChanged",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 358815,
            "endOffset": 358933,
            "count": 20
          }
        ]
      },
      {
        "functionName": "isContextProvider",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 358942,
            "endOffset": 359149,
            "count": 1
          }
        ]
      },
      {
        "functionName": "popContext",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 359158,
            "endOffset": 359315,
            "count": 0
          }
        ]
      },
      {
        "functionName": "popTopLevelContextObject",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 359324,
            "endOffset": 359495,
            "count": 2
          }
        ]
      },
      {
        "functionName": "pushTopLevelContextObject",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 359504,
            "endOffset": 359939,
            "count": 2
          },
          {
            "startOffset": 359647,
            "endOffset": 359800,
            "count": 0
          }
        ]
      },
      {
        "functionName": "processChildContext",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 359948,
            "endOffset": 361384,
            "count": 0
          }
        ]
      },
      {
        "functionName": "pushContextProvider",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 361393,
            "endOffset": 361922,
            "count": 0
          }
        ]
      },
      {
        "functionName": "invalidateContextProvider",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 361931,
            "endOffset": 362924,
            "count": 0
          }
        ]
      },
      {
        "functionName": "findCurrentUnmaskedContext",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 362933,
            "endOffset": 363936,
            "count": 0
          }
        ]
      },
      {
        "functionName": "scheduleSyncCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 364125,
            "endOffset": 364317,
            "count": 0
          }
        ]
      },
      {
        "functionName": "scheduleLegacySyncCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 364326,
            "endOffset": 364471,
            "count": 0
          }
        ]
      },
      {
        "functionName": "flushSyncCallbacksOnlyInLegacyMode",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 364480,
            "endOffset": 364628,
            "count": 14
          },
          {
            "startOffset": 364571,
            "endOffset": 364618,
            "count": 0
          }
        ]
      },
      {
        "functionName": "flushSyncCallbacks",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 364637,
            "endOffset": 365738,
            "count": 4
          },
          {
            "startOffset": 364727,
            "endOffset": 365705,
            "count": 0
          }
        ]
      },
      {
        "functionName": "isForkedChild",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 366040,
            "endOffset": 366186,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getForksAtLevel",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 366195,
            "endOffset": 366312,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getTreeId",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 366321,
            "endOffset": 366564,
            "count": 0
          }
        ]
      },
      {
        "functionName": "pushTreeFork",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 366573,
            "endOffset": 366870,
            "count": 0
          }
        ]
      },
      {
        "functionName": "pushTreeId",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 366879,
            "endOffset": 368487,
            "count": 0
          }
        ]
      },
      {
        "functionName": "pushMaterializedTreeId",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 368496,
            "endOffset": 368881,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getBitLength",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 368890,
            "endOffset": 368968,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getLeadingBit",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 368977,
            "endOffset": 369059,
            "count": 0
          }
        ]
      },
      {
        "functionName": "popTreeContext",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 369068,
            "endOffset": 369767,
            "count": 95
          },
          {
            "startOffset": 369166,
            "endOffset": 369388,
            "count": 0
          },
          {
            "startOffset": 369447,
            "endOffset": 369757,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getSuspendedTreeContext",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 369776,
            "endOffset": 370069,
            "count": 0
          }
        ]
      },
      {
        "functionName": "restoreSuspendedTreeContext",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 370078,
            "endOffset": 370513,
            "count": 0
          }
        ]
      },
      {
        "functionName": "warnIfNotHydrating",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 370522,
            "endOffset": 370734,
            "count": 0
          }
        ]
      },
      {
        "functionName": "warnIfHydrating",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 370938,
            "endOffset": 371145,
            "count": 0
          }
        ]
      },
      {
        "functionName": "markDidThrowWhileHydratingDEV",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 371154,
            "endOffset": 371271,
            "count": 0
          }
        ]
      },
      {
        "functionName": "didSuspendOrErrorWhileHydratingDEV",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 371280,
            "endOffset": 371402,
            "count": 0
          }
        ]
      },
      {
        "functionName": "enterHydrationState",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 371411,
            "endOffset": 371778,
            "count": 0
          }
        ]
      },
      {
        "functionName": "reenterHydrationStateFromDehydratedSuspenseInstance",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 371787,
            "endOffset": 372275,
            "count": 0
          }
        ]
      },
      {
        "functionName": "warnUnhydratedInstance",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 372284,
            "endOffset": 373383,
            "count": 0
          }
        ]
      },
      {
        "functionName": "deleteHydratableInstance",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 373392,
            "endOffset": 373941,
            "count": 0
          }
        ]
      },
      {
        "functionName": "warnNonhydratedInstance",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 373950,
            "endOffset": 377179,
            "count": 0
          }
        ]
      },
      {
        "functionName": "insertNonHydratedInstance",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 377188,
            "endOffset": 377371,
            "count": 0
          }
        ]
      },
      {
        "functionName": "tryHydrate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 377380,
            "endOffset": 379222,
            "count": 0
          }
        ]
      },
      {
        "functionName": "shouldClientRenderOnMismatch",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 379231,
            "endOffset": 379388,
            "count": 0
          }
        ]
      },
      {
        "functionName": "throwOnHydrationMismatch",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 379397,
            "endOffset": 379567,
            "count": 0
          }
        ]
      },
      {
        "functionName": "tryToClaimNextHydratableInstance",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 379576,
            "endOffset": 380914,
            "count": 41
          },
          {
            "startOffset": 379688,
            "endOffset": 380904,
            "count": 0
          }
        ]
      },
      {
        "functionName": "prepareToHydrateHostInstance",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 380923,
            "endOffset": 381424,
            "count": 0
          }
        ]
      },
      {
        "functionName": "prepareToHydrateHostTextInstance",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 381433,
            "endOffset": 383173,
            "count": 0
          }
        ]
      },
      {
        "functionName": "prepareToHydrateHostSuspenseInstance",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 383182,
            "endOffset": 383643,
            "count": 0
          }
        ]
      },
      {
        "functionName": "skipPastDehydratedSuspenseInstance",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 383652,
            "endOffset": 384134,
            "count": 0
          }
        ]
      },
      {
        "functionName": "popToNextHostParent",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 384143,
            "endOffset": 384447,
            "count": 0
          }
        ]
      },
      {
        "functionName": "popHydrationState",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 384456,
            "endOffset": 385738,
            "count": 42
          },
          {
            "startOffset": 384577,
            "endOffset": 384896,
            "count": 0
          },
          {
            "startOffset": 384898,
            "endOffset": 385737,
            "count": 0
          }
        ]
      },
      {
        "functionName": "hasUnhydratedTailNodes",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 385747,
            "endOffset": 385857,
            "count": 0
          }
        ]
      },
      {
        "functionName": "warnIfUnhydratedTailNodes",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 385866,
            "endOffset": 386141,
            "count": 0
          }
        ]
      },
      {
        "functionName": "resetHydrationState",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 386150,
            "endOffset": 386343,
            "count": 2
          }
        ]
      },
      {
        "functionName": "upgradeHydrationErrorsToRecoverable",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 386352,
            "endOffset": 386553,
            "count": 1
          },
          {
            "startOffset": 386441,
            "endOffset": 386543,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getIsHydrating",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 386562,
            "endOffset": 386629,
            "count": 64
          }
        ]
      },
      {
        "functionName": "queueHydrationError",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 386638,
            "endOffset": 386841,
            "count": 0
          }
        ]
      },
      {
        "functionName": "requestCurrentTransition",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 386969,
            "endOffset": 387071,
            "count": 2
          }
        ]
      },
      {
        "functionName": "recordUnsafeLifecycleWarnings",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 387153,
            "endOffset": 387192,
            "count": 0
          }
        ]
      },
      {
        "functionName": "flushPendingUnsafeLifecycleWarnings",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 387241,
            "endOffset": 387265,
            "count": 0
          }
        ]
      },
      {
        "functionName": "recordLegacyContextWarning",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 387305,
            "endOffset": 387344,
            "count": 0
          }
        ]
      },
      {
        "functionName": "flushLegacyContextWarning",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 387383,
            "endOffset": 387407,
            "count": 0
          }
        ]
      },
      {
        "functionName": "discardPendingWarnings",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 387443,
            "endOffset": 387467,
            "count": 0
          }
        ]
      },
      {
        "functionName": "findStrictRoot",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 387520,
            "endOffset": 387845,
            "count": 6
          },
          {
            "startOffset": 387642,
            "endOffset": 387797,
            "count": 37
          },
          {
            "startOffset": 387692,
            "endOffset": 387749,
            "count": 31
          }
        ]
      },
      {
        "functionName": "setToSortedString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 387881,
            "endOffset": 388073,
            "count": 0
          }
        ]
      },
      {
        "functionName": "ReactStrictModeWarnings.recordUnsafeLifecycleWarnings",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 388574,
            "endOffset": 390044,
            "count": 0
          }
        ]
      },
      {
        "functionName": "ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 390118,
            "endOffset": 397322,
            "count": 2
          },
          {
            "startOffset": 390268,
            "endOffset": 390591,
            "count": 0
          },
          {
            "startOffset": 390743,
            "endOffset": 391087,
            "count": 0
          },
          {
            "startOffset": 391239,
            "endOffset": 391583,
            "count": 0
          },
          {
            "startOffset": 391749,
            "endOffset": 392114,
            "count": 0
          },
          {
            "startOffset": 392254,
            "endOffset": 392580,
            "count": 0
          },
          {
            "startOffset": 392734,
            "endOffset": 393081,
            "count": 0
          },
          {
            "startOffset": 393145,
            "endOffset": 393601,
            "count": 0
          },
          {
            "startOffset": 393672,
            "endOffset": 394316,
            "count": 0
          },
          {
            "startOffset": 394381,
            "endOffset": 394814,
            "count": 0
          },
          {
            "startOffset": 394871,
            "endOffset": 395585,
            "count": 0
          },
          {
            "startOffset": 395649,
            "endOffset": 396563,
            "count": 0
          },
          {
            "startOffset": 396621,
            "endOffset": 397310,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 390326,
            "endOffset": 390521,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 390808,
            "endOffset": 391010,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 391304,
            "endOffset": 391506,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 391821,
            "endOffset": 392030,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 392313,
            "endOffset": 392509,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 392800,
            "endOffset": 393003,
            "count": 0
          }
        ]
      },
      {
        "functionName": "ReactStrictModeWarnings.recordLegacyContextWarning",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 397527,
            "endOffset": 398424,
            "count": 6
          },
          {
            "startOffset": 397644,
            "endOffset": 397837,
            "count": 0
          },
          {
            "startOffset": 397897,
            "endOffset": 397934,
            "count": 0
          },
          {
            "startOffset": 398123,
            "endOffset": 398172,
            "count": 0
          },
          {
            "startOffset": 398174,
            "endOffset": 398412,
            "count": 0
          }
        ]
      },
      {
        "functionName": "ReactStrictModeWarnings.flushLegacyContextWarning",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 398488,
            "endOffset": 399563,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 398549,
            "endOffset": 399549,
            "count": 0
          }
        ]
      },
      {
        "functionName": "ReactStrictModeWarnings.discardPendingWarnings",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 399624,
            "endOffset": 400066,
            "count": 2
          }
        ]
      },
      {
        "functionName": "resolveDefaultProps",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 400086,
            "endOffset": 400554,
            "count": 0
          }
        ]
      },
      {
        "functionName": "resetContextDependencies",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 400867,
            "endOffset": 401113,
            "count": 2
          }
        ]
      },
      {
        "functionName": "enterDisallowedContextReadInDEV",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 401122,
            "endOffset": 401249,
            "count": 0
          }
        ]
      },
      {
        "functionName": "exitDisallowedContextReadInDEV",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 401258,
            "endOffset": 401385,
            "count": 0
          }
        ]
      },
      {
        "functionName": "pushProvider",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 401394,
            "endOffset": 401977,
            "count": 2
          },
          {
            "startOffset": 401686,
            "endOffset": 401731,
            "count": 1
          },
          {
            "startOffset": 401733,
            "endOffset": 401885,
            "count": 0
          }
        ]
      },
      {
        "functionName": "popProvider",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 401986,
            "endOffset": 402239,
            "count": 2
          }
        ]
      },
      {
        "functionName": "scheduleContextWorkOnParentPath",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 402248,
            "endOffset": 403297,
            "count": 0
          }
        ]
      },
      {
        "functionName": "propagateContextChange",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 403306,
            "endOffset": 403495,
            "count": 0
          }
        ]
      },
      {
        "functionName": "propagateContextChange_eager",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 403504,
            "endOffset": 407001,
            "count": 0
          }
        ]
      },
      {
        "functionName": "prepareToReadContext",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 407010,
            "endOffset": 407671,
            "count": 7
          },
          {
            "startOffset": 407305,
            "endOffset": 407661,
            "count": 0
          }
        ]
      },
      {
        "functionName": "readContext",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 407680,
            "endOffset": 409100,
            "count": 4
          },
          {
            "startOffset": 407770,
            "endOffset": 408062,
            "count": 0
          },
          {
            "startOffset": 408184,
            "endOffset": 408185,
            "count": 0
          },
          {
            "startOffset": 408382,
            "endOffset": 408953,
            "count": 2
          },
          {
            "startOffset": 408436,
            "endOffset": 408742,
            "count": 0
          },
          {
            "startOffset": 408953,
            "endOffset": 409054,
            "count": 2
          }
        ]
      },
      {
        "functionName": "pushConcurrentUpdateQueue",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 409146,
            "endOffset": 409355,
            "count": 2
          },
          {
            "startOffset": 409284,
            "endOffset": 409345,
            "count": 0
          }
        ]
      },
      {
        "functionName": "finishQueueingConcurrentUpdates",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 409364,
            "endOffset": 410258,
            "count": 2
          },
          {
            "startOffset": 409894,
            "endOffset": 410114,
            "count": 0
          }
        ]
      },
      {
        "functionName": "enqueueConcurrentHookUpdate",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 410267,
            "endOffset": 410721,
            "count": 1
          },
          {
            "startOffset": 410510,
            "endOffset": 410612,
            "count": 0
          }
        ]
      },
      {
        "functionName": "enqueueConcurrentHookUpdateAndEagerlyBailout",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 410730,
            "endOffset": 411140,
            "count": 0
          }
        ]
      },
      {
        "functionName": "enqueueConcurrentClassUpdate",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 411149,
            "endOffset": 411604,
            "count": 1
          },
          {
            "startOffset": 411393,
            "endOffset": 411495,
            "count": 0
          }
        ]
      },
      {
        "functionName": "enqueueConcurrentRenderForLane",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 411613,
            "endOffset": 411738,
            "count": 0
          }
        ]
      },
      {
        "functionName": "markUpdateLaneFromFiberToRoot",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 411829,
            "endOffset": 413142,
            "count": 2
          },
          {
            "startOffset": 412039,
            "endOffset": 412117,
            "count": 0
          },
          {
            "startOffset": 412227,
            "endOffset": 412311,
            "count": 0
          },
          {
            "startOffset": 412435,
            "endOffset": 412971,
            "count": 10
          },
          {
            "startOffset": 412584,
            "endOffset": 412676,
            "count": 1
          },
          {
            "startOffset": 412676,
            "endOffset": 412896,
            "count": 9
          },
          {
            "startOffset": 412774,
            "endOffset": 412866,
            "count": 0
          },
          {
            "startOffset": 413088,
            "endOffset": 413132,
            "count": 0
          }
        ]
      },
      {
        "functionName": "initializeUpdateQueue",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 413491,
            "endOffset": 413881,
            "count": 1
          }
        ]
      },
      {
        "functionName": "cloneUpdateQueue",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 413890,
            "endOffset": 414454,
            "count": 1
          }
        ]
      },
      {
        "functionName": "createUpdate",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 414463,
            "endOffset": 414725,
            "count": 1
          }
        ]
      },
      {
        "functionName": "enqueueUpdate",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 414734,
            "endOffset": 415871,
            "count": 1
          },
          {
            "startOffset": 414863,
            "endOffset": 414901,
            "count": 0
          },
          {
            "startOffset": 415019,
            "endOffset": 415048,
            "count": 0
          },
          {
            "startOffset": 415050,
            "endOffset": 415340,
            "count": 0
          },
          {
            "startOffset": 415401,
            "endOffset": 415759,
            "count": 0
          }
        ]
      },
      {
        "functionName": "entangleTransitions",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 415880,
            "endOffset": 416440,
            "count": 1
          },
          {
            "startOffset": 416014,
            "endOffset": 416047,
            "count": 0
          },
          {
            "startOffset": 416134,
            "endOffset": 416430,
            "count": 0
          }
        ]
      },
      {
        "functionName": "enqueueCapturedUpdate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 416449,
            "endOffset": 418563,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getStateFromUpdate",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 418572,
            "endOffset": 420855,
            "count": 1
          },
          {
            "startOffset": 418710,
            "endOffset": 419518,
            "count": 0
          },
          {
            "startOffset": 419531,
            "endOffset": 419657,
            "count": 0
          },
          {
            "startOffset": 419817,
            "endOffset": 420434,
            "count": 0
          },
          {
            "startOffset": 420567,
            "endOffset": 420618,
            "count": 0
          },
          {
            "startOffset": 420703,
            "endOffset": 420805,
            "count": 0
          },
          {
            "startOffset": 420817,
            "endOffset": 420854,
            "count": 0
          }
        ]
      },
      {
        "functionName": "processUpdateQueue",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 420864,
            "endOffset": 426337,
            "count": 1
          },
          {
            "startOffset": 421605,
            "endOffset": 421682,
            "count": 0
          },
          {
            "startOffset": 422150,
            "endOffset": 422242,
            "count": 0
          },
          {
            "startOffset": 422813,
            "endOffset": 423446,
            "count": 0
          },
          {
            "startOffset": 423502,
            "endOffset": 424132,
            "count": 0
          },
          {
            "startOffset": 424325,
            "endOffset": 424465,
            "count": 0
          },
          {
            "startOffset": 424467,
            "endOffset": 424763,
            "count": 0
          },
          {
            "startOffset": 424993,
            "endOffset": 425350,
            "count": 0
          },
          {
            "startOffset": 425750,
            "endOffset": 426005,
            "count": 0
          },
          {
            "startOffset": 426041,
            "endOffset": 426100,
            "count": 0
          }
        ]
      },
      {
        "functionName": "callCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 426346,
            "endOffset": 426619,
            "count": 0
          }
        ]
      },
      {
        "functionName": "resetHasForceUpdateBeforeProcessing",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 426628,
            "endOffset": 426720,
            "count": 0
          }
        ]
      },
      {
        "functionName": "checkHasForceUpdateAfterProcessing",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 426729,
            "endOffset": 426819,
            "count": 0
          }
        ]
      },
      {
        "functionName": "commitUpdateQueue",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 426828,
            "endOffset": 427337,
            "count": 0
          }
        ]
      },
      {
        "functionName": "warnOnInvalidCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 428671,
            "endOffset": 429132,
            "count": 0
          }
        ]
      },
      {
        "functionName": "warnOnUndefinedDerivedState",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 429174,
            "endOffset": 429665,
            "count": 0
          }
        ]
      },
      {
        "functionName": "value",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 429797,
            "endOffset": 430190,
            "count": 0
          }
        ]
      },
      {
        "functionName": "applyDerivedStateFromProps",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 430270,
            "endOffset": 431269,
            "count": 0
          }
        ]
      },
      {
        "functionName": "enqueueSetState",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 431356,
            "endOffset": 432150,
            "count": 0
          }
        ]
      },
      {
        "functionName": "enqueueReplaceState",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 432183,
            "endOffset": 433020,
            "count": 0
          }
        ]
      },
      {
        "functionName": "enqueueForceUpdate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 433052,
            "endOffset": 433840,
            "count": 0
          }
        ]
      },
      {
        "functionName": "checkShouldComponentUpdate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 433860,
            "endOffset": 435061,
            "count": 0
          }
        ]
      },
      {
        "functionName": "checkClassInstance",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 435070,
            "endOffset": 441406,
            "count": 0
          }
        ]
      },
      {
        "functionName": "adoptClassInstance",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 441415,
            "endOffset": 441715,
            "count": 0
          }
        ]
      },
      {
        "functionName": "constructClassInstance",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 441724,
            "endOffset": 448105,
            "count": 0
          }
        ]
      },
      {
        "functionName": "callComponentWillMount",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 448114,
            "endOffset": 448875,
            "count": 0
          }
        ]
      },
      {
        "functionName": "callComponentWillReceiveProps",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 448884,
            "endOffset": 449976,
            "count": 0
          }
        ]
      },
      {
        "functionName": "mountClassInstance",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 449985,
            "endOffset": 452802,
            "count": 0
          }
        ]
      },
      {
        "functionName": "resumeMountClassInstance",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 452811,
            "endOffset": 456881,
            "count": 0
          }
        ]
      },
      {
        "functionName": "updateClassInstance",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 456890,
            "endOffset": 461857,
            "count": 0
          }
        ]
      },
      {
        "functionName": "warnForMissingKey",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 462068,
            "endOffset": 462108,
            "count": 0
          }
        ]
      },
      {
        "functionName": "warnForMissingKey",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 462349,
            "endOffset": 463253,
            "count": 41
          },
          {
            "startOffset": 462441,
            "endOffset": 462478,
            "count": 0
          },
          {
            "startOffset": 462535,
            "endOffset": 462555,
            "count": 24
          },
          {
            "startOffset": 462594,
            "endOffset": 462951,
            "count": 0
          },
          {
            "startOffset": 463007,
            "endOffset": 463252,
            "count": 0
          }
        ]
      },
      {
        "functionName": "coerceRef",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 463273,
            "endOffset": 466821,
            "count": 75
          },
          {
            "startOffset": 463396,
            "endOffset": 463429,
            "count": 10
          },
          {
            "startOffset": 463430,
            "endOffset": 463461,
            "count": 10
          },
          {
            "startOffset": 463463,
            "endOffset": 466784,
            "count": 0
          }
        ]
      },
      {
        "functionName": "ref",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 465626,
            "endOffset": 465986,
            "count": 0
          }
        ]
      },
      {
        "functionName": "throwOnInvalidObjectType",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 466830,
            "endOffset": 467240,
            "count": 0
          }
        ]
      },
      {
        "functionName": "warnOnFunctionType",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 467249,
            "endOffset": 467781,
            "count": 0
          }
        ]
      },
      {
        "functionName": "resolveLazy",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 467790,
            "endOffset": 467944,
            "count": 0
          }
        ]
      },
      {
        "functionName": "ChildReconciler",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 467953,
            "endOffset": 496921,
            "count": 2
          }
        ]
      },
      {
        "functionName": "deleteChild",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 468014,
            "endOffset": 468429,
            "count": 0
          }
        ]
      },
      {
        "functionName": "deleteRemainingChildren",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 468440,
            "endOffset": 468845,
            "count": 50
          },
          {
            "startOffset": 468548,
            "endOffset": 468590,
            "count": 23
          },
          {
            "startOffset": 468590,
            "endOffset": 468685,
            "count": 27
          },
          {
            "startOffset": 468685,
            "endOffset": 468808,
            "count": 0
          },
          {
            "startOffset": 468808,
            "endOffset": 468844,
            "count": 27
          }
        ]
      },
      {
        "functionName": "mapRemainingChildren",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 468856,
            "endOffset": 469426,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useFiber",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 469437,
            "endOffset": 469645,
            "count": 26
          }
        ]
      },
      {
        "functionName": "placeChild",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 469656,
            "endOffset": 470350,
            "count": 41
          },
          {
            "startOffset": 469795,
            "endOffset": 469888,
            "count": 29
          },
          {
            "startOffset": 469888,
            "endOffset": 470236,
            "count": 12
          },
          {
            "startOffset": 470064,
            "endOffset": 470166,
            "count": 0
          },
          {
            "startOffset": 470236,
            "endOffset": 470338,
            "count": 0
          }
        ]
      },
      {
        "functionName": "placeSingleChild",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 470361,
            "endOffset": 470569,
            "count": 34
          },
          {
            "startOffset": 470438,
            "endOffset": 470468,
            "count": 15
          },
          {
            "startOffset": 470470,
            "endOffset": 470528,
            "count": 1
          }
        ]
      },
      {
        "functionName": "updateTextNode",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 470580,
            "endOffset": 471060,
            "count": 0
          }
        ]
      },
      {
        "functionName": "updateElement",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 471071,
            "endOffset": 472663,
            "count": 12
          },
          {
            "startOffset": 471232,
            "endOffset": 471352,
            "count": 0
          },
          {
            "startOffset": 471445,
            "endOffset": 471575,
            "count": 0
          },
          {
            "startOffset": 471576,
            "endOffset": 472023,
            "count": 0
          },
          {
            "startOffset": 472428,
            "endOffset": 472662,
            "count": 0
          }
        ]
      },
      {
        "functionName": "updatePortal",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 472674,
            "endOffset": 473280,
            "count": 0
          }
        ]
      },
      {
        "functionName": "updateFragment2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 473291,
            "endOffset": 473777,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createChild",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 473788,
            "endOffset": 475540,
            "count": 29
          },
          {
            "startOffset": 473886,
            "endOffset": 473904,
            "count": 0
          },
          {
            "startOffset": 473938,
            "endOffset": 474116,
            "count": 0
          },
          {
            "startOffset": 474555,
            "endOffset": 474776,
            "count": 0
          },
          {
            "startOffset": 474793,
            "endOffset": 475003,
            "count": 0
          },
          {
            "startOffset": 475019,
            "endOffset": 475082,
            "count": 0
          },
          {
            "startOffset": 475084,
            "endOffset": 475489,
            "count": 0
          },
          {
            "startOffset": 475503,
            "endOffset": 475539,
            "count": 0
          }
        ]
      },
      {
        "functionName": "updateSlot",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 475551,
            "endOffset": 477361,
            "count": 12
          },
          {
            "startOffset": 475668,
            "endOffset": 475674,
            "count": 0
          },
          {
            "startOffset": 475721,
            "endOffset": 475739,
            "count": 0
          },
          {
            "startOffset": 475773,
            "endOffset": 475949,
            "count": 0
          },
          {
            "startOffset": 476252,
            "endOffset": 476312,
            "count": 0
          },
          {
            "startOffset": 476347,
            "endOffset": 476597,
            "count": 0
          },
          {
            "startOffset": 476614,
            "endOffset": 476833,
            "count": 0
          },
          {
            "startOffset": 476849,
            "endOffset": 476912,
            "count": 0
          },
          {
            "startOffset": 476914,
            "endOffset": 477310,
            "count": 0
          },
          {
            "startOffset": 477324,
            "endOffset": 477360,
            "count": 0
          }
        ]
      },
      {
        "functionName": "updateFromMap",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 477372,
            "endOffset": 479115,
            "count": 0
          }
        ]
      },
      {
        "functionName": "warnOnInvalidKey",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 479126,
            "endOffset": 480572,
            "count": 41
          },
          {
            "startOffset": 479262,
            "endOffset": 479313,
            "count": 0
          },
          {
            "startOffset": 479578,
            "endOffset": 479626,
            "count": 17
          },
          {
            "startOffset": 479626,
            "endOffset": 479669,
            "count": 24
          },
          {
            "startOffset": 479669,
            "endOffset": 479816,
            "count": 2
          },
          {
            "startOffset": 479816,
            "endOffset": 479948,
            "count": 22
          },
          {
            "startOffset": 479948,
            "endOffset": 480272,
            "count": 0
          },
          {
            "startOffset": 480289,
            "endOffset": 480500,
            "count": 0
          }
        ]
      },
      {
        "functionName": "reconcileChildrenArray",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 480583,
            "endOffset": 484716,
            "count": 8
          },
          {
            "startOffset": 480778,
            "endOffset": 480916,
            "count": 41
          },
          {
            "startOffset": 481201,
            "endOffset": 481231,
            "count": 12
          },
          {
            "startOffset": 481243,
            "endOffset": 482280,
            "count": 12
          },
          {
            "startOffset": 481288,
            "endOffset": 481379,
            "count": 0
          },
          {
            "startOffset": 481581,
            "endOffset": 481723,
            "count": 0
          },
          {
            "startOffset": 481829,
            "endOffset": 481902,
            "count": 0
          },
          {
            "startOffset": 482043,
            "endOffset": 482108,
            "count": 1
          },
          {
            "startOffset": 482108,
            "endOffset": 482184,
            "count": 11
          },
          {
            "startOffset": 482328,
            "endOffset": 482603,
            "count": 1
          },
          {
            "startOffset": 482428,
            "endOffset": 482547,
            "count": 0
          },
          {
            "startOffset": 482603,
            "endOffset": 483433,
            "count": 7
          },
          {
            "startOffset": 482701,
            "endOffset": 483219,
            "count": 29
          },
          {
            "startOffset": 482829,
            "endOffset": 482876,
            "count": 0
          },
          {
            "startOffset": 483006,
            "endOffset": 483076,
            "count": 7
          },
          {
            "startOffset": 483076,
            "endOffset": 483157,
            "count": 22
          },
          {
            "startOffset": 483256,
            "endOffset": 483377,
            "count": 0
          },
          {
            "startOffset": 483433,
            "endOffset": 484715,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 484405,
            "endOffset": 484496,
            "count": 0
          }
        ]
      },
      {
        "functionName": "reconcileChildrenIterator",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 484727,
            "endOffset": 490472,
            "count": 0
          }
        ]
      },
      {
        "functionName": "reconcileSingleTextNode",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 490483,
            "endOffset": 491129,
            "count": 0
          }
        ]
      },
      {
        "functionName": "reconcileSingleElement",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 491140,
            "endOffset": 493910,
            "count": 34
          },
          {
            "startOffset": 491335,
            "endOffset": 493370,
            "count": 14
          },
          {
            "startOffset": 491481,
            "endOffset": 491973,
            "count": 0
          },
          {
            "startOffset": 492037,
            "endOffset": 492168,
            "count": 0
          },
          {
            "startOffset": 492169,
            "endOffset": 492629,
            "count": 0
          },
          {
            "startOffset": 493147,
            "endOffset": 493370,
            "count": 0
          },
          {
            "startOffset": 493370,
            "endOffset": 493425,
            "count": 20
          },
          {
            "startOffset": 493425,
            "endOffset": 493629,
            "count": 0
          },
          {
            "startOffset": 493629,
            "endOffset": 493898,
            "count": 20
          }
        ]
      },
      {
        "functionName": "reconcileSinglePortal",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 493921,
            "endOffset": 494981,
            "count": 0
          }
        ]
      },
      {
        "functionName": "reconcileChildFibers2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 494992,
            "endOffset": 496871,
            "count": 77
          },
          {
            "startOffset": 495147,
            "endOffset": 495167,
            "count": 74
          },
          {
            "startOffset": 495168,
            "endOffset": 495208,
            "count": 42
          },
          {
            "startOffset": 495209,
            "endOffset": 495233,
            "count": 1
          },
          {
            "startOffset": 495278,
            "endOffset": 495343,
            "count": 1
          },
          {
            "startOffset": 495389,
            "endOffset": 495409,
            "count": 74
          },
          {
            "startOffset": 495411,
            "endOffset": 496407,
            "count": 42
          },
          {
            "startOffset": 495472,
            "endOffset": 495612,
            "count": 34
          },
          {
            "startOffset": 495629,
            "endOffset": 495767,
            "count": 0
          },
          {
            "startOffset": 495784,
            "endOffset": 496003,
            "count": 0
          },
          {
            "startOffset": 496019,
            "endOffset": 496170,
            "count": 8
          },
          {
            "startOffset": 496170,
            "endOffset": 496407,
            "count": 0
          },
          {
            "startOffset": 496407,
            "endOffset": 496453,
            "count": 35
          },
          {
            "startOffset": 496453,
            "endOffset": 496471,
            "count": 0
          },
          {
            "startOffset": 496472,
            "endOffset": 496503,
            "count": 35
          },
          {
            "startOffset": 496505,
            "endOffset": 496638,
            "count": 0
          },
          {
            "startOffset": 496638,
            "endOffset": 496703,
            "count": 35
          },
          {
            "startOffset": 496703,
            "endOffset": 496769,
            "count": 0
          },
          {
            "startOffset": 496783,
            "endOffset": 496870,
            "count": 35
          }
        ]
      },
      {
        "functionName": "cloneChildFibers",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 497043,
            "endOffset": 497872,
            "count": 10
          },
          {
            "startOffset": 497175,
            "endOffset": 497255,
            "count": 0
          },
          {
            "startOffset": 497302,
            "endOffset": 497335,
            "count": 0
          },
          {
            "startOffset": 497613,
            "endOffset": 497827,
            "count": 8
          }
        ]
      },
      {
        "functionName": "resetChildFibers",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 497881,
            "endOffset": 498116,
            "count": 0
          }
        ]
      },
      {
        "functionName": "requiredContext",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 498343,
            "endOffset": 498581,
            "count": 298
          },
          {
            "startOffset": 498405,
            "endOffset": 498551,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getRootHostContainer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 498590,
            "endOffset": 498743,
            "count": 77
          }
        ]
      },
      {
        "functionName": "pushHostContainer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 498752,
            "endOffset": 499169,
            "count": 2
          }
        ]
      },
      {
        "functionName": "popHostContainer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 499178,
            "endOffset": 499360,
            "count": 2
          }
        ]
      },
      {
        "functionName": "getHostContext",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 499369,
            "endOffset": 499503,
            "count": 67
          }
        ]
      },
      {
        "functionName": "pushHostContext",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 499512,
            "endOffset": 499961,
            "count": 77
          },
          {
            "startOffset": 499805,
            "endOffset": 499838,
            "count": 0
          }
        ]
      },
      {
        "functionName": "popHostContext",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 499970,
            "endOffset": 500194,
            "count": 77
          },
          {
            "startOffset": 500060,
            "endOffset": 500093,
            "count": 0
          }
        ]
      },
      {
        "functionName": "hasSuspenseContext",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 500446,
            "endOffset": 500553,
            "count": 0
          }
        ]
      },
      {
        "functionName": "setDefaultShallowSuspenseContext",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 500562,
            "endOffset": 500691,
            "count": 0
          }
        ]
      },
      {
        "functionName": "setShallowSuspenseContext",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 500700,
            "endOffset": 500855,
            "count": 0
          }
        ]
      },
      {
        "functionName": "addSubtreeSuspenseContext",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 500864,
            "endOffset": 500990,
            "count": 0
          }
        ]
      },
      {
        "functionName": "pushSuspenseContext",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 500999,
            "endOffset": 501114,
            "count": 0
          }
        ]
      },
      {
        "functionName": "popSuspenseContext",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 501123,
            "endOffset": 501212,
            "count": 0
          }
        ]
      },
      {
        "functionName": "shouldCaptureSuspense",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 501221,
            "endOffset": 501623,
            "count": 0
          }
        ]
      },
      {
        "functionName": "findFirstSuspended",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 501632,
            "endOffset": 503039,
            "count": 0
          }
        ]
      },
      {
        "functionName": "resetWorkInProgressVersions",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 503418,
            "endOffset": 503743,
            "count": 2
          },
          {
            "startOffset": 503524,
            "endOffset": 503689,
            "count": 0
          }
        ]
      },
      {
        "functionName": "registerMutableSourceForHydration",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 503752,
            "endOffset": 504193,
            "count": 0
          }
        ]
      },
      {
        "functionName": "mountHookTypesDev",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 505087,
            "endOffset": 505360,
            "count": 78
          },
          {
            "startOffset": 505218,
            "endOffset": 505274,
            "count": 12
          },
          {
            "startOffset": 505274,
            "endOffset": 505338,
            "count": 66
          }
        ]
      },
      {
        "functionName": "updateHookTypesDev",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 505369,
            "endOffset": 505718,
            "count": 10
          },
          {
            "startOffset": 505614,
            "endOffset": 505682,
            "count": 0
          }
        ]
      },
      {
        "functionName": "checkDepsAreArrayDev",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 505727,
            "endOffset": 506070,
            "count": 22
          },
          {
            "startOffset": 505845,
            "endOffset": 506048,
            "count": 0
          }
        ]
      },
      {
        "functionName": "warnOnHookMismatchInDev",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 506079,
            "endOffset": 507449,
            "count": 0
          }
        ]
      },
      {
        "functionName": "throwInvalidHookError",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 507458,
            "endOffset": 507964,
            "count": 0
          }
        ]
      },
      {
        "functionName": "areHookInputsEqual",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 507973,
            "endOffset": 509042,
            "count": 4
          },
          {
            "startOffset": 508079,
            "endOffset": 508122,
            "count": 0
          },
          {
            "startOffset": 508168,
            "endOffset": 508450,
            "count": 0
          },
          {
            "startOffset": 508516,
            "endOffset": 508790,
            "count": 0
          },
          {
            "startOffset": 508849,
            "endOffset": 508871,
            "count": 2
          },
          {
            "startOffset": 508878,
            "endOffset": 509009,
            "count": 2
          },
          {
            "startOffset": 508932,
            "endOffset": 508971,
            "count": 0
          },
          {
            "startOffset": 509009,
            "endOffset": 509041,
            "count": 2
          }
        ]
      },
      {
        "functionName": "renderWithHooks",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 509051,
            "endOffset": 512543,
            "count": 14
          },
          {
            "startOffset": 509304,
            "endOffset": 509330,
            "count": 2
          },
          {
            "startOffset": 509331,
            "endOffset": 509337,
            "count": 12
          },
          {
            "startOffset": 509440,
            "endOffset": 509481,
            "count": 2
          },
          {
            "startOffset": 509678,
            "endOffset": 509712,
            "count": 2
          },
          {
            "startOffset": 509714,
            "endOffset": 509808,
            "count": 2
          },
          {
            "startOffset": 509808,
            "endOffset": 510046,
            "count": 12
          },
          {
            "startOffset": 509841,
            "endOffset": 509947,
            "count": 0
          },
          {
            "startOffset": 510171,
            "endOffset": 511061,
            "count": 0
          },
          {
            "startOffset": 511272,
            "endOffset": 511300,
            "count": 2
          },
          {
            "startOffset": 511608,
            "endOffset": 511681,
            "count": 2
          },
          {
            "startOffset": 511682,
            "endOffset": 512141,
            "count": 0
          },
          {
            "startOffset": 512143,
            "endOffset": 512268,
            "count": 0
          },
          {
            "startOffset": 512365,
            "endOffset": 512506,
            "count": 0
          }
        ]
      },
      {
        "functionName": "checkDidRenderIdHook",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 512552,
            "endOffset": 512713,
            "count": 14
          }
        ]
      },
      {
        "functionName": "bailoutHooks",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 512722,
            "endOffset": 513167,
            "count": 0
          }
        ]
      },
      {
        "functionName": "resetHooksAfterThrow",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 513176,
            "endOffset": 514101,
            "count": 0
          }
        ]
      },
      {
        "functionName": "mountWorkInProgressHook",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 514110,
            "endOffset": 514590,
            "count": 74
          },
          {
            "startOffset": 514365,
            "endOffset": 514459,
            "count": 12
          },
          {
            "startOffset": 514459,
            "endOffset": 514543,
            "count": 62
          }
        ]
      },
      {
        "functionName": "updateWorkInProgressHook",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 514599,
            "endOffset": 516243,
            "count": 10
          },
          {
            "startOffset": 514704,
            "endOffset": 514947,
            "count": 2
          },
          {
            "startOffset": 514876,
            "endOffset": 514935,
            "count": 0
          },
          {
            "startOffset": 514947,
            "endOffset": 515014,
            "count": 8
          },
          {
            "startOffset": 515096,
            "endOffset": 515187,
            "count": 2
          },
          {
            "startOffset": 515187,
            "endOffset": 515268,
            "count": 8
          },
          {
            "startOffset": 515316,
            "endOffset": 515491,
            "count": 0
          },
          {
            "startOffset": 515541,
            "endOffset": 515643,
            "count": 0
          },
          {
            "startOffset": 515992,
            "endOffset": 516093,
            "count": 2
          },
          {
            "startOffset": 516093,
            "endOffset": 516184,
            "count": 8
          }
        ]
      },
      {
        "functionName": "createFunctionComponentUpdateQueue",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 516252,
            "endOffset": 516396,
            "count": 12
          }
        ]
      },
      {
        "functionName": "basicStateReducer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 516405,
            "endOffset": 516530,
            "count": 1
          },
          {
            "startOffset": 516511,
            "endOffset": 516519,
            "count": 0
          }
        ]
      },
      {
        "functionName": "mountReducer",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 516539,
            "endOffset": 517311,
            "count": 0
          }
        ]
      },
      {
        "functionName": "updateReducer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 517320,
            "endOffset": 521638,
            "count": 2
          },
          {
            "startOffset": 517485,
            "endOffset": 517604,
            "count": 0
          },
          {
            "startOffset": 517817,
            "endOffset": 518374,
            "count": 1
          },
          {
            "startOffset": 517855,
            "endOffset": 518058,
            "count": 0
          },
          {
            "startOffset": 518125,
            "endOffset": 518255,
            "count": 0
          },
          {
            "startOffset": 518772,
            "endOffset": 519474,
            "count": 0
          },
          {
            "startOffset": 519529,
            "endOffset": 520131,
            "count": 0
          },
          {
            "startOffset": 520241,
            "endOffset": 520368,
            "count": 0
          },
          {
            "startOffset": 520577,
            "endOffset": 520655,
            "count": 0
          },
          {
            "startOffset": 521063,
            "endOffset": 521460,
            "count": 0
          },
          {
            "startOffset": 521490,
            "endOffset": 521538,
            "count": 0
          }
        ]
      },
      {
        "functionName": "rerenderReducer",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 521647,
            "endOffset": 522896,
            "count": 0
          }
        ]
      },
      {
        "functionName": "mountMutableSource",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 522905,
            "endOffset": 523027,
            "count": 0
          }
        ]
      },
      {
        "functionName": "updateMutableSource",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 523036,
            "endOffset": 523159,
            "count": 0
          }
        ]
      },
      {
        "functionName": "mountSyncExternalStore",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 523168,
            "endOffset": 525296,
            "count": 0
          }
        ]
      },
      {
        "functionName": "updateSyncExternalStore",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 525305,
            "endOffset": 527153,
            "count": 0
          }
        ]
      },
      {
        "functionName": "pushStoreConsistencyCheck",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 527162,
            "endOffset": 527950,
            "count": 0
          }
        ]
      },
      {
        "functionName": "updateStoreInstance",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 527959,
            "endOffset": 528215,
            "count": 0
          }
        ]
      },
      {
        "functionName": "subscribeToStore",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 528224,
            "endOffset": 528495,
            "count": 0
          }
        ]
      },
      {
        "functionName": "checkIfSnapshotChanged",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 528504,
            "endOffset": 528826,
            "count": 0
          }
        ]
      },
      {
        "functionName": "forceStoreRerender",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 528835,
            "endOffset": 529068,
            "count": 0
          }
        ]
      },
      {
        "functionName": "mountState",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 529077,
            "endOffset": 529770,
            "count": 12
          },
          {
            "startOffset": 529211,
            "endOffset": 529267,
            "count": 0
          }
        ]
      },
      {
        "functionName": "updateState",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 529779,
            "endOffset": 529876,
            "count": 2
          }
        ]
      },
      {
        "functionName": "rerenderState",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 529885,
            "endOffset": 529986,
            "count": 0
          }
        ]
      },
      {
        "functionName": "pushEffect",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 529995,
            "endOffset": 531001,
            "count": 22
          },
          {
            "startOffset": 530327,
            "endOffset": 530555,
            "count": 12
          },
          {
            "startOffset": 530555,
            "endOffset": 530966,
            "count": 10
          },
          {
            "startOffset": 530662,
            "endOffset": 530747,
            "count": 0
          }
        ]
      },
      {
        "functionName": "mountRef",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 531010,
            "endOffset": 531268,
            "count": 40
          }
        ]
      },
      {
        "functionName": "updateRef",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 531277,
            "endOffset": 531407,
            "count": 4
          }
        ]
      },
      {
        "functionName": "mountEffectImpl",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 531416,
            "endOffset": 531742,
            "count": 18
          },
          {
            "startOffset": 531569,
            "endOffset": 531575,
            "count": 0
          }
        ]
      },
      {
        "functionName": "updateEffectImpl",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 531751,
            "endOffset": 532544,
            "count": 4
          },
          {
            "startOffset": 531906,
            "endOffset": 531912,
            "count": 0
          },
          {
            "startOffset": 532230,
            "endOffset": 532358,
            "count": 2
          },
          {
            "startOffset": 532384,
            "endOffset": 532543,
            "count": 2
          }
        ]
      },
      {
        "functionName": "mountEffect",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 532553,
            "endOffset": 532901,
            "count": 14
          },
          {
            "startOffset": 532786,
            "endOffset": 532891,
            "count": 0
          }
        ]
      },
      {
        "functionName": "updateEffect",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 532910,
            "endOffset": 533026,
            "count": 4
          }
        ]
      },
      {
        "functionName": "mountInsertionEffect",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 533035,
            "endOffset": 533157,
            "count": 0
          }
        ]
      },
      {
        "functionName": "updateInsertionEffect",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 533166,
            "endOffset": 533290,
            "count": 0
          }
        ]
      },
      {
        "functionName": "mountLayoutEffect",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 533299,
            "endOffset": 533653,
            "count": 4
          }
        ]
      },
      {
        "functionName": "updateLayoutEffect",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 533662,
            "endOffset": 533780,
            "count": 0
          }
        ]
      },
      {
        "functionName": "imperativeHandleEffect",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 533789,
            "endOffset": 534651,
            "count": 0
          }
        ]
      },
      {
        "functionName": "mountImperativeHandle",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 534660,
            "endOffset": 535419,
            "count": 0
          }
        ]
      },
      {
        "functionName": "updateImperativeHandle",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 535428,
            "endOffset": 535951,
            "count": 0
          }
        ]
      },
      {
        "functionName": "mountDebugValue",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 535960,
            "endOffset": 536016,
            "count": 0
          }
        ]
      },
      {
        "functionName": "mountCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 536073,
            "endOffset": 536307,
            "count": 4
          },
          {
            "startOffset": 536203,
            "endOffset": 536209,
            "count": 0
          }
        ]
      },
      {
        "functionName": "updateCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 536316,
            "endOffset": 536853,
            "count": 0
          }
        ]
      },
      {
        "functionName": "mountMemo",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 536862,
            "endOffset": 537136,
            "count": 0
          }
        ]
      },
      {
        "functionName": "updateMemo",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 537145,
            "endOffset": 537722,
            "count": 0
          }
        ]
      },
      {
        "functionName": "mountDeferredValue",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 537731,
            "endOffset": 537887,
            "count": 0
          }
        ]
      },
      {
        "functionName": "updateDeferredValue",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 537896,
            "endOffset": 538168,
            "count": 0
          }
        ]
      },
      {
        "functionName": "rerenderDeferredValue",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 538177,
            "endOffset": 538533,
            "count": 0
          }
        ]
      },
      {
        "functionName": "updateDeferredValueImpl",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 538542,
            "endOffset": 539299,
            "count": 0
          }
        ]
      },
      {
        "functionName": "startTransition",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 539308,
            "endOffset": 540655,
            "count": 0
          }
        ]
      },
      {
        "functionName": "mountTransition",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 540664,
            "endOffset": 540991,
            "count": 0
          }
        ]
      },
      {
        "functionName": "updateTransition",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 541000,
            "endOffset": 541240,
            "count": 0
          }
        ]
      },
      {
        "functionName": "rerenderTransition",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 541249,
            "endOffset": 541497,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getIsUpdatingOpaqueValueInRenderPhaseInDEV",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 541562,
            "endOffset": 541706,
            "count": 0
          }
        ]
      },
      {
        "functionName": "mountId",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 541715,
            "endOffset": 542431,
            "count": 0
          }
        ]
      },
      {
        "functionName": "updateId",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 542440,
            "endOffset": 542580,
            "count": 0
          }
        ]
      },
      {
        "functionName": "dispatchReducerAction",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 542589,
            "endOffset": 543653,
            "count": 0
          }
        ]
      },
      {
        "functionName": "dispatchSetState",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 543662,
            "endOffset": 545901,
            "count": 1
          },
          {
            "startOffset": 543776,
            "endOffset": 544009,
            "count": 0
          },
          {
            "startOffset": 544274,
            "endOffset": 544340,
            "count": 0
          },
          {
            "startOffset": 544456,
            "endOffset": 544486,
            "count": 0
          },
          {
            "startOffset": 545162,
            "endOffset": 545305,
            "count": 0
          },
          {
            "startOffset": 545324,
            "endOffset": 545358,
            "count": 0
          }
        ]
      },
      {
        "functionName": "isRenderPhaseUpdate",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 545910,
            "endOffset": 546119,
            "count": 1
          },
          {
            "startOffset": 546066,
            "endOffset": 546108,
            "count": 0
          }
        ]
      },
      {
        "functionName": "enqueueRenderPhaseUpdate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 546128,
            "endOffset": 546527,
            "count": 0
          }
        ]
      },
      {
        "functionName": "entangleTransitionUpdate",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 546536,
            "endOffset": 546924,
            "count": 1
          },
          {
            "startOffset": 546630,
            "endOffset": 546914,
            "count": 0
          }
        ]
      },
      {
        "functionName": "markUpdateInDevTools",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 546933,
            "endOffset": 547070,
            "count": 1
          }
        ]
      },
      {
        "functionName": "warnInvalidContextAccess",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 548402,
            "endOffset": 548701,
            "count": 0
          }
        ]
      },
      {
        "functionName": "warnInvalidHookAccess",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 548741,
            "endOffset": 548998,
            "count": 0
          }
        ]
      },
      {
        "functionName": "readContext",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 549067,
            "endOffset": 549143,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 549170,
            "endOffset": 549391,
            "count": 4
          }
        ]
      },
      {
        "functionName": "useContext",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 549417,
            "endOffset": 549579,
            "count": 4
          }
        ]
      },
      {
        "functionName": "useEffect",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 549604,
            "endOffset": 549817,
            "count": 14
          }
        ]
      },
      {
        "functionName": "useImperativeHandle",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 549852,
            "endOffset": 550095,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useInsertionEffect",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 550129,
            "endOffset": 550360,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useLayoutEffect",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 550391,
            "endOffset": 550616,
            "count": 4
          }
        ]
      },
      {
        "functionName": "useMemo",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 550639,
            "endOffset": 551139,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useReducer",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 551165,
            "endOffset": 551655,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useRef",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 551677,
            "endOffset": 551842,
            "count": 40
          }
        ]
      },
      {
        "functionName": "useState",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 551866,
            "endOffset": 552326,
            "count": 12
          }
        ]
      },
      {
        "functionName": "useDebugValue",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 552355,
            "endOffset": 552528,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useDeferredValue",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 552560,
            "endOffset": 552731,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useTransition",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 552760,
            "endOffset": 552915,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useMutableSource",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 552947,
            "endOffset": 553138,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useSyncExternalStore",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 553174,
            "endOffset": 553425,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useId",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 553446,
            "endOffset": 553585,
            "count": 0
          }
        ]
      },
      {
        "functionName": "readContext",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 553738,
            "endOffset": 553814,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 553841,
            "endOffset": 554021,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useContext",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 554047,
            "endOffset": 554210,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useEffect",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 554235,
            "endOffset": 554407,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useImperativeHandle",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 554442,
            "endOffset": 554644,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useInsertionEffect",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 554678,
            "endOffset": 554868,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useLayoutEffect",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 554899,
            "endOffset": 555083,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useMemo",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 555106,
            "endOffset": 555565,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useReducer",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 555591,
            "endOffset": 556082,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useRef",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 556104,
            "endOffset": 556270,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useState",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 556294,
            "endOffset": 556755,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useDebugValue",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 556784,
            "endOffset": 556958,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useDeferredValue",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 556990,
            "endOffset": 557162,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useTransition",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 557191,
            "endOffset": 557347,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useMutableSource",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 557379,
            "endOffset": 557571,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useSyncExternalStore",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 557607,
            "endOffset": 557859,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useId",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 557880,
            "endOffset": 558020,
            "count": 0
          }
        ]
      },
      {
        "functionName": "readContext",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 558161,
            "endOffset": 558237,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 558264,
            "endOffset": 558445,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useContext",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 558471,
            "endOffset": 558634,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useEffect",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 558659,
            "endOffset": 558832,
            "count": 4
          }
        ]
      },
      {
        "functionName": "useImperativeHandle",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 558867,
            "endOffset": 559070,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useInsertionEffect",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 559104,
            "endOffset": 559295,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useLayoutEffect",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 559326,
            "endOffset": 559511,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useMemo",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 559534,
            "endOffset": 559995,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useReducer",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 560021,
            "endOffset": 560514,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useRef",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 560536,
            "endOffset": 560691,
            "count": 4
          }
        ]
      },
      {
        "functionName": "useState",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 560715,
            "endOffset": 561178,
            "count": 2
          }
        ]
      },
      {
        "functionName": "useDebugValue",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 561207,
            "endOffset": 561382,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useDeferredValue",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 561414,
            "endOffset": 561587,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useTransition",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 561616,
            "endOffset": 561773,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useMutableSource",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 561805,
            "endOffset": 561998,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useSyncExternalStore",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 562034,
            "endOffset": 562268,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useId",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 562289,
            "endOffset": 562430,
            "count": 0
          }
        ]
      },
      {
        "functionName": "readContext",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 562573,
            "endOffset": 562649,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 562676,
            "endOffset": 562857,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useContext",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 562883,
            "endOffset": 563046,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useEffect",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 563071,
            "endOffset": 563244,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useImperativeHandle",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 563279,
            "endOffset": 563482,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useInsertionEffect",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 563516,
            "endOffset": 563707,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useLayoutEffect",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 563738,
            "endOffset": 563923,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useMemo",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 563946,
            "endOffset": 564409,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useReducer",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 564435,
            "endOffset": 564932,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useRef",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 564954,
            "endOffset": 565109,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useState",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 565133,
            "endOffset": 565600,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useDebugValue",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 565629,
            "endOffset": 565804,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useDeferredValue",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 565836,
            "endOffset": 566011,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useTransition",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 566040,
            "endOffset": 566199,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useMutableSource",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 566231,
            "endOffset": 566424,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useSyncExternalStore",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 566460,
            "endOffset": 566694,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useId",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 566715,
            "endOffset": 566856,
            "count": 0
          }
        ]
      },
      {
        "functionName": "readContext",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 567009,
            "endOffset": 567127,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 567154,
            "endOffset": 567372,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useContext",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 567398,
            "endOffset": 567599,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useEffect",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 567624,
            "endOffset": 567834,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useImperativeHandle",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 567869,
            "endOffset": 568109,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useInsertionEffect",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 568143,
            "endOffset": 568371,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useLayoutEffect",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 568402,
            "endOffset": 568624,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useMemo",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 568647,
            "endOffset": 569144,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useReducer",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 569170,
            "endOffset": 569699,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useRef",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 569721,
            "endOffset": 569925,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useState",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 569949,
            "endOffset": 570448,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useDebugValue",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 570477,
            "endOffset": 570689,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useDeferredValue",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 570721,
            "endOffset": 570931,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useTransition",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 570960,
            "endOffset": 571154,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useMutableSource",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 571186,
            "endOffset": 571416,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useSyncExternalStore",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 571452,
            "endOffset": 571742,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useId",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 571763,
            "endOffset": 571941,
            "count": 0
          }
        ]
      },
      {
        "functionName": "readContext",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 572095,
            "endOffset": 572213,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 572240,
            "endOffset": 572460,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useContext",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 572486,
            "endOffset": 572688,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useEffect",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 572713,
            "endOffset": 572925,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useImperativeHandle",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 572960,
            "endOffset": 573202,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useInsertionEffect",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 573236,
            "endOffset": 573466,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useLayoutEffect",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 573497,
            "endOffset": 573721,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useMemo",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 573744,
            "endOffset": 574244,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useReducer",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 574270,
            "endOffset": 574802,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useRef",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 574824,
            "endOffset": 575018,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useState",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 575042,
            "endOffset": 575544,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useDebugValue",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 575573,
            "endOffset": 575787,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useDeferredValue",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 575819,
            "endOffset": 576031,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useTransition",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 576060,
            "endOffset": 576256,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useMutableSource",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 576288,
            "endOffset": 576520,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useSyncExternalStore",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 576556,
            "endOffset": 576829,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useId",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 576850,
            "endOffset": 577030,
            "count": 0
          }
        ]
      },
      {
        "functionName": "readContext",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 577186,
            "endOffset": 577304,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 577331,
            "endOffset": 577551,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useContext",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 577577,
            "endOffset": 577779,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useEffect",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 577804,
            "endOffset": 578016,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useImperativeHandle",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 578051,
            "endOffset": 578293,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useInsertionEffect",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 578327,
            "endOffset": 578557,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useLayoutEffect",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 578588,
            "endOffset": 578812,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useMemo",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 578835,
            "endOffset": 579335,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useReducer",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 579361,
            "endOffset": 579895,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useRef",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 579917,
            "endOffset": 580111,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useState",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 580135,
            "endOffset": 580639,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useDebugValue",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 580668,
            "endOffset": 580882,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useDeferredValue",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 580914,
            "endOffset": 581128,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useTransition",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 581157,
            "endOffset": 581355,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useMutableSource",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 581387,
            "endOffset": 581619,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useSyncExternalStore",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 581655,
            "endOffset": 581928,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useId",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 581949,
            "endOffset": 582129,
            "count": 0
          }
        ]
      },
      {
        "functionName": "isCurrentUpdateNested",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 582495,
            "endOffset": 582579,
            "count": 0
          }
        ]
      },
      {
        "functionName": "markNestedUpdateScheduled",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 582588,
            "endOffset": 582702,
            "count": 0
          }
        ]
      },
      {
        "functionName": "resetNestedUpdateFlag",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 582711,
            "endOffset": 582865,
            "count": 2
          }
        ]
      },
      {
        "functionName": "syncNestedUpdateFlag",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 582874,
            "endOffset": 583043,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getCommitTime",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 583052,
            "endOffset": 583117,
            "count": 0
          }
        ]
      },
      {
        "functionName": "recordCommitTime",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 583126,
            "endOffset": 583197,
            "count": 2
          }
        ]
      },
      {
        "functionName": "startProfilerTimer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 583206,
            "endOffset": 583391,
            "count": 190
          },
          {
            "startOffset": 583323,
            "endOffset": 583381,
            "count": 95
          }
        ]
      },
      {
        "functionName": "stopProfilerTimerIfRunning",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 583400,
            "endOffset": 583488,
            "count": 18
          }
        ]
      },
      {
        "functionName": "stopProfilerTimerIfRunningAndRecordDelta",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 583497,
            "endOffset": 583881,
            "count": 190
          },
          {
            "startOffset": 583612,
            "endOffset": 583871,
            "count": 172
          },
          {
            "startOffset": 583756,
            "endOffset": 583823,
            "count": 77
          }
        ]
      },
      {
        "functionName": "recordLayoutEffectDuration",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 583890,
            "endOffset": 584659,
            "count": 2
          },
          {
            "startOffset": 584167,
            "endOffset": 584637,
            "count": 10
          },
          {
            "startOffset": 584226,
            "endOffset": 584374,
            "count": 2
          },
          {
            "startOffset": 584391,
            "endOffset": 584559,
            "count": 0
          },
          {
            "startOffset": 584575,
            "endOffset": 584637,
            "count": 8
          }
        ]
      },
      {
        "functionName": "recordPassiveEffectDuration",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 584668,
            "endOffset": 585589,
            "count": 10
          },
          {
            "startOffset": 584949,
            "endOffset": 585567,
            "count": 68
          },
          {
            "startOffset": 585008,
            "endOffset": 585225,
            "count": 10
          },
          {
            "startOffset": 585242,
            "endOffset": 585489,
            "count": 0
          },
          {
            "startOffset": 585505,
            "endOffset": 585567,
            "count": 58
          }
        ]
      },
      {
        "functionName": "startLayoutEffectTimer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 585598,
            "endOffset": 585686,
            "count": 2
          }
        ]
      },
      {
        "functionName": "startPassiveEffectTimer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 585695,
            "endOffset": 585785,
            "count": 10
          }
        ]
      },
      {
        "functionName": "transferActualDuration",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 585794,
            "endOffset": 586010,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createCapturedValueAtFiber",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 586019,
            "endOffset": 586233,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createCapturedValue",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 586242,
            "endOffset": 586481,
            "count": 0
          }
        ]
      },
      {
        "functionName": "showErrorDialog",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 586490,
            "endOffset": 586570,
            "count": 0
          }
        ]
      },
      {
        "functionName": "logCapturedError",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 586579,
            "endOffset": 588467,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createRootErrorUpdate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 588555,
            "endOffset": 588987,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createClassErrorUpdate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 588996,
            "endOffset": 590822,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attachPingListener",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 590831,
            "endOffset": 591739,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attachRetryListener",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 591748,
            "endOffset": 592142,
            "count": 0
          }
        ]
      },
      {
        "functionName": "resetSuspendedComponent",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 592151,
            "endOffset": 592832,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getNearestSuspenseBoundaryToCapture",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 592841,
            "endOffset": 593171,
            "count": 0
          }
        ]
      },
      {
        "functionName": "markSuspenseBoundaryShouldCapture",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 593180,
            "endOffset": 594432,
            "count": 0
          }
        ]
      },
      {
        "functionName": "throwException",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 594441,
            "endOffset": 598502,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getSuspendedCache",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 598511,
            "endOffset": 598600,
            "count": 0
          }
        ]
      },
      {
        "functionName": "reconcileChildren",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 599472,
            "endOffset": 599855,
            "count": 77
          },
          {
            "startOffset": 599589,
            "endOffset": 599707,
            "count": 49
          },
          {
            "startOffset": 599707,
            "endOffset": 599845,
            "count": 28
          }
        ]
      },
      {
        "functionName": "forceUnmountCurrentAndReconcile",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 599864,
            "endOffset": 600187,
            "count": 0
          }
        ]
      },
      {
        "functionName": "updateForwardRef",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 600196,
            "endOffset": 602295,
            "count": 0
          }
        ]
      },
      {
        "functionName": "updateMemoComponent",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 602304,
            "endOffset": 605047,
            "count": 0
          }
        ]
      },
      {
        "functionName": "updateSimpleMemoComponent",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 605056,
            "endOffset": 607062,
            "count": 0
          }
        ]
      },
      {
        "functionName": "updateOffscreenComponent",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 607071,
            "endOffset": 609546,
            "count": 0
          }
        ]
      },
      {
        "functionName": "updateFragment",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 609555,
            "endOffset": 609814,
            "count": 0
          }
        ]
      },
      {
        "functionName": "updateMode",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 609823,
            "endOffset": 610087,
            "count": 1
          }
        ]
      },
      {
        "functionName": "updateProfiler",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 610096,
            "endOffset": 610650,
            "count": 0
          }
        ]
      },
      {
        "functionName": "markRef",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 610659,
            "endOffset": 610983,
            "count": 67
          },
          {
            "startOffset": 610778,
            "endOffset": 610793,
            "count": 41
          },
          {
            "startOffset": 610794,
            "endOffset": 610838,
            "count": 58
          },
          {
            "startOffset": 610815,
            "endOffset": 610838,
            "count": 26
          },
          {
            "startOffset": 610840,
            "endOffset": 610973,
            "count": 9
          }
        ]
      },
      {
        "functionName": "updateFunctionComponent",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 610992,
            "endOffset": 613236,
            "count": 1
          },
          {
            "startOffset": 611172,
            "endOffset": 611525,
            "count": 0
          },
          {
            "startOffset": 612774,
            "endOffset": 612944,
            "count": 0
          },
          {
            "startOffset": 612976,
            "endOffset": 612984,
            "count": 0
          },
          {
            "startOffset": 612986,
            "endOffset": 613052,
            "count": 0
          }
        ]
      },
      {
        "functionName": "updateClassComponent",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 613245,
            "endOffset": 616446,
            "count": 0
          }
        ]
      },
      {
        "functionName": "finishClassComponent",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 616455,
            "endOffset": 618466,
            "count": 0
          }
        ]
      },
      {
        "functionName": "pushHostRootContext",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 618475,
            "endOffset": 618932,
            "count": 2
          },
          {
            "startOffset": 618608,
            "endOffset": 618739,
            "count": 0
          }
        ]
      },
      {
        "functionName": "updateHostRoot",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 618941,
            "endOffset": 621715,
            "count": 1
          },
          {
            "startOffset": 619089,
            "endOffset": 619187,
            "count": 0
          },
          {
            "startOffset": 619674,
            "endOffset": 621370,
            "count": 0
          },
          {
            "startOffset": 621460,
            "endOffset": 621567,
            "count": 0
          }
        ]
      },
      {
        "functionName": "mountHostRootWithoutHydrating",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 621724,
            "endOffset": 622107,
            "count": 0
          }
        ]
      },
      {
        "functionName": "updateHostComponent",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 622116,
            "endOffset": 623034,
            "count": 67
          },
          {
            "startOffset": 622265,
            "endOffset": 622341,
            "count": 41
          },
          {
            "startOffset": 622485,
            "endOffset": 622509,
            "count": 26
          },
          {
            "startOffset": 622510,
            "endOffset": 622516,
            "count": 41
          },
          {
            "startOffset": 622673,
            "endOffset": 622719,
            "count": 31
          },
          {
            "startOffset": 622719,
            "endOffset": 622854,
            "count": 36
          },
          {
            "startOffset": 622748,
            "endOffset": 622788,
            "count": 14
          },
          {
            "startOffset": 622790,
            "endOffset": 622854,
            "count": 0
          }
        ]
      },
      {
        "functionName": "updateHostText",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 623043,
            "endOffset": 623238,
            "count": 0
          }
        ]
      },
      {
        "functionName": "mountLazyComponent",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 623247,
            "endOffset": 626239,
            "count": 0
          }
        ]
      },
      {
        "functionName": "mountIncompleteClassComponent",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 626248,
            "endOffset": 627028,
            "count": 0
          }
        ]
      },
      {
        "functionName": "mountIndeterminateComponent",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 627037,
            "endOffset": 632266,
            "count": 6
          },
          {
            "startOffset": 627703,
            "endOffset": 627754,
            "count": 1
          },
          {
            "startOffset": 627756,
            "endOffset": 628212,
            "count": 0
          },
          {
            "startOffset": 628848,
            "endOffset": 628885,
            "count": 5
          },
          {
            "startOffset": 628886,
            "endOffset": 628914,
            "count": 0
          },
          {
            "startOffset": 628916,
            "endOffset": 629605,
            "count": 0
          },
          {
            "startOffset": 629823,
            "endOffset": 629860,
            "count": 5
          },
          {
            "startOffset": 629861,
            "endOffset": 629889,
            "count": 0
          },
          {
            "startOffset": 629902,
            "endOffset": 631418,
            "count": 0
          },
          {
            "startOffset": 631945,
            "endOffset": 631953,
            "count": 0
          },
          {
            "startOffset": 631955,
            "endOffset": 632025,
            "count": 0
          }
        ]
      },
      {
        "functionName": "validateFunctionComponentInDev",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 632275,
            "endOffset": 634402,
            "count": 6
          },
          {
            "startOffset": 632433,
            "endOffset": 632602,
            "count": 0
          },
          {
            "startOffset": 632663,
            "endOffset": 633434,
            "count": 0
          },
          {
            "startOffset": 633509,
            "endOffset": 633908,
            "count": 0
          },
          {
            "startOffset": 633967,
            "endOffset": 634000,
            "count": 0
          },
          {
            "startOffset": 634002,
            "endOffset": 634380,
            "count": 0
          }
        ]
      },
      {
        "functionName": "mountSuspenseOffscreenState",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 634540,
            "endOffset": 634745,
            "count": 0
          }
        ]
      },
      {
        "functionName": "updateSuspenseOffscreenState",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 634754,
            "endOffset": 635059,
            "count": 0
          }
        ]
      },
      {
        "functionName": "shouldRemainOnFallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 635068,
            "endOffset": 635433,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getRemainingWorkInPrimaryTree",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 635442,
            "endOffset": 635581,
            "count": 0
          }
        ]
      },
      {
        "functionName": "updateSuspenseComponent",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 635590,
            "endOffset": 639283,
            "count": 0
          }
        ]
      },
      {
        "functionName": "mountSuspensePrimaryChildren",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 639292,
            "endOffset": 639797,
            "count": 0
          }
        ]
      },
      {
        "functionName": "mountSuspenseFallbackChildren",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 639806,
            "endOffset": 641397,
            "count": 0
          }
        ]
      },
      {
        "functionName": "mountWorkInProgressOffscreenFiber",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 641406,
            "endOffset": 641576,
            "count": 0
          }
        ]
      },
      {
        "functionName": "updateWorkInProgressOffscreenFiber",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 641585,
            "endOffset": 641731,
            "count": 0
          }
        ]
      },
      {
        "functionName": "updateSuspensePrimaryChildren",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 641740,
            "endOffset": 642891,
            "count": 0
          }
        ]
      },
      {
        "functionName": "updateSuspenseFallbackChildren",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 642900,
            "endOffset": 645704,
            "count": 0
          }
        ]
      },
      {
        "functionName": "retrySuspenseComponentWithoutHydrating",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 645713,
            "endOffset": 646369,
            "count": 0
          }
        ]
      },
      {
        "functionName": "mountSuspenseFallbackAfterRetryWithoutHydrating",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 646378,
            "endOffset": 647394,
            "count": 0
          }
        ]
      },
      {
        "functionName": "mountDehydratedSuspenseComponent",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 647403,
            "endOffset": 648168,
            "count": 0
          }
        ]
      },
      {
        "functionName": "updateDehydratedSuspenseComponent",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 648177,
            "endOffset": 653039,
            "count": 0
          }
        ]
      },
      {
        "functionName": "scheduleSuspenseWorkOnFiber",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 653048,
            "endOffset": 653449,
            "count": 0
          }
        ]
      },
      {
        "functionName": "propagateSuspenseContextChange",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 653458,
            "endOffset": 654528,
            "count": 0
          }
        ]
      },
      {
        "functionName": "findLastContentRow",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 654537,
            "endOffset": 654942,
            "count": 0
          }
        ]
      },
      {
        "functionName": "validateRevealOrder",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 654951,
            "endOffset": 656428,
            "count": 0
          }
        ]
      },
      {
        "functionName": "validateTailOptions",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 656437,
            "endOffset": 657208,
            "count": 0
          }
        ]
      },
      {
        "functionName": "validateSuspenseListNestedChild",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 657217,
            "endOffset": 657890,
            "count": 0
          }
        ]
      },
      {
        "functionName": "validateSuspenseListChildren",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 657899,
            "endOffset": 659270,
            "count": 0
          }
        ]
      },
      {
        "functionName": "initSuspenseListRenderState",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 659279,
            "endOffset": 660022,
            "count": 0
          }
        ]
      },
      {
        "functionName": "updateSuspenseListComponent",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 660031,
            "endOffset": 663619,
            "count": 0
          }
        ]
      },
      {
        "functionName": "updatePortalComponent",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 663628,
            "endOffset": 664158,
            "count": 0
          }
        ]
      },
      {
        "functionName": "updateContextProvider",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 664236,
            "endOffset": 665860,
            "count": 1
          },
          {
            "startOffset": 664612,
            "endOffset": 664912,
            "count": 0
          },
          {
            "startOffset": 665016,
            "endOffset": 665118,
            "count": 0
          },
          {
            "startOffset": 665238,
            "endOffset": 665668,
            "count": 0
          }
        ]
      },
      {
        "functionName": "updateContextConsumer",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 665927,
            "endOffset": 667691,
            "count": 0
          }
        ]
      },
      {
        "functionName": "markWorkInProgressReceivedUpdate",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 667700,
            "endOffset": 667790,
            "count": 2
          }
        ]
      },
      {
        "functionName": "resetSuspendedCurrentOnMountInLegacyMode",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 667799,
            "endOffset": 668157,
            "count": 6
          },
          {
            "startOffset": 667944,
            "endOffset": 668147,
            "count": 0
          }
        ]
      },
      {
        "functionName": "bailoutOnAlreadyFinishedWork",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 668166,
            "endOffset": 668731,
            "count": 18
          },
          {
            "startOffset": 668558,
            "endOffset": 668626,
            "count": 8
          },
          {
            "startOffset": 668626,
            "endOffset": 668730,
            "count": 10
          }
        ]
      },
      {
        "functionName": "remountFiber",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 668740,
            "endOffset": 670362,
            "count": 0
          }
        ]
      },
      {
        "functionName": "checkScheduledUpdateOrContext",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 670371,
            "endOffset": 670611,
            "count": 20
          },
          {
            "startOffset": 670539,
            "endOffset": 670577,
            "count": 2
          },
          {
            "startOffset": 670577,
            "endOffset": 670610,
            "count": 18
          }
        ]
      },
      {
        "functionName": "attemptEarlyBailoutIfNoScheduledUpdate",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 670620,
            "endOffset": 674774,
            "count": 18
          },
          {
            "startOffset": 670764,
            "endOffset": 670941,
            "count": 1
          },
          {
            "startOffset": 670954,
            "endOffset": 671042,
            "count": 10
          },
          {
            "startOffset": 671055,
            "endOffset": 671284,
            "count": 0
          },
          {
            "startOffset": 671297,
            "endOffset": 671425,
            "count": 0
          },
          {
            "startOffset": 671438,
            "endOffset": 671685,
            "count": 1
          },
          {
            "startOffset": 671698,
            "endOffset": 672165,
            "count": 0
          },
          {
            "startOffset": 672178,
            "endOffset": 673487,
            "count": 0
          },
          {
            "startOffset": 673500,
            "endOffset": 674436,
            "count": 0
          },
          {
            "startOffset": 674449,
            "endOffset": 674473,
            "count": 0
          },
          {
            "startOffset": 674486,
            "endOffset": 674664,
            "count": 0
          }
        ]
      },
      {
        "functionName": "beginWork",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 674783,
            "endOffset": 681630,
            "count": 95
          },
          {
            "startOffset": 674908,
            "endOffset": 674928,
            "count": 0
          },
          {
            "startOffset": 674930,
            "endOffset": 675191,
            "count": 0
          },
          {
            "startOffset": 675237,
            "endOffset": 676358,
            "count": 46
          },
          {
            "startOffset": 675385,
            "endOffset": 675407,
            "count": 20
          },
          {
            "startOffset": 675408,
            "endOffset": 675531,
            "count": 20
          },
          {
            "startOffset": 675533,
            "endOffset": 675587,
            "count": 26
          },
          {
            "startOffset": 675587,
            "endOffset": 676346,
            "count": 20
          },
          {
            "startOffset": 675745,
            "endOffset": 675964,
            "count": 18
          },
          {
            "startOffset": 675966,
            "endOffset": 676129,
            "count": 18
          },
          {
            "startOffset": 676129,
            "endOffset": 676209,
            "count": 2
          },
          {
            "startOffset": 676209,
            "endOffset": 676267,
            "count": 0
          },
          {
            "startOffset": 676267,
            "endOffset": 676332,
            "count": 2
          },
          {
            "startOffset": 676358,
            "endOffset": 676674,
            "count": 49
          },
          {
            "startOffset": 676437,
            "endOffset": 676470,
            "count": 0
          },
          {
            "startOffset": 676472,
            "endOffset": 676662,
            "count": 0
          },
          {
            "startOffset": 676674,
            "endOffset": 676771,
            "count": 77
          },
          {
            "startOffset": 676771,
            "endOffset": 676928,
            "count": 6
          },
          {
            "startOffset": 676941,
            "endOffset": 677132,
            "count": 0
          },
          {
            "startOffset": 677145,
            "endOffset": 677560,
            "count": 1
          },
          {
            "startOffset": 677383,
            "endOffset": 677432,
            "count": 0
          },
          {
            "startOffset": 677573,
            "endOffset": 677991,
            "count": 0
          },
          {
            "startOffset": 678004,
            "endOffset": 678096,
            "count": 1
          },
          {
            "startOffset": 678109,
            "endOffset": 678211,
            "count": 67
          },
          {
            "startOffset": 678224,
            "endOffset": 678302,
            "count": 0
          },
          {
            "startOffset": 678315,
            "endOffset": 678425,
            "count": 0
          },
          {
            "startOffset": 678438,
            "endOffset": 678539,
            "count": 0
          },
          {
            "startOffset": 678552,
            "endOffset": 678943,
            "count": 0
          },
          {
            "startOffset": 678956,
            "endOffset": 679048,
            "count": 0
          },
          {
            "startOffset": 679061,
            "endOffset": 679145,
            "count": 1
          },
          {
            "startOffset": 679158,
            "endOffset": 679250,
            "count": 0
          },
          {
            "startOffset": 679263,
            "endOffset": 679369,
            "count": 1
          },
          {
            "startOffset": 679382,
            "endOffset": 679488,
            "count": 0
          },
          {
            "startOffset": 679501,
            "endOffset": 680441,
            "count": 0
          },
          {
            "startOffset": 680454,
            "endOffset": 680636,
            "count": 0
          },
          {
            "startOffset": 680649,
            "endOffset": 681095,
            "count": 0
          },
          {
            "startOffset": 681108,
            "endOffset": 681242,
            "count": 0
          },
          {
            "startOffset": 681255,
            "endOffset": 681312,
            "count": 0
          },
          {
            "startOffset": 681325,
            "endOffset": 681453,
            "count": 0
          },
          {
            "startOffset": 681465,
            "endOffset": 681629,
            "count": 0
          }
        ]
      },
      {
        "functionName": "markUpdate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 681639,
            "endOffset": 681730,
            "count": 0
          }
        ]
      },
      {
        "functionName": "markRef$1",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 681739,
            "endOffset": 681898,
            "count": 9
          }
        ]
      },
      {
        "functionName": "appendAllChildren",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 682068,
            "endOffset": 683001,
            "count": 41
          },
          {
            "startOffset": 682217,
            "endOffset": 682989,
            "count": 40
          },
          {
            "startOffset": 682264,
            "endOffset": 682288,
            "count": 2
          },
          {
            "startOffset": 682290,
            "endOffset": 682367,
            "count": 38
          },
          {
            "startOffset": 682367,
            "endOffset": 682584,
            "count": 2
          },
          {
            "startOffset": 682418,
            "endOffset": 682419,
            "count": 0
          },
          {
            "startOffset": 682584,
            "endOffset": 682629,
            "count": 38
          },
          {
            "startOffset": 682629,
            "endOffset": 682670,
            "count": 0
          },
          {
            "startOffset": 682670,
            "endOffset": 682715,
            "count": 38
          },
          {
            "startOffset": 682715,
            "endOffset": 682891,
            "count": 21
          },
          {
            "startOffset": 682794,
            "endOffset": 682839,
            "count": 19
          },
          {
            "startOffset": 682839,
            "endOffset": 682891,
            "count": 2
          },
          {
            "startOffset": 682891,
            "endOffset": 682989,
            "count": 19
          }
        ]
      },
      {
        "functionName": "updateHostContainer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 683035,
            "endOffset": 683084,
            "count": 2
          }
        ]
      },
      {
        "functionName": "updateHostComponent$1",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 683120,
            "endOffset": 683718,
            "count": 36
          },
          {
            "startOffset": 683287,
            "endOffset": 683324,
            "count": 10
          },
          {
            "startOffset": 683324,
            "endOffset": 683648,
            "count": 26
          },
          {
            "startOffset": 683648,
            "endOffset": 683706,
            "count": 0
          }
        ]
      },
      {
        "functionName": "updateHostText$1",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 683749,
            "endOffset": 683912,
            "count": 0
          }
        ]
      },
      {
        "functionName": "cutOffTailIfNeeded",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 683932,
            "endOffset": 685383,
            "count": 0
          }
        ]
      },
      {
        "functionName": "bubbleProperties",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 685392,
            "endOffset": 688214,
            "count": 95
          },
          {
            "startOffset": 685495,
            "endOffset": 685551,
            "count": 46
          },
          {
            "startOffset": 685657,
            "endOffset": 686937,
            "count": 75
          },
          {
            "startOffset": 685942,
            "endOffset": 686313,
            "count": 93
          },
          {
            "startOffset": 686453,
            "endOffset": 686869,
            "count": 0
          },
          {
            "startOffset": 686937,
            "endOffset": 688123,
            "count": 20
          },
          {
            "startOffset": 687168,
            "endOffset": 687524,
            "count": 5
          },
          {
            "startOffset": 687604,
            "endOffset": 688055,
            "count": 0
          }
        ]
      },
      {
        "functionName": "completeDehydratedSuspenseBoundary",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 688223,
            "endOffset": 690620,
            "count": 0
          }
        ]
      },
      {
        "functionName": "completeWork",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 690629,
            "endOffset": 706305,
            "count": 95
          },
          {
            "startOffset": 690845,
            "endOffset": 690873,
            "count": 0
          },
          {
            "startOffset": 690886,
            "endOffset": 690905,
            "count": 0
          },
          {
            "startOffset": 690918,
            "endOffset": 690943,
            "count": 0
          },
          {
            "startOffset": 690956,
            "endOffset": 690979,
            "count": 12
          },
          {
            "startOffset": 690992,
            "endOffset": 691008,
            "count": 12
          },
          {
            "startOffset": 691021,
            "endOffset": 691035,
            "count": 12
          },
          {
            "startOffset": 691048,
            "endOffset": 691058,
            "count": 14
          },
          {
            "startOffset": 691071,
            "endOffset": 691085,
            "count": 14
          },
          {
            "startOffset": 691098,
            "endOffset": 691119,
            "count": 14
          },
          {
            "startOffset": 691132,
            "endOffset": 691227,
            "count": 14
          },
          {
            "startOffset": 691240,
            "endOffset": 691515,
            "count": 0
          },
          {
            "startOffset": 691528,
            "endOffset": 692916,
            "count": 2
          },
          {
            "startOffset": 691797,
            "endOffset": 691925,
            "count": 0
          },
          {
            "startOffset": 691990,
            "endOffset": 692764,
            "count": 1
          },
          {
            "startOffset": 692095,
            "endOffset": 692161,
            "count": 0
          },
          {
            "startOffset": 692399,
            "endOffset": 692546,
            "count": 0
          },
          {
            "startOffset": 692929,
            "endOffset": 694841,
            "count": 77
          },
          {
            "startOffset": 693147,
            "endOffset": 693183,
            "count": 36
          },
          {
            "startOffset": 693185,
            "endOffset": 693431,
            "count": 36
          },
          {
            "startOffset": 693350,
            "endOffset": 693415,
            "count": 0
          },
          {
            "startOffset": 693431,
            "endOffset": 694751,
            "count": 41
          },
          {
            "startOffset": 693470,
            "endOffset": 693801,
            "count": 0
          },
          {
            "startOffset": 693966,
            "endOffset": 694168,
            "count": 0
          },
          {
            "startOffset": 694531,
            "endOffset": 694601,
            "count": 0
          },
          {
            "startOffset": 694670,
            "endOffset": 694735,
            "count": 9
          },
          {
            "startOffset": 694854,
            "endOffset": 696096,
            "count": 0
          },
          {
            "startOffset": 696109,
            "endOffset": 698729,
            "count": 0
          },
          {
            "startOffset": 698742,
            "endOffset": 699077,
            "count": 0
          },
          {
            "startOffset": 699090,
            "endOffset": 699299,
            "count": 2
          },
          {
            "startOffset": 699312,
            "endOffset": 699599,
            "count": 0
          },
          {
            "startOffset": 699612,
            "endOffset": 704696,
            "count": 0
          },
          {
            "startOffset": 704709,
            "endOffset": 704766,
            "count": 0
          },
          {
            "startOffset": 704779,
            "endOffset": 704803,
            "count": 0
          },
          {
            "startOffset": 704816,
            "endOffset": 705968,
            "count": 0
          },
          {
            "startOffset": 705981,
            "endOffset": 706044,
            "count": 0
          },
          {
            "startOffset": 706057,
            "endOffset": 706128,
            "count": 0
          },
          {
            "startOffset": 706140,
            "endOffset": 706304,
            "count": 0
          }
        ]
      },
      {
        "functionName": "unwindWork",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 706314,
            "endOffset": 709362,
            "count": 0
          }
        ]
      },
      {
        "functionName": "unwindInterruptedWork",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 709371,
            "endOffset": 710854,
            "count": 0
          }
        ]
      },
      {
        "functionName": "reportUncaughtErrorInDEV",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 711298,
            "endOffset": 711504,
            "count": 0
          }
        ]
      },
      {
        "functionName": "callComponentWillUnmountWithTimer",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 711553,
            "endOffset": 712011,
            "count": 0
          }
        ]
      },
      {
        "functionName": "safelyCallCommitHookLayoutEffectListMount",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 712021,
            "endOffset": 712310,
            "count": 0
          }
        ]
      },
      {
        "functionName": "safelyCallComponentWillUnmount",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 712319,
            "endOffset": 712617,
            "count": 0
          }
        ]
      },
      {
        "functionName": "safelyCallComponentDidMount",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 712626,
            "endOffset": 712896,
            "count": 0
          }
        ]
      },
      {
        "functionName": "safelyAttachRef",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 712905,
            "endOffset": 713150,
            "count": 0
          }
        ]
      },
      {
        "functionName": "safelyDetachRef",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 713159,
            "endOffset": 714262,
            "count": 0
          }
        ]
      },
      {
        "functionName": "safelyCallDestroy",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 714271,
            "endOffset": 714511,
            "count": 4
          },
          {
            "startOffset": 714394,
            "endOffset": 714501,
            "count": 0
          }
        ]
      },
      {
        "functionName": "commitBeforeMutationEffects",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 714617,
            "endOffset": 715023,
            "count": 2
          }
        ]
      },
      {
        "functionName": "commitBeforeMutationEffects_begin",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 715032,
            "endOffset": 715463,
            "count": 2
          },
          {
            "startOffset": 715117,
            "endOffset": 715453,
            "count": 9
          },
          {
            "startOffset": 715262,
            "endOffset": 715279,
            "count": 5
          },
          {
            "startOffset": 715281,
            "endOffset": 715366,
            "count": 5
          },
          {
            "startOffset": 715366,
            "endOffset": 715441,
            "count": 4
          }
        ]
      },
      {
        "functionName": "commitBeforeMutationEffects_complete",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 715472,
            "endOffset": 716109,
            "count": 4
          },
          {
            "startOffset": 715560,
            "endOffset": 716099,
            "count": 9
          },
          {
            "startOffset": 715723,
            "endOffset": 715821,
            "count": 0
          },
          {
            "startOffset": 715930,
            "endOffset": 716048,
            "count": 2
          },
          {
            "startOffset": 716048,
            "endOffset": 716099,
            "count": 7
          }
        ]
      },
      {
        "functionName": "commitBeforeMutationEffectsOnFiber",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 716118,
            "endOffset": 719170,
            "count": 9
          },
          {
            "startOffset": 716315,
            "endOffset": 719160,
            "count": 1
          },
          {
            "startOffset": 716414,
            "endOffset": 716437,
            "count": 0
          },
          {
            "startOffset": 716452,
            "endOffset": 716468,
            "count": 0
          },
          {
            "startOffset": 716483,
            "endOffset": 716549,
            "count": 0
          },
          {
            "startOffset": 716564,
            "endOffset": 718526,
            "count": 0
          },
          {
            "startOffset": 718756,
            "endOffset": 718775,
            "count": 0
          },
          {
            "startOffset": 718790,
            "endOffset": 718804,
            "count": 0
          },
          {
            "startOffset": 718819,
            "endOffset": 718835,
            "count": 0
          },
          {
            "startOffset": 718850,
            "endOffset": 718903,
            "count": 0
          },
          {
            "startOffset": 718918,
            "endOffset": 719101,
            "count": 0
          }
        ]
      },
      {
        "functionName": "commitHookEffectListUnmount",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 719179,
            "endOffset": 720962,
            "count": 12
          },
          {
            "startOffset": 719390,
            "endOffset": 719396,
            "count": 0
          },
          {
            "startOffset": 719535,
            "endOffset": 720908,
            "count": 22
          },
          {
            "startOffset": 719587,
            "endOffset": 720858,
            "count": 19
          },
          {
            "startOffset": 719716,
            "endOffset": 720842,
            "count": 4
          },
          {
            "startOffset": 719797,
            "endOffset": 719898,
            "count": 3
          },
          {
            "startOffset": 719898,
            "endOffset": 720040,
            "count": 1
          },
          {
            "startOffset": 720140,
            "endOffset": 720220,
            "count": 0
          },
          {
            "startOffset": 720404,
            "endOffset": 720485,
            "count": 0
          },
          {
            "startOffset": 720585,
            "endOffset": 720674,
            "count": 3
          },
          {
            "startOffset": 720674,
            "endOffset": 720804,
            "count": 1
          }
        ]
      },
      {
        "functionName": "commitHookEffectListMount",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 720971,
            "endOffset": 724137,
            "count": 12
          },
          {
            "startOffset": 721156,
            "endOffset": 721162,
            "count": 0
          },
          {
            "startOffset": 721301,
            "endOffset": 724083,
            "count": 22
          },
          {
            "startOffset": 721353,
            "endOffset": 724033,
            "count": 19
          },
          {
            "startOffset": 721430,
            "endOffset": 721525,
            "count": 15
          },
          {
            "startOffset": 721525,
            "endOffset": 721661,
            "count": 4
          },
          {
            "startOffset": 721799,
            "endOffset": 721875,
            "count": 0
          },
          {
            "startOffset": 722012,
            "endOffset": 722089,
            "count": 0
          },
          {
            "startOffset": 722183,
            "endOffset": 722266,
            "count": 15
          },
          {
            "startOffset": 722266,
            "endOffset": 722390,
            "count": 4
          },
          {
            "startOffset": 722516,
            "endOffset": 722548,
            "count": 8
          },
          {
            "startOffset": 722550,
            "endOffset": 723999,
            "count": 0
          }
        ]
      },
      {
        "functionName": "commitPassiveEffectDurations",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 724146,
            "endOffset": 725904,
            "count": 0
          }
        ]
      },
      {
        "functionName": "commitLayoutEffectOnFiber",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 725913,
            "endOffset": 735538,
            "count": 10
          },
          {
            "startOffset": 726121,
            "endOffset": 726144,
            "count": 1
          },
          {
            "startOffset": 726159,
            "endOffset": 726175,
            "count": 1
          },
          {
            "startOffset": 726190,
            "endOffset": 726784,
            "count": 1
          },
          {
            "startOffset": 726619,
            "endOffset": 726727,
            "count": 0
          },
          {
            "startOffset": 726799,
            "endOffset": 731491,
            "count": 0
          },
          {
            "startOffset": 731506,
            "endOffset": 732248,
            "count": 0
          },
          {
            "startOffset": 732263,
            "endOffset": 732632,
            "count": 9
          },
          {
            "startOffset": 732412,
            "endOffset": 732593,
            "count": 0
          },
          {
            "startOffset": 732647,
            "endOffset": 732702,
            "count": 0
          },
          {
            "startOffset": 732717,
            "endOffset": 732774,
            "count": 0
          },
          {
            "startOffset": 732789,
            "endOffset": 734685,
            "count": 0
          },
          {
            "startOffset": 734700,
            "endOffset": 734842,
            "count": 0
          },
          {
            "startOffset": 734857,
            "endOffset": 734884,
            "count": 0
          },
          {
            "startOffset": 734899,
            "endOffset": 734929,
            "count": 0
          },
          {
            "startOffset": 734944,
            "endOffset": 734964,
            "count": 0
          },
          {
            "startOffset": 734979,
            "endOffset": 735003,
            "count": 0
          },
          {
            "startOffset": 735018,
            "endOffset": 735045,
            "count": 0
          },
          {
            "startOffset": 735060,
            "endOffset": 735129,
            "count": 0
          },
          {
            "startOffset": 735144,
            "endOffset": 735309,
            "count": 0
          },
          {
            "startOffset": 735438,
            "endOffset": 735502,
            "count": 9
          }
        ]
      },
      {
        "functionName": "reappearLayoutEffectsOnFiber",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 735547,
            "endOffset": 736634,
            "count": 0
          }
        ]
      },
      {
        "functionName": "hideOrUnhideAllChildren",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 736643,
            "endOffset": 738917,
            "count": 0
          }
        ]
      },
      {
        "functionName": "commitAttachRef",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 738926,
            "endOffset": 740414,
            "count": 9
          },
          {
            "startOffset": 739289,
            "endOffset": 739339,
            "count": 0
          },
          {
            "startOffset": 739397,
            "endOffset": 740061,
            "count": 0
          },
          {
            "startOffset": 740137,
            "endOffset": 740319,
            "count": 0
          }
        ]
      },
      {
        "functionName": "detachFiberMutation",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 740423,
            "endOffset": 740629,
            "count": 0
          }
        ]
      },
      {
        "functionName": "detachFiberAfterEffects",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 740638,
            "endOffset": 741624,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getHostParentFiber",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 741633,
            "endOffset": 742014,
            "count": 1
          },
          {
            "startOffset": 741825,
            "endOffset": 742013,
            "count": 0
          }
        ]
      },
      {
        "functionName": "isHostParent",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 742023,
            "endOffset": 742163,
            "count": 2
          },
          {
            "startOffset": 742125,
            "endOffset": 742152,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getHostSibling",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 742172,
            "endOffset": 743168,
            "count": 1
          },
          {
            "startOffset": 742447,
            "endOffset": 742656,
            "count": 0
          },
          {
            "startOffset": 742657,
            "endOffset": 742691,
            "count": 0
          },
          {
            "startOffset": 742693,
            "endOffset": 743144,
            "count": 0
          }
        ]
      },
      {
        "functionName": "commitPlacement",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 743177,
            "endOffset": 744206,
            "count": 1
          },
          {
            "startOffset": 743329,
            "endOffset": 743729,
            "count": 0
          },
          {
            "startOffset": 744046,
            "endOffset": 744184,
            "count": 0
          }
        ]
      },
      {
        "functionName": "insertOrAppendPlacementNodeIntoContainer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 744215,
            "endOffset": 745119,
            "count": 9
          },
          {
            "startOffset": 744364,
            "endOffset": 744383,
            "count": 6
          },
          {
            "startOffset": 744407,
            "endOffset": 744648,
            "count": 3
          },
          {
            "startOffset": 744477,
            "endOffset": 744558,
            "count": 0
          },
          {
            "startOffset": 744648,
            "endOffset": 745109,
            "count": 6
          },
          {
            "startOffset": 744690,
            "endOffset": 744691,
            "count": 0
          },
          {
            "startOffset": 744777,
            "endOffset": 745097,
            "count": 5
          },
          {
            "startOffset": 744940,
            "endOffset": 745083,
            "count": 3
          }
        ]
      },
      {
        "functionName": "insertOrAppendPlacementNode",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 745128,
            "endOffset": 745971,
            "count": 0
          }
        ]
      },
      {
        "functionName": "commitDeletionEffects",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 746054,
            "endOffset": 747369,
            "count": 0
          }
        ]
      },
      {
        "functionName": "recursivelyTraverseDeletionEffects",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 747378,
            "endOffset": 747684,
            "count": 0
          }
        ]
      },
      {
        "functionName": "commitDeletionEffectsOnFiber",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 747693,
            "endOffset": 753364,
            "count": 0
          }
        ]
      },
      {
        "functionName": "commitSuspenseCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 753373,
            "endOffset": 753483,
            "count": 0
          }
        ]
      },
      {
        "functionName": "commitSuspenseHydrationCallbacks",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 753492,
            "endOffset": 754081,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attachSuspenseRetryListeners",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 754090,
            "endOffset": 755193,
            "count": 0
          }
        ]
      },
      {
        "functionName": "commitMutationEffects",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 755202,
            "endOffset": 755569,
            "count": 2
          }
        ]
      },
      {
        "functionName": "recursivelyTraverseMutationEffects",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 755578,
            "endOffset": 756485,
            "count": 23
          },
          {
            "startOffset": 755734,
            "endOffset": 756086,
            "count": 0
          },
          {
            "startOffset": 756192,
            "endOffset": 756432,
            "count": 12
          },
          {
            "startOffset": 756272,
            "endOffset": 756420,
            "count": 21
          }
        ]
      },
      {
        "functionName": "commitMutationEffectsOnFiber",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 756494,
            "endOffset": 765667,
            "count": 23
          },
          {
            "startOffset": 756703,
            "endOffset": 756726,
            "count": 6
          },
          {
            "startOffset": 756739,
            "endOffset": 756755,
            "count": 6
          },
          {
            "startOffset": 756768,
            "endOffset": 756787,
            "count": 6
          },
          {
            "startOffset": 756800,
            "endOffset": 758141,
            "count": 6
          },
          {
            "startOffset": 756990,
            "endOffset": 758105,
            "count": 1
          },
          {
            "startOffset": 757219,
            "endOffset": 757339,
            "count": 0
          },
          {
            "startOffset": 757589,
            "endOffset": 757713,
            "count": 0
          },
          {
            "startOffset": 757791,
            "endOffset": 758089,
            "count": 0
          },
          {
            "startOffset": 758154,
            "endOffset": 758510,
            "count": 0
          },
          {
            "startOffset": 758523,
            "endOffset": 760122,
            "count": 13
          },
          {
            "startOffset": 758704,
            "endOffset": 758842,
            "count": 9
          },
          {
            "startOffset": 758745,
            "endOffset": 758826,
            "count": 0
          },
          {
            "startOffset": 758914,
            "endOffset": 759207,
            "count": 0
          },
          {
            "startOffset": 759244,
            "endOffset": 760070,
            "count": 0
          },
          {
            "startOffset": 760135,
            "endOffset": 761077,
            "count": 0
          },
          {
            "startOffset": 761090,
            "endOffset": 761816,
            "count": 2
          },
          {
            "startOffset": 761269,
            "endOffset": 761780,
            "count": 0
          },
          {
            "startOffset": 761829,
            "endOffset": 762011,
            "count": 0
          },
          {
            "startOffset": 762024,
            "endOffset": 763174,
            "count": 0
          },
          {
            "startOffset": 763187,
            "endOffset": 765069,
            "count": 0
          },
          {
            "startOffset": 765082,
            "endOffset": 765387,
            "count": 0
          },
          {
            "startOffset": 765400,
            "endOffset": 765458,
            "count": 0
          },
          {
            "startOffset": 765471,
            "endOffset": 765645,
            "count": 2
          }
        ]
      },
      {
        "functionName": "commitReconciliationEffects",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 765676,
            "endOffset": 766156,
            "count": 23
          },
          {
            "startOffset": 765804,
            "endOffset": 766053,
            "count": 1
          },
          {
            "startOffset": 765883,
            "endOffset": 765995,
            "count": 0
          },
          {
            "startOffset": 766087,
            "endOffset": 766146,
            "count": 0
          }
        ]
      },
      {
        "functionName": "commitLayoutEffects",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 766165,
            "endOffset": 766498,
            "count": 2
          }
        ]
      },
      {
        "functionName": "commitLayoutEffects_begin",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 766507,
            "endOffset": 768928,
            "count": 2
          },
          {
            "startOffset": 766695,
            "endOffset": 768918,
            "count": 23
          },
          {
            "startOffset": 766824,
            "endOffset": 766839,
            "count": 0
          },
          {
            "startOffset": 766841,
            "endOffset": 768618,
            "count": 0
          },
          {
            "startOffset": 768681,
            "endOffset": 768703,
            "count": 12
          },
          {
            "startOffset": 768705,
            "endOffset": 768800,
            "count": 12
          },
          {
            "startOffset": 768800,
            "endOffset": 768906,
            "count": 11
          }
        ]
      },
      {
        "functionName": "commitLayoutMountEffects_complete",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 768937,
            "endOffset": 769871,
            "count": 11
          },
          {
            "startOffset": 769056,
            "endOffset": 769861,
            "count": 23
          },
          {
            "startOffset": 769150,
            "endOffset": 769506,
            "count": 10
          },
          {
            "startOffset": 769355,
            "endOffset": 769457,
            "count": 0
          },
          {
            "startOffset": 769546,
            "endOffset": 769616,
            "count": 2
          },
          {
            "startOffset": 769616,
            "endOffset": 769692,
            "count": 21
          },
          {
            "startOffset": 769692,
            "endOffset": 769810,
            "count": 9
          },
          {
            "startOffset": 769810,
            "endOffset": 769861,
            "count": 12
          }
        ]
      },
      {
        "functionName": "disappearLayoutEffects_begin",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 769880,
            "endOffset": 771701,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disappearLayoutEffects_complete",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 771710,
            "endOffset": 772206,
            "count": 0
          }
        ]
      },
      {
        "functionName": "reappearLayoutEffects_begin",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 772215,
            "endOffset": 772877,
            "count": 0
          }
        ]
      },
      {
        "functionName": "reappearLayoutEffects_complete",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 772886,
            "endOffset": 773632,
            "count": 0
          }
        ]
      },
      {
        "functionName": "commitPassiveMountEffects",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 773641,
            "endOffset": 773885,
            "count": 2
          }
        ]
      },
      {
        "functionName": "commitPassiveMountEffects_begin",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 773894,
            "endOffset": 774446,
            "count": 2
          },
          {
            "startOffset": 774033,
            "endOffset": 774436,
            "count": 38
          },
          {
            "startOffset": 774176,
            "endOffset": 774198,
            "count": 20
          },
          {
            "startOffset": 774200,
            "endOffset": 774295,
            "count": 20
          },
          {
            "startOffset": 774295,
            "endOffset": 774424,
            "count": 18
          }
        ]
      },
      {
        "functionName": "commitPassiveMountEffects_complete",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 774455,
            "endOffset": 775375,
            "count": 18
          },
          {
            "startOffset": 774597,
            "endOffset": 775365,
            "count": 38
          },
          {
            "startOffset": 774688,
            "endOffset": 775010,
            "count": 5
          },
          {
            "startOffset": 774859,
            "endOffset": 774961,
            "count": 0
          },
          {
            "startOffset": 775050,
            "endOffset": 775120,
            "count": 2
          },
          {
            "startOffset": 775120,
            "endOffset": 775196,
            "count": 36
          },
          {
            "startOffset": 775196,
            "endOffset": 775314,
            "count": 16
          },
          {
            "startOffset": 775314,
            "endOffset": 775365,
            "count": 20
          }
        ]
      },
      {
        "functionName": "commitPassiveMountOnFiber",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 775384,
            "endOffset": 776112,
            "count": 5
          },
          {
            "startOffset": 775952,
            "endOffset": 776055,
            "count": 0
          }
        ]
      },
      {
        "functionName": "commitPassiveUnmountEffects",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 776121,
            "endOffset": 776263,
            "count": 2
          }
        ]
      },
      {
        "functionName": "commitPassiveUnmountEffects_begin",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 776272,
            "endOffset": 777791,
            "count": 2
          },
          {
            "startOffset": 776357,
            "endOffset": 777781,
            "count": 38
          },
          {
            "startOffset": 776496,
            "endOffset": 777526,
            "count": 0
          },
          {
            "startOffset": 777590,
            "endOffset": 777607,
            "count": 20
          },
          {
            "startOffset": 777609,
            "endOffset": 777694,
            "count": 20
          },
          {
            "startOffset": 777694,
            "endOffset": 777769,
            "count": 18
          }
        ]
      },
      {
        "functionName": "commitPassiveUnmountEffects_complete",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 777800,
            "endOffset": 778372,
            "count": 18
          },
          {
            "startOffset": 777888,
            "endOffset": 778362,
            "count": 38
          },
          {
            "startOffset": 777979,
            "endOffset": 778117,
            "count": 5
          },
          {
            "startOffset": 778193,
            "endOffset": 778311,
            "count": 16
          },
          {
            "startOffset": 778311,
            "endOffset": 778362,
            "count": 22
          }
        ]
      },
      {
        "functionName": "commitPassiveUnmountOnFiber",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 778381,
            "endOffset": 779033,
            "count": 5
          },
          {
            "startOffset": 778850,
            "endOffset": 778976,
            "count": 0
          }
        ]
      },
      {
        "functionName": "commitPassiveUnmountEffectsInsideOfDeletedTree_begin",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 779042,
            "endOffset": 779672,
            "count": 0
          }
        ]
      },
      {
        "functionName": "commitPassiveUnmountEffectsInsideOfDeletedTree_complete",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 779681,
            "endOffset": 780339,
            "count": 0
          }
        ]
      },
      {
        "functionName": "commitPassiveUnmountInsideDeletedTreeOnFiber",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 780348,
            "endOffset": 780999,
            "count": 0
          }
        ]
      },
      {
        "functionName": "invokeLayoutEffectMountInDEV",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 781008,
            "endOffset": 781823,
            "count": 1
          },
          {
            "startOffset": 781323,
            "endOffset": 781429,
            "count": 0
          },
          {
            "startOffset": 781483,
            "endOffset": 781787,
            "count": 0
          }
        ]
      },
      {
        "functionName": "invokePassiveEffectMountInDEV",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 781832,
            "endOffset": 782332,
            "count": 4
          },
          {
            "startOffset": 782151,
            "endOffset": 782257,
            "count": 0
          }
        ]
      },
      {
        "functionName": "invokeLayoutEffectUnmountInDEV",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 782341,
            "endOffset": 783153,
            "count": 1
          },
          {
            "startOffset": 782674,
            "endOffset": 782780,
            "count": 0
          },
          {
            "startOffset": 782834,
            "endOffset": 783117,
            "count": 0
          }
        ]
      },
      {
        "functionName": "invokePassiveEffectUnmountInDEV",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 783162,
            "endOffset": 783657,
            "count": 4
          },
          {
            "startOffset": 783499,
            "endOffset": 783605,
            "count": 0
          }
        ]
      },
      {
        "functionName": "onCommitRoot$1",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 784251,
            "endOffset": 784418,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 784323,
            "endOffset": 784394,
            "count": 0
          }
        ]
      },
      {
        "functionName": "isLegacyActEnvironment",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 784505,
            "endOffset": 784970,
            "count": 0
          }
        ]
      },
      {
        "functionName": "isConcurrentActEnvironment",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 784979,
            "endOffset": 785552,
            "count": 2
          },
          {
            "startOffset": 785235,
            "endOffset": 785261,
            "count": 0
          },
          {
            "startOffset": 785373,
            "endOffset": 785482,
            "count": 0
          }
        ]
      },
      {
        "functionName": "resetRenderTimer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 787388,
            "endOffset": 787501,
            "count": 14
          }
        ]
      },
      {
        "functionName": "getRenderTargetTime",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 787510,
            "endOffset": 787605,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getWorkInProgressRoot",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 788489,
            "endOffset": 788570,
            "count": 0
          }
        ]
      },
      {
        "functionName": "requestEventTime",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 788579,
            "endOffset": 788910,
            "count": 2
          },
          {
            "startOffset": 788691,
            "endOffset": 788730,
            "count": 0
          },
          {
            "startOffset": 788779,
            "endOffset": 788829,
            "count": 0
          }
        ]
      },
      {
        "functionName": "requestUpdateLane",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 788919,
            "endOffset": 790134,
            "count": 2
          },
          {
            "startOffset": 789038,
            "endOffset": 789080,
            "count": 0
          },
          {
            "startOffset": 789139,
            "endOffset": 789183,
            "count": 0
          },
          {
            "startOffset": 789185,
            "endOffset": 789267,
            "count": 0
          },
          {
            "startOffset": 789370,
            "endOffset": 789906,
            "count": 0
          },
          {
            "startOffset": 789999,
            "endOffset": 790043,
            "count": 0
          }
        ]
      },
      {
        "functionName": "requestRetryLane",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 790143,
            "endOffset": 790352,
            "count": 0
          }
        ]
      },
      {
        "functionName": "scheduleUpdateOnFiber",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 790361,
            "endOffset": 792020,
            "count": 2
          },
          {
            "startOffset": 790514,
            "endOffset": 790599,
            "count": 0
          },
          {
            "startOffset": 790666,
            "endOffset": 790741,
            "count": 0
          },
          {
            "startOffset": 790866,
            "endOffset": 790897,
            "count": 0
          },
          {
            "startOffset": 790899,
            "endOffset": 790965,
            "count": 0
          },
          {
            "startOffset": 791212,
            "endOffset": 791602,
            "count": 0
          },
          {
            "startOffset": 791690,
            "endOffset": 791723,
            "count": 0
          },
          {
            "startOffset": 791724,
            "endOffset": 791767,
            "count": 0
          },
          {
            "startOffset": 791768,
            "endOffset": 791895,
            "count": 0
          },
          {
            "startOffset": 791897,
            "endOffset": 791998,
            "count": 0
          }
        ]
      },
      {
        "functionName": "scheduleInitialHydrationOnRoot",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 792029,
            "endOffset": 792279,
            "count": 0
          }
        ]
      },
      {
        "functionName": "isUnsafeClassRenderPhaseUpdate",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 792288,
            "endOffset": 792566,
            "count": 1
          }
        ]
      },
      {
        "functionName": "ensureRootIsScheduled",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 792575,
            "endOffset": 795940,
            "count": 6
          },
          {
            "startOffset": 792817,
            "endOffset": 792848,
            "count": 0
          },
          {
            "startOffset": 792898,
            "endOffset": 793132,
            "count": 4
          },
          {
            "startOffset": 792947,
            "endOffset": 793016,
            "count": 0
          },
          {
            "startOffset": 793132,
            "endOffset": 793332,
            "count": 2
          },
          {
            "startOffset": 793332,
            "endOffset": 793622,
            "count": 0
          },
          {
            "startOffset": 793624,
            "endOffset": 793925,
            "count": 0
          },
          {
            "startOffset": 793925,
            "endOffset": 793970,
            "count": 2
          },
          {
            "startOffset": 793970,
            "endOffset": 794035,
            "count": 0
          },
          {
            "startOffset": 794035,
            "endOffset": 794115,
            "count": 2
          },
          {
            "startOffset": 794115,
            "endOffset": 794982,
            "count": 0
          },
          {
            "startOffset": 794982,
            "endOffset": 795826,
            "count": 2
          },
          {
            "startOffset": 795099,
            "endOffset": 795209,
            "count": 0
          },
          {
            "startOffset": 795224,
            "endOffset": 795339,
            "count": 0
          },
          {
            "startOffset": 795475,
            "endOffset": 795576,
            "count": 0
          },
          {
            "startOffset": 795591,
            "endOffset": 795679,
            "count": 0
          },
          {
            "startOffset": 795826,
            "endOffset": 795939,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 794718,
            "endOffset": 794902,
            "count": 0
          }
        ]
      },
      {
        "functionName": "performConcurrentWorkOnRoot",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 795949,
            "endOffset": 799219,
            "count": 2
          },
          {
            "startOffset": 796240,
            "endOffset": 796316,
            "count": 0
          },
          {
            "startOffset": 796474,
            "endOffset": 796591,
            "count": 0
          },
          {
            "startOffset": 796663,
            "endOffset": 796694,
            "count": 0
          },
          {
            "startOffset": 796740,
            "endOffset": 796778,
            "count": 0
          },
          {
            "startOffset": 796847,
            "endOffset": 796884,
            "count": 0
          },
          {
            "startOffset": 796885,
            "endOffset": 796899,
            "count": 0
          },
          {
            "startOffset": 796944,
            "endOffset": 796980,
            "count": 0
          },
          {
            "startOffset": 797104,
            "endOffset": 797386,
            "count": 0
          },
          {
            "startOffset": 797436,
            "endOffset": 797693,
            "count": 0
          },
          {
            "startOffset": 797745,
            "endOffset": 797809,
            "count": 0
          },
          {
            "startOffset": 797990,
            "endOffset": 798044,
            "count": 0
          },
          {
            "startOffset": 798046,
            "endOffset": 798818,
            "count": 0
          },
          {
            "startOffset": 799107,
            "endOffset": 799186,
            "count": 0
          }
        ]
      },
      {
        "functionName": "recoverFromConcurrentError",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 799228,
            "endOffset": 800088,
            "count": 0
          }
        ]
      },
      {
        "functionName": "queueRecoverableErrors",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 800097,
            "endOffset": 800404,
            "count": 0
          }
        ]
      },
      {
        "functionName": "finishConcurrentRender",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 800413,
            "endOffset": 803199,
            "count": 2
          },
          {
            "startOffset": 800517,
            "endOffset": 800537,
            "count": 0
          },
          {
            "startOffset": 800550,
            "endOffset": 800669,
            "count": 0
          },
          {
            "startOffset": 800682,
            "endOffset": 800833,
            "count": 0
          },
          {
            "startOffset": 800846,
            "endOffset": 802007,
            "count": 0
          },
          {
            "startOffset": 802020,
            "endOffset": 802914,
            "count": 0
          },
          {
            "startOffset": 803093,
            "endOffset": 803177,
            "count": 0
          }
        ]
      },
      {
        "functionName": "isRenderConsistentWithExternalStores",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 803208,
            "endOffset": 804722,
            "count": 0
          }
        ]
      },
      {
        "functionName": "markRootSuspended$1",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 804731,
            "endOffset": 805032,
            "count": 0
          }
        ]
      },
      {
        "functionName": "performSyncWorkOnRoot",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 805041,
            "endOffset": 806666,
            "count": 0
          }
        ]
      },
      {
        "functionName": "flushRoot",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 806675,
            "endOffset": 807052,
            "count": 0
          }
        ]
      },
      {
        "functionName": "batchedUpdates$1",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 807061,
            "endOffset": 807613,
            "count": 14
          }
        ]
      },
      {
        "functionName": "discreteUpdates",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 807622,
            "endOffset": 808228,
            "count": 0
          }
        ]
      },
      {
        "functionName": "flushSync",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 808237,
            "endOffset": 809320,
            "count": 0
          }
        ]
      },
      {
        "functionName": "isAlreadyRendering",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 809329,
            "endOffset": 809455,
            "count": 0
          }
        ]
      },
      {
        "functionName": "pushRenderLanes",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 809464,
            "endOffset": 809749,
            "count": 0
          }
        ]
      },
      {
        "functionName": "popRenderLanes",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 809758,
            "endOffset": 809913,
            "count": 0
          }
        ]
      },
      {
        "functionName": "prepareFreshStack",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 809922,
            "endOffset": 811406,
            "count": 2
          },
          {
            "startOffset": 810137,
            "endOffset": 810237,
            "count": 0
          },
          {
            "startOffset": 810277,
            "endOffset": 810584,
            "count": 0
          }
        ]
      },
      {
        "functionName": "handleError",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 811415,
            "endOffset": 813266,
            "count": 0
          }
        ]
      },
      {
        "functionName": "pushDispatcher",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 813275,
            "endOffset": 813594,
            "count": 2
          },
          {
            "startOffset": 813475,
            "endOffset": 813584,
            "count": 1
          }
        ]
      },
      {
        "functionName": "popDispatcher",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 813603,
            "endOffset": 813714,
            "count": 2
          }
        ]
      },
      {
        "functionName": "markCommitTimeOfFallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 813723,
            "endOffset": 813818,
            "count": 0
          }
        ]
      },
      {
        "functionName": "markSkippedUpdateLanes",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 813827,
            "endOffset": 813969,
            "count": 19
          }
        ]
      },
      {
        "functionName": "renderDidSuspend",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 813978,
            "endOffset": 814152,
            "count": 0
          }
        ]
      },
      {
        "functionName": "renderDidSuspendDelayIfPossible",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 814161,
            "endOffset": 814721,
            "count": 0
          }
        ]
      },
      {
        "functionName": "renderDidError",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 814730,
            "endOffset": 815126,
            "count": 0
          }
        ]
      },
      {
        "functionName": "renderHasNotSuspendedYet",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 815135,
            "endOffset": 815248,
            "count": 0
          }
        ]
      },
      {
        "functionName": "renderRootSync",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 815257,
            "endOffset": 816842,
            "count": 2
          },
          {
            "startOffset": 815489,
            "endOffset": 815531,
            "count": 0
          },
          {
            "startOffset": 815698,
            "endOffset": 815841,
            "count": 0
          },
          {
            "startOffset": 816214,
            "endOffset": 816296,
            "count": 0
          },
          {
            "startOffset": 816492,
            "endOffset": 816640,
            "count": 0
          }
        ]
      },
      {
        "functionName": "workLoopSync",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 816851,
            "endOffset": 816989,
            "count": 2
          },
          {
            "startOffset": 816919,
            "endOffset": 816979,
            "count": 95
          }
        ]
      },
      {
        "functionName": "renderRootConcurrent",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 816998,
            "endOffset": 818621,
            "count": 0
          }
        ]
      },
      {
        "functionName": "workLoopConcurrent",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 818630,
            "endOffset": 818792,
            "count": 0
          }
        ]
      },
      {
        "functionName": "performUnitOfWork",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 818801,
            "endOffset": 819592,
            "count": 95
          },
          {
            "startOffset": 819209,
            "endOffset": 819302,
            "count": 0
          },
          {
            "startOffset": 819425,
            "endOffset": 819482,
            "count": 43
          },
          {
            "startOffset": 819482,
            "endOffset": 819536,
            "count": 52
          }
        ]
      },
      {
        "functionName": "completeUnitOfWork",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 819601,
            "endOffset": 822067,
            "count": 43
          },
          {
            "startOffset": 819698,
            "endOffset": 821890,
            "count": 95
          },
          {
            "startOffset": 820014,
            "endOffset": 820113,
            "count": 0
          },
          {
            "startOffset": 820418,
            "endOffset": 820498,
            "count": 0
          },
          {
            "startOffset": 820512,
            "endOffset": 821617,
            "count": 0
          },
          {
            "startOffset": 821711,
            "endOffset": 821793,
            "count": 41
          },
          {
            "startOffset": 821793,
            "endOffset": 821890,
            "count": 54
          },
          {
            "startOffset": 821890,
            "endOffset": 822057,
            "count": 2
          }
        ]
      },
      {
        "functionName": "commitRoot",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 822076,
            "endOffset": 822705,
            "count": 2
          }
        ]
      },
      {
        "functionName": "commitRootImpl",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 822714,
            "endOffset": 828773,
            "count": 2
          },
          {
            "startOffset": 823045,
            "endOffset": 823121,
            "count": 0
          },
          {
            "startOffset": 823313,
            "endOffset": 823414,
            "count": 0
          },
          {
            "startOffset": 823473,
            "endOffset": 823596,
            "count": 0
          },
          {
            "startOffset": 823747,
            "endOffset": 823900,
            "count": 0
          },
          {
            "startOffset": 824164,
            "endOffset": 824304,
            "count": 0
          },
          {
            "startOffset": 824373,
            "endOffset": 824422,
            "count": 0
          },
          {
            "startOffset": 825052,
            "endOffset": 825068,
            "count": 0
          },
          {
            "startOffset": 826218,
            "endOffset": 826341,
            "count": 0
          },
          {
            "startOffset": 826614,
            "endOffset": 826756,
            "count": 0
          },
          {
            "startOffset": 826975,
            "endOffset": 827058,
            "count": 0
          },
          {
            "startOffset": 827404,
            "endOffset": 827861,
            "count": 0
          },
          {
            "startOffset": 827894,
            "endOffset": 828057,
            "count": 0
          },
          {
            "startOffset": 828127,
            "endOffset": 828154,
            "count": 0
          },
          {
            "startOffset": 828156,
            "endOffset": 828204,
            "count": 0
          },
          {
            "startOffset": 828310,
            "endOffset": 828597,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 824626,
            "endOffset": 824722,
            "count": 2
          }
        ]
      },
      {
        "functionName": "flushPassiveEffects",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 828782,
            "endOffset": 829558,
            "count": 6
          },
          {
            "startOffset": 828869,
            "endOffset": 829524,
            "count": 2
          },
          {
            "startOffset": 829524,
            "endOffset": 829557,
            "count": 4
          }
        ]
      },
      {
        "functionName": "enqueuePendingPassiveProfilerEffect",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 829567,
            "endOffset": 829967,
            "count": 0
          }
        ]
      },
      {
        "functionName": "flushPassiveEffectsImpl",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 829976,
            "endOffset": 832318,
            "count": 2
          },
          {
            "startOffset": 830067,
            "endOffset": 830106,
            "count": 0
          },
          {
            "startOffset": 830487,
            "endOffset": 830586,
            "count": 0
          },
          {
            "startOffset": 831204,
            "endOffset": 831325,
            "count": 0
          },
          {
            "startOffset": 831642,
            "endOffset": 831900,
            "count": 0
          }
        ]
      },
      {
        "functionName": "isAlreadyFailedLegacyErrorBoundary",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 832327,
            "endOffset": 832514,
            "count": 0
          }
        ]
      },
      {
        "functionName": "markLegacyErrorBoundaryAsFailed",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 832523,
            "endOffset": 832837,
            "count": 0
          }
        ]
      },
      {
        "functionName": "prepareToThrowUncaughtError",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 832846,
            "endOffset": 833027,
            "count": 0
          }
        ]
      },
      {
        "functionName": "captureCommitPhaseErrorOnRoot",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 833095,
            "endOffset": 833596,
            "count": 0
          }
        ]
      },
      {
        "functionName": "captureCommitPhaseError",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 833605,
            "endOffset": 835444,
            "count": 0
          }
        ]
      },
      {
        "functionName": "pingSuspendedRoot",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 835453,
            "endOffset": 836407,
            "count": 0
          }
        ]
      },
      {
        "functionName": "retryTimedOutBoundary",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 836416,
            "endOffset": 836872,
            "count": 0
          }
        ]
      },
      {
        "functionName": "retryDehydratedSuspenseBoundary",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 836881,
            "endOffset": 837201,
            "count": 0
          }
        ]
      },
      {
        "functionName": "resolveRetryWakeable",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 837210,
            "endOffset": 838061,
            "count": 0
          }
        ]
      },
      {
        "functionName": "jnd",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 838070,
            "endOffset": 838319,
            "count": 0
          }
        ]
      },
      {
        "functionName": "checkForNestedUpdates",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 838328,
            "endOffset": 839193,
            "count": 2
          },
          {
            "startOffset": 838418,
            "endOffset": 838749,
            "count": 0
          },
          {
            "startOffset": 838834,
            "endOffset": 839171,
            "count": 0
          }
        ]
      },
      {
        "functionName": "flushRenderPhaseStrictModeWarningsInDEV",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 839202,
            "endOffset": 839458,
            "count": 2
          }
        ]
      },
      {
        "functionName": "commitDoubleInvokeEffectsInDEV",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 839467,
            "endOffset": 840091,
            "count": 2
          }
        ]
      },
      {
        "functionName": "invokeEffectsInDev",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 840100,
            "endOffset": 840922,
            "count": 8
          },
          {
            "startOffset": 840295,
            "endOffset": 840900,
            "count": 88
          },
          {
            "startOffset": 840415,
            "endOffset": 840441,
            "count": 58
          },
          {
            "startOffset": 840442,
            "endOffset": 840475,
            "count": 44
          },
          {
            "startOffset": 840477,
            "endOffset": 840537,
            "count": 30
          },
          {
            "startOffset": 840537,
            "endOffset": 840886,
            "count": 58
          },
          {
            "startOffset": 840608,
            "endOffset": 840671,
            "count": 10
          },
          {
            "startOffset": 840719,
            "endOffset": 840785,
            "count": 20
          },
          {
            "startOffset": 840785,
            "endOffset": 840870,
            "count": 38
          }
        ]
      },
      {
        "functionName": "warnAboutUpdateOnNotYetMountedFiberInDEV",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 840995,
            "endOffset": 842598,
            "count": 0
          }
        ]
      },
      {
        "functionName": "beginWork$1",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 842691,
            "endOffset": 844040,
            "count": 95
          },
          {
            "startOffset": 842921,
            "endOffset": 844028,
            "count": 0
          }
        ]
      },
      {
        "functionName": "warnAboutRenderPhaseUpdatesInDEV",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 844272,
            "endOffset": 845812,
            "count": 0
          }
        ]
      },
      {
        "functionName": "restorePendingUpdaters",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 845821,
            "endOffset": 846166,
            "count": 0
          }
        ]
      },
      {
        "functionName": "scheduleCallback$1",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 846213,
            "endOffset": 846577,
            "count": 4
          },
          {
            "startOffset": 846374,
            "endOffset": 846470,
            "count": 0
          }
        ]
      },
      {
        "functionName": "cancelCallback$1",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 846586,
            "endOffset": 846770,
            "count": 0
          }
        ]
      },
      {
        "functionName": "shouldForceFlushFallbacksInDEV",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 846779,
            "endOffset": 846890,
            "count": 0
          }
        ]
      },
      {
        "functionName": "warnIfUpdatesNotWrappedWithActDEV",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 846899,
            "endOffset": 848309,
            "count": 2
          },
          {
            "startOffset": 847114,
            "endOffset": 848287,
            "count": 0
          }
        ]
      },
      {
        "functionName": "warnIfSuspenseResolutionNotWrappedWithActDEV",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 848318,
            "endOffset": 848981,
            "count": 0
          }
        ]
      },
      {
        "functionName": "setIsRunningInsertionEffect",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 848990,
            "endOffset": 849123,
            "count": 0
          }
        ]
      },
      {
        "functionName": "setRefreshHandler",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 849227,
            "endOffset": 849317,
            "count": 0
          }
        ]
      },
      {
        "functionName": "resolveFunctionForHotReloading",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 849327,
            "endOffset": 849650,
            "count": 12
          },
          {
            "startOffset": 849469,
            "endOffset": 849649,
            "count": 0
          }
        ]
      },
      {
        "functionName": "resolveClassForHotReloading",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 849659,
            "endOffset": 849768,
            "count": 0
          }
        ]
      },
      {
        "functionName": "resolveForwardRefForHotReloading",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 849777,
            "endOffset": 850697,
            "count": 0
          }
        ]
      },
      {
        "functionName": "isCompatibleFamilyForHotReloading",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 850706,
            "endOffset": 852675,
            "count": 0
          }
        ]
      },
      {
        "functionName": "markFailedErrorBoundaryForHotReloading",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 852684,
            "endOffset": 853101,
            "count": 0
          }
        ]
      },
      {
        "functionName": "scheduleRefresh",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 853132,
            "endOffset": 853551,
            "count": 0
          }
        ]
      },
      {
        "functionName": "scheduleRoot",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 853580,
            "endOffset": 853877,
            "count": 0
          }
        ]
      },
      {
        "functionName": "scheduleFibersWithFamiliesRecursively",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 853887,
            "endOffset": 856088,
            "count": 0
          }
        ]
      },
      {
        "functionName": "findHostInstancesForRefresh",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 856131,
            "endOffset": 856499,
            "count": 0
          }
        ]
      },
      {
        "functionName": "findHostInstancesForMatchingFibersRecursively",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 856509,
            "endOffset": 857684,
            "count": 0
          }
        ]
      },
      {
        "functionName": "findHostInstancesForFiberShallowly",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 857693,
            "endOffset": 858612,
            "count": 0
          }
        ]
      },
      {
        "functionName": "findChildHostInstancesForFiberShallowly",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 858621,
            "endOffset": 859584,
            "count": 0
          }
        ]
      },
      {
        "functionName": "FiberNode",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 859967,
            "endOffset": 861441,
            "count": 190
          }
        ]
      },
      {
        "functionName": "createFiber",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 861468,
            "endOffset": 861580,
            "count": 190
          }
        ]
      },
      {
        "functionName": "shouldConstruct$1",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 861590,
            "endOffset": 861748,
            "count": 6
          },
          {
            "startOffset": 861707,
            "endOffset": 861736,
            "count": 1
          }
        ]
      },
      {
        "functionName": "isSimpleFunctionComponent",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 861757,
            "endOffset": 861914,
            "count": 0
          }
        ]
      },
      {
        "functionName": "resolveLazyComponentTag",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 861923,
            "endOffset": 862480,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createWorkInProgress",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 862489,
            "endOffset": 865372,
            "count": 46
          },
          {
            "startOffset": 862637,
            "endOffset": 863260,
            "count": 45
          },
          {
            "startOffset": 863260,
            "endOffset": 863659,
            "count": 1
          },
          {
            "startOffset": 864206,
            "endOffset": 864212,
            "count": 44
          },
          {
            "startOffset": 864213,
            "endOffset": 864333,
            "count": 2
          },
          {
            "startOffset": 864804,
            "endOffset": 864832,
            "count": 0
          },
          {
            "startOffset": 864847,
            "endOffset": 864870,
            "count": 6
          },
          {
            "startOffset": 864885,
            "endOffset": 865019,
            "count": 6
          },
          {
            "startOffset": 865034,
            "endOffset": 865160,
            "count": 0
          },
          {
            "startOffset": 865175,
            "endOffset": 865302,
            "count": 0
          }
        ]
      },
      {
        "functionName": "resetWorkInProgress",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 865381,
            "endOffset": 867194,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createHostRootFiber",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 867203,
            "endOffset": 867759,
            "count": 1
          },
          {
            "startOffset": 867423,
            "endOffset": 867553,
            "count": 0
          },
          {
            "startOffset": 867565,
            "endOffset": 867611,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createFiberFromTypeAndProps",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 867768,
            "endOffset": 871799,
            "count": 49
          },
          {
            "startOffset": 867978,
            "endOffset": 868325,
            "count": 6
          },
          {
            "startOffset": 868021,
            "endOffset": 868183,
            "count": 0
          },
          {
            "startOffset": 868325,
            "endOffset": 871528,
            "count": 43
          },
          {
            "startOffset": 868361,
            "endOffset": 868412,
            "count": 41
          },
          {
            "startOffset": 868412,
            "endOffset": 871528,
            "count": 2
          },
          {
            "startOffset": 868486,
            "endOffset": 868602,
            "count": 0
          },
          {
            "startOffset": 868619,
            "endOffset": 868878,
            "count": 1
          },
          {
            "startOffset": 868895,
            "endOffset": 869002,
            "count": 0
          },
          {
            "startOffset": 869019,
            "endOffset": 869126,
            "count": 0
          },
          {
            "startOffset": 869143,
            "endOffset": 869259,
            "count": 0
          },
          {
            "startOffset": 869276,
            "endOffset": 869385,
            "count": 0
          },
          {
            "startOffset": 869402,
            "endOffset": 869432,
            "count": 0
          },
          {
            "startOffset": 869449,
            "endOffset": 869471,
            "count": 0
          },
          {
            "startOffset": 869488,
            "endOffset": 869510,
            "count": 0
          },
          {
            "startOffset": 869527,
            "endOffset": 869558,
            "count": 0
          },
          {
            "startOffset": 869575,
            "endOffset": 869610,
            "count": 0
          },
          {
            "startOffset": 869627,
            "endOffset": 871500,
            "count": 1
          },
          {
            "startOffset": 869910,
            "endOffset": 870024,
            "count": 0
          },
          {
            "startOffset": 870047,
            "endOffset": 870301,
            "count": 0
          },
          {
            "startOffset": 870324,
            "endOffset": 870433,
            "count": 0
          },
          {
            "startOffset": 870456,
            "endOffset": 870610,
            "count": 0
          },
          {
            "startOffset": 870652,
            "endOffset": 870824,
            "count": 0
          },
          {
            "startOffset": 870826,
            "endOffset": 871088,
            "count": 0
          },
          {
            "startOffset": 871089,
            "endOffset": 871095,
            "count": 0
          },
          {
            "startOffset": 871132,
            "endOffset": 871240,
            "count": 0
          },
          {
            "startOffset": 871260,
            "endOffset": 871451,
            "count": 0
          },
          {
            "startOffset": 871452,
            "endOffset": 871465,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createFiberFromElement",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 871808,
            "endOffset": 872315,
            "count": 49
          }
        ]
      },
      {
        "functionName": "createFiberFromFragment",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 872324,
            "endOffset": 872517,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createFiberFromProfiler",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 872526,
            "endOffset": 873166,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createFiberFromSuspense",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 873175,
            "endOffset": 873436,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createFiberFromSuspenseList",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 873445,
            "endOffset": 873719,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createFiberFromOffscreen",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 873728,
            "endOffset": 874122,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createFiberFromText",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 874131,
            "endOffset": 874314,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createFiberFromHostInstanceForDeletion",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 874323,
            "endOffset": 874519,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createFiberFromDehydratedFragment",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 874528,
            "endOffset": 874741,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createFiberFromPortal",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 874750,
            "endOffset": 875244,
            "count": 0
          }
        ]
      },
      {
        "functionName": "assignFiberPropertiesInDEV",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 875253,
            "endOffset": 876942,
            "count": 95
          }
        ]
      },
      {
        "functionName": "FiberRootNode",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 876951,
            "endOffset": 878831,
            "count": 1
          },
          {
            "startOffset": 878389,
            "endOffset": 878474,
            "count": 31
          },
          {
            "startOffset": 878608,
            "endOffset": 878625,
            "count": 0
          },
          {
            "startOffset": 878681,
            "endOffset": 878795,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createFiberRoot",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 878840,
            "endOffset": 879759,
            "count": 1
          }
        ]
      },
      {
        "functionName": "createPortal",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 879805,
            "endOffset": 880309,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getContextForSubtree",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 880517,
            "endOffset": 881036,
            "count": 1
          },
          {
            "startOffset": 880650,
            "endOffset": 881035,
            "count": 0
          }
        ]
      },
      {
        "functionName": "findHostInstanceWithWarning",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 881045,
            "endOffset": 883129,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createContainer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 883138,
            "endOffset": 883582,
            "count": 1
          }
        ]
      },
      {
        "functionName": "createHydrationContainer",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 883591,
            "endOffset": 884508,
            "count": 0
          }
        ]
      },
      {
        "functionName": "updateContainer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 884517,
            "endOffset": 886314,
            "count": 1
          },
          {
            "startOffset": 885027,
            "endOffset": 885094,
            "count": 0
          },
          {
            "startOffset": 885135,
            "endOffset": 885154,
            "count": 0
          },
          {
            "startOffset": 885155,
            "endOffset": 885184,
            "count": 0
          },
          {
            "startOffset": 885186,
            "endOffset": 885541,
            "count": 0
          },
          {
            "startOffset": 885711,
            "endOffset": 885717,
            "count": 0
          },
          {
            "startOffset": 885763,
            "endOffset": 886048,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getPublicRootInstance",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 886323,
            "endOffset": 886738,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attemptSynchronousHydration$1",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 886747,
            "endOffset": 887614,
            "count": 0
          }
        ]
      },
      {
        "functionName": "markRetryLaneImpl",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 887623,
            "endOffset": 887913,
            "count": 0
          }
        ]
      },
      {
        "functionName": "markRetryLaneIfNotHydrated",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 887922,
            "endOffset": 888169,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attemptContinuousHydration$1",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 888178,
            "endOffset": 888636,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attemptHydrationAtCurrentPriority$1",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 888645,
            "endOffset": 889112,
            "count": 0
          }
        ]
      },
      {
        "functionName": "findHostInstanceWithNoPortals",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 889121,
            "endOffset": 889357,
            "count": 1
          },
          {
            "startOffset": 889309,
            "endOffset": 889356,
            "count": 0
          }
        ]
      },
      {
        "functionName": "shouldErrorImpl",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 889388,
            "endOffset": 889438,
            "count": 0
          }
        ]
      },
      {
        "functionName": "shouldError",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 889448,
            "endOffset": 889528,
            "count": 0
          }
        ]
      },
      {
        "functionName": "shouldSuspendImpl",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 889561,
            "endOffset": 889612,
            "count": 0
          }
        ]
      },
      {
        "functionName": "shouldSuspend",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 889622,
            "endOffset": 889706,
            "count": 0
          }
        ]
      },
      {
        "functionName": "copyWithDeleteImpl",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 890118,
            "endOffset": 890614,
            "count": 0
          }
        ]
      },
      {
        "functionName": "copyWithDelete",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 890647,
            "endOffset": 890733,
            "count": 0
          }
        ]
      },
      {
        "functionName": "copyWithRenameImpl",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 890770,
            "endOffset": 891537,
            "count": 0
          }
        ]
      },
      {
        "functionName": "copyWithRename",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 891570,
            "endOffset": 892133,
            "count": 0
          }
        ]
      },
      {
        "functionName": "copyWithSetImpl",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 892167,
            "endOffset": 892513,
            "count": 0
          }
        ]
      },
      {
        "functionName": "copyWithSet",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 892543,
            "endOffset": 892640,
            "count": 0
          }
        ]
      },
      {
        "functionName": "findHook",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 892667,
            "endOffset": 892921,
            "count": 0
          }
        ]
      },
      {
        "functionName": "overrideHookState",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 892953,
            "endOffset": 893523,
            "count": 0
          }
        ]
      },
      {
        "functionName": "overrideHookStateDeletePath",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 893565,
            "endOffset": 894124,
            "count": 0
          }
        ]
      },
      {
        "functionName": "overrideHookStateRenamePath",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 894166,
            "endOffset": 894749,
            "count": 0
          }
        ]
      },
      {
        "functionName": "overrideProps",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 894777,
            "endOffset": 895208,
            "count": 0
          }
        ]
      },
      {
        "functionName": "overridePropsDeletePath",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 895246,
            "endOffset": 895666,
            "count": 0
          }
        ]
      },
      {
        "functionName": "overridePropsRenamePath",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 895704,
            "endOffset": 896148,
            "count": 0
          }
        ]
      },
      {
        "functionName": "scheduleUpdate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 896177,
            "endOffset": 896401,
            "count": 0
          }
        ]
      },
      {
        "functionName": "setErrorHandler",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 896431,
            "endOffset": 896523,
            "count": 0
          }
        ]
      },
      {
        "functionName": "setSuspenseHandler",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 896556,
            "endOffset": 896654,
            "count": 0
          }
        ]
      },
      {
        "functionName": "findHostInstanceByFiber",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 896674,
            "endOffset": 896891,
            "count": 0
          }
        ]
      },
      {
        "functionName": "emptyFindFiberByHostInstance",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 896900,
            "endOffset": 896982,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getCurrentFiberForDevTools",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 896991,
            "endOffset": 897066,
            "count": 0
          }
        ]
      },
      {
        "functionName": "injectIntoDevTools",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 897075,
            "endOffset": 898556,
            "count": 1
          },
          {
            "startOffset": 898005,
            "endOffset": 898036,
            "count": 0
          }
        ]
      },
      {
        "functionName": "defaultOnRecoverableError",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 898797,
            "endOffset": 898861,
            "count": 0
          }
        ]
      },
      {
        "functionName": "ReactDOMRoot",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 898871,
            "endOffset": 898963,
            "count": 1
          }
        ]
      },
      {
        "functionName": "ReactDOMHydrationRoot.render.ReactDOMRoot.render",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 899045,
            "endOffset": 900512,
            "count": 1
          },
          {
            "startOffset": 899138,
            "endOffset": 899216,
            "count": 0
          },
          {
            "startOffset": 899281,
            "endOffset": 899471,
            "count": 0
          },
          {
            "startOffset": 899513,
            "endOffset": 899699,
            "count": 0
          },
          {
            "startOffset": 899746,
            "endOffset": 899868,
            "count": 0
          },
          {
            "startOffset": 900084,
            "endOffset": 900420,
            "count": 0
          }
        ]
      },
      {
        "functionName": "ReactDOMHydrationRoot.unmount.ReactDOMRoot.unmount",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 900597,
            "endOffset": 901510,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createRoot",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 901520,
            "endOffset": 903578,
            "count": 1
          },
          {
            "startOffset": 901607,
            "endOffset": 901708,
            "count": 0
          },
          {
            "startOffset": 902051,
            "endOffset": 903140,
            "count": 0
          },
          {
            "startOffset": 903431,
            "endOffset": 903453,
            "count": 0
          }
        ]
      },
      {
        "functionName": "ReactDOMHydrationRoot",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 903587,
            "endOffset": 903688,
            "count": 0
          }
        ]
      },
      {
        "functionName": "scheduleHydration",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 903697,
            "endOffset": 903829,
            "count": 0
          }
        ]
      },
      {
        "functionName": "hydrateRoot",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 903926,
            "endOffset": 905815,
            "count": 0
          }
        ]
      },
      {
        "functionName": "isValidContainer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 905824,
            "endOffset": 906044,
            "count": 2
          },
          {
            "startOffset": 905883,
            "endOffset": 906032,
            "count": 1
          },
          {
            "startOffset": 905918,
            "endOffset": 905952,
            "count": 0
          },
          {
            "startOffset": 905953,
            "endOffset": 905996,
            "count": 0
          },
          {
            "startOffset": 905997,
            "endOffset": 906031,
            "count": 0
          }
        ]
      },
      {
        "functionName": "isValidContainerLegacy",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 906053,
            "endOffset": 906331,
            "count": 0
          }
        ]
      },
      {
        "functionName": "warnIfReactDOMContainerInDEV",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 906340,
            "endOffset": 907380,
            "count": 1
          },
          {
            "startOffset": 906523,
            "endOffset": 906822,
            "count": 0
          },
          {
            "startOffset": 906875,
            "endOffset": 907358,
            "count": 0
          }
        ]
      },
      {
        "functionName": "topLevelUpdateWarnings",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 907536,
            "endOffset": 909173,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getReactRootElementInContainer",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 909193,
            "endOffset": 909492,
            "count": 0
          }
        ]
      },
      {
        "functionName": "noopOnRecoverableError",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 909501,
            "endOffset": 909546,
            "count": 0
          }
        ]
      },
      {
        "functionName": "legacyCreateRootFromDOMContainer",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 909555,
            "endOffset": 912053,
            "count": 0
          }
        ]
      },
      {
        "functionName": "warnOnInvalidCallback$1",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 912062,
            "endOffset": 912379,
            "count": 0
          }
        ]
      },
      {
        "functionName": "legacyRenderSubtreeIntoContainer",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 912388,
            "endOffset": 913340,
            "count": 0
          }
        ]
      },
      {
        "functionName": "findDOMNode",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 913349,
            "endOffset": 914418,
            "count": 0
          }
        ]
      },
      {
        "functionName": "hydrate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 914427,
            "endOffset": 915369,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 915378,
            "endOffset": 916306,
            "count": 0
          }
        ]
      },
      {
        "functionName": "unstable_renderSubtreeIntoContainer",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 916315,
            "endOffset": 917138,
            "count": 0
          }
        ]
      },
      {
        "functionName": "unmountComponentAtNode",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 917147,
            "endOffset": 919294,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createPortal$1",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 920379,
            "endOffset": 920718,
            "count": 0
          }
        ]
      },
      {
        "functionName": "renderSubtreeIntoContainer",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 920727,
            "endOffset": 920930,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createRoot$1",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 921273,
            "endOffset": 921623,
            "count": 1
          },
          {
            "startOffset": 921379,
            "endOffset": 921386,
            "count": 0
          },
          {
            "startOffset": 921388,
            "endOffset": 921551,
            "count": 0
          }
        ]
      },
      {
        "functionName": "hydrateRoot$1",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 921632,
            "endOffset": 922019,
            "count": 0
          }
        ]
      },
      {
        "functionName": "flushSync$1",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 922028,
            "endOffset": 922364,
            "count": 0
          }
        ]
      },
      {
        "functionName": "../../node_modules/.pnpm/react-dom@18.2.0_react@18.2.0/node_modules/react-dom/index.js",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 924310,
            "endOffset": 924578,
            "count": 1
          },
          {
            "startOffset": 924451,
            "endOffset": 924505,
            "count": 0
          }
        ]
      },
      {
        "functionName": "../../node_modules/.pnpm/react-dom@18.2.0_react@18.2.0/node_modules/react-dom/client.js",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 924711,
            "endOffset": 925485,
            "count": 1
          },
          {
            "startOffset": 924860,
            "endOffset": 924951,
            "count": 0
          }
        ]
      },
      {
        "functionName": "exports.createRoot",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 925050,
            "endOffset": 925238,
            "count": 1
          }
        ]
      },
      {
        "functionName": "exports.hydrateRoot",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 925268,
            "endOffset": 925463,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5173/@fs/home/will/local_dev/portfolio/packages/motion-system/src/providers/MotionProvider.tsx?t=1750724128976",
    "scriptId": "34",
    "source": "import { createHotContext as __vite__createHotContext } from \"/@vite/client\";import.meta.hot = __vite__createHotContext(\"/@fs/home/will/local_dev/portfolio/packages/motion-system/src/providers/MotionProvider.tsx\");import __vite__cjsImport0_react_jsxDevRuntime from \"/node_modules/.vite/deps/react_jsx-dev-runtime.js?v=a50bb159\"; const jsxDEV = __vite__cjsImport0_react_jsxDevRuntime[\"jsxDEV\"];\nimport RefreshRuntime from \"/@react-refresh\";\nconst inWebWorker = typeof WorkerGlobalScope !== \"undefined\" && self instanceof WorkerGlobalScope;\nlet prevRefreshReg;\nlet prevRefreshSig;\nif (import.meta.hot && !inWebWorker) {\n  if (!window.__vite_plugin_react_preamble_installed__) {\n    throw new Error(\"@vitejs/plugin-react can't detect preamble. Something is wrong. See https://github.com/vitejs/vite-plugin-react/pull/11#discussion_r430879201\");\n  }\n  prevRefreshReg = window.$RefreshReg$;\n  prevRefreshSig = window.$RefreshSig$;\n  window.$RefreshReg$ = (type, id) => {\n    RefreshRuntime.register(type, \"/home/will/local_dev/portfolio/packages/motion-system/src/providers/MotionProvider.tsx \" + id);\n  };\n  window.$RefreshSig$ = RefreshRuntime.createSignatureFunctionForTransform;\n}\nvar _s = $RefreshSig$(), _s2 = $RefreshSig$();\nimport __vite__cjsImport3_react from \"/node_modules/.vite/deps/react.js?v=a50bb159\"; const createContext = __vite__cjsImport3_react[\"createContext\"]; const useContext = __vite__cjsImport3_react[\"useContext\"]; const useState = __vite__cjsImport3_react[\"useState\"]; const useEffect = __vite__cjsImport3_react[\"useEffect\"]; const useRef = __vite__cjsImport3_react[\"useRef\"]; const useCallback = __vite__cjsImport3_react[\"useCallback\"]\n\n\n\n\n\n\n;\nimport Lenis from \"/node_modules/.vite/deps/lenis.js?v=a50bb159\";\nimport { gsap } from \"/node_modules/.vite/deps/gsap.js?v=a50bb159\";\nimport { ScrollTrigger } from \"/node_modules/.vite/deps/gsap_ScrollTrigger.js?v=a50bb159\";\ngsap.registerPlugin(ScrollTrigger);\nconst MotionContext = createContext(void 0);\nconst DEFAULT_CHAPTERS = [\n  { id: \"hero\", start: 0, end: 0.25 },\n  { id: \"morph\", start: 0.25, end: 0.5 },\n  { id: \"sticky\", start: 0.5, end: 0.75 },\n  { id: \"footer\", start: 0.75, end: 1 }\n];\nexport const MotionProvider = ({\n  children,\n  chapters = DEFAULT_CHAPTERS\n}) => {\n  _s();\n  console.log(\"[MotionProvider] Initializing\");\n  const [motionState, setMotionState] = useState({\n    scrollProgress: 0,\n    velocity: 0,\n    currentChapter: \"hero\",\n    chapterProgress: 0\n  });\n  const elementRegistry = useRef(/* @__PURE__ */ new Map());\n  const lenisRef = useRef(null);\n  const registerElement = useCallback(\n    (id, ref) => {\n      console.log(\"[MotionProvider] Registering element:\", id);\n      elementRegistry.current.set(id, ref);\n    },\n    []\n  );\n  const getElement = useCallback((id) => {\n    return elementRegistry.current.get(id);\n  }, []);\n  useEffect(() => {\n    console.log(\"[MotionProvider] Setting up Lenis smooth scrolling\");\n    return;\n    const lenis = new Lenis({\n      duration: 1.2,\n      easing: (t) => Math.min(1, 1.001 - Math.pow(2, -10 * t)),\n      touchMultiplier: 2,\n      infinite: false\n    });\n    lenisRef.current = lenis;\n    lenis.on(\"scroll\", (e) => {\n      const scrollProgress = e.progress;\n      const velocity = e.velocity;\n      const activeChapter = chapters.find(\n        (chapter) => scrollProgress >= chapter.start && scrollProgress < chapter.end\n      ) || chapters[chapters.length - 1];\n      const chapterDuration = activeChapter.end - activeChapter.start;\n      const progressInChapter = chapterDuration > 0 ? (scrollProgress - activeChapter.start) / chapterDuration : 0;\n      setMotionState({\n        scrollProgress,\n        velocity,\n        currentChapter: activeChapter.id,\n        chapterProgress: Math.max(0, Math.min(1, progressInChapter))\n      });\n    });\n    function raf(time) {\n      lenis.raf(time);\n      requestAnimationFrame(raf);\n    }\n    requestAnimationFrame(raf);\n    ScrollTrigger.scrollerProxy(document.body, {\n      scrollTop(value) {\n        if (arguments.length) {\n          lenis.scrollTo(value, { immediate: true });\n        }\n        return lenis.scroll;\n      },\n      getBoundingClientRect() {\n        return {\n          top: 0,\n          left: 0,\n          width: window.innerWidth,\n          height: window.innerHeight\n        };\n      }\n    });\n    const handleResize = () => {\n      lenis.resize();\n      ScrollTrigger.refresh();\n    };\n    window.addEventListener(\"resize\", handleResize);\n    ScrollTrigger.addEventListener(\"refresh\", () => lenis.resize());\n    ScrollTrigger.refresh();\n    const handleVisibilityChange = () => {\n      if (document.hidden) {\n        lenis.stop();\n      } else {\n        lenis.start();\n      }\n    };\n    document.addEventListener(\"visibilitychange\", handleVisibilityChange);\n    return () => {\n      lenis.destroy();\n      window.removeEventListener(\"resize\", handleResize);\n      document.removeEventListener(\"visibilitychange\", handleVisibilityChange);\n      ScrollTrigger.removeEventListener(\"refresh\", () => lenis.resize());\n    };\n  }, [chapters]);\n  useEffect(() => {\n    console.log(\"[MotionProvider] Scroll persistence DISABLED - conflicts with Observer\");\n    return;\n    const saveScrollPosition = () => {\n      if (typeof window !== \"undefined\") {\n        sessionStorage.setItem(\"scroll-position\", String(window.scrollY));\n      }\n    };\n    window.addEventListener(\"beforeunload\", saveScrollPosition);\n    const savedPosition = sessionStorage.getItem(\"scroll-position\");\n    if (savedPosition && lenisRef.current) {\n      const position = parseFloat(savedPosition);\n      setTimeout(() => {\n        lenisRef.current?.scrollTo(position, { immediate: true });\n        sessionStorage.removeItem(\"scroll-position\");\n      }, 100);\n    }\n    return () => {\n      window.removeEventListener(\"beforeunload\", saveScrollPosition);\n    };\n  }, []);\n  const contextValue = {\n    ...motionState,\n    registerElement,\n    getElement\n  };\n  return /* @__PURE__ */ jsxDEV(MotionContext.Provider, { value: contextValue, children }, void 0, false, {\n    fileName: \"/home/will/local_dev/portfolio/packages/motion-system/src/providers/MotionProvider.tsx\",\n    lineNumber: 193,\n    columnNumber: 5\n  }, this);\n};\n_s(MotionProvider, \"VmVfHMK81MISZxGxRanRNQJmk0w=\");\n_c = MotionProvider;\nexport const useMotion = () => {\n  _s2();\n  const context = useContext(MotionContext);\n  if (context === void 0) {\n    throw new Error(\"useMotion must be used within a MotionProvider\");\n  }\n  return context;\n};\n_s2(useMotion, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nvar _c;\n$RefreshReg$(_c, \"MotionProvider\");\nif (import.meta.hot && !inWebWorker) {\n  window.$RefreshReg$ = prevRefreshReg;\n  window.$RefreshSig$ = prevRefreshSig;\n  RefreshRuntime.__hmr_import(import.meta.url).then((currentExports) => {\n    RefreshRuntime.registerExportsForReactRefresh(\"/home/will/local_dev/portfolio/packages/motion-system/src/providers/MotionProvider.tsx\", currentExports);\n    import.meta.hot.accept((nextExports) => {\n      if (!nextExports)\n        return;\n      const invalidateMessage = RefreshRuntime.validateRefreshBoundaryAndEnqueueUpdate(currentExports, nextExports);\n      if (invalidateMessage)\n        import.meta.hot.invalidate(invalidateMessage);\n    });\n  });\n}\n\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJtYXBwaW5ncyI6IkFBZ01JOztBQWhNSixvQkFBWTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBQ1ZBO0FBQUFBLEVBQ0FDO0FBQUFBLEVBQ0FDO0FBQUFBLEVBQ0FDO0FBQUFBLEVBQ0FDO0FBQUFBLEVBR0FDO0FBQUFBLE9BQ0s7QUFDUCxPQUFPQyxXQUFXO0FBQ2xCLFNBQVNDLFlBQVk7QUFDckIsU0FBU0MscUJBQXFCO0FBRzlCRCxLQUFLRSxlQUFlRCxhQUFhO0FBRWpDLE1BQU1FLGdCQUFnQlYsY0FBNkNXLE1BQVM7QUFHNUUsTUFBTUMsbUJBQThCO0FBQUEsRUFDbEMsRUFBRUMsSUFBSSxRQUFRQyxPQUFPLEdBQUdDLEtBQUssS0FBSztBQUFBLEVBQ2xDLEVBQUVGLElBQUksU0FBU0MsT0FBTyxNQUFNQyxLQUFLLElBQUk7QUFBQSxFQUNyQyxFQUFFRixJQUFJLFVBQVVDLE9BQU8sS0FBS0MsS0FBSyxLQUFLO0FBQUEsRUFDdEMsRUFBRUYsSUFBSSxVQUFVQyxPQUFPLE1BQU1DLEtBQUssRUFBSTtBQUFDO0FBUWxDLGFBQU1DLGlCQUFnREEsQ0FBQztBQUFBLEVBQzVEQztBQUFBQSxFQUNBQyxXQUFXTjtBQUNiLE1BQU07QUFBQU8sS0FBQTtBQUNKQyxVQUFRQyxJQUFJLCtCQUErQjtBQUMzQyxRQUFNLENBQUNDLGFBQWFDLGNBQWMsSUFBSXJCLFNBQXNCO0FBQUEsSUFDMURzQixnQkFBZ0I7QUFBQSxJQUNoQkMsVUFBVTtBQUFBLElBQ1ZDLGdCQUFnQjtBQUFBLElBQ2hCQyxpQkFBaUI7QUFBQSxFQUNuQixDQUFDO0FBRUQsUUFBTUMsa0JBQWtCeEIsT0FBNEMsb0JBQUl5QixJQUFJLENBQUM7QUFDN0UsUUFBTUMsV0FBVzFCLE9BQXFCLElBQUk7QUFFMUMsUUFBTTJCLGtCQUFrQjFCO0FBQUFBLElBQ3RCLENBQUNRLElBQVltQixRQUFnQztBQUMzQ1osY0FBUUMsSUFBSSx5Q0FBeUNSLEVBQUU7QUFDdkRlLHNCQUFnQkssUUFBUUMsSUFBSXJCLElBQUltQixHQUFHO0FBQUEsSUFDckM7QUFBQSxJQUNBO0FBQUEsRUFDRjtBQUVBLFFBQU1HLGFBQWE5QixZQUFZLENBQUNRLE9BQWU7QUFDN0MsV0FBT2UsZ0JBQWdCSyxRQUFRRyxJQUFJdkIsRUFBRTtBQUFBLEVBQ3ZDLEdBQUcsRUFBRTtBQUVMVixZQUFVLE1BQU07QUFDZGlCLFlBQVFDLElBQUksb0RBQW9EO0FBRWhFO0FBR0EsVUFBTWdCLFFBQVEsSUFBSS9CLE1BQU07QUFBQSxNQUN0QmdDLFVBQVU7QUFBQSxNQUNWQyxRQUFRQSxDQUFDQyxNQUFNQyxLQUFLQyxJQUFJLEdBQUcsUUFBUUQsS0FBS0UsSUFBSSxHQUFHLE1BQU1ILENBQUMsQ0FBQztBQUFBLE1BQ3ZESSxpQkFBaUI7QUFBQSxNQUNqQkMsVUFBVTtBQUFBLElBQ1osQ0FBQztBQUVEZixhQUFTRyxVQUFVSTtBQUduQkEsVUFBTVMsR0FBRyxVQUFVLENBQUNDLE1BQThDO0FBQ2hFLFlBQU12QixpQkFBaUJ1QixFQUFFQztBQUN6QixZQUFNdkIsV0FBV3NCLEVBQUV0QjtBQUduQixZQUFNd0IsZ0JBQ0ovQixTQUFTZ0M7QUFBQUEsUUFDUCxDQUFDQyxZQUNDM0Isa0JBQWtCMkIsUUFBUXJDLFNBQVNVLGlCQUFpQjJCLFFBQVFwQztBQUFBQSxNQUNoRSxLQUFLRyxTQUFTQSxTQUFTa0MsU0FBUyxDQUFDO0FBR25DLFlBQU1DLGtCQUFrQkosY0FBY2xDLE1BQU1rQyxjQUFjbkM7QUFDMUQsWUFBTXdDLG9CQUNKRCxrQkFBa0IsS0FDYjdCLGlCQUFpQnlCLGNBQWNuQyxTQUFTdUMsa0JBQ3pDO0FBRU45QixxQkFBZTtBQUFBLFFBQ2JDO0FBQUFBLFFBQ0FDO0FBQUFBLFFBQ0FDLGdCQUFnQnVCLGNBQWNwQztBQUFBQSxRQUM5QmMsaUJBQWlCYyxLQUFLYyxJQUFJLEdBQUdkLEtBQUtDLElBQUksR0FBR1ksaUJBQWlCLENBQUM7QUFBQSxNQUM3RCxDQUFDO0FBQUEsSUFDSCxDQUFDO0FBR0QsYUFBU0UsSUFBSUMsTUFBYztBQUN6QnBCLFlBQU1tQixJQUFJQyxJQUFJO0FBQ2RDLDRCQUFzQkYsR0FBRztBQUFBLElBQzNCO0FBRUFFLDBCQUFzQkYsR0FBRztBQUd6QmhELGtCQUFjbUQsY0FBY0MsU0FBU0MsTUFBTTtBQUFBLE1BQ3pDQyxVQUFVQyxPQUFnQjtBQUN4QixZQUFJQyxVQUFVWixRQUFRO0FBQ3BCZixnQkFBTTRCLFNBQVNGLE9BQVEsRUFBRUcsV0FBVyxLQUFLLENBQUM7QUFBQSxRQUM1QztBQUNBLGVBQU83QixNQUFNOEI7QUFBQUEsTUFDZjtBQUFBLE1BQ0FDLHdCQUF3QjtBQUN0QixlQUFPO0FBQUEsVUFDTEMsS0FBSztBQUFBLFVBQ0xDLE1BQU07QUFBQSxVQUNOQyxPQUFPQyxPQUFPQztBQUFBQSxVQUNkQyxRQUFRRixPQUFPRztBQUFBQSxRQUNqQjtBQUFBLE1BQ0Y7QUFBQSxJQUNGLENBQUM7QUFHRCxVQUFNQyxlQUFlQSxNQUFNO0FBQ3pCdkMsWUFBTXdDLE9BQU87QUFDYnJFLG9CQUFjc0UsUUFBUTtBQUFBLElBQ3hCO0FBRUFOLFdBQU9PLGlCQUFpQixVQUFVSCxZQUFZO0FBQzlDcEUsa0JBQWN1RSxpQkFBaUIsV0FBVyxNQUFNMUMsTUFBTXdDLE9BQU8sQ0FBQztBQUM5RHJFLGtCQUFjc0UsUUFBUTtBQUd0QixVQUFNRSx5QkFBeUJBLE1BQU07QUFDbkMsVUFBSXBCLFNBQVNxQixRQUFRO0FBQ25CNUMsY0FBTTZDLEtBQUs7QUFBQSxNQUNiLE9BQU87QUFDTDdDLGNBQU12QixNQUFNO0FBQUEsTUFDZDtBQUFBLElBQ0Y7QUFFQThDLGFBQVNtQixpQkFBaUIsb0JBQW9CQyxzQkFBc0I7QUFHcEUsV0FBTyxNQUFNO0FBQ1gzQyxZQUFNOEMsUUFBUTtBQUNkWCxhQUFPWSxvQkFBb0IsVUFBVVIsWUFBWTtBQUNqRGhCLGVBQVN3QixvQkFBb0Isb0JBQW9CSixzQkFBc0I7QUFDdkV4RSxvQkFBYzRFLG9CQUFvQixXQUFXLE1BQU0vQyxNQUFNd0MsT0FBTyxDQUFDO0FBQUEsSUFDbkU7QUFBQSxFQUNGLEdBQUcsQ0FBQzNELFFBQVEsQ0FBQztBQUdiZixZQUFVLE1BQU07QUFDZGlCLFlBQVFDLElBQUksd0VBQXdFO0FBQ3BGO0FBRUEsVUFBTWdFLHFCQUFxQkEsTUFBTTtBQUMvQixVQUFJLE9BQU9iLFdBQVcsYUFBYTtBQUNqQ2MsdUJBQWVDLFFBQVEsbUJBQW1CQyxPQUFPaEIsT0FBT2lCLE9BQU8sQ0FBQztBQUFBLE1BQ2xFO0FBQUEsSUFDRjtBQUVBakIsV0FBT08saUJBQWlCLGdCQUFnQk0sa0JBQWtCO0FBRzFELFVBQU1LLGdCQUFnQkosZUFBZUssUUFBUSxpQkFBaUI7QUFDOUQsUUFBSUQsaUJBQWlCNUQsU0FBU0csU0FBUztBQUNyQyxZQUFNMkQsV0FBV0MsV0FBV0gsYUFBYTtBQUN6Q0ksaUJBQVcsTUFBTTtBQUNmaEUsaUJBQVNHLFNBQVNnQyxTQUFTMkIsVUFBVSxFQUFFMUIsV0FBVyxLQUFLLENBQUM7QUFDeERvQix1QkFBZVMsV0FBVyxpQkFBaUI7QUFBQSxNQUM3QyxHQUFHLEdBQUc7QUFBQSxJQUNSO0FBRUEsV0FBTyxNQUFNO0FBQ1h2QixhQUFPWSxvQkFBb0IsZ0JBQWdCQyxrQkFBa0I7QUFBQSxJQUMvRDtBQUFBLEVBQ0YsR0FBRyxFQUFFO0FBRUwsUUFBTVcsZUFBa0M7QUFBQSxJQUN0QyxHQUFHMUU7QUFBQUEsSUFDSFM7QUFBQUEsSUFDQUk7QUFBQUEsRUFDRjtBQUVBLFNBQ0UsdUJBQUMsY0FBYyxVQUFkLEVBQXVCLE9BQU82RCxjQUM1Qi9FLFlBREg7QUFBQTtBQUFBO0FBQUE7QUFBQSxTQUVBO0FBRUo7QUFFQUUsR0F0S2FILGdCQUE2QztBQUFBaUYsS0FBN0NqRjtBQXVLTixhQUFNa0YsWUFBWUEsTUFBTTtBQUFBQyxNQUFBO0FBQzdCLFFBQU1DLFVBQVVuRyxXQUFXUyxhQUFhO0FBQ3hDLE1BQUkwRixZQUFZekYsUUFBVztBQUN6QixVQUFNLElBQUkwRixNQUFNLGdEQUFnRDtBQUFBLEVBQ2xFO0FBQ0EsU0FBT0Q7QUFDVDtBQUFDRCxJQU5ZRCxXQUFTO0FBQUEsSUFBQUQ7QUFBQUssYUFBQUwsSUFBQSIsIm5hbWVzIjpbImNyZWF0ZUNvbnRleHQiLCJ1c2VDb250ZXh0IiwidXNlU3RhdGUiLCJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJ1c2VDYWxsYmFjayIsIkxlbmlzIiwiZ3NhcCIsIlNjcm9sbFRyaWdnZXIiLCJyZWdpc3RlclBsdWdpbiIsIk1vdGlvbkNvbnRleHQiLCJ1bmRlZmluZWQiLCJERUZBVUxUX0NIQVBURVJTIiwiaWQiLCJzdGFydCIsImVuZCIsIk1vdGlvblByb3ZpZGVyIiwiY2hpbGRyZW4iLCJjaGFwdGVycyIsIl9zIiwiY29uc29sZSIsImxvZyIsIm1vdGlvblN0YXRlIiwic2V0TW90aW9uU3RhdGUiLCJzY3JvbGxQcm9ncmVzcyIsInZlbG9jaXR5IiwiY3VycmVudENoYXB0ZXIiLCJjaGFwdGVyUHJvZ3Jlc3MiLCJlbGVtZW50UmVnaXN0cnkiLCJNYXAiLCJsZW5pc1JlZiIsInJlZ2lzdGVyRWxlbWVudCIsInJlZiIsImN1cnJlbnQiLCJzZXQiLCJnZXRFbGVtZW50IiwiZ2V0IiwibGVuaXMiLCJkdXJhdGlvbiIsImVhc2luZyIsInQiLCJNYXRoIiwibWluIiwicG93IiwidG91Y2hNdWx0aXBsaWVyIiwiaW5maW5pdGUiLCJvbiIsImUiLCJwcm9ncmVzcyIsImFjdGl2ZUNoYXB0ZXIiLCJmaW5kIiwiY2hhcHRlciIsImxlbmd0aCIsImNoYXB0ZXJEdXJhdGlvbiIsInByb2dyZXNzSW5DaGFwdGVyIiwibWF4IiwicmFmIiwidGltZSIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsInNjcm9sbGVyUHJveHkiLCJkb2N1bWVudCIsImJvZHkiLCJzY3JvbGxUb3AiLCJ2YWx1ZSIsImFyZ3VtZW50cyIsInNjcm9sbFRvIiwiaW1tZWRpYXRlIiwic2Nyb2xsIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwidG9wIiwibGVmdCIsIndpZHRoIiwid2luZG93IiwiaW5uZXJXaWR0aCIsImhlaWdodCIsImlubmVySGVpZ2h0IiwiaGFuZGxlUmVzaXplIiwicmVzaXplIiwicmVmcmVzaCIsImFkZEV2ZW50TGlzdGVuZXIiLCJoYW5kbGVWaXNpYmlsaXR5Q2hhbmdlIiwiaGlkZGVuIiwic3RvcCIsImRlc3Ryb3kiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwic2F2ZVNjcm9sbFBvc2l0aW9uIiwic2Vzc2lvblN0b3JhZ2UiLCJzZXRJdGVtIiwiU3RyaW5nIiwic2Nyb2xsWSIsInNhdmVkUG9zaXRpb24iLCJnZXRJdGVtIiwicG9zaXRpb24iLCJwYXJzZUZsb2F0Iiwic2V0VGltZW91dCIsInJlbW92ZUl0ZW0iLCJjb250ZXh0VmFsdWUiLCJfYyIsInVzZU1vdGlvbiIsIl9zMiIsImNvbnRleHQiLCJFcnJvciIsIiRSZWZyZXNoUmVnJCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlcyI6WyJNb3Rpb25Qcm92aWRlci50c3giXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0LCB7XG4gIGNyZWF0ZUNvbnRleHQsXG4gIHVzZUNvbnRleHQsXG4gIHVzZVN0YXRlLFxuICB1c2VFZmZlY3QsXG4gIHVzZVJlZixcbiAgUmVhY3ROb2RlLFxuICBSZWZPYmplY3QsXG4gIHVzZUNhbGxiYWNrLFxufSBmcm9tICdyZWFjdCdcbmltcG9ydCBMZW5pcyBmcm9tICdsZW5pcydcbmltcG9ydCB7IGdzYXAgfSBmcm9tICdnc2FwJ1xuaW1wb3J0IHsgU2Nyb2xsVHJpZ2dlciB9IGZyb20gJ2dzYXAvU2Nyb2xsVHJpZ2dlcidcbmltcG9ydCB7IE1vdGlvblN0YXRlLCBNb3Rpb25Db250ZXh0VHlwZSwgQ2hhcHRlciB9IGZyb20gJy4uL3R5cGVzJ1xuXG5nc2FwLnJlZ2lzdGVyUGx1Z2luKFNjcm9sbFRyaWdnZXIpXG5cbmNvbnN0IE1vdGlvbkNvbnRleHQgPSBjcmVhdGVDb250ZXh0PE1vdGlvbkNvbnRleHRUeXBlIHwgdW5kZWZpbmVkPih1bmRlZmluZWQpXG5cbi8vIERlZmluZSBjaGFwdGVyIGNvbmZpZ3VyYXRpb24gZm9yIHRoZSBzY3JvbGwgbmFycmF0aXZlXG5jb25zdCBERUZBVUxUX0NIQVBURVJTOiBDaGFwdGVyW10gPSBbXG4gIHsgaWQ6ICdoZXJvJywgc3RhcnQ6IDAsIGVuZDogMC4yNSB9LFxuICB7IGlkOiAnbW9ycGgnLCBzdGFydDogMC4yNSwgZW5kOiAwLjUgfSxcbiAgeyBpZDogJ3N0aWNreScsIHN0YXJ0OiAwLjUsIGVuZDogMC43NSB9LFxuICB7IGlkOiAnZm9vdGVyJywgc3RhcnQ6IDAuNzUsIGVuZDogMS4wIH0sXG5dXG5cbmludGVyZmFjZSBNb3Rpb25Qcm92aWRlclByb3BzIHtcbiAgY2hpbGRyZW46IFJlYWN0Tm9kZVxuICBjaGFwdGVycz86IENoYXB0ZXJbXVxufVxuXG5leHBvcnQgY29uc3QgTW90aW9uUHJvdmlkZXI6IFJlYWN0LkZDPE1vdGlvblByb3ZpZGVyUHJvcHM+ID0gKHtcbiAgY2hpbGRyZW4sXG4gIGNoYXB0ZXJzID0gREVGQVVMVF9DSEFQVEVSUyxcbn0pID0+IHtcbiAgY29uc29sZS5sb2coJ1tNb3Rpb25Qcm92aWRlcl0gSW5pdGlhbGl6aW5nJylcbiAgY29uc3QgW21vdGlvblN0YXRlLCBzZXRNb3Rpb25TdGF0ZV0gPSB1c2VTdGF0ZTxNb3Rpb25TdGF0ZT4oe1xuICAgIHNjcm9sbFByb2dyZXNzOiAwLFxuICAgIHZlbG9jaXR5OiAwLFxuICAgIGN1cnJlbnRDaGFwdGVyOiAnaGVybycsXG4gICAgY2hhcHRlclByb2dyZXNzOiAwLFxuICB9KVxuXG4gIGNvbnN0IGVsZW1lbnRSZWdpc3RyeSA9IHVzZVJlZjxNYXA8c3RyaW5nLCBSZWZPYmplY3Q8SFRNTEVsZW1lbnQ+Pj4obmV3IE1hcCgpKVxuICBjb25zdCBsZW5pc1JlZiA9IHVzZVJlZjxMZW5pcyB8IG51bGw+KG51bGwpXG5cbiAgY29uc3QgcmVnaXN0ZXJFbGVtZW50ID0gdXNlQ2FsbGJhY2soXG4gICAgKGlkOiBzdHJpbmcsIHJlZjogUmVmT2JqZWN0PEhUTUxFbGVtZW50PikgPT4ge1xuICAgICAgY29uc29sZS5sb2coJ1tNb3Rpb25Qcm92aWRlcl0gUmVnaXN0ZXJpbmcgZWxlbWVudDonLCBpZClcbiAgICAgIGVsZW1lbnRSZWdpc3RyeS5jdXJyZW50LnNldChpZCwgcmVmKVxuICAgIH0sXG4gICAgW11cbiAgKVxuXG4gIGNvbnN0IGdldEVsZW1lbnQgPSB1c2VDYWxsYmFjaygoaWQ6IHN0cmluZykgPT4ge1xuICAgIHJldHVybiBlbGVtZW50UmVnaXN0cnkuY3VycmVudC5nZXQoaWQpXG4gIH0sIFtdKVxuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc29sZS5sb2coJ1tNb3Rpb25Qcm92aWRlcl0gU2V0dGluZyB1cCBMZW5pcyBzbW9vdGggc2Nyb2xsaW5nJylcbiAgICAvLyBESVNBQkxFRDogTGVuaXMgY29uZmxpY3RzIHdpdGggT2JzZXJ2ZXIgcGF0dGVyblxuICAgIHJldHVybiAvLyBFQVJMWSBSRVRVUk4gLSBza2lwIExlbmlzIHNldHVwXG4gICAgXG4gICAgLy8gSW5pdGlhbGl6ZSBMZW5pcyBmb3Igc21vb3RoIHNjcm9sbGluZ1xuICAgIGNvbnN0IGxlbmlzID0gbmV3IExlbmlzKHtcbiAgICAgIGR1cmF0aW9uOiAxLjIsXG4gICAgICBlYXNpbmc6ICh0KSA9PiBNYXRoLm1pbigxLCAxLjAwMSAtIE1hdGgucG93KDIsIC0xMCAqIHQpKSxcbiAgICAgIHRvdWNoTXVsdGlwbGllcjogMixcbiAgICAgIGluZmluaXRlOiBmYWxzZSxcbiAgICB9KVxuXG4gICAgbGVuaXNSZWYuY3VycmVudCA9IGxlbmlzXG5cbiAgICAvLyBIYW5kbGUgc2Nyb2xsIHVwZGF0ZXNcbiAgICBsZW5pcy5vbignc2Nyb2xsJywgKGU6IHsgcHJvZ3Jlc3M6IG51bWJlcjsgdmVsb2NpdHk6IG51bWJlciB9KSA9PiB7XG4gICAgICBjb25zdCBzY3JvbGxQcm9ncmVzcyA9IGUucHJvZ3Jlc3NcbiAgICAgIGNvbnN0IHZlbG9jaXR5ID0gZS52ZWxvY2l0eVxuXG4gICAgICAvLyBGaW5kIGFjdGl2ZSBjaGFwdGVyXG4gICAgICBjb25zdCBhY3RpdmVDaGFwdGVyID1cbiAgICAgICAgY2hhcHRlcnMuZmluZChcbiAgICAgICAgICAoY2hhcHRlcikgPT5cbiAgICAgICAgICAgIHNjcm9sbFByb2dyZXNzID49IGNoYXB0ZXIuc3RhcnQgJiYgc2Nyb2xsUHJvZ3Jlc3MgPCBjaGFwdGVyLmVuZFxuICAgICAgICApIHx8IGNoYXB0ZXJzW2NoYXB0ZXJzLmxlbmd0aCAtIDFdXG5cbiAgICAgIC8vIENhbGN1bGF0ZSBwcm9ncmVzcyB3aXRoaW4gY2hhcHRlclxuICAgICAgY29uc3QgY2hhcHRlckR1cmF0aW9uID0gYWN0aXZlQ2hhcHRlci5lbmQgLSBhY3RpdmVDaGFwdGVyLnN0YXJ0XG4gICAgICBjb25zdCBwcm9ncmVzc0luQ2hhcHRlciA9XG4gICAgICAgIGNoYXB0ZXJEdXJhdGlvbiA+IDBcbiAgICAgICAgICA/IChzY3JvbGxQcm9ncmVzcyAtIGFjdGl2ZUNoYXB0ZXIuc3RhcnQpIC8gY2hhcHRlckR1cmF0aW9uXG4gICAgICAgICAgOiAwXG5cbiAgICAgIHNldE1vdGlvblN0YXRlKHtcbiAgICAgICAgc2Nyb2xsUHJvZ3Jlc3MsXG4gICAgICAgIHZlbG9jaXR5LFxuICAgICAgICBjdXJyZW50Q2hhcHRlcjogYWN0aXZlQ2hhcHRlci5pZCxcbiAgICAgICAgY2hhcHRlclByb2dyZXNzOiBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCBwcm9ncmVzc0luQ2hhcHRlcikpLFxuICAgICAgfSlcbiAgICB9KVxuXG4gICAgLy8gQW5pbWF0aW9uIGZyYW1lIGxvb3BcbiAgICBmdW5jdGlvbiByYWYodGltZTogbnVtYmVyKSB7XG4gICAgICBsZW5pcy5yYWYodGltZSlcbiAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShyYWYpXG4gICAgfVxuXG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHJhZilcblxuICAgIC8vIEludGVncmF0ZSBMZW5pcyB3aXRoIEdTQVAgU2Nyb2xsVHJpZ2dlclxuICAgIFNjcm9sbFRyaWdnZXIuc2Nyb2xsZXJQcm94eShkb2N1bWVudC5ib2R5LCB7XG4gICAgICBzY3JvbGxUb3AodmFsdWU/OiBudW1iZXIpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICBsZW5pcy5zY3JvbGxUbyh2YWx1ZSEsIHsgaW1tZWRpYXRlOiB0cnVlIH0pXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxlbmlzLnNjcm9sbFxuICAgICAgfSxcbiAgICAgIGdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0b3A6IDAsXG4gICAgICAgICAgbGVmdDogMCxcbiAgICAgICAgICB3aWR0aDogd2luZG93LmlubmVyV2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiB3aW5kb3cuaW5uZXJIZWlnaHQsXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgfSlcblxuICAgIC8vIEhhbmRsZSByZXNpemVcbiAgICBjb25zdCBoYW5kbGVSZXNpemUgPSAoKSA9PiB7XG4gICAgICBsZW5pcy5yZXNpemUoKVxuICAgICAgU2Nyb2xsVHJpZ2dlci5yZWZyZXNoKClcbiAgICB9XG5cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgaGFuZGxlUmVzaXplKVxuICAgIFNjcm9sbFRyaWdnZXIuYWRkRXZlbnRMaXN0ZW5lcigncmVmcmVzaCcsICgpID0+IGxlbmlzLnJlc2l6ZSgpKVxuICAgIFNjcm9sbFRyaWdnZXIucmVmcmVzaCgpXG5cbiAgICAvLyBIYW5kbGUgcGFnZSB2aXNpYmlsaXR5IGZvciBwZXJmb3JtYW5jZVxuICAgIGNvbnN0IGhhbmRsZVZpc2liaWxpdHlDaGFuZ2UgPSAoKSA9PiB7XG4gICAgICBpZiAoZG9jdW1lbnQuaGlkZGVuKSB7XG4gICAgICAgIGxlbmlzLnN0b3AoKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGVuaXMuc3RhcnQoKVxuICAgICAgfVxuICAgIH1cblxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Zpc2liaWxpdHljaGFuZ2UnLCBoYW5kbGVWaXNpYmlsaXR5Q2hhbmdlKVxuXG4gICAgLy8gQ2xlYW51cFxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBsZW5pcy5kZXN0cm95KClcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCBoYW5kbGVSZXNpemUpXG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd2aXNpYmlsaXR5Y2hhbmdlJywgaGFuZGxlVmlzaWJpbGl0eUNoYW5nZSlcbiAgICAgIFNjcm9sbFRyaWdnZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVmcmVzaCcsICgpID0+IGxlbmlzLnJlc2l6ZSgpKVxuICAgIH1cbiAgfSwgW2NoYXB0ZXJzXSlcblxuICAvLyBESVNBQkxFRDogU2Nyb2xsIHBlcnNpc3RlbmNlIGNvbmZsaWN0cyB3aXRoIE9ic2VydmVyIHBhdHRlcm5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zb2xlLmxvZygnW01vdGlvblByb3ZpZGVyXSBTY3JvbGwgcGVyc2lzdGVuY2UgRElTQUJMRUQgLSBjb25mbGljdHMgd2l0aCBPYnNlcnZlcicpXG4gICAgcmV0dXJuIC8vIEVBUkxZIFJFVFVSTiAtIHNraXAgc2Nyb2xsIHBlcnNpc3RlbmNlXG4gICAgXG4gICAgY29uc3Qgc2F2ZVNjcm9sbFBvc2l0aW9uID0gKCkgPT4ge1xuICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHNlc3Npb25TdG9yYWdlLnNldEl0ZW0oJ3Njcm9sbC1wb3NpdGlvbicsIFN0cmluZyh3aW5kb3cuc2Nyb2xsWSkpXG4gICAgICB9XG4gICAgfVxuXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2JlZm9yZXVubG9hZCcsIHNhdmVTY3JvbGxQb3NpdGlvbilcblxuICAgIC8vIFJlc3RvcmUgc2Nyb2xsIHBvc2l0aW9uXG4gICAgY29uc3Qgc2F2ZWRQb3NpdGlvbiA9IHNlc3Npb25TdG9yYWdlLmdldEl0ZW0oJ3Njcm9sbC1wb3NpdGlvbicpXG4gICAgaWYgKHNhdmVkUG9zaXRpb24gJiYgbGVuaXNSZWYuY3VycmVudCkge1xuICAgICAgY29uc3QgcG9zaXRpb24gPSBwYXJzZUZsb2F0KHNhdmVkUG9zaXRpb24pXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgbGVuaXNSZWYuY3VycmVudD8uc2Nyb2xsVG8ocG9zaXRpb24sIHsgaW1tZWRpYXRlOiB0cnVlIH0pXG4gICAgICAgIHNlc3Npb25TdG9yYWdlLnJlbW92ZUl0ZW0oJ3Njcm9sbC1wb3NpdGlvbicpXG4gICAgICB9LCAxMDApXG4gICAgfVxuXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdiZWZvcmV1bmxvYWQnLCBzYXZlU2Nyb2xsUG9zaXRpb24pXG4gICAgfVxuICB9LCBbXSlcblxuICBjb25zdCBjb250ZXh0VmFsdWU6IE1vdGlvbkNvbnRleHRUeXBlID0ge1xuICAgIC4uLm1vdGlvblN0YXRlLFxuICAgIHJlZ2lzdGVyRWxlbWVudCxcbiAgICBnZXRFbGVtZW50LFxuICB9XG5cbiAgcmV0dXJuIChcbiAgICA8TW90aW9uQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17Y29udGV4dFZhbHVlfT5cbiAgICAgIHtjaGlsZHJlbn1cbiAgICA8L01vdGlvbkNvbnRleHQuUHJvdmlkZXI+XG4gIClcbn1cblxuLy8gQ3VzdG9tIGhvb2sgZm9yIGNvbnN1bWluZyBtb3Rpb24gY29udGV4dFxuZXhwb3J0IGNvbnN0IHVzZU1vdGlvbiA9ICgpID0+IHtcbiAgY29uc3QgY29udGV4dCA9IHVzZUNvbnRleHQoTW90aW9uQ29udGV4dClcbiAgaWYgKGNvbnRleHQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBFcnJvcigndXNlTW90aW9uIG11c3QgYmUgdXNlZCB3aXRoaW4gYSBNb3Rpb25Qcm92aWRlcicpXG4gIH1cbiAgcmV0dXJuIGNvbnRleHRcbn1cbiJdLCJmaWxlIjoiL2hvbWUvd2lsbC9sb2NhbF9kZXYvcG9ydGZvbGlvL3BhY2thZ2VzL21vdGlvbi1zeXN0ZW0vc3JjL3Byb3ZpZGVycy9Nb3Rpb25Qcm92aWRlci50c3gifQ==",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 21795,
            "count": 1
          },
          {
            "startOffset": 501,
            "endOffset": 537,
            "count": 0
          },
          {
            "startOffset": 674,
            "endOffset": 845,
            "count": 0
          }
        ]
      },
      {
        "functionName": "window.$RefreshReg$",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 950,
            "endOffset": 1100,
            "count": 1
          }
        ]
      },
      {
        "functionName": "MotionProvider",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 2197,
            "endOffset": 6201,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 2591,
            "endOffset": 2719,
            "count": 10
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 2766,
            "endOffset": 2823,
            "count": 10
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 2842,
            "endOffset": 5037,
            "count": 2
          },
          {
            "startOffset": 2932,
            "endOffset": 5036,
            "count": 0
          }
        ]
      },
      {
        "functionName": "raf",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 3797,
            "endOffset": 3880,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5064,
            "endOffset": 5842,
            "count": 2
          },
          {
            "startOffset": 5174,
            "endOffset": 5841,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useMotion",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 6301,
            "endOffset": 6485,
            "count": 4
          },
          {
            "startOffset": 6389,
            "endOffset": 6465,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 6750,
            "endOffset": 7227,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 6956,
            "endOffset": 7221,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5173/node_modules/.vite/deps/chunk-JIUMHI3X.js?v=a50bb159",
    "scriptId": "33",
    "source": "// ../../node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/Observer.js\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor)\n      descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps)\n    _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps)\n    _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\nvar gsap;\nvar _coreInitted;\nvar _clamp;\nvar _win;\nvar _doc;\nvar _docEl;\nvar _body;\nvar _isTouch;\nvar _pointerType;\nvar ScrollTrigger;\nvar _root;\nvar _normalizer;\nvar _eventTypes;\nvar _context;\nvar _getGSAP = function _getGSAP2() {\n  return gsap || typeof window !== \"undefined\" && (gsap = window.gsap) && gsap.registerPlugin && gsap;\n};\nvar _startup = 1;\nvar _observers = [];\nvar _scrollers = [];\nvar _proxies = [];\nvar _getTime = Date.now;\nvar _bridge = function _bridge2(name, value) {\n  return value;\n};\nvar _integrate = function _integrate2() {\n  var core = ScrollTrigger.core, data = core.bridge || {}, scrollers = core._scrollers, proxies = core._proxies;\n  scrollers.push.apply(scrollers, _scrollers);\n  proxies.push.apply(proxies, _proxies);\n  _scrollers = scrollers;\n  _proxies = proxies;\n  _bridge = function _bridge3(name, value) {\n    return data[name](value);\n  };\n};\nvar _getProxyProp = function _getProxyProp2(element, property) {\n  return ~_proxies.indexOf(element) && _proxies[_proxies.indexOf(element) + 1][property];\n};\nvar _isViewport = function _isViewport2(el) {\n  return !!~_root.indexOf(el);\n};\nvar _addListener = function _addListener2(element, type, func, passive, capture) {\n  return element.addEventListener(type, func, {\n    passive: passive !== false,\n    capture: !!capture\n  });\n};\nvar _removeListener = function _removeListener2(element, type, func, capture) {\n  return element.removeEventListener(type, func, !!capture);\n};\nvar _scrollLeft = \"scrollLeft\";\nvar _scrollTop = \"scrollTop\";\nvar _onScroll = function _onScroll2() {\n  return _normalizer && _normalizer.isPressed || _scrollers.cache++;\n};\nvar _scrollCacheFunc = function _scrollCacheFunc2(f, doNotCache) {\n  var cachingFunc = function cachingFunc2(value) {\n    if (value || value === 0) {\n      _startup && (_win.history.scrollRestoration = \"manual\");\n      var isNormalizing = _normalizer && _normalizer.isPressed;\n      value = cachingFunc2.v = Math.round(value) || (_normalizer && _normalizer.iOS ? 1 : 0);\n      f(value);\n      cachingFunc2.cacheID = _scrollers.cache;\n      isNormalizing && _bridge(\"ss\", value);\n    } else if (doNotCache || _scrollers.cache !== cachingFunc2.cacheID || _bridge(\"ref\")) {\n      cachingFunc2.cacheID = _scrollers.cache;\n      cachingFunc2.v = f();\n    }\n    return cachingFunc2.v + cachingFunc2.offset;\n  };\n  cachingFunc.offset = 0;\n  return f && cachingFunc;\n};\nvar _horizontal = {\n  s: _scrollLeft,\n  p: \"left\",\n  p2: \"Left\",\n  os: \"right\",\n  os2: \"Right\",\n  d: \"width\",\n  d2: \"Width\",\n  a: \"x\",\n  sc: _scrollCacheFunc(function(value) {\n    return arguments.length ? _win.scrollTo(value, _vertical.sc()) : _win.pageXOffset || _doc[_scrollLeft] || _docEl[_scrollLeft] || _body[_scrollLeft] || 0;\n  })\n};\nvar _vertical = {\n  s: _scrollTop,\n  p: \"top\",\n  p2: \"Top\",\n  os: \"bottom\",\n  os2: \"Bottom\",\n  d: \"height\",\n  d2: \"Height\",\n  a: \"y\",\n  op: _horizontal,\n  sc: _scrollCacheFunc(function(value) {\n    return arguments.length ? _win.scrollTo(_horizontal.sc(), value) : _win.pageYOffset || _doc[_scrollTop] || _docEl[_scrollTop] || _body[_scrollTop] || 0;\n  })\n};\nvar _getTarget = function _getTarget2(t, self) {\n  return (self && self._ctx && self._ctx.selector || gsap.utils.toArray)(t)[0] || (typeof t === \"string\" && gsap.config().nullTargetWarn !== false ? console.warn(\"Element not found:\", t) : null);\n};\nvar _getScrollFunc = function _getScrollFunc2(element, _ref) {\n  var s = _ref.s, sc = _ref.sc;\n  _isViewport(element) && (element = _doc.scrollingElement || _docEl);\n  var i = _scrollers.indexOf(element), offset = sc === _vertical.sc ? 1 : 2;\n  !~i && (i = _scrollers.push(element) - 1);\n  _scrollers[i + offset] || _addListener(element, \"scroll\", _onScroll);\n  var prev = _scrollers[i + offset], func = prev || (_scrollers[i + offset] = _scrollCacheFunc(_getProxyProp(element, s), true) || (_isViewport(element) ? sc : _scrollCacheFunc(function(value) {\n    return arguments.length ? element[s] = value : element[s];\n  })));\n  func.target = element;\n  prev || (func.smooth = gsap.getProperty(element, \"scrollBehavior\") === \"smooth\");\n  return func;\n};\nvar _getVelocityProp = function _getVelocityProp2(value, minTimeRefresh, useDelta) {\n  var v1 = value, v2 = value, t1 = _getTime(), t2 = t1, min = minTimeRefresh || 50, dropToZeroTime = Math.max(500, min * 3), update = function update2(value2, force) {\n    var t = _getTime();\n    if (force || t - t1 > min) {\n      v2 = v1;\n      v1 = value2;\n      t2 = t1;\n      t1 = t;\n    } else if (useDelta) {\n      v1 += value2;\n    } else {\n      v1 = v2 + (value2 - v2) / (t - t2) * (t1 - t2);\n    }\n  }, reset = function reset2() {\n    v2 = v1 = useDelta ? 0 : v1;\n    t2 = t1 = 0;\n  }, getVelocity = function getVelocity2(latestValue) {\n    var tOld = t2, vOld = v2, t = _getTime();\n    (latestValue || latestValue === 0) && latestValue !== v1 && update(latestValue);\n    return t1 === t2 || t - t2 > dropToZeroTime ? 0 : (v1 + (useDelta ? vOld : -vOld)) / ((useDelta ? t : t1) - tOld) * 1e3;\n  };\n  return {\n    update,\n    reset,\n    getVelocity\n  };\n};\nvar _getEvent = function _getEvent2(e, preventDefault) {\n  preventDefault && !e._gsapAllow && e.preventDefault();\n  return e.changedTouches ? e.changedTouches[0] : e;\n};\nvar _getAbsoluteMax = function _getAbsoluteMax2(a) {\n  var max = Math.max.apply(Math, a), min = Math.min.apply(Math, a);\n  return Math.abs(max) >= Math.abs(min) ? max : min;\n};\nvar _setScrollTrigger = function _setScrollTrigger2() {\n  ScrollTrigger = gsap.core.globals().ScrollTrigger;\n  ScrollTrigger && ScrollTrigger.core && _integrate();\n};\nvar _initCore = function _initCore2(core) {\n  gsap = core || _getGSAP();\n  if (!_coreInitted && gsap && typeof document !== \"undefined\" && document.body) {\n    _win = window;\n    _doc = document;\n    _docEl = _doc.documentElement;\n    _body = _doc.body;\n    _root = [_win, _doc, _docEl, _body];\n    _clamp = gsap.utils.clamp;\n    _context = gsap.core.context || function() {\n    };\n    _pointerType = \"onpointerenter\" in _body ? \"pointer\" : \"mouse\";\n    _isTouch = Observer.isTouch = _win.matchMedia && _win.matchMedia(\"(hover: none), (pointer: coarse)\").matches ? 1 : \"ontouchstart\" in _win || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0 ? 2 : 0;\n    _eventTypes = Observer.eventTypes = (\"ontouchstart\" in _docEl ? \"touchstart,touchmove,touchcancel,touchend\" : !(\"onpointerdown\" in _docEl) ? \"mousedown,mousemove,mouseup,mouseup\" : \"pointerdown,pointermove,pointercancel,pointerup\").split(\",\");\n    setTimeout(function() {\n      return _startup = 0;\n    }, 500);\n    _setScrollTrigger();\n    _coreInitted = 1;\n  }\n  return _coreInitted;\n};\n_horizontal.op = _vertical;\n_scrollers.cache = 0;\nvar Observer = function() {\n  function Observer2(vars) {\n    this.init(vars);\n  }\n  var _proto = Observer2.prototype;\n  _proto.init = function init(vars) {\n    _coreInitted || _initCore(gsap) || console.warn(\"Please gsap.registerPlugin(Observer)\");\n    ScrollTrigger || _setScrollTrigger();\n    var tolerance = vars.tolerance, dragMinimum = vars.dragMinimum, type = vars.type, target = vars.target, lineHeight = vars.lineHeight, debounce = vars.debounce, preventDefault = vars.preventDefault, onStop = vars.onStop, onStopDelay = vars.onStopDelay, ignore = vars.ignore, wheelSpeed = vars.wheelSpeed, event = vars.event, onDragStart = vars.onDragStart, onDragEnd = vars.onDragEnd, onDrag = vars.onDrag, onPress = vars.onPress, onRelease = vars.onRelease, onRight = vars.onRight, onLeft = vars.onLeft, onUp = vars.onUp, onDown = vars.onDown, onChangeX = vars.onChangeX, onChangeY = vars.onChangeY, onChange = vars.onChange, onToggleX = vars.onToggleX, onToggleY = vars.onToggleY, onHover = vars.onHover, onHoverEnd = vars.onHoverEnd, onMove = vars.onMove, ignoreCheck = vars.ignoreCheck, isNormalizer = vars.isNormalizer, onGestureStart = vars.onGestureStart, onGestureEnd = vars.onGestureEnd, onWheel = vars.onWheel, onEnable = vars.onEnable, onDisable = vars.onDisable, onClick = vars.onClick, scrollSpeed = vars.scrollSpeed, capture = vars.capture, allowClicks = vars.allowClicks, lockAxis = vars.lockAxis, onLockAxis = vars.onLockAxis;\n    this.target = target = _getTarget(target) || _docEl;\n    this.vars = vars;\n    ignore && (ignore = gsap.utils.toArray(ignore));\n    tolerance = tolerance || 1e-9;\n    dragMinimum = dragMinimum || 0;\n    wheelSpeed = wheelSpeed || 1;\n    scrollSpeed = scrollSpeed || 1;\n    type = type || \"wheel,touch,pointer\";\n    debounce = debounce !== false;\n    lineHeight || (lineHeight = parseFloat(_win.getComputedStyle(_body).lineHeight) || 22);\n    var id, onStopDelayedCall, dragged, moved, wheeled, locked, axis, self = this, prevDeltaX = 0, prevDeltaY = 0, passive = vars.passive || !preventDefault, scrollFuncX = _getScrollFunc(target, _horizontal), scrollFuncY = _getScrollFunc(target, _vertical), scrollX = scrollFuncX(), scrollY = scrollFuncY(), limitToTouch = ~type.indexOf(\"touch\") && !~type.indexOf(\"pointer\") && _eventTypes[0] === \"pointerdown\", isViewport = _isViewport(target), ownerDoc = target.ownerDocument || _doc, deltaX = [0, 0, 0], deltaY = [0, 0, 0], onClickTime = 0, clickCapture = function clickCapture2() {\n      return onClickTime = _getTime();\n    }, _ignoreCheck = function _ignoreCheck2(e, isPointerOrTouch) {\n      return (self.event = e) && ignore && ~ignore.indexOf(e.target) || isPointerOrTouch && limitToTouch && e.pointerType !== \"touch\" || ignoreCheck && ignoreCheck(e, isPointerOrTouch);\n    }, onStopFunc = function onStopFunc2() {\n      self._vx.reset();\n      self._vy.reset();\n      onStopDelayedCall.pause();\n      onStop && onStop(self);\n    }, update = function update2() {\n      var dx = self.deltaX = _getAbsoluteMax(deltaX), dy = self.deltaY = _getAbsoluteMax(deltaY), changedX = Math.abs(dx) >= tolerance, changedY = Math.abs(dy) >= tolerance;\n      onChange && (changedX || changedY) && onChange(self, dx, dy, deltaX, deltaY);\n      if (changedX) {\n        onRight && self.deltaX > 0 && onRight(self);\n        onLeft && self.deltaX < 0 && onLeft(self);\n        onChangeX && onChangeX(self);\n        onToggleX && self.deltaX < 0 !== prevDeltaX < 0 && onToggleX(self);\n        prevDeltaX = self.deltaX;\n        deltaX[0] = deltaX[1] = deltaX[2] = 0;\n      }\n      if (changedY) {\n        onDown && self.deltaY > 0 && onDown(self);\n        onUp && self.deltaY < 0 && onUp(self);\n        onChangeY && onChangeY(self);\n        onToggleY && self.deltaY < 0 !== prevDeltaY < 0 && onToggleY(self);\n        prevDeltaY = self.deltaY;\n        deltaY[0] = deltaY[1] = deltaY[2] = 0;\n      }\n      if (moved || dragged) {\n        onMove && onMove(self);\n        if (dragged) {\n          onDrag(self);\n          dragged = false;\n        }\n        moved = false;\n      }\n      locked && !(locked = false) && onLockAxis && onLockAxis(self);\n      if (wheeled) {\n        onWheel(self);\n        wheeled = false;\n      }\n      id = 0;\n    }, onDelta = function onDelta2(x, y, index) {\n      deltaX[index] += x;\n      deltaY[index] += y;\n      self._vx.update(x);\n      self._vy.update(y);\n      debounce ? id || (id = requestAnimationFrame(update)) : update();\n    }, onTouchOrPointerDelta = function onTouchOrPointerDelta2(x, y) {\n      if (lockAxis && !axis) {\n        self.axis = axis = Math.abs(x) > Math.abs(y) ? \"x\" : \"y\";\n        locked = true;\n      }\n      if (axis !== \"y\") {\n        deltaX[2] += x;\n        self._vx.update(x, true);\n      }\n      if (axis !== \"x\") {\n        deltaY[2] += y;\n        self._vy.update(y, true);\n      }\n      debounce ? id || (id = requestAnimationFrame(update)) : update();\n    }, _onDrag = function _onDrag2(e) {\n      if (_ignoreCheck(e, 1)) {\n        return;\n      }\n      e = _getEvent(e, preventDefault);\n      var x = e.clientX, y = e.clientY, dx = x - self.x, dy = y - self.y, isDragging = self.isDragging;\n      self.x = x;\n      self.y = y;\n      if (isDragging || Math.abs(self.startX - x) >= dragMinimum || Math.abs(self.startY - y) >= dragMinimum) {\n        onDrag && (dragged = true);\n        isDragging || (self.isDragging = true);\n        onTouchOrPointerDelta(dx, dy);\n        isDragging || onDragStart && onDragStart(self);\n      }\n    }, _onPress = self.onPress = function(e) {\n      if (_ignoreCheck(e, 1) || e && e.button) {\n        return;\n      }\n      self.axis = axis = null;\n      onStopDelayedCall.pause();\n      self.isPressed = true;\n      e = _getEvent(e);\n      prevDeltaX = prevDeltaY = 0;\n      self.startX = self.x = e.clientX;\n      self.startY = self.y = e.clientY;\n      self._vx.reset();\n      self._vy.reset();\n      _addListener(isNormalizer ? target : ownerDoc, _eventTypes[1], _onDrag, passive, true);\n      self.deltaX = self.deltaY = 0;\n      onPress && onPress(self);\n    }, _onRelease = self.onRelease = function(e) {\n      if (_ignoreCheck(e, 1)) {\n        return;\n      }\n      _removeListener(isNormalizer ? target : ownerDoc, _eventTypes[1], _onDrag, true);\n      var isTrackingDrag = !isNaN(self.y - self.startY), wasDragging = self.isDragging, isDragNotClick = wasDragging && (Math.abs(self.x - self.startX) > 3 || Math.abs(self.y - self.startY) > 3), eventData = _getEvent(e);\n      if (!isDragNotClick && isTrackingDrag) {\n        self._vx.reset();\n        self._vy.reset();\n        if (preventDefault && allowClicks) {\n          gsap.delayedCall(0.08, function() {\n            if (_getTime() - onClickTime > 300 && !e.defaultPrevented) {\n              if (e.target.click) {\n                e.target.click();\n              } else if (ownerDoc.createEvent) {\n                var syntheticEvent = ownerDoc.createEvent(\"MouseEvents\");\n                syntheticEvent.initMouseEvent(\"click\", true, true, _win, 1, eventData.screenX, eventData.screenY, eventData.clientX, eventData.clientY, false, false, false, false, 0, null);\n                e.target.dispatchEvent(syntheticEvent);\n              }\n            }\n          });\n        }\n      }\n      self.isDragging = self.isGesturing = self.isPressed = false;\n      onStop && wasDragging && !isNormalizer && onStopDelayedCall.restart(true);\n      onDragEnd && wasDragging && onDragEnd(self);\n      onRelease && onRelease(self, isDragNotClick);\n    }, _onGestureStart = function _onGestureStart2(e) {\n      return e.touches && e.touches.length > 1 && (self.isGesturing = true) && onGestureStart(e, self.isDragging);\n    }, _onGestureEnd = function _onGestureEnd2() {\n      return (self.isGesturing = false) || onGestureEnd(self);\n    }, onScroll = function onScroll2(e) {\n      if (_ignoreCheck(e)) {\n        return;\n      }\n      var x = scrollFuncX(), y = scrollFuncY();\n      onDelta((x - scrollX) * scrollSpeed, (y - scrollY) * scrollSpeed, 1);\n      scrollX = x;\n      scrollY = y;\n      onStop && onStopDelayedCall.restart(true);\n    }, _onWheel = function _onWheel2(e) {\n      if (_ignoreCheck(e)) {\n        return;\n      }\n      e = _getEvent(e, preventDefault);\n      onWheel && (wheeled = true);\n      var multiplier = (e.deltaMode === 1 ? lineHeight : e.deltaMode === 2 ? _win.innerHeight : 1) * wheelSpeed;\n      onDelta(e.deltaX * multiplier, e.deltaY * multiplier, 0);\n      onStop && !isNormalizer && onStopDelayedCall.restart(true);\n    }, _onMove = function _onMove2(e) {\n      if (_ignoreCheck(e)) {\n        return;\n      }\n      var x = e.clientX, y = e.clientY, dx = x - self.x, dy = y - self.y;\n      self.x = x;\n      self.y = y;\n      moved = true;\n      onStop && onStopDelayedCall.restart(true);\n      (dx || dy) && onTouchOrPointerDelta(dx, dy);\n    }, _onHover = function _onHover2(e) {\n      self.event = e;\n      onHover(self);\n    }, _onHoverEnd = function _onHoverEnd2(e) {\n      self.event = e;\n      onHoverEnd(self);\n    }, _onClick = function _onClick2(e) {\n      return _ignoreCheck(e) || _getEvent(e, preventDefault) && onClick(self);\n    };\n    onStopDelayedCall = self._dc = gsap.delayedCall(onStopDelay || 0.25, onStopFunc).pause();\n    self.deltaX = self.deltaY = 0;\n    self._vx = _getVelocityProp(0, 50, true);\n    self._vy = _getVelocityProp(0, 50, true);\n    self.scrollX = scrollFuncX;\n    self.scrollY = scrollFuncY;\n    self.isDragging = self.isGesturing = self.isPressed = false;\n    _context(this);\n    self.enable = function(e) {\n      if (!self.isEnabled) {\n        _addListener(isViewport ? ownerDoc : target, \"scroll\", _onScroll);\n        type.indexOf(\"scroll\") >= 0 && _addListener(isViewport ? ownerDoc : target, \"scroll\", onScroll, passive, capture);\n        type.indexOf(\"wheel\") >= 0 && _addListener(target, \"wheel\", _onWheel, passive, capture);\n        if (type.indexOf(\"touch\") >= 0 && _isTouch || type.indexOf(\"pointer\") >= 0) {\n          _addListener(target, _eventTypes[0], _onPress, passive, capture);\n          _addListener(ownerDoc, _eventTypes[2], _onRelease);\n          _addListener(ownerDoc, _eventTypes[3], _onRelease);\n          allowClicks && _addListener(target, \"click\", clickCapture, true, true);\n          onClick && _addListener(target, \"click\", _onClick);\n          onGestureStart && _addListener(ownerDoc, \"gesturestart\", _onGestureStart);\n          onGestureEnd && _addListener(ownerDoc, \"gestureend\", _onGestureEnd);\n          onHover && _addListener(target, _pointerType + \"enter\", _onHover);\n          onHoverEnd && _addListener(target, _pointerType + \"leave\", _onHoverEnd);\n          onMove && _addListener(target, _pointerType + \"move\", _onMove);\n        }\n        self.isEnabled = true;\n        e && e.type && _onPress(e);\n        onEnable && onEnable(self);\n      }\n      return self;\n    };\n    self.disable = function() {\n      if (self.isEnabled) {\n        _observers.filter(function(o) {\n          return o !== self && _isViewport(o.target);\n        }).length || _removeListener(isViewport ? ownerDoc : target, \"scroll\", _onScroll);\n        if (self.isPressed) {\n          self._vx.reset();\n          self._vy.reset();\n          _removeListener(isNormalizer ? target : ownerDoc, _eventTypes[1], _onDrag, true);\n        }\n        _removeListener(isViewport ? ownerDoc : target, \"scroll\", onScroll, capture);\n        _removeListener(target, \"wheel\", _onWheel, capture);\n        _removeListener(target, _eventTypes[0], _onPress, capture);\n        _removeListener(ownerDoc, _eventTypes[2], _onRelease);\n        _removeListener(ownerDoc, _eventTypes[3], _onRelease);\n        _removeListener(target, \"click\", clickCapture, true);\n        _removeListener(target, \"click\", _onClick);\n        _removeListener(ownerDoc, \"gesturestart\", _onGestureStart);\n        _removeListener(ownerDoc, \"gestureend\", _onGestureEnd);\n        _removeListener(target, _pointerType + \"enter\", _onHover);\n        _removeListener(target, _pointerType + \"leave\", _onHoverEnd);\n        _removeListener(target, _pointerType + \"move\", _onMove);\n        self.isEnabled = self.isPressed = self.isDragging = false;\n        onDisable && onDisable(self);\n      }\n    };\n    self.kill = self.revert = function() {\n      self.disable();\n      var i = _observers.indexOf(self);\n      i >= 0 && _observers.splice(i, 1);\n      _normalizer === self && (_normalizer = 0);\n    };\n    _observers.push(self);\n    isNormalizer && _isViewport(target) && (_normalizer = self);\n    self.enable(event);\n  };\n  _createClass(Observer2, [{\n    key: \"velocityX\",\n    get: function get() {\n      return this._vx.getVelocity();\n    }\n  }, {\n    key: \"velocityY\",\n    get: function get() {\n      return this._vy.getVelocity();\n    }\n  }]);\n  return Observer2;\n}();\nObserver.version = \"3.12.5\";\nObserver.create = function(vars) {\n  return new Observer(vars);\n};\nObserver.register = _initCore;\nObserver.getAll = function() {\n  return _observers.slice();\n};\nObserver.getById = function(id) {\n  return _observers.filter(function(o) {\n    return o.vars.id === id;\n  })[0];\n};\n_getGSAP() && gsap.registerPlugin(Observer);\n\nexport {\n  _scrollers,\n  _proxies,\n  _getProxyProp,\n  _isViewport,\n  _horizontal,\n  _vertical,\n  _getTarget,\n  _getScrollFunc,\n  _getVelocityProp,\n  Observer\n};\n/*! Bundled license information:\n\ngsap/Observer.js:\n  (*!\n   * Observer 3.12.5\n   * https://gsap.com\n   *\n   * @license Copyright 2008-2024, GreenSock. All rights reserved.\n   * Subject to the terms at https://gsap.com/standard-license or for\n   * Club GSAP members, the agreement issued with that membership.\n   * @author: Jack Doyle, jack@greensock.com\n  *)\n*/\n//# sourceMappingURL=chunk-JIUMHI3X.js.map\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 20937,
            "count": 1
          },
          {
            "startOffset": 20335,
            "endOffset": 20367,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_defineProperties",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 70,
            "endOffset": 417,
            "count": 1
          },
          {
            "startOffset": 155,
            "endOffset": 415,
            "count": 2
          },
          {
            "startOffset": 321,
            "endOffset": 348,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_createClass",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 418,
            "endOffset": 647,
            "count": 1
          },
          {
            "startOffset": 579,
            "endOffset": 623,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_getGSAP2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 856,
            "endOffset": 983,
            "count": 1
          },
          {
            "startOffset": 950,
            "endOffset": 972,
            "count": 0
          },
          {
            "startOffset": 973,
            "endOffset": 980,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_bridge2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1103,
            "endOffset": 1153,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_integrate2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1172,
            "endOffset": 1527,
            "count": 1
          },
          {
            "startOffset": 1249,
            "endOffset": 1254,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_bridge3",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1458,
            "endOffset": 1524,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_getProxyProp2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1549,
            "endOffset": 1685,
            "count": 2
          },
          {
            "startOffset": 1630,
            "endOffset": 1682,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_isViewport2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1705,
            "endOffset": 1765,
            "count": 5
          }
        ]
      },
      {
        "functionName": "_addListener2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1786,
            "endOffset": 1960,
            "count": 7
          }
        ]
      },
      {
        "functionName": "_removeListener2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1984,
            "endOffset": 2104,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_onScroll2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2184,
            "endOffset": 2278,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_scrollCacheFunc2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 2303,
            "endOffset": 3040,
            "count": 4
          },
          {
            "startOffset": 3023,
            "endOffset": 3037,
            "count": 2
          }
        ]
      },
      {
        "functionName": "cachingFunc2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 2367,
            "endOffset": 2984,
            "count": 4
          },
          {
            "startOffset": 2428,
            "endOffset": 2764,
            "count": 0
          },
          {
            "startOffset": 2830,
            "endOffset": 2847,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 3200,
            "endOffset": 3379,
            "count": 2
          },
          {
            "startOffset": 3246,
            "endOffset": 3284,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 3560,
            "endOffset": 3738,
            "count": 2
          },
          {
            "startOffset": 3606,
            "endOffset": 3646,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_getTarget2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 3760,
            "endOffset": 3989,
            "count": 1
          },
          {
            "startOffset": 3807,
            "endOffset": 3819,
            "count": 0
          },
          {
            "startOffset": 3820,
            "endOffset": 3841,
            "count": 0
          },
          {
            "startOffset": 3897,
            "endOffset": 3938,
            "count": 0
          },
          {
            "startOffset": 3939,
            "endOffset": 3978,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_getScrollFunc2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 4012,
            "endOffset": 4742,
            "count": 2
          },
          {
            "startOffset": 4145,
            "endOffset": 4154,
            "count": 0
          },
          {
            "startOffset": 4225,
            "endOffset": 4228,
            "count": 1
          },
          {
            "startOffset": 4229,
            "endOffset": 4232,
            "count": 1
          },
          {
            "startOffset": 4240,
            "endOffset": 4277,
            "count": 1
          },
          {
            "startOffset": 4509,
            "endOffset": 4613,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4528,
            "endOffset": 4612,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_getVelocityProp2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 4767,
            "endOffset": 5693,
            "count": 2
          },
          {
            "startOffset": 4906,
            "endOffset": 4911,
            "count": 0
          }
        ]
      },
      {
        "functionName": "update2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4963,
            "endOffset": 5240,
            "count": 0
          }
        ]
      },
      {
        "functionName": "reset2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 5250,
            "endOffset": 5323,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getVelocity2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 5339,
            "endOffset": 5635,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_getEvent2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 5711,
            "endOffset": 5863,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_getAbsoluteMax2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 5887,
            "endOffset": 6040,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_setScrollTrigger2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 6066,
            "endOffset": 6207,
            "count": 1
          }
        ]
      },
      {
        "functionName": "_initCore2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 6225,
            "endOffset": 7267,
            "count": 2
          },
          {
            "startOffset": 6267,
            "endOffset": 6280,
            "count": 0
          },
          {
            "startOffset": 6302,
            "endOffset": 6309,
            "count": 1
          },
          {
            "startOffset": 6310,
            "endOffset": 6344,
            "count": 1
          },
          {
            "startOffset": 6345,
            "endOffset": 6361,
            "count": 1
          },
          {
            "startOffset": 6363,
            "endOffset": 7242,
            "count": 1
          },
          {
            "startOffset": 6568,
            "endOffset": 6589,
            "count": 0
          },
          {
            "startOffset": 6648,
            "endOffset": 6657,
            "count": 0
          },
          {
            "startOffset": 6772,
            "endOffset": 6775,
            "count": 0
          },
          {
            "startOffset": 6867,
            "endOffset": 6870,
            "count": 0
          },
          {
            "startOffset": 6942,
            "endOffset": 6987,
            "count": 0
          },
          {
            "startOffset": 7019,
            "endOffset": 7058,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_context",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 6571,
            "endOffset": 6589,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7139,
            "endOffset": 7184,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7334,
            "endOffset": 20014,
            "count": 1
          }
        ]
      },
      {
        "functionName": "Observer2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7349,
            "endOffset": 7400,
            "count": 1
          }
        ]
      },
      {
        "functionName": "init",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7453,
            "endOffset": 19766,
            "count": 1
          },
          {
            "startOffset": 7492,
            "endOffset": 7510,
            "count": 0
          },
          {
            "startOffset": 7511,
            "endOffset": 7566,
            "count": 0
          },
          {
            "startOffset": 7586,
            "endOffset": 7608,
            "count": 0
          },
          {
            "startOffset": 8846,
            "endOffset": 8886,
            "count": 0
          },
          {
            "startOffset": 8914,
            "endOffset": 8921,
            "count": 0
          },
          {
            "startOffset": 8987,
            "endOffset": 8991,
            "count": 0
          },
          {
            "startOffset": 9045,
            "endOffset": 9069,
            "count": 0
          },
          {
            "startOffset": 9190,
            "endOffset": 9195,
            "count": 0
          },
          {
            "startOffset": 9573,
            "endOffset": 9608,
            "count": 0
          },
          {
            "startOffset": 9676,
            "endOffset": 9683,
            "count": 0
          },
          {
            "startOffset": 19691,
            "endOffset": 19713,
            "count": 0
          },
          {
            "startOffset": 19714,
            "endOffset": 19737,
            "count": 0
          }
        ]
      },
      {
        "functionName": "clickCapture2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 9757,
            "endOffset": 9828,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_ignoreCheck2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 9845,
            "endOffset": 10082,
            "count": 0
          }
        ]
      },
      {
        "functionName": "onStopFunc2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10097,
            "endOffset": 10238,
            "count": 0
          }
        ]
      },
      {
        "functionName": "update2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10249,
            "endOffset": 11522,
            "count": 0
          }
        ]
      },
      {
        "functionName": "onDelta2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11534,
            "endOffset": 11748,
            "count": 0
          }
        ]
      },
      {
        "functionName": "onTouchOrPointerDelta2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11774,
            "endOffset": 12203,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_onDrag2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12215,
            "endOffset": 12778,
            "count": 0
          }
        ]
      },
      {
        "functionName": "self.onPress",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12806,
            "endOffset": 13341,
            "count": 0
          }
        ]
      },
      {
        "functionName": "self.onRelease",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13373,
            "endOffset": 14773,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_onGestureStart2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14793,
            "endOffset": 14944,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_onGestureEnd2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14962,
            "endOffset": 15058,
            "count": 0
          }
        ]
      },
      {
        "functionName": "onScroll2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15071,
            "endOffset": 15364,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_onWheel2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15377,
            "endOffset": 15777,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_onMove2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15789,
            "endOffset": 16100,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_onHover2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 16113,
            "endOffset": 16185,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_onHoverEnd2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 16201,
            "endOffset": 16279,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_onClick2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 16292,
            "endOffset": 16400,
            "count": 0
          }
        ]
      },
      {
        "functionName": "self.enable",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 16790,
            "endOffset": 18101,
            "count": 1
          },
          {
            "startOffset": 16876,
            "endOffset": 16884,
            "count": 0
          },
          {
            "startOffset": 16944,
            "endOffset": 17029,
            "count": 0
          },
          {
            "startOffset": 17436,
            "endOffset": 17494,
            "count": 0
          },
          {
            "startOffset": 17514,
            "endOffset": 17556,
            "count": 0
          },
          {
            "startOffset": 17583,
            "endOffset": 17641,
            "count": 0
          },
          {
            "startOffset": 17666,
            "endOffset": 17720,
            "count": 0
          },
          {
            "startOffset": 17740,
            "endOffset": 17797,
            "count": 0
          },
          {
            "startOffset": 17820,
            "endOffset": 17880,
            "count": 0
          },
          {
            "startOffset": 17899,
            "endOffset": 17954,
            "count": 0
          },
          {
            "startOffset": 18007,
            "endOffset": 18016,
            "count": 0
          },
          {
            "startOffset": 18017,
            "endOffset": 18031,
            "count": 0
          },
          {
            "startOffset": 18050,
            "endOffset": 18067,
            "count": 0
          }
        ]
      },
      {
        "functionName": "self.disable",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 18122,
            "endOffset": 19443,
            "count": 0
          }
        ]
      },
      {
        "functionName": "self.kill.self.revert",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 19475,
            "endOffset": 19645,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 19828,
            "endOffset": 19887,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 19926,
            "endOffset": 19985,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Observer.create",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 20065,
            "endOffset": 20112,
            "count": 1
          }
        ]
      },
      {
        "functionName": "Observer.getAll",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 20163,
            "endOffset": 20206,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Observer.getById",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 20227,
            "endOffset": 20322,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5173/@fs/home/will/local_dev/portfolio/packages/motion-system/src/hooks/useScrollStateMachine.ts?t=1750724128976",
    "scriptId": "36",
    "source": "import __vite__cjsImport0_react from \"/node_modules/.vite/deps/react.js?v=a50bb159\"; const useEffect = __vite__cjsImport0_react[\"useEffect\"]; const useState = __vite__cjsImport0_react[\"useState\"]; const useCallback = __vite__cjsImport0_react[\"useCallback\"]; const useRef = __vite__cjsImport0_react[\"useRef\"];\nimport { useMotion } from \"/@fs/home/will/local_dev/portfolio/packages/motion-system/src/providers/MotionProvider.tsx?t=1750724128976\";\nexport const useScrollStateMachine = (options) => {\n  const { chapters, onChapterChange } = options;\n  const { scrollProgress, velocity, currentChapter } = useMotion();\n  const [state, setState] = useState({\n    currentChapter: chapters[0]?.id || \"\",\n    previousChapter: null,\n    nextChapter: chapters[1]?.id || null,\n    isTransitioning: false,\n    transitionProgress: 0,\n    direction: \"idle\"\n  });\n  const previousChapterRef = useRef(chapters[0]?.id || \"\");\n  const transitionTimeoutRef = useRef();\n  const getDirection = useCallback(\n    (velocity2) => {\n      if (Math.abs(velocity2) < 0.01)\n        return \"idle\";\n      return velocity2 > 0 ? \"forward\" : \"backward\";\n    },\n    []\n  );\n  const getAdjacentChapters = useCallback(\n    (chapterId) => {\n      const currentIndex = chapters.findIndex((ch) => ch.id === chapterId);\n      const previous = currentIndex > 0 ? chapters[currentIndex - 1].id : null;\n      const next = currentIndex < chapters.length - 1 ? chapters[currentIndex + 1].id : null;\n      return { previous, next };\n    },\n    [chapters]\n  );\n  const getTransitionProgress = useCallback(\n    (scrollProgress2, fromChapter, toChapter) => {\n      const fromChapterData = chapters.find((ch) => ch.id === fromChapter);\n      const toChapterData = chapters.find((ch) => ch.id === toChapter);\n      if (!fromChapterData || !toChapterData)\n        return 0;\n      const overlapStart = Math.max(fromChapterData.start, toChapterData.start);\n      const overlapEnd = Math.min(fromChapterData.end, toChapterData.end);\n      if (scrollProgress2 < overlapStart)\n        return 0;\n      if (scrollProgress2 > overlapEnd)\n        return 1;\n      return (scrollProgress2 - overlapStart) / (overlapEnd - overlapStart);\n    },\n    [chapters]\n  );\n  useEffect(() => {\n    const direction = getDirection(velocity);\n    const { previous, next } = getAdjacentChapters(currentChapter);\n    if (currentChapter !== previousChapterRef.current) {\n      previousChapterRef.current = currentChapter;\n      if (onChapterChange) {\n        onChapterChange(currentChapter);\n      }\n      setState((prev) => ({\n        ...prev,\n        isTransitioning: true,\n        previousChapter: previousChapterRef.current\n      }));\n      if (transitionTimeoutRef.current) {\n        clearTimeout(transitionTimeoutRef.current);\n      }\n      transitionTimeoutRef.current = setTimeout(() => {\n        setState((prev) => ({\n          ...prev,\n          isTransitioning: false\n        }));\n      }, 300);\n    }\n    let transitionProgress = 0;\n    if (previous && direction === \"backward\") {\n      transitionProgress = getTransitionProgress(\n        scrollProgress,\n        currentChapter,\n        previous\n      );\n    } else if (next && direction === \"forward\") {\n      transitionProgress = getTransitionProgress(\n        scrollProgress,\n        currentChapter,\n        next\n      );\n    }\n    setState((prev) => ({\n      ...prev,\n      currentChapter,\n      previousChapter: previous,\n      nextChapter: next,\n      direction,\n      transitionProgress\n    }));\n  }, [\n    scrollProgress,\n    velocity,\n    currentChapter,\n    chapters,\n    getDirection,\n    getAdjacentChapters,\n    getTransitionProgress,\n    onChapterChange\n  ]);\n  useEffect(() => {\n    return () => {\n      if (transitionTimeoutRef.current) {\n        clearTimeout(transitionTimeoutRef.current);\n      }\n    };\n  }, []);\n  return state;\n};\n\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInVzZVNjcm9sbFN0YXRlTWFjaGluZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VFZmZlY3QsIHVzZVN0YXRlLCB1c2VDYWxsYmFjaywgdXNlUmVmIH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgeyB1c2VNb3Rpb24gfSBmcm9tICcuLi9wcm92aWRlcnMvTW90aW9uUHJvdmlkZXInXG5pbXBvcnQgeyBTY3JvbGxTdGF0ZU1hY2hpbmVPcHRpb25zIH0gZnJvbSAnLi4vdHlwZXMnXG5cbmV4cG9ydCBpbnRlcmZhY2UgU2Nyb2xsU3RhdGUge1xuICBjdXJyZW50Q2hhcHRlcjogc3RyaW5nXG4gIHByZXZpb3VzQ2hhcHRlcjogc3RyaW5nIHwgbnVsbFxuICBuZXh0Q2hhcHRlcjogc3RyaW5nIHwgbnVsbFxuICBpc1RyYW5zaXRpb25pbmc6IGJvb2xlYW5cbiAgdHJhbnNpdGlvblByb2dyZXNzOiBudW1iZXJcbiAgZGlyZWN0aW9uOiAnZm9yd2FyZCcgfCAnYmFja3dhcmQnIHwgJ2lkbGUnXG59XG5cbmV4cG9ydCBjb25zdCB1c2VTY3JvbGxTdGF0ZU1hY2hpbmUgPSAob3B0aW9uczogU2Nyb2xsU3RhdGVNYWNoaW5lT3B0aW9ucykgPT4ge1xuICBjb25zdCB7IGNoYXB0ZXJzLCBvbkNoYXB0ZXJDaGFuZ2UgfSA9IG9wdGlvbnNcbiAgY29uc3QgeyBzY3JvbGxQcm9ncmVzcywgdmVsb2NpdHksIGN1cnJlbnRDaGFwdGVyIH0gPSB1c2VNb3Rpb24oKVxuXG4gIGNvbnN0IFtzdGF0ZSwgc2V0U3RhdGVdID0gdXNlU3RhdGU8U2Nyb2xsU3RhdGU+KHtcbiAgICBjdXJyZW50Q2hhcHRlcjogY2hhcHRlcnNbMF0/LmlkIHx8ICcnLFxuICAgIHByZXZpb3VzQ2hhcHRlcjogbnVsbCxcbiAgICBuZXh0Q2hhcHRlcjogY2hhcHRlcnNbMV0/LmlkIHx8IG51bGwsXG4gICAgaXNUcmFuc2l0aW9uaW5nOiBmYWxzZSxcbiAgICB0cmFuc2l0aW9uUHJvZ3Jlc3M6IDAsXG4gICAgZGlyZWN0aW9uOiAnaWRsZScsXG4gIH0pXG5cbiAgY29uc3QgcHJldmlvdXNDaGFwdGVyUmVmID0gdXNlUmVmPHN0cmluZz4oY2hhcHRlcnNbMF0/LmlkIHx8ICcnKVxuICBjb25zdCB0cmFuc2l0aW9uVGltZW91dFJlZiA9IHVzZVJlZjxOb2RlSlMuVGltZW91dD4oKVxuXG4gIC8vIERldGVybWluZSBzY3JvbGwgZGlyZWN0aW9uXG4gIGNvbnN0IGdldERpcmVjdGlvbiA9IHVzZUNhbGxiYWNrKFxuICAgICh2ZWxvY2l0eTogbnVtYmVyKTogJ2ZvcndhcmQnIHwgJ2JhY2t3YXJkJyB8ICdpZGxlJyA9PiB7XG4gICAgICBpZiAoTWF0aC5hYnModmVsb2NpdHkpIDwgMC4wMSkgcmV0dXJuICdpZGxlJ1xuICAgICAgcmV0dXJuIHZlbG9jaXR5ID4gMCA/ICdmb3J3YXJkJyA6ICdiYWNrd2FyZCdcbiAgICB9LFxuICAgIFtdXG4gIClcblxuICAvLyBGaW5kIGFkamFjZW50IGNoYXB0ZXJzXG4gIGNvbnN0IGdldEFkamFjZW50Q2hhcHRlcnMgPSB1c2VDYWxsYmFjayhcbiAgICAoY2hhcHRlcklkOiBzdHJpbmcpID0+IHtcbiAgICAgIGNvbnN0IGN1cnJlbnRJbmRleCA9IGNoYXB0ZXJzLmZpbmRJbmRleCgoY2gpID0+IGNoLmlkID09PSBjaGFwdGVySWQpXG4gICAgICBjb25zdCBwcmV2aW91cyA9IGN1cnJlbnRJbmRleCA+IDAgPyBjaGFwdGVyc1tjdXJyZW50SW5kZXggLSAxXS5pZCA6IG51bGxcbiAgICAgIGNvbnN0IG5leHQgPVxuICAgICAgICBjdXJyZW50SW5kZXggPCBjaGFwdGVycy5sZW5ndGggLSAxXG4gICAgICAgICAgPyBjaGFwdGVyc1tjdXJyZW50SW5kZXggKyAxXS5pZFxuICAgICAgICAgIDogbnVsbFxuICAgICAgcmV0dXJuIHsgcHJldmlvdXMsIG5leHQgfVxuICAgIH0sXG4gICAgW2NoYXB0ZXJzXVxuICApXG5cbiAgLy8gQ2FsY3VsYXRlIHRyYW5zaXRpb24gcHJvZ3Jlc3MgYmV0d2VlbiBjaGFwdGVyc1xuICBjb25zdCBnZXRUcmFuc2l0aW9uUHJvZ3Jlc3MgPSB1c2VDYWxsYmFjayhcbiAgICAoc2Nyb2xsUHJvZ3Jlc3M6IG51bWJlciwgZnJvbUNoYXB0ZXI6IHN0cmluZywgdG9DaGFwdGVyOiBzdHJpbmcpID0+IHtcbiAgICAgIGNvbnN0IGZyb21DaGFwdGVyRGF0YSA9IGNoYXB0ZXJzLmZpbmQoKGNoKSA9PiBjaC5pZCA9PT0gZnJvbUNoYXB0ZXIpXG4gICAgICBjb25zdCB0b0NoYXB0ZXJEYXRhID0gY2hhcHRlcnMuZmluZCgoY2gpID0+IGNoLmlkID09PSB0b0NoYXB0ZXIpXG5cbiAgICAgIGlmICghZnJvbUNoYXB0ZXJEYXRhIHx8ICF0b0NoYXB0ZXJEYXRhKSByZXR1cm4gMFxuXG4gICAgICAvLyBDYWxjdWxhdGUgb3ZlcmxhcCB6b25lXG4gICAgICBjb25zdCBvdmVybGFwU3RhcnQgPSBNYXRoLm1heChmcm9tQ2hhcHRlckRhdGEuc3RhcnQsIHRvQ2hhcHRlckRhdGEuc3RhcnQpXG4gICAgICBjb25zdCBvdmVybGFwRW5kID0gTWF0aC5taW4oZnJvbUNoYXB0ZXJEYXRhLmVuZCwgdG9DaGFwdGVyRGF0YS5lbmQpXG5cbiAgICAgIGlmIChzY3JvbGxQcm9ncmVzcyA8IG92ZXJsYXBTdGFydCkgcmV0dXJuIDBcbiAgICAgIGlmIChzY3JvbGxQcm9ncmVzcyA+IG92ZXJsYXBFbmQpIHJldHVybiAxXG5cbiAgICAgIHJldHVybiAoc2Nyb2xsUHJvZ3Jlc3MgLSBvdmVybGFwU3RhcnQpIC8gKG92ZXJsYXBFbmQgLSBvdmVybGFwU3RhcnQpXG4gICAgfSxcbiAgICBbY2hhcHRlcnNdXG4gIClcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGRpcmVjdGlvbiA9IGdldERpcmVjdGlvbih2ZWxvY2l0eSlcbiAgICBjb25zdCB7IHByZXZpb3VzLCBuZXh0IH0gPSBnZXRBZGphY2VudENoYXB0ZXJzKGN1cnJlbnRDaGFwdGVyKVxuXG4gICAgLy8gRGV0ZWN0IGNoYXB0ZXIgY2hhbmdlXG4gICAgaWYgKGN1cnJlbnRDaGFwdGVyICE9PSBwcmV2aW91c0NoYXB0ZXJSZWYuY3VycmVudCkge1xuICAgICAgcHJldmlvdXNDaGFwdGVyUmVmLmN1cnJlbnQgPSBjdXJyZW50Q2hhcHRlclxuXG4gICAgICAvLyBUcmlnZ2VyIGNhbGxiYWNrXG4gICAgICBpZiAob25DaGFwdGVyQ2hhbmdlKSB7XG4gICAgICAgIG9uQ2hhcHRlckNoYW5nZShjdXJyZW50Q2hhcHRlcilcbiAgICAgIH1cblxuICAgICAgLy8gU2V0IHRyYW5zaXRpb25pbmcgc3RhdGVcbiAgICAgIHNldFN0YXRlKChwcmV2KSA9PiAoe1xuICAgICAgICAuLi5wcmV2LFxuICAgICAgICBpc1RyYW5zaXRpb25pbmc6IHRydWUsXG4gICAgICAgIHByZXZpb3VzQ2hhcHRlcjogcHJldmlvdXNDaGFwdGVyUmVmLmN1cnJlbnQsXG4gICAgICB9KSlcblxuICAgICAgLy8gQ2xlYXIgZXhpc3RpbmcgdGltZW91dFxuICAgICAgaWYgKHRyYW5zaXRpb25UaW1lb3V0UmVmLmN1cnJlbnQpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRyYW5zaXRpb25UaW1lb3V0UmVmLmN1cnJlbnQpXG4gICAgICB9XG5cbiAgICAgIC8vIEVuZCB0cmFuc2l0aW9uIGFmdGVyIGEgZGVsYXlcbiAgICAgIHRyYW5zaXRpb25UaW1lb3V0UmVmLmN1cnJlbnQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgc2V0U3RhdGUoKHByZXYpID0+ICh7XG4gICAgICAgICAgLi4ucHJldixcbiAgICAgICAgICBpc1RyYW5zaXRpb25pbmc6IGZhbHNlLFxuICAgICAgICB9KSlcbiAgICAgIH0sIDMwMClcbiAgICB9XG5cbiAgICAvLyBDYWxjdWxhdGUgdHJhbnNpdGlvbiBwcm9ncmVzcyBpZiBiZXR3ZWVuIGNoYXB0ZXJzXG4gICAgbGV0IHRyYW5zaXRpb25Qcm9ncmVzcyA9IDBcbiAgICBpZiAocHJldmlvdXMgJiYgZGlyZWN0aW9uID09PSAnYmFja3dhcmQnKSB7XG4gICAgICB0cmFuc2l0aW9uUHJvZ3Jlc3MgPSBnZXRUcmFuc2l0aW9uUHJvZ3Jlc3MoXG4gICAgICAgIHNjcm9sbFByb2dyZXNzLFxuICAgICAgICBjdXJyZW50Q2hhcHRlcixcbiAgICAgICAgcHJldmlvdXNcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKG5leHQgJiYgZGlyZWN0aW9uID09PSAnZm9yd2FyZCcpIHtcbiAgICAgIHRyYW5zaXRpb25Qcm9ncmVzcyA9IGdldFRyYW5zaXRpb25Qcm9ncmVzcyhcbiAgICAgICAgc2Nyb2xsUHJvZ3Jlc3MsXG4gICAgICAgIGN1cnJlbnRDaGFwdGVyLFxuICAgICAgICBuZXh0XG4gICAgICApXG4gICAgfVxuXG4gICAgc2V0U3RhdGUoKHByZXYpID0+ICh7XG4gICAgICAuLi5wcmV2LFxuICAgICAgY3VycmVudENoYXB0ZXIsXG4gICAgICBwcmV2aW91c0NoYXB0ZXI6IHByZXZpb3VzLFxuICAgICAgbmV4dENoYXB0ZXI6IG5leHQsXG4gICAgICBkaXJlY3Rpb24sXG4gICAgICB0cmFuc2l0aW9uUHJvZ3Jlc3MsXG4gICAgfSkpXG4gIH0sIFtcbiAgICBzY3JvbGxQcm9ncmVzcyxcbiAgICB2ZWxvY2l0eSxcbiAgICBjdXJyZW50Q2hhcHRlcixcbiAgICBjaGFwdGVycyxcbiAgICBnZXREaXJlY3Rpb24sXG4gICAgZ2V0QWRqYWNlbnRDaGFwdGVycyxcbiAgICBnZXRUcmFuc2l0aW9uUHJvZ3Jlc3MsXG4gICAgb25DaGFwdGVyQ2hhbmdlLFxuICBdKVxuXG4gIC8vIENsZWFudXBcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaWYgKHRyYW5zaXRpb25UaW1lb3V0UmVmLmN1cnJlbnQpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRyYW5zaXRpb25UaW1lb3V0UmVmLmN1cnJlbnQpXG4gICAgICB9XG4gICAgfVxuICB9LCBbXSlcblxuICByZXR1cm4gc3RhdGVcbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUEsU0FBUyxXQUFXLFVBQVUsYUFBYSxjQUFjO0FBQ3pELFNBQVMsaUJBQWlCO0FBWW5CLGFBQU0sd0JBQXdCLENBQUMsWUFBdUM7QUFDM0UsUUFBTSxFQUFFLFVBQVUsZ0JBQWdCLElBQUk7QUFDdEMsUUFBTSxFQUFFLGdCQUFnQixVQUFVLGVBQWUsSUFBSSxVQUFVO0FBRS9ELFFBQU0sQ0FBQyxPQUFPLFFBQVEsSUFBSSxTQUFzQjtBQUFBLElBQzlDLGdCQUFnQixTQUFTLENBQUMsR0FBRyxNQUFNO0FBQUEsSUFDbkMsaUJBQWlCO0FBQUEsSUFDakIsYUFBYSxTQUFTLENBQUMsR0FBRyxNQUFNO0FBQUEsSUFDaEMsaUJBQWlCO0FBQUEsSUFDakIsb0JBQW9CO0FBQUEsSUFDcEIsV0FBVztBQUFBLEVBQ2IsQ0FBQztBQUVELFFBQU0scUJBQXFCLE9BQWUsU0FBUyxDQUFDLEdBQUcsTUFBTSxFQUFFO0FBQy9ELFFBQU0sdUJBQXVCLE9BQXVCO0FBR3BELFFBQU0sZUFBZTtBQUFBLElBQ25CLENBQUNBLGNBQXNEO0FBQ3JELFVBQUksS0FBSyxJQUFJQSxTQUFRLElBQUk7QUFBTSxlQUFPO0FBQ3RDLGFBQU9BLFlBQVcsSUFBSSxZQUFZO0FBQUEsSUFDcEM7QUFBQSxJQUNBLENBQUM7QUFBQSxFQUNIO0FBR0EsUUFBTSxzQkFBc0I7QUFBQSxJQUMxQixDQUFDLGNBQXNCO0FBQ3JCLFlBQU0sZUFBZSxTQUFTLFVBQVUsQ0FBQyxPQUFPLEdBQUcsT0FBTyxTQUFTO0FBQ25FLFlBQU0sV0FBVyxlQUFlLElBQUksU0FBUyxlQUFlLENBQUMsRUFBRSxLQUFLO0FBQ3BFLFlBQU0sT0FDSixlQUFlLFNBQVMsU0FBUyxJQUM3QixTQUFTLGVBQWUsQ0FBQyxFQUFFLEtBQzNCO0FBQ04sYUFBTyxFQUFFLFVBQVUsS0FBSztBQUFBLElBQzFCO0FBQUEsSUFDQSxDQUFDLFFBQVE7QUFBQSxFQUNYO0FBR0EsUUFBTSx3QkFBd0I7QUFBQSxJQUM1QixDQUFDQyxpQkFBd0IsYUFBcUIsY0FBc0I7QUFDbEUsWUFBTSxrQkFBa0IsU0FBUyxLQUFLLENBQUMsT0FBTyxHQUFHLE9BQU8sV0FBVztBQUNuRSxZQUFNLGdCQUFnQixTQUFTLEtBQUssQ0FBQyxPQUFPLEdBQUcsT0FBTyxTQUFTO0FBRS9ELFVBQUksQ0FBQyxtQkFBbUIsQ0FBQztBQUFlLGVBQU87QUFHL0MsWUFBTSxlQUFlLEtBQUssSUFBSSxnQkFBZ0IsT0FBTyxjQUFjLEtBQUs7QUFDeEUsWUFBTSxhQUFhLEtBQUssSUFBSSxnQkFBZ0IsS0FBSyxjQUFjLEdBQUc7QUFFbEUsVUFBSUEsa0JBQWlCO0FBQWMsZUFBTztBQUMxQyxVQUFJQSxrQkFBaUI7QUFBWSxlQUFPO0FBRXhDLGNBQVFBLGtCQUFpQixpQkFBaUIsYUFBYTtBQUFBLElBQ3pEO0FBQUEsSUFDQSxDQUFDLFFBQVE7QUFBQSxFQUNYO0FBRUEsWUFBVSxNQUFNO0FBQ2QsVUFBTSxZQUFZLGFBQWEsUUFBUTtBQUN2QyxVQUFNLEVBQUUsVUFBVSxLQUFLLElBQUksb0JBQW9CLGNBQWM7QUFHN0QsUUFBSSxtQkFBbUIsbUJBQW1CLFNBQVM7QUFDakQseUJBQW1CLFVBQVU7QUFHN0IsVUFBSSxpQkFBaUI7QUFDbkIsd0JBQWdCLGNBQWM7QUFBQSxNQUNoQztBQUdBLGVBQVMsQ0FBQyxVQUFVO0FBQUEsUUFDbEIsR0FBRztBQUFBLFFBQ0gsaUJBQWlCO0FBQUEsUUFDakIsaUJBQWlCLG1CQUFtQjtBQUFBLE1BQ3RDLEVBQUU7QUFHRixVQUFJLHFCQUFxQixTQUFTO0FBQ2hDLHFCQUFhLHFCQUFxQixPQUFPO0FBQUEsTUFDM0M7QUFHQSwyQkFBcUIsVUFBVSxXQUFXLE1BQU07QUFDOUMsaUJBQVMsQ0FBQyxVQUFVO0FBQUEsVUFDbEIsR0FBRztBQUFBLFVBQ0gsaUJBQWlCO0FBQUEsUUFDbkIsRUFBRTtBQUFBLE1BQ0osR0FBRyxHQUFHO0FBQUEsSUFDUjtBQUdBLFFBQUkscUJBQXFCO0FBQ3pCLFFBQUksWUFBWSxjQUFjLFlBQVk7QUFDeEMsMkJBQXFCO0FBQUEsUUFDbkI7QUFBQSxRQUNBO0FBQUEsUUFDQTtBQUFBLE1BQ0Y7QUFBQSxJQUNGLFdBQVcsUUFBUSxjQUFjLFdBQVc7QUFDMUMsMkJBQXFCO0FBQUEsUUFDbkI7QUFBQSxRQUNBO0FBQUEsUUFDQTtBQUFBLE1BQ0Y7QUFBQSxJQUNGO0FBRUEsYUFBUyxDQUFDLFVBQVU7QUFBQSxNQUNsQixHQUFHO0FBQUEsTUFDSDtBQUFBLE1BQ0EsaUJBQWlCO0FBQUEsTUFDakIsYUFBYTtBQUFBLE1BQ2I7QUFBQSxNQUNBO0FBQUEsSUFDRixFQUFFO0FBQUEsRUFDSixHQUFHO0FBQUEsSUFDRDtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxFQUNGLENBQUM7QUFHRCxZQUFVLE1BQU07QUFDZCxXQUFPLE1BQU07QUFDWCxVQUFJLHFCQUFxQixTQUFTO0FBQ2hDLHFCQUFhLHFCQUFxQixPQUFPO0FBQUEsTUFDM0M7QUFBQSxJQUNGO0FBQUEsRUFDRixHQUFHLENBQUMsQ0FBQztBQUVMLFNBQU87QUFDVDsiLCJuYW1lcyI6WyJ2ZWxvY2l0eSIsInNjcm9sbFByb2dyZXNzIl19",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 12963,
            "count": 1
          }
        ]
      },
      {
        "functionName": "useScrollStateMachine",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 482,
            "endOffset": 3830,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5173/@fs/home/will/local_dev/portfolio/packages/motion-system/src/orchestrators/HeroToContactHeaderOrchestrator.tsx?t=1750724128976",
    "scriptId": "35",
    "source": "import { createHotContext as __vite__createHotContext } from \"/@vite/client\";import.meta.hot = __vite__createHotContext(\"/@fs/home/will/local_dev/portfolio/packages/motion-system/src/orchestrators/HeroToContactHeaderOrchestrator.tsx\");import RefreshRuntime from \"/@react-refresh\";\nconst inWebWorker = typeof WorkerGlobalScope !== \"undefined\" && self instanceof WorkerGlobalScope;\nlet prevRefreshReg;\nlet prevRefreshSig;\nif (import.meta.hot && !inWebWorker) {\n  if (!window.__vite_plugin_react_preamble_installed__) {\n    throw new Error(\"@vitejs/plugin-react can't detect preamble. Something is wrong. See https://github.com/vitejs/vite-plugin-react/pull/11#discussion_r430879201\");\n  }\n  prevRefreshReg = window.$RefreshReg$;\n  prevRefreshSig = window.$RefreshSig$;\n  window.$RefreshReg$ = (type, id) => {\n    RefreshRuntime.register(type, \"/home/will/local_dev/portfolio/packages/motion-system/src/orchestrators/HeroToContactHeaderOrchestrator.tsx \" + id);\n  };\n  window.$RefreshSig$ = RefreshRuntime.createSignatureFunctionForTransform;\n}\nvar _s = $RefreshSig$();\nimport __vite__cjsImport2_react from \"/node_modules/.vite/deps/react.js?v=a50bb159\"; const React = __vite__cjsImport2_react.__esModule ? __vite__cjsImport2_react.default : __vite__cjsImport2_react; const useRef = __vite__cjsImport2_react[\"useRef\"];\nimport { gsap } from \"/node_modules/.vite/deps/gsap.js?v=a50bb159\";\nimport { Observer } from \"/node_modules/.vite/deps/gsap_Observer.js?v=a50bb159\";\nimport { useGSAP } from \"/node_modules/.vite/deps/@gsap_react.js?v=a50bb159\";\nimport { useMotion } from \"/@fs/home/will/local_dev/portfolio/packages/motion-system/src/providers/MotionProvider.tsx?t=1750724128976\";\nlet siteConfig = null;\ntry {\n  const configModule = require(\"../../../apps/robin-noguier/src/config/site-config.json\");\n  siteConfig = configModule;\n} catch {\n  siteConfig = {\n    header: {\n      brandName: \"rys designs \",\n      tagline: \"Research in Progress\",\n      email: \"hello@rysdesigns.com\"\n    },\n    motionSystem: {\n      sections: [\"hero\", \"header\"],\n      animationDuration: 1e3,\n      easing: \"expo.inOut\",\n      staggerDelay: 0.05\n    }\n  };\n}\ngsap.registerPlugin(Observer, useGSAP);\nconst sections = siteConfig.motionSystem.sections;\nexport const HeroToContactHeaderOrchestrator = () => {\n  _s();\n  const { getElement } = useMotion();\n  const headerRef = useRef(null);\n  const currentIndexRef = useRef(0);\n  const animatingRef = useRef(false);\n  const wrap = gsap.utils.wrap(0, sections.length);\n  useGSAP(() => {\n    console.log(\"[HeroToContactHeader] Initializing orchestrator\");\n    console.log(\"[HeroToContactHeader] Initial scroll position:\", window.scrollY);\n    console.log(\"[HeroToContactHeader] Current index:\", currentIndexRef.current);\n    console.log(\"[HeroToContactHeader] React.StrictMode:\", \"root\" in React ? \"enabled\" : \"disabled\");\n    const existingHeader = document.getElementById(\"sticky-header-container\");\n    if (existingHeader) {\n      console.log(\"[HeroToContactHeader] Removing existing header from previous render\");\n      existingHeader.remove();\n    }\n    gsap.set(window, { scrollTo: 0 });\n    console.log(\"[HeroToContactHeader] Scroll reset to:\", window.scrollY);\n    const heroName = getElement(\"hero-name\")?.current;\n    const heroTitle = getElement(\"hero-title\")?.current;\n    const heroEmail = getElement(\"hero-email\")?.current;\n    const heroInstitution = getElement(\"hero-institution\")?.current;\n    const heroContact = getElement(\"hero-contact\")?.current;\n    if (!heroName || !heroTitle || !heroEmail) {\n      console.log(\"[HeroToContactHeader] Waiting for elements to register:\", {\n        heroName: !!heroName,\n        heroTitle: !!heroTitle,\n        heroEmail: !!heroEmail\n      });\n      return;\n    }\n    const heroElements = [heroName, heroTitle, heroEmail, heroInstitution, heroContact].filter(Boolean);\n    if (!headerRef.current && !document.getElementById(\"sticky-header-container\")) {\n      console.log(\"[HeroToContactHeader] Creating header element\");\n      headerRef.current = document.createElement(\"div\");\n      headerRef.current.id = \"sticky-header-container\";\n      headerRef.current.innerHTML = `\n        <div class=\"header-left\">\n          <h1 id=\"header-name\">${siteConfig.header.brandName}</h1>\n          <span id=\"header-title\">${siteConfig.header.tagline}</span>\n        </div>\n        <div class=\"header-right\" style=\"display: flex; align-items: center; gap: 1rem;\">\n          <div id=\"header-phone\"></div>\n          <a id=\"header-email\" href=\"mailto:${siteConfig.header.email}\">${siteConfig.header.email}</a>\n        </div>\n      `;\n      gsap.set(heroElements, { zIndex: 1, autoAlpha: 1 });\n      gsap.set(headerRef.current, {\n        position: \"fixed\",\n        top: 0,\n        left: 0,\n        right: 0,\n        height: 80,\n        background: \"var(--bg-primary)\",\n        borderBottom: \"1px solid var(--border)\",\n        zIndex: 0,\n        display: \"flex\",\n        alignItems: \"center\",\n        justifyContent: \"space-between\",\n        padding: \"0 2rem\",\n        autoAlpha: 0\n      });\n      const headerName = headerRef.current.querySelector(\"#header-name\");\n      const headerTitle = headerRef.current.querySelector(\"#header-title\");\n      const headerEmail = headerRef.current.querySelector(\"#header-email\");\n      if (headerName) {\n        gsap.set(headerName, {\n          fontFamily: \"var(--font-heading)\",\n          fontSize: \"clamp(1.5rem, 3vw, 2rem)\",\n          fontWeight: 700,\n          margin: 0,\n          letterSpacing: \"-0.02em\",\n          lineHeight: 1,\n          textTransform: \"lowercase\",\n          color: \"var(--text-primary)\"\n        });\n      }\n      if (headerTitle) {\n        gsap.set(headerTitle, {\n          fontFamily: \"var(--font-subtitle)\",\n          fontSize: \"clamp(0.875rem, 1.25vw, 1rem)\",\n          fontWeight: 300,\n          margin: 0,\n          marginTop: \"0.25rem\",\n          letterSpacing: \"0.05em\",\n          opacity: 0.8,\n          color: \"var(--text-primary)\"\n        });\n      }\n      if (headerEmail) {\n        gsap.set(headerEmail, {\n          fontFamily: \"var(--font-subtitle)\",\n          fontSize: \"clamp(0.875rem, 1.25vw, 1rem)\",\n          fontWeight: 300,\n          color: \"var(--text-primary)\",\n          textDecoration: \"none\",\n          opacity: 0.8,\n          transition: \"opacity 0.2s ease\"\n        });\n      }\n      if (!document.getElementById(\"sticky-header-container\")) {\n        console.log(\"[HeroToContactHeader] Appending header to DOM\");\n        document.body.appendChild(headerRef.current);\n      } else {\n        console.log(\"[HeroToContactHeader] Header already in DOM, skipping append\");\n      }\n      const headerPhone = headerRef.current.querySelector(\"#header-phone\");\n      if (headerPhone) {\n        const container = document.createElement(\"div\");\n        container.className = \"container\";\n        container.style.cssText = `\n          position: relative;\n          display: inline-block;\n          margin-right: 1rem;\n        `;\n        const phoneLink = document.createElement(\"a\");\n        phoneLink.href = \"tel:3322879533\";\n        phoneLink.className = \"phoneLink\";\n        phoneLink.style.cssText = `\n          display: inline-flex;\n          align-items: center;\n          text-decoration: none;\n          color: var(--text-primary);\n          font-family: var(--font-subtitle);\n          font-size: clamp(0.875rem, 1.25vw, 1rem);\n          font-weight: 400;\n          letter-spacing: 0;\n          opacity: 0.8;\n          transition: opacity 0.3s ease;\n        `;\n        const stages = [\"332 287-9533\", \"332 AT-RYLEE\", \"NYC @ RYLEE \"];\n        let currentStage = 0;\n        const createFlipStructure = (text) => {\n          phoneLink.innerHTML = \"\";\n          text.split(\"\").forEach((char, index) => {\n            const flipContainer = document.createElement(\"span\");\n            flipContainer.className = \"flipContainer\";\n            flipContainer.style.cssText = `\n              display: inline-block;\n              position: relative;\n              height: 1.2em;\n              overflow: hidden;\n              transform-style: preserve-3d;\n              perspective: 300px;\n            `;\n            const flipper = document.createElement(\"span\");\n            flipper.className = \"flipper\";\n            flipper.style.cssText = `\n              display: inline-flex;\n              align-items: center;\n              justify-content: center;\n              height: 100%;\n              min-width: 0.5ch;\n              transform-origin: center center;\n              transform-style: preserve-3d;\n              font-variant-numeric: tabular-nums;\n            `;\n            flipper.textContent = char;\n            flipContainer.appendChild(flipper);\n            phoneLink.appendChild(flipContainer);\n          });\n        };\n        createFlipStructure(stages[0]);\n        const animateFlip = () => {\n          const prevStage = currentStage;\n          currentStage = (currentStage + 1) % stages.length;\n          const prevText = stages[prevStage];\n          const newText = stages[currentStage];\n          const flippers = phoneLink.querySelectorAll(\".flipper\");\n          newText.split(\"\").forEach((char, index) => {\n            if (flippers[index]) {\n              const flipper = flippers[index];\n              const prevChar = prevText[index];\n              if (char !== prevChar) {\n                const delay = index * 0.03;\n                gsap.to(flipper, {\n                  rotateX: -90,\n                  duration: 0.3,\n                  delay,\n                  ease: \"power2.in\",\n                  onComplete: () => {\n                    flipper.textContent = char;\n                    gsap.to(flipper, {\n                      rotateX: 0,\n                      duration: 0.3,\n                      ease: \"power2.out\"\n                    });\n                  }\n                });\n              }\n            }\n          });\n        };\n        console.log(\"[HeroToContactHeader] Starting kinetic phone animation\");\n        setInterval(animateFlip, 3e3);\n        container.appendChild(phoneLink);\n        headerPhone.appendChild(container);\n      }\n    }\n    function gotoSection(index, direction) {\n      console.log(\"[HeroToContactHeader] gotoSection called:\", {\n        targetIndex: index,\n        direction: direction > 0 ? \"down\" : \"up\",\n        currentIndex: currentIndexRef.current,\n        animating: animatingRef.current,\n        timestamp: (/* @__PURE__ */ new Date()).toISOString()\n      });\n      if (animatingRef.current) {\n        console.warn(\"[HeroToContactHeader] BLOCKED: Animation already in progress\");\n        return;\n      }\n      animatingRef.current = true;\n      index = wrap(index);\n      let tl = gsap.timeline({\n        defaults: {\n          duration: siteConfig.motionSystem.animationDuration / 1e3,\n          ease: siteConfig.motionSystem.easing\n        },\n        onComplete: () => {\n          animatingRef.current = false;\n          console.log(\"[HeroToContactHeader] Animation complete:\", {\n            newIndex: index,\n            section: index === 0 ? \"hero\" : \"header\",\n            timestamp: (/* @__PURE__ */ new Date()).toISOString()\n          });\n        }\n      });\n      gsap.set([heroElements, headerRef.current], { zIndex: 0, autoAlpha: 0 });\n      if (index === 1) {\n        console.log(\"[HeroToContactHeader] Transitioning: hero -> header\");\n        gsap.set(heroElements, { zIndex: 1, autoAlpha: 1 });\n        gsap.set(headerRef.current, { zIndex: 2, autoAlpha: 1 });\n        tl.to(heroElements, {\n          autoAlpha: 0,\n          y: -20,\n          stagger: siteConfig.motionSystem.staggerDelay\n        }, 0).fromTo(\n          headerRef.current,\n          { y: -100, autoAlpha: 0 },\n          { y: 0, autoAlpha: 1 },\n          0.2\n        );\n      } else {\n        console.log(\"[HeroToContactHeader] Transitioning: header -> hero\");\n        gsap.set(headerRef.current, { zIndex: 1, autoAlpha: 1 });\n        gsap.set(heroElements, { zIndex: 2, autoAlpha: 1 });\n        console.log(\"[HeroToContactHeader] Animating scroll to top\");\n        tl.to(window, {\n          scrollTo: 0,\n          duration: siteConfig.motionSystem.animationDuration / 1e3,\n          ease: siteConfig.motionSystem.easing\n        }, 0).to(headerRef.current, {\n          y: -100,\n          autoAlpha: 0\n        }, 0).fromTo(\n          heroElements,\n          { y: -20, autoAlpha: 0 },\n          { y: 0, autoAlpha: 1, stagger: siteConfig.motionSystem.staggerDelay },\n          0.2\n        );\n      }\n      currentIndexRef.current = index;\n    }\n    let observer = null;\n    const observerTimeout = setTimeout(() => {\n      console.log(\"[HeroToContactHeader] Creating Observer after delay\");\n      console.log(\"[HeroToContactHeader] Pre-Observer scroll position:\", window.scrollY);\n      window.scrollTo(0, 0);\n      console.log(\"[HeroToContactHeader] Force reset scroll to:\", window.scrollY);\n      observer = Observer.create({\n        type: \"wheel,touch,pointer\",\n        preventDefault: true,\n        wheelSpeed: -1,\n        onUp: () => {\n          console.log(\"[Observer] Scroll DOWN detected:\", {\n            scrollY: window.scrollY,\n            currentIndex: currentIndexRef.current,\n            animating: animatingRef.current,\n            timestamp: (/* @__PURE__ */ new Date()).toISOString()\n          });\n          if (animatingRef.current) {\n            console.warn(\"[Observer] BLOCKED: Animation in progress\");\n            return;\n          }\n          if (currentIndexRef.current >= sections.length - 1) {\n            console.warn(\"[Observer] BLOCKED: Already at last section\");\n            return;\n          }\n          gotoSection(currentIndexRef.current + 1, 1);\n        },\n        onDown: () => {\n          console.log(\"[Observer] Scroll UP detected:\", {\n            scrollY: window.scrollY,\n            currentIndex: currentIndexRef.current,\n            animating: animatingRef.current,\n            timestamp: (/* @__PURE__ */ new Date()).toISOString()\n          });\n          if (animatingRef.current) {\n            console.warn(\"[Observer] BLOCKED: Animation in progress\");\n            return;\n          }\n          if (currentIndexRef.current <= 0) {\n            console.warn(\"[Observer] BLOCKED: Already at first section\");\n            return;\n          }\n          gotoSection(currentIndexRef.current - 1, -1);\n        },\n        tolerance: 10,\n        debounce: true\n        // Prevent rapid firing\n      });\n      console.log(\"[HeroToContactHeader] Observer created successfully\");\n    }, 100);\n    window.testGotoSection = (section) => {\n      const targetIndex = section === \"header\" ? 1 : 0;\n      const direction = targetIndex > currentIndexRef.current ? 1 : -1;\n      gotoSection(targetIndex, direction);\n    };\n    return () => {\n      console.log(\"[HeroToContactHeader] Cleaning up orchestrator\");\n      clearTimeout(observerTimeout);\n      if (observer) {\n        console.log(\"[HeroToContactHeader] Killing Observer\");\n        observer.kill();\n      }\n      if (headerRef.current?.parentNode) {\n        console.log(\"[HeroToContactHeader] Removing header from DOM\");\n        headerRef.current.parentNode.removeChild(headerRef.current);\n      }\n    };\n  }, [getElement]);\n  return null;\n};\n_s(HeroToContactHeaderOrchestrator, \"B5CpsSt/Wg6Jl58bdxIUu1ewAzM=\", false, function() {\n  return [useMotion, useGSAP];\n});\n_c = HeroToContactHeaderOrchestrator;\nvar _c;\n$RefreshReg$(_c, \"HeroToContactHeaderOrchestrator\");\nif (import.meta.hot && !inWebWorker) {\n  window.$RefreshReg$ = prevRefreshReg;\n  window.$RefreshSig$ = prevRefreshSig;\n  RefreshRuntime.__hmr_import(import.meta.url).then((currentExports) => {\n    RefreshRuntime.registerExportsForReactRefresh(\"/home/will/local_dev/portfolio/packages/motion-system/src/orchestrators/HeroToContactHeaderOrchestrator.tsx\", currentExports);\n    import.meta.hot.accept((nextExports) => {\n      if (!nextExports)\n        return;\n      const invalidateMessage = RefreshRuntime.validateRefreshBoundaryAndEnqueueUpdate(currentExports, nextExports);\n      if (invalidateMessage)\n        import.meta.hot.invalidate(invalidateMessage);\n    });\n  });\n}\n\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJtYXBwaW5ncyI6IjJCQUFBO0FBQWdCQSxNQUFRQyxjQUFnQixPQUFPO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQy9DLFNBQVNDLFlBQVk7QUFDckIsU0FBU0MsZ0JBQWdCO0FBQ3pCLFNBQVNDLGVBQWU7QUFDeEIsU0FBU0MsaUJBQWlCO0FBSTFCLElBQUlDLGFBQWtCO0FBQ3RCLElBQUk7QUFFRixRQUFNQyxlQUFlQyxRQUFRLHlEQUF5RDtBQUN0RkYsZUFBYUM7QUFDZixRQUFRO0FBRU5ELGVBQWE7QUFBQSxJQUNYRyxRQUFRO0FBQUEsTUFDTkMsV0FBVztBQUFBLE1BQ1hDLFNBQVM7QUFBQSxNQUNUQyxPQUFPO0FBQUEsSUFDVDtBQUFBLElBQ0FDLGNBQWM7QUFBQSxNQUNaQyxVQUFVLENBQUMsUUFBUSxRQUFRO0FBQUEsTUFDM0JDLG1CQUFtQjtBQUFBLE1BQ25CQyxRQUFRO0FBQUEsTUFDUkMsY0FBYztBQUFBLElBQ2hCO0FBQUEsRUFDRjtBQUNGO0FBRUFmLEtBQUtnQixlQUFlZixVQUFVQyxPQUFPO0FBRXJDLE1BQU1VLFdBQVdSLFdBQVdPLGFBQWFDO0FBR2xDLGFBQU1LLGtDQUE0Q0EsTUFBTTtBQUFBQyxLQUFBO0FBQzdELFFBQU0sRUFBRUMsV0FBVyxJQUFJaEIsVUFBVTtBQUNqQyxRQUFNaUIsWUFBWXRCLE9BQThCLElBQUk7QUFDcEQsUUFBTXVCLGtCQUFrQnZCLE9BQU8sQ0FBQztBQUNoQyxRQUFNd0IsZUFBZXhCLE9BQU8sS0FBSztBQUVqQyxRQUFNeUIsT0FBT3ZCLEtBQUt3QixNQUFNRCxLQUFLLEdBQUdYLFNBQVNhLE1BQU07QUFFL0N2QixVQUFRLE1BQU07QUFDWndCLFlBQVFDLElBQUksaURBQWlEO0FBQzdERCxZQUFRQyxJQUFJLGtEQUFrREMsT0FBT0MsT0FBTztBQUM1RUgsWUFBUUMsSUFBSSx3Q0FBd0NOLGdCQUFnQlMsT0FBTztBQUMzRUosWUFBUUMsSUFBSSwyQ0FBMkMsVUFBVUksUUFBUSxZQUFZLFVBQVU7QUFHL0YsVUFBTUMsaUJBQWlCQyxTQUFTQyxlQUFlLHlCQUF5QjtBQUN4RSxRQUFJRixnQkFBZ0I7QUFDbEJOLGNBQVFDLElBQUkscUVBQXFFO0FBQ2pGSyxxQkFBZUcsT0FBTztBQUFBLElBQ3hCO0FBR0FuQyxTQUFLb0MsSUFBSVIsUUFBUSxFQUFFUyxVQUFVLEVBQUUsQ0FBQztBQUNoQ1gsWUFBUUMsSUFBSSwwQ0FBMENDLE9BQU9DLE9BQU87QUFFcEUsVUFBTVMsV0FBV25CLFdBQVcsV0FBVyxHQUFHVztBQUMxQyxVQUFNUyxZQUFZcEIsV0FBVyxZQUFZLEdBQUdXO0FBQzVDLFVBQU1VLFlBQVlyQixXQUFXLFlBQVksR0FBR1c7QUFDNUMsVUFBTVcsa0JBQWtCdEIsV0FBVyxrQkFBa0IsR0FBR1c7QUFDeEQsVUFBTVksY0FBY3ZCLFdBQVcsY0FBYyxHQUFHVztBQUVoRCxRQUFJLENBQUNRLFlBQVksQ0FBQ0MsYUFBYSxDQUFDQyxXQUFXO0FBRXpDZCxjQUFRQyxJQUFJLDJEQUEyRDtBQUFBLFFBQ3JFVyxVQUFVLENBQUMsQ0FBQ0E7QUFBQUEsUUFDWkMsV0FBVyxDQUFDLENBQUNBO0FBQUFBLFFBQ2JDLFdBQVcsQ0FBQyxDQUFDQTtBQUFBQSxNQUNmLENBQUM7QUFDRDtBQUFBLElBQ0Y7QUFFQSxVQUFNRyxlQUFlLENBQUNMLFVBQVVDLFdBQVdDLFdBQVdDLGlCQUFpQkMsV0FBVyxFQUFFRSxPQUFPQyxPQUFPO0FBR2xHLFFBQUksQ0FBQ3pCLFVBQVVVLFdBQVcsQ0FBQ0csU0FBU0MsZUFBZSx5QkFBeUIsR0FBRztBQUM3RVIsY0FBUUMsSUFBSSwrQ0FBK0M7QUFDM0RQLGdCQUFVVSxVQUFVRyxTQUFTYSxjQUFjLEtBQUs7QUFDaEQxQixnQkFBVVUsUUFBUWlCLEtBQUs7QUFDdkIzQixnQkFBVVUsUUFBUWtCLFlBQVk7QUFBQTtBQUFBLGlDQUVINUMsV0FBV0csT0FBT0MsU0FBUztBQUFBLG9DQUN4QkosV0FBV0csT0FBT0UsT0FBTztBQUFBO0FBQUE7QUFBQTtBQUFBLDhDQUlmTCxXQUFXRyxPQUFPRyxLQUFLLEtBQUtOLFdBQVdHLE9BQU9HLEtBQUs7QUFBQTtBQUFBO0FBSzNGVixXQUFLb0MsSUFBSU8sY0FBYyxFQUFFTSxRQUFRLEdBQUdDLFdBQVcsRUFBRSxDQUFDO0FBQ2xEbEQsV0FBS29DLElBQUloQixVQUFVVSxTQUFTO0FBQUEsUUFDMUJxQixVQUFVO0FBQUEsUUFDVkMsS0FBSztBQUFBLFFBQ0xDLE1BQU07QUFBQSxRQUNOQyxPQUFPO0FBQUEsUUFDUEMsUUFBUTtBQUFBLFFBQ1JDLFlBQVk7QUFBQSxRQUNaQyxjQUFjO0FBQUEsUUFDZFIsUUFBUTtBQUFBLFFBQ1JTLFNBQVM7QUFBQSxRQUNUQyxZQUFZO0FBQUEsUUFDWkMsZ0JBQWdCO0FBQUEsUUFDaEJDLFNBQVM7QUFBQSxRQUNUWCxXQUFXO0FBQUEsTUFDYixDQUFDO0FBR0QsWUFBTVksYUFBYTFDLFVBQVVVLFFBQVFpQyxjQUFjLGNBQWM7QUFDakUsWUFBTUMsY0FBYzVDLFVBQVVVLFFBQVFpQyxjQUFjLGVBQWU7QUFDbkUsWUFBTUUsY0FBYzdDLFVBQVVVLFFBQVFpQyxjQUFjLGVBQWU7QUFFbkUsVUFBSUQsWUFBWTtBQUNkOUQsYUFBS29DLElBQUkwQixZQUFZO0FBQUEsVUFDbkJJLFlBQVk7QUFBQSxVQUNaQyxVQUFVO0FBQUEsVUFDVkMsWUFBWTtBQUFBLFVBQ1pDLFFBQVE7QUFBQSxVQUNSQyxlQUFlO0FBQUEsVUFDZkMsWUFBWTtBQUFBLFVBQ1pDLGVBQWU7QUFBQSxVQUNmQyxPQUFPO0FBQUEsUUFDVCxDQUFDO0FBQUEsTUFDSDtBQUVBLFVBQUlULGFBQWE7QUFDZmhFLGFBQUtvQyxJQUFJNEIsYUFBYTtBQUFBLFVBQ3BCRSxZQUFZO0FBQUEsVUFDWkMsVUFBVTtBQUFBLFVBQ1ZDLFlBQVk7QUFBQSxVQUNaQyxRQUFRO0FBQUEsVUFDUkssV0FBVztBQUFBLFVBQ1hKLGVBQWU7QUFBQSxVQUNmSyxTQUFTO0FBQUEsVUFDVEYsT0FBTztBQUFBLFFBQ1QsQ0FBQztBQUFBLE1BQ0g7QUFFQSxVQUFJUixhQUFhO0FBQ2ZqRSxhQUFLb0MsSUFBSTZCLGFBQWE7QUFBQSxVQUNwQkMsWUFBWTtBQUFBLFVBQ1pDLFVBQVU7QUFBQSxVQUNWQyxZQUFZO0FBQUEsVUFDWkssT0FBTztBQUFBLFVBQ1BHLGdCQUFnQjtBQUFBLFVBQ2hCRCxTQUFTO0FBQUEsVUFDVEUsWUFBWTtBQUFBLFFBQ2QsQ0FBQztBQUFBLE1BQ0g7QUFHQSxVQUFJLENBQUM1QyxTQUFTQyxlQUFlLHlCQUF5QixHQUFHO0FBQ3ZEUixnQkFBUUMsSUFBSSwrQ0FBK0M7QUFDM0RNLGlCQUFTNkMsS0FBS0MsWUFBWTNELFVBQVVVLE9BQU87QUFBQSxNQUM3QyxPQUFPO0FBQ0xKLGdCQUFRQyxJQUFJLDhEQUE4RDtBQUFBLE1BQzVFO0FBR0EsWUFBTXFELGNBQWM1RCxVQUFVVSxRQUFRaUMsY0FBYyxlQUFlO0FBQ25FLFVBQUlpQixhQUFhO0FBRWYsY0FBTUMsWUFBWWhELFNBQVNhLGNBQWMsS0FBSztBQUM5Q21DLGtCQUFVQyxZQUFZO0FBQ3RCRCxrQkFBVUUsTUFBTUMsVUFBVTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBTzFCLGNBQU1DLFlBQVlwRCxTQUFTYSxjQUFjLEdBQUc7QUFDNUN1QyxrQkFBVUMsT0FBTztBQUNqQkQsa0JBQVVILFlBQVk7QUFDdEJHLGtCQUFVRixNQUFNQyxVQUFVO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQWExQixjQUFNRyxTQUFTLENBQUMsZ0JBQWdCLGdCQUFnQixjQUFjO0FBQzlELFlBQUlDLGVBQWU7QUFHbkIsY0FBTUMsc0JBQXNCQSxDQUFDQyxTQUFpQjtBQUM1Q0wsb0JBQVVyQyxZQUFZO0FBQ3RCMEMsZUFBS0MsTUFBTSxFQUFFLEVBQUVDLFFBQVEsQ0FBQ0MsTUFBTUMsVUFBVTtBQUV0QyxrQkFBTUMsZ0JBQWdCOUQsU0FBU2EsY0FBYyxNQUFNO0FBQ25EaUQsMEJBQWNiLFlBQVk7QUFDMUJhLDBCQUFjWixNQUFNQyxVQUFVO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFVOUIsa0JBQU1ZLFVBQVUvRCxTQUFTYSxjQUFjLE1BQU07QUFDN0NrRCxvQkFBUWQsWUFBWTtBQUNwQmMsb0JBQVFiLE1BQU1DLFVBQVU7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFVeEJZLG9CQUFRQyxjQUFjSjtBQUV0QkUsMEJBQWNoQixZQUFZaUIsT0FBTztBQUNqQ1gsc0JBQVVOLFlBQVlnQixhQUFhO0FBQUEsVUFDckMsQ0FBQztBQUFBLFFBQ0g7QUFHQU4sNEJBQW9CRixPQUFPLENBQUMsQ0FBQztBQUc3QixjQUFNVyxjQUFjQSxNQUFNO0FBQ3hCLGdCQUFNQyxZQUFZWDtBQUNsQkEsMEJBQWdCQSxlQUFlLEtBQUtELE9BQU85RDtBQUMzQyxnQkFBTTJFLFdBQVdiLE9BQU9ZLFNBQVM7QUFDakMsZ0JBQU1FLFVBQVVkLE9BQU9DLFlBQVk7QUFDbkMsZ0JBQU1jLFdBQVdqQixVQUFVa0IsaUJBQWlCLFVBQVU7QUFFdERGLGtCQUFRVixNQUFNLEVBQUUsRUFBRUMsUUFBUSxDQUFDQyxNQUFNQyxVQUFVO0FBQ3pDLGdCQUFJUSxTQUFTUixLQUFLLEdBQUc7QUFDbkIsb0JBQU1FLFVBQVVNLFNBQVNSLEtBQUs7QUFDOUIsb0JBQU1VLFdBQVdKLFNBQVNOLEtBQUs7QUFHL0Isa0JBQUlELFNBQVNXLFVBQVU7QUFDckIsc0JBQU1DLFFBQVFYLFFBQVE7QUFHdEI5RixxQkFBSzBHLEdBQUdWLFNBQVM7QUFBQSxrQkFDZlcsU0FBUztBQUFBLGtCQUNUQyxVQUFVO0FBQUEsa0JBQ1ZIO0FBQUFBLGtCQUNBSSxNQUFNO0FBQUEsa0JBQ05DLFlBQVlBLE1BQU07QUFDaEJkLDRCQUFRQyxjQUFjSjtBQUN0QjdGLHlCQUFLMEcsR0FBR1YsU0FBUztBQUFBLHNCQUNmVyxTQUFTO0FBQUEsc0JBQ1RDLFVBQVU7QUFBQSxzQkFDVkMsTUFBTTtBQUFBLG9CQUNSLENBQUM7QUFBQSxrQkFDSDtBQUFBLGdCQUNGLENBQUM7QUFBQSxjQUNIO0FBQUEsWUFDRjtBQUFBLFVBQ0YsQ0FBQztBQUFBLFFBQ0g7QUFHQW5GLGdCQUFRQyxJQUFJLHdEQUF3RDtBQUNwRW9GLG9CQUFZYixhQUFhLEdBQUk7QUFFN0JqQixrQkFBVUYsWUFBWU0sU0FBUztBQUMvQkwsb0JBQVlELFlBQVlFLFNBQVM7QUFBQSxNQUNuQztBQUFBLElBQ0Y7QUFFQSxhQUFTK0IsWUFBWWxCLE9BQWVtQixXQUFtQjtBQUNyRHZGLGNBQVFDLElBQUksNkNBQTZDO0FBQUEsUUFDdkR1RixhQUFhcEI7QUFBQUEsUUFDYm1CLFdBQVdBLFlBQVksSUFBSSxTQUFTO0FBQUEsUUFDcENFLGNBQWM5RixnQkFBZ0JTO0FBQUFBLFFBQzlCc0YsV0FBVzlGLGFBQWFRO0FBQUFBLFFBQ3hCdUYsWUFBVyxvQkFBSUMsS0FBSyxHQUFFQyxZQUFZO0FBQUEsTUFDcEMsQ0FBQztBQUdELFVBQUlqRyxhQUFhUSxTQUFTO0FBQ3hCSixnQkFBUThGLEtBQUssOERBQThEO0FBQzNFO0FBQUEsTUFDRjtBQUVBbEcsbUJBQWFRLFVBQVU7QUFDdkJnRSxjQUFRdkUsS0FBS3VFLEtBQUs7QUFFbEIsVUFBSTJCLEtBQUt6SCxLQUFLMEgsU0FBUztBQUFBLFFBQ3JCQyxVQUFVO0FBQUEsVUFDUmYsVUFBVXhHLFdBQVdPLGFBQWFFLG9CQUFvQjtBQUFBLFVBQ3REZ0csTUFBTXpHLFdBQVdPLGFBQWFHO0FBQUFBLFFBQ2hDO0FBQUEsUUFDQWdHLFlBQVlBLE1BQU07QUFDaEJ4Rix1QkFBYVEsVUFBVTtBQUN2Qkosa0JBQVFDLElBQUksNkNBQTZDO0FBQUEsWUFDdkRpRyxVQUFVOUI7QUFBQUEsWUFDVitCLFNBQVMvQixVQUFVLElBQUksU0FBUztBQUFBLFlBQ2hDdUIsWUFBVyxvQkFBSUMsS0FBSyxHQUFFQyxZQUFZO0FBQUEsVUFDcEMsQ0FBQztBQUFBLFFBQ0g7QUFBQSxNQUNGLENBQUM7QUFHRHZILFdBQUtvQyxJQUFJLENBQUNPLGNBQWN2QixVQUFVVSxPQUFPLEdBQUcsRUFBRW1CLFFBQVEsR0FBR0MsV0FBVyxFQUFFLENBQUM7QUFFdkUsVUFBSTRDLFVBQVUsR0FBRztBQUNmcEUsZ0JBQVFDLElBQUkscURBQXFEO0FBRWpFM0IsYUFBS29DLElBQUlPLGNBQWMsRUFBRU0sUUFBUSxHQUFHQyxXQUFXLEVBQUUsQ0FBQztBQUNsRGxELGFBQUtvQyxJQUFJaEIsVUFBVVUsU0FBUyxFQUFFbUIsUUFBUSxHQUFHQyxXQUFXLEVBQUUsQ0FBQztBQUV2RHVFLFdBQUdmLEdBQUcvRCxjQUFjO0FBQUEsVUFDbEJPLFdBQVc7QUFBQSxVQUNYNEUsR0FBRztBQUFBLFVBQ0hDLFNBQVMzSCxXQUFXTyxhQUFhSTtBQUFBQSxRQUNuQyxHQUFHLENBQUMsRUFDSGlIO0FBQUFBLFVBQU81RyxVQUFVVTtBQUFBQSxVQUNoQixFQUFFZ0csR0FBRyxNQUFNNUUsV0FBVyxFQUFFO0FBQUEsVUFDeEIsRUFBRTRFLEdBQUcsR0FBRzVFLFdBQVcsRUFBRTtBQUFBLFVBQUc7QUFBQSxRQUFHO0FBQUEsTUFDL0IsT0FBTztBQUNMeEIsZ0JBQVFDLElBQUkscURBQXFEO0FBRWpFM0IsYUFBS29DLElBQUloQixVQUFVVSxTQUFTLEVBQUVtQixRQUFRLEdBQUdDLFdBQVcsRUFBRSxDQUFDO0FBQ3ZEbEQsYUFBS29DLElBQUlPLGNBQWMsRUFBRU0sUUFBUSxHQUFHQyxXQUFXLEVBQUUsQ0FBQztBQUdsRHhCLGdCQUFRQyxJQUFJLCtDQUErQztBQUMzRDhGLFdBQUdmLEdBQUc5RSxRQUFRO0FBQUEsVUFDWlMsVUFBVTtBQUFBLFVBQ1Z1RSxVQUFVeEcsV0FBV08sYUFBYUUsb0JBQW9CO0FBQUEsVUFDdERnRyxNQUFNekcsV0FBV08sYUFBYUc7QUFBQUEsUUFDaEMsR0FBRyxDQUFDLEVBQ0g0RixHQUFHdEYsVUFBVVUsU0FBUztBQUFBLFVBQ3JCZ0csR0FBRztBQUFBLFVBQ0g1RSxXQUFXO0FBQUEsUUFDYixHQUFHLENBQUMsRUFDSDhFO0FBQUFBLFVBQU9yRjtBQUFBQSxVQUNOLEVBQUVtRixHQUFHLEtBQUs1RSxXQUFXLEVBQUU7QUFBQSxVQUN2QixFQUFFNEUsR0FBRyxHQUFHNUUsV0FBVyxHQUFHNkUsU0FBUzNILFdBQVdPLGFBQWFJLGFBQWE7QUFBQSxVQUFHO0FBQUEsUUFBRztBQUFBLE1BQzlFO0FBRUFNLHNCQUFnQlMsVUFBVWdFO0FBQUFBLElBQzVCO0FBR0EsUUFBSW1DLFdBQWdCO0FBR3BCLFVBQU1DLGtCQUFrQkMsV0FBVyxNQUFNO0FBQ3ZDekcsY0FBUUMsSUFBSSxxREFBcUQ7QUFDakVELGNBQVFDLElBQUksdURBQXVEQyxPQUFPQyxPQUFPO0FBR2pGRCxhQUFPUyxTQUFTLEdBQUcsQ0FBQztBQUNwQlgsY0FBUUMsSUFBSSxnREFBZ0RDLE9BQU9DLE9BQU87QUFFMUVvRyxpQkFBV2hJLFNBQVNtSSxPQUFPO0FBQUEsUUFDM0JDLE1BQU07QUFBQSxRQUNOQyxnQkFBZ0I7QUFBQSxRQUNoQkMsWUFBWTtBQUFBLFFBQ1pDLE1BQU1BLE1BQU07QUFDVjlHLGtCQUFRQyxJQUFJLG9DQUFvQztBQUFBLFlBQzlDRSxTQUFTRCxPQUFPQztBQUFBQSxZQUNoQnNGLGNBQWM5RixnQkFBZ0JTO0FBQUFBLFlBQzlCc0YsV0FBVzlGLGFBQWFRO0FBQUFBLFlBQ3hCdUYsWUFBVyxvQkFBSUMsS0FBSyxHQUFFQyxZQUFZO0FBQUEsVUFDcEMsQ0FBQztBQUNELGNBQUlqRyxhQUFhUSxTQUFTO0FBQ3hCSixvQkFBUThGLEtBQUssMkNBQTJDO0FBQ3hEO0FBQUEsVUFDRjtBQUNBLGNBQUluRyxnQkFBZ0JTLFdBQVdsQixTQUFTYSxTQUFTLEdBQUc7QUFDbERDLG9CQUFROEYsS0FBSyw2Q0FBNkM7QUFDMUQ7QUFBQSxVQUNGO0FBQ0FSLHNCQUFZM0YsZ0JBQWdCUyxVQUFVLEdBQUcsQ0FBRTtBQUFBLFFBQzdDO0FBQUEsUUFDQTJHLFFBQVFBLE1BQU07QUFDWi9HLGtCQUFRQyxJQUFJLGtDQUFrQztBQUFBLFlBQzVDRSxTQUFTRCxPQUFPQztBQUFBQSxZQUNoQnNGLGNBQWM5RixnQkFBZ0JTO0FBQUFBLFlBQzlCc0YsV0FBVzlGLGFBQWFRO0FBQUFBLFlBQ3hCdUYsWUFBVyxvQkFBSUMsS0FBSyxHQUFFQyxZQUFZO0FBQUEsVUFDcEMsQ0FBQztBQUNELGNBQUlqRyxhQUFhUSxTQUFTO0FBQ3hCSixvQkFBUThGLEtBQUssMkNBQTJDO0FBQ3hEO0FBQUEsVUFDRjtBQUNBLGNBQUluRyxnQkFBZ0JTLFdBQVcsR0FBRztBQUNoQ0osb0JBQVE4RixLQUFLLDhDQUE4QztBQUMzRDtBQUFBLFVBQ0Y7QUFDQVIsc0JBQVkzRixnQkFBZ0JTLFVBQVUsR0FBRyxFQUFFO0FBQUEsUUFDN0M7QUFBQSxRQUNBNEcsV0FBVztBQUFBLFFBQ1hDLFVBQVU7QUFBQTtBQUFBLE1BQ1osQ0FBQztBQUNDakgsY0FBUUMsSUFBSSxxREFBcUQ7QUFBQSxJQUNuRSxHQUFHLEdBQUc7QUFHTCxJQUFDQyxPQUFlZ0gsa0JBQWtCLENBQUNmLFlBQW9CO0FBQ3RELFlBQU1YLGNBQWNXLFlBQVksV0FBVyxJQUFJO0FBQy9DLFlBQU1aLFlBQVlDLGNBQWM3RixnQkFBZ0JTLFVBQVUsSUFBSTtBQUM5RGtGLGtCQUFZRSxhQUFhRCxTQUFTO0FBQUEsSUFDcEM7QUFFQSxXQUFPLE1BQU07QUFDWHZGLGNBQVFDLElBQUksZ0RBQWdEO0FBRzVEa0gsbUJBQWFYLGVBQWU7QUFHNUIsVUFBSUQsVUFBVTtBQUNadkcsZ0JBQVFDLElBQUksd0NBQXdDO0FBQ3BEc0csaUJBQVNhLEtBQUs7QUFBQSxNQUNoQjtBQUVBLFVBQUkxSCxVQUFVVSxTQUFTaUgsWUFBWTtBQUNqQ3JILGdCQUFRQyxJQUFJLGdEQUFnRDtBQUM1RFAsa0JBQVVVLFFBQVFpSCxXQUFXQyxZQUFZNUgsVUFBVVUsT0FBTztBQUFBLE1BQzVEO0FBQUEsSUFDRjtBQUFBLEVBQ0YsR0FBRyxDQUFDWCxVQUFVLENBQUM7QUFFZixTQUFPO0FBQ1Q7QUFBQ0QsR0FuWllELGlDQUF5QztBQUFBLFVBQzdCZCxXQU92QkQsT0FBTztBQUFBO0FBQUErSSxLQVJJaEk7QUFBeUMsSUFBQWdJO0FBQUFDLGFBQUFELElBQUEiLCJuYW1lcyI6WyJ1c2VSZWYiLCJ1c2VTdGF0ZSIsImdzYXAiLCJPYnNlcnZlciIsInVzZUdTQVAiLCJ1c2VNb3Rpb24iLCJzaXRlQ29uZmlnIiwiY29uZmlnTW9kdWxlIiwicmVxdWlyZSIsImhlYWRlciIsImJyYW5kTmFtZSIsInRhZ2xpbmUiLCJlbWFpbCIsIm1vdGlvblN5c3RlbSIsInNlY3Rpb25zIiwiYW5pbWF0aW9uRHVyYXRpb24iLCJlYXNpbmciLCJzdGFnZ2VyRGVsYXkiLCJyZWdpc3RlclBsdWdpbiIsIkhlcm9Ub0NvbnRhY3RIZWFkZXJPcmNoZXN0cmF0b3IiLCJfcyIsImdldEVsZW1lbnQiLCJoZWFkZXJSZWYiLCJjdXJyZW50SW5kZXhSZWYiLCJhbmltYXRpbmdSZWYiLCJ3cmFwIiwidXRpbHMiLCJsZW5ndGgiLCJjb25zb2xlIiwibG9nIiwid2luZG93Iiwic2Nyb2xsWSIsImN1cnJlbnQiLCJSZWFjdCIsImV4aXN0aW5nSGVhZGVyIiwiZG9jdW1lbnQiLCJnZXRFbGVtZW50QnlJZCIsInJlbW92ZSIsInNldCIsInNjcm9sbFRvIiwiaGVyb05hbWUiLCJoZXJvVGl0bGUiLCJoZXJvRW1haWwiLCJoZXJvSW5zdGl0dXRpb24iLCJoZXJvQ29udGFjdCIsImhlcm9FbGVtZW50cyIsImZpbHRlciIsIkJvb2xlYW4iLCJjcmVhdGVFbGVtZW50IiwiaWQiLCJpbm5lckhUTUwiLCJ6SW5kZXgiLCJhdXRvQWxwaGEiLCJwb3NpdGlvbiIsInRvcCIsImxlZnQiLCJyaWdodCIsImhlaWdodCIsImJhY2tncm91bmQiLCJib3JkZXJCb3R0b20iLCJkaXNwbGF5IiwiYWxpZ25JdGVtcyIsImp1c3RpZnlDb250ZW50IiwicGFkZGluZyIsImhlYWRlck5hbWUiLCJxdWVyeVNlbGVjdG9yIiwiaGVhZGVyVGl0bGUiLCJoZWFkZXJFbWFpbCIsImZvbnRGYW1pbHkiLCJmb250U2l6ZSIsImZvbnRXZWlnaHQiLCJtYXJnaW4iLCJsZXR0ZXJTcGFjaW5nIiwibGluZUhlaWdodCIsInRleHRUcmFuc2Zvcm0iLCJjb2xvciIsIm1hcmdpblRvcCIsIm9wYWNpdHkiLCJ0ZXh0RGVjb3JhdGlvbiIsInRyYW5zaXRpb24iLCJib2R5IiwiYXBwZW5kQ2hpbGQiLCJoZWFkZXJQaG9uZSIsImNvbnRhaW5lciIsImNsYXNzTmFtZSIsInN0eWxlIiwiY3NzVGV4dCIsInBob25lTGluayIsImhyZWYiLCJzdGFnZXMiLCJjdXJyZW50U3RhZ2UiLCJjcmVhdGVGbGlwU3RydWN0dXJlIiwidGV4dCIsInNwbGl0IiwiZm9yRWFjaCIsImNoYXIiLCJpbmRleCIsImZsaXBDb250YWluZXIiLCJmbGlwcGVyIiwidGV4dENvbnRlbnQiLCJhbmltYXRlRmxpcCIsInByZXZTdGFnZSIsInByZXZUZXh0IiwibmV3VGV4dCIsImZsaXBwZXJzIiwicXVlcnlTZWxlY3RvckFsbCIsInByZXZDaGFyIiwiZGVsYXkiLCJ0byIsInJvdGF0ZVgiLCJkdXJhdGlvbiIsImVhc2UiLCJvbkNvbXBsZXRlIiwic2V0SW50ZXJ2YWwiLCJnb3RvU2VjdGlvbiIsImRpcmVjdGlvbiIsInRhcmdldEluZGV4IiwiY3VycmVudEluZGV4IiwiYW5pbWF0aW5nIiwidGltZXN0YW1wIiwiRGF0ZSIsInRvSVNPU3RyaW5nIiwid2FybiIsInRsIiwidGltZWxpbmUiLCJkZWZhdWx0cyIsIm5ld0luZGV4Iiwic2VjdGlvbiIsInkiLCJzdGFnZ2VyIiwiZnJvbVRvIiwib2JzZXJ2ZXIiLCJvYnNlcnZlclRpbWVvdXQiLCJzZXRUaW1lb3V0IiwiY3JlYXRlIiwidHlwZSIsInByZXZlbnREZWZhdWx0Iiwid2hlZWxTcGVlZCIsIm9uVXAiLCJvbkRvd24iLCJ0b2xlcmFuY2UiLCJkZWJvdW5jZSIsInRlc3RHb3RvU2VjdGlvbiIsImNsZWFyVGltZW91dCIsImtpbGwiLCJwYXJlbnROb2RlIiwicmVtb3ZlQ2hpbGQiLCJfYyIsIiRSZWZyZXNoUmVnJCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlcyI6WyJIZXJvVG9Db250YWN0SGVhZGVyT3JjaGVzdHJhdG9yLnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QsIHsgdXNlUmVmLCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHsgZ3NhcCB9IGZyb20gJ2dzYXAnXG5pbXBvcnQgeyBPYnNlcnZlciB9IGZyb20gJ2dzYXAvT2JzZXJ2ZXInXG5pbXBvcnQgeyB1c2VHU0FQIH0gZnJvbSAnQGdzYXAvcmVhY3QnXG5pbXBvcnQgeyB1c2VNb3Rpb24gfSBmcm9tICcuLi9wcm92aWRlcnMvTW90aW9uUHJvdmlkZXInXG5cbi8vIEltcG9ydCBjb25maWcgLSBub3RlOiB0aGlzIGNyZWF0ZXMgYSBkZXBlbmRlbmN5IG9uIHRoZSBhcHAgY29uZmlnXG4vLyBJbiBhIHJlYWwgaW1wbGVtZW50YXRpb24sIHlvdSBtaWdodCB3YW50IHRvIHBhc3MgdGhpcyBhcyBwcm9wc1xubGV0IHNpdGVDb25maWc6IGFueSA9IG51bGxcbnRyeSB7XG4gIC8vIER5bmFtaWMgaW1wb3J0IHRvIGF2b2lkIGJ1aWxkIGlzc3VlcyBpZiBjb25maWcgZG9lc24ndCBleGlzdFxuICBjb25zdCBjb25maWdNb2R1bGUgPSByZXF1aXJlKCcuLi8uLi8uLi9hcHBzL3JvYmluLW5vZ3VpZXIvc3JjL2NvbmZpZy9zaXRlLWNvbmZpZy5qc29uJylcbiAgc2l0ZUNvbmZpZyA9IGNvbmZpZ01vZHVsZVxufSBjYXRjaCB7XG4gIC8vIEZhbGxiYWNrIGNvbmZpZ1xuICBzaXRlQ29uZmlnID0ge1xuICAgIGhlYWRlcjoge1xuICAgICAgYnJhbmROYW1lOiBcInJ5cyBkZXNpZ25zIOKdpO+4j1wiLFxuICAgICAgdGFnbGluZTogXCJSZXNlYXJjaCBpbiBQcm9ncmVzc1wiLFxuICAgICAgZW1haWw6IFwiaGVsbG9AcnlzZGVzaWducy5jb21cIlxuICAgIH0sXG4gICAgbW90aW9uU3lzdGVtOiB7XG4gICAgICBzZWN0aW9uczogW1wiaGVyb1wiLCBcImhlYWRlclwiXSxcbiAgICAgIGFuaW1hdGlvbkR1cmF0aW9uOiAxMDAwLFxuICAgICAgZWFzaW5nOiBcImV4cG8uaW5PdXRcIixcbiAgICAgIHN0YWdnZXJEZWxheTogMC4wNVxuICAgIH1cbiAgfVxufVxuXG5nc2FwLnJlZ2lzdGVyUGx1Z2luKE9ic2VydmVyLCB1c2VHU0FQKVxuXG5jb25zdCBzZWN0aW9ucyA9IHNpdGVDb25maWcubW90aW9uU3lzdGVtLnNlY3Rpb25zIGFzIGNvbnN0XG50eXBlIFNlY3Rpb24gPSB0eXBlb2Ygc2VjdGlvbnNbbnVtYmVyXVxuXG5leHBvcnQgY29uc3QgSGVyb1RvQ29udGFjdEhlYWRlck9yY2hlc3RyYXRvcjogUmVhY3QuRkMgPSAoKSA9PiB7XG4gIGNvbnN0IHsgZ2V0RWxlbWVudCB9ID0gdXNlTW90aW9uKClcbiAgY29uc3QgaGVhZGVyUmVmID0gdXNlUmVmPEhUTUxEaXZFbGVtZW50IHwgbnVsbD4obnVsbClcbiAgY29uc3QgY3VycmVudEluZGV4UmVmID0gdXNlUmVmKDApXG4gIGNvbnN0IGFuaW1hdGluZ1JlZiA9IHVzZVJlZihmYWxzZSlcbiAgXG4gIGNvbnN0IHdyYXAgPSBnc2FwLnV0aWxzLndyYXAoMCwgc2VjdGlvbnMubGVuZ3RoKVxuXG4gIHVzZUdTQVAoKCkgPT4ge1xuICAgIGNvbnNvbGUubG9nKCdbSGVyb1RvQ29udGFjdEhlYWRlcl0gSW5pdGlhbGl6aW5nIG9yY2hlc3RyYXRvcicpXG4gICAgY29uc29sZS5sb2coJ1tIZXJvVG9Db250YWN0SGVhZGVyXSBJbml0aWFsIHNjcm9sbCBwb3NpdGlvbjonLCB3aW5kb3cuc2Nyb2xsWSlcbiAgICBjb25zb2xlLmxvZygnW0hlcm9Ub0NvbnRhY3RIZWFkZXJdIEN1cnJlbnQgaW5kZXg6JywgY3VycmVudEluZGV4UmVmLmN1cnJlbnQpXG4gICAgY29uc29sZS5sb2coJ1tIZXJvVG9Db250YWN0SGVhZGVyXSBSZWFjdC5TdHJpY3RNb2RlOicsICdyb290JyBpbiBSZWFjdCA/ICdlbmFibGVkJyA6ICdkaXNhYmxlZCcpXG4gICAgXG4gICAgLy8gQ2xlYW4gdXAgYW55IGV4aXN0aW5nIGhlYWRlciBmcm9tIHByZXZpb3VzIFN0cmljdE1vZGUgcmVuZGVyXG4gICAgY29uc3QgZXhpc3RpbmdIZWFkZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc3RpY2t5LWhlYWRlci1jb250YWluZXInKVxuICAgIGlmIChleGlzdGluZ0hlYWRlcikge1xuICAgICAgY29uc29sZS5sb2coJ1tIZXJvVG9Db250YWN0SGVhZGVyXSBSZW1vdmluZyBleGlzdGluZyBoZWFkZXIgZnJvbSBwcmV2aW91cyByZW5kZXInKVxuICAgICAgZXhpc3RpbmdIZWFkZXIucmVtb3ZlKClcbiAgICB9XG4gICAgXG4gICAgLy8gRm9yY2Ugc2Nyb2xsIHJlc2V0IHVzaW5nIEdTQVAgdG8gYnlwYXNzIE9ic2VydmVyXG4gICAgZ3NhcC5zZXQod2luZG93LCB7IHNjcm9sbFRvOiAwIH0pXG4gICAgY29uc29sZS5sb2coJ1tIZXJvVG9Db250YWN0SGVhZGVyXSBTY3JvbGwgcmVzZXQgdG86Jywgd2luZG93LnNjcm9sbFkpXG4gICAgXG4gICAgY29uc3QgaGVyb05hbWUgPSBnZXRFbGVtZW50KCdoZXJvLW5hbWUnKT8uY3VycmVudFxuICAgIGNvbnN0IGhlcm9UaXRsZSA9IGdldEVsZW1lbnQoJ2hlcm8tdGl0bGUnKT8uY3VycmVudFxuICAgIGNvbnN0IGhlcm9FbWFpbCA9IGdldEVsZW1lbnQoJ2hlcm8tZW1haWwnKT8uY3VycmVudFxuICAgIGNvbnN0IGhlcm9JbnN0aXR1dGlvbiA9IGdldEVsZW1lbnQoJ2hlcm8taW5zdGl0dXRpb24nKT8uY3VycmVudFxuICAgIGNvbnN0IGhlcm9Db250YWN0ID0gZ2V0RWxlbWVudCgnaGVyby1jb250YWN0Jyk/LmN1cnJlbnRcblxuICAgIGlmICghaGVyb05hbWUgfHwgIWhlcm9UaXRsZSB8fCAhaGVyb0VtYWlsKSB7XG4gICAgICAvLyBUaGlzIGlzIGV4cGVjdGVkIG9uIGZpcnN0IHJlbmRlciBiZWZvcmUgZWxlbWVudHMgcmVnaXN0ZXJcbiAgICAgIGNvbnNvbGUubG9nKCdbSGVyb1RvQ29udGFjdEhlYWRlcl0gV2FpdGluZyBmb3IgZWxlbWVudHMgdG8gcmVnaXN0ZXI6Jywge1xuICAgICAgICBoZXJvTmFtZTogISFoZXJvTmFtZSxcbiAgICAgICAgaGVyb1RpdGxlOiAhIWhlcm9UaXRsZSxcbiAgICAgICAgaGVyb0VtYWlsOiAhIWhlcm9FbWFpbFxuICAgICAgfSlcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IGhlcm9FbGVtZW50cyA9IFtoZXJvTmFtZSwgaGVyb1RpdGxlLCBoZXJvRW1haWwsIGhlcm9JbnN0aXR1dGlvbiwgaGVyb0NvbnRhY3RdLmZpbHRlcihCb29sZWFuKVxuXG4gICAgLy8gQ3JlYXRlIGhlYWRlciBlbGVtZW50IG9uY2UgLSBJREVNUE9URU5UIENIRUNLXG4gICAgaWYgKCFoZWFkZXJSZWYuY3VycmVudCAmJiAhZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3N0aWNreS1oZWFkZXItY29udGFpbmVyJykpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdbSGVyb1RvQ29udGFjdEhlYWRlcl0gQ3JlYXRpbmcgaGVhZGVyIGVsZW1lbnQnKVxuICAgICAgaGVhZGVyUmVmLmN1cnJlbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICAgICAgaGVhZGVyUmVmLmN1cnJlbnQuaWQgPSAnc3RpY2t5LWhlYWRlci1jb250YWluZXInXG4gICAgICBoZWFkZXJSZWYuY3VycmVudC5pbm5lckhUTUwgPSBgXG4gICAgICAgIDxkaXYgY2xhc3M9XCJoZWFkZXItbGVmdFwiPlxuICAgICAgICAgIDxoMSBpZD1cImhlYWRlci1uYW1lXCI+JHtzaXRlQ29uZmlnLmhlYWRlci5icmFuZE5hbWV9PC9oMT5cbiAgICAgICAgICA8c3BhbiBpZD1cImhlYWRlci10aXRsZVwiPiR7c2l0ZUNvbmZpZy5oZWFkZXIudGFnbGluZX08L3NwYW4+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzPVwiaGVhZGVyLXJpZ2h0XCIgc3R5bGU9XCJkaXNwbGF5OiBmbGV4OyBhbGlnbi1pdGVtczogY2VudGVyOyBnYXA6IDFyZW07XCI+XG4gICAgICAgICAgPGRpdiBpZD1cImhlYWRlci1waG9uZVwiPjwvZGl2PlxuICAgICAgICAgIDxhIGlkPVwiaGVhZGVyLWVtYWlsXCIgaHJlZj1cIm1haWx0bzoke3NpdGVDb25maWcuaGVhZGVyLmVtYWlsfVwiPiR7c2l0ZUNvbmZpZy5oZWFkZXIuZW1haWx9PC9hPlxuICAgICAgICA8L2Rpdj5cbiAgICAgIGBcbiAgICAgIFxuICAgICAgLy8gU2V0IGluaXRpYWwgc3RhdGVzIGZvbGxvd2luZyBnaXN0IHBhdHRlcm5cbiAgICAgIGdzYXAuc2V0KGhlcm9FbGVtZW50cywgeyB6SW5kZXg6IDEsIGF1dG9BbHBoYTogMSB9KVxuICAgICAgZ3NhcC5zZXQoaGVhZGVyUmVmLmN1cnJlbnQsIHtcbiAgICAgICAgcG9zaXRpb246ICdmaXhlZCcsXG4gICAgICAgIHRvcDogMCxcbiAgICAgICAgbGVmdDogMCxcbiAgICAgICAgcmlnaHQ6IDAsXG4gICAgICAgIGhlaWdodDogODAsXG4gICAgICAgIGJhY2tncm91bmQ6ICd2YXIoLS1iZy1wcmltYXJ5KScsXG4gICAgICAgIGJvcmRlckJvdHRvbTogJzFweCBzb2xpZCB2YXIoLS1ib3JkZXIpJyxcbiAgICAgICAgekluZGV4OiAwLFxuICAgICAgICBkaXNwbGF5OiAnZmxleCcsXG4gICAgICAgIGFsaWduSXRlbXM6ICdjZW50ZXInLFxuICAgICAgICBqdXN0aWZ5Q29udGVudDogJ3NwYWNlLWJldHdlZW4nLFxuICAgICAgICBwYWRkaW5nOiAnMCAycmVtJyxcbiAgICAgICAgYXV0b0FscGhhOiAwXG4gICAgICB9KVxuXG4gICAgICAvLyBTdHlsZSB0aGUgaGVhZGVyIGVsZW1lbnRzIHdpdGggcHJvcGVyIHR5cG9ncmFwaHlcbiAgICAgIGNvbnN0IGhlYWRlck5hbWUgPSBoZWFkZXJSZWYuY3VycmVudC5xdWVyeVNlbGVjdG9yKCcjaGVhZGVyLW5hbWUnKSBhcyBIVE1MRWxlbWVudFxuICAgICAgY29uc3QgaGVhZGVyVGl0bGUgPSBoZWFkZXJSZWYuY3VycmVudC5xdWVyeVNlbGVjdG9yKCcjaGVhZGVyLXRpdGxlJykgYXMgSFRNTEVsZW1lbnRcbiAgICAgIGNvbnN0IGhlYWRlckVtYWlsID0gaGVhZGVyUmVmLmN1cnJlbnQucXVlcnlTZWxlY3RvcignI2hlYWRlci1lbWFpbCcpIGFzIEhUTUxFbGVtZW50XG4gICAgICBcbiAgICAgIGlmIChoZWFkZXJOYW1lKSB7XG4gICAgICAgIGdzYXAuc2V0KGhlYWRlck5hbWUsIHtcbiAgICAgICAgICBmb250RmFtaWx5OiAndmFyKC0tZm9udC1oZWFkaW5nKScsXG4gICAgICAgICAgZm9udFNpemU6ICdjbGFtcCgxLjVyZW0sIDN2dywgMnJlbSknLFxuICAgICAgICAgIGZvbnRXZWlnaHQ6IDcwMCxcbiAgICAgICAgICBtYXJnaW46IDAsXG4gICAgICAgICAgbGV0dGVyU3BhY2luZzogJy0wLjAyZW0nLFxuICAgICAgICAgIGxpbmVIZWlnaHQ6IDEsXG4gICAgICAgICAgdGV4dFRyYW5zZm9ybTogJ2xvd2VyY2FzZScsXG4gICAgICAgICAgY29sb3I6ICd2YXIoLS10ZXh0LXByaW1hcnkpJ1xuICAgICAgICB9KVxuICAgICAgfVxuICAgICAgXG4gICAgICBpZiAoaGVhZGVyVGl0bGUpIHtcbiAgICAgICAgZ3NhcC5zZXQoaGVhZGVyVGl0bGUsIHtcbiAgICAgICAgICBmb250RmFtaWx5OiAndmFyKC0tZm9udC1zdWJ0aXRsZSknLFxuICAgICAgICAgIGZvbnRTaXplOiAnY2xhbXAoMC44NzVyZW0sIDEuMjV2dywgMXJlbSknLFxuICAgICAgICAgIGZvbnRXZWlnaHQ6IDMwMCxcbiAgICAgICAgICBtYXJnaW46IDAsXG4gICAgICAgICAgbWFyZ2luVG9wOiAnMC4yNXJlbScsXG4gICAgICAgICAgbGV0dGVyU3BhY2luZzogJzAuMDVlbScsXG4gICAgICAgICAgb3BhY2l0eTogMC44LFxuICAgICAgICAgIGNvbG9yOiAndmFyKC0tdGV4dC1wcmltYXJ5KSdcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICAgIFxuICAgICAgaWYgKGhlYWRlckVtYWlsKSB7XG4gICAgICAgIGdzYXAuc2V0KGhlYWRlckVtYWlsLCB7XG4gICAgICAgICAgZm9udEZhbWlseTogJ3ZhcigtLWZvbnQtc3VidGl0bGUpJyxcbiAgICAgICAgICBmb250U2l6ZTogJ2NsYW1wKDAuODc1cmVtLCAxLjI1dncsIDFyZW0pJyxcbiAgICAgICAgICBmb250V2VpZ2h0OiAzMDAsXG4gICAgICAgICAgY29sb3I6ICd2YXIoLS10ZXh0LXByaW1hcnkpJyxcbiAgICAgICAgICB0ZXh0RGVjb3JhdGlvbjogJ25vbmUnLFxuICAgICAgICAgIG9wYWNpdHk6IDAuOCxcbiAgICAgICAgICB0cmFuc2l0aW9uOiAnb3BhY2l0eSAwLjJzIGVhc2UnXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIE9ubHkgYXBwZW5kIGlmIG5vdCBhbHJlYWR5IGluIERPTVxuICAgICAgaWYgKCFkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc3RpY2t5LWhlYWRlci1jb250YWluZXInKSkge1xuICAgICAgICBjb25zb2xlLmxvZygnW0hlcm9Ub0NvbnRhY3RIZWFkZXJdIEFwcGVuZGluZyBoZWFkZXIgdG8gRE9NJylcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChoZWFkZXJSZWYuY3VycmVudClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdbSGVyb1RvQ29udGFjdEhlYWRlcl0gSGVhZGVyIGFscmVhZHkgaW4gRE9NLCBza2lwcGluZyBhcHBlbmQnKVxuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBDUkVBVEUgQUNUVUFMIEtJTkVUSUMgUEhPTkUgU1RSVUNUVVJFIC0gbm90IGp1c3QgdGV4dFxuICAgICAgY29uc3QgaGVhZGVyUGhvbmUgPSBoZWFkZXJSZWYuY3VycmVudC5xdWVyeVNlbGVjdG9yKCcjaGVhZGVyLXBob25lJylcbiAgICAgIGlmIChoZWFkZXJQaG9uZSkge1xuICAgICAgICAvLyBDcmVhdGUgY29udGFpbmVyIHdpdGggcHJvcGVyIGNsYXNzZXNcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgICAgICAgY29udGFpbmVyLmNsYXNzTmFtZSA9ICdjb250YWluZXInIC8vIE1hdGNoIEtpbmV0aWNQaG9uZSBDU1NcbiAgICAgICAgY29udGFpbmVyLnN0eWxlLmNzc1RleHQgPSBgXG4gICAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcbiAgICAgICAgICBtYXJnaW4tcmlnaHQ6IDFyZW07XG4gICAgICAgIGBcbiAgICAgICAgXG4gICAgICAgIC8vIENyZWF0ZSBwaG9uZSBsaW5rXG4gICAgICAgIGNvbnN0IHBob25lTGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKVxuICAgICAgICBwaG9uZUxpbmsuaHJlZiA9ICd0ZWw6MzMyMjg3OTUzMydcbiAgICAgICAgcGhvbmVMaW5rLmNsYXNzTmFtZSA9ICdwaG9uZUxpbmsnIC8vIE1hdGNoIEtpbmV0aWNQaG9uZSBDU1NcbiAgICAgICAgcGhvbmVMaW5rLnN0eWxlLmNzc1RleHQgPSBgXG4gICAgICAgICAgZGlzcGxheTogaW5saW5lLWZsZXg7XG4gICAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICAgICAgICB0ZXh0LWRlY29yYXRpb246IG5vbmU7XG4gICAgICAgICAgY29sb3I6IHZhcigtLXRleHQtcHJpbWFyeSk7XG4gICAgICAgICAgZm9udC1mYW1pbHk6IHZhcigtLWZvbnQtc3VidGl0bGUpO1xuICAgICAgICAgIGZvbnQtc2l6ZTogY2xhbXAoMC44NzVyZW0sIDEuMjV2dywgMXJlbSk7XG4gICAgICAgICAgZm9udC13ZWlnaHQ6IDQwMDtcbiAgICAgICAgICBsZXR0ZXItc3BhY2luZzogMDtcbiAgICAgICAgICBvcGFjaXR5OiAwLjg7XG4gICAgICAgICAgdHJhbnNpdGlvbjogb3BhY2l0eSAwLjNzIGVhc2U7XG4gICAgICAgIGBcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IHN0YWdlcyA9IFsnMzMyIDI4Ny05NTMzJywgJzMzMiBBVC1SWUxFRScsICdOWUMgQCBSWUxFRSAnXVxuICAgICAgICBsZXQgY3VycmVudFN0YWdlID0gMFxuICAgICAgICBcbiAgICAgICAgLy8gQ1JFQVRFIEZMSVAgQ09OVEFJTkVSUyBBTkQgRkxJUFBFUlNcbiAgICAgICAgY29uc3QgY3JlYXRlRmxpcFN0cnVjdHVyZSA9ICh0ZXh0OiBzdHJpbmcpID0+IHtcbiAgICAgICAgICBwaG9uZUxpbmsuaW5uZXJIVE1MID0gJydcbiAgICAgICAgICB0ZXh0LnNwbGl0KCcnKS5mb3JFYWNoKChjaGFyLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIGZsaXAgY29udGFpbmVyXG4gICAgICAgICAgICBjb25zdCBmbGlwQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpXG4gICAgICAgICAgICBmbGlwQ29udGFpbmVyLmNsYXNzTmFtZSA9ICdmbGlwQ29udGFpbmVyJyAvLyBDUklUSUNBTDogVGhpcyBjbGFzcyBtdXN0IGV4aXN0IGZvciB0ZXN0XG4gICAgICAgICAgICBmbGlwQ29udGFpbmVyLnN0eWxlLmNzc1RleHQgPSBgXG4gICAgICAgICAgICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcbiAgICAgICAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgICAgICAgICBoZWlnaHQ6IDEuMmVtO1xuICAgICAgICAgICAgICBvdmVyZmxvdzogaGlkZGVuO1xuICAgICAgICAgICAgICB0cmFuc2Zvcm0tc3R5bGU6IHByZXNlcnZlLTNkO1xuICAgICAgICAgICAgICBwZXJzcGVjdGl2ZTogMzAwcHg7XG4gICAgICAgICAgICBgXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIENyZWF0ZSBmbGlwcGVyXG4gICAgICAgICAgICBjb25zdCBmbGlwcGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpXG4gICAgICAgICAgICBmbGlwcGVyLmNsYXNzTmFtZSA9ICdmbGlwcGVyJyAvLyBDUklUSUNBTDogVGhpcyBjbGFzcyBtdXN0IGV4aXN0IGZvciB0ZXN0XG4gICAgICAgICAgICBmbGlwcGVyLnN0eWxlLmNzc1RleHQgPSBgXG4gICAgICAgICAgICAgIGRpc3BsYXk6IGlubGluZS1mbGV4O1xuICAgICAgICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgICAgICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICAgICAgICAgICAgaGVpZ2h0OiAxMDAlO1xuICAgICAgICAgICAgICBtaW4td2lkdGg6IDAuNWNoO1xuICAgICAgICAgICAgICB0cmFuc2Zvcm0tb3JpZ2luOiBjZW50ZXIgY2VudGVyO1xuICAgICAgICAgICAgICB0cmFuc2Zvcm0tc3R5bGU6IHByZXNlcnZlLTNkO1xuICAgICAgICAgICAgICBmb250LXZhcmlhbnQtbnVtZXJpYzogdGFidWxhci1udW1zO1xuICAgICAgICAgICAgYFxuICAgICAgICAgICAgZmxpcHBlci50ZXh0Q29udGVudCA9IGNoYXJcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgZmxpcENvbnRhaW5lci5hcHBlbmRDaGlsZChmbGlwcGVyKVxuICAgICAgICAgICAgcGhvbmVMaW5rLmFwcGVuZENoaWxkKGZsaXBDb250YWluZXIpXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gSW5pdGlhbCBzdHJ1Y3R1cmVcbiAgICAgICAgY3JlYXRlRmxpcFN0cnVjdHVyZShzdGFnZXNbMF0pXG4gICAgICAgIFxuICAgICAgICAvLyBBbmltYXRpb24gZnVuY3Rpb24gd2l0aCBhY3R1YWwgRkxJUCBlZmZlY3RcbiAgICAgICAgY29uc3QgYW5pbWF0ZUZsaXAgPSAoKSA9PiB7XG4gICAgICAgICAgY29uc3QgcHJldlN0YWdlID0gY3VycmVudFN0YWdlXG4gICAgICAgICAgY3VycmVudFN0YWdlID0gKGN1cnJlbnRTdGFnZSArIDEpICUgc3RhZ2VzLmxlbmd0aFxuICAgICAgICAgIGNvbnN0IHByZXZUZXh0ID0gc3RhZ2VzW3ByZXZTdGFnZV1cbiAgICAgICAgICBjb25zdCBuZXdUZXh0ID0gc3RhZ2VzW2N1cnJlbnRTdGFnZV1cbiAgICAgICAgICBjb25zdCBmbGlwcGVycyA9IHBob25lTGluay5xdWVyeVNlbGVjdG9yQWxsKCcuZmxpcHBlcicpXG4gICAgICAgICAgXG4gICAgICAgICAgbmV3VGV4dC5zcGxpdCgnJykuZm9yRWFjaCgoY2hhciwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGlmIChmbGlwcGVyc1tpbmRleF0pIHtcbiAgICAgICAgICAgICAgY29uc3QgZmxpcHBlciA9IGZsaXBwZXJzW2luZGV4XSBhcyBIVE1MRWxlbWVudFxuICAgICAgICAgICAgICBjb25zdCBwcmV2Q2hhciA9IHByZXZUZXh0W2luZGV4XVxuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgLy8gT25seSBmbGlwIGlmIGNoYXJhY3RlciBhY3R1YWxseSBjaGFuZ2VzXG4gICAgICAgICAgICAgIGlmIChjaGFyICE9PSBwcmV2Q2hhcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlbGF5ID0gaW5kZXggKiAwLjAzXG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gR1NBUCAzRCBmbGlwIGFuaW1hdGlvbiB1c2luZyByb3RhdGVYIChub3Qgcm90YXRpb25YKVxuICAgICAgICAgICAgICAgIGdzYXAudG8oZmxpcHBlciwge1xuICAgICAgICAgICAgICAgICAgcm90YXRlWDogLTkwLFxuICAgICAgICAgICAgICAgICAgZHVyYXRpb246IDAuMyxcbiAgICAgICAgICAgICAgICAgIGRlbGF5LFxuICAgICAgICAgICAgICAgICAgZWFzZTogJ3Bvd2VyMi5pbicsXG4gICAgICAgICAgICAgICAgICBvbkNvbXBsZXRlOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGZsaXBwZXIudGV4dENvbnRlbnQgPSBjaGFyXG4gICAgICAgICAgICAgICAgICAgIGdzYXAudG8oZmxpcHBlciwge1xuICAgICAgICAgICAgICAgICAgICAgIHJvdGF0ZVg6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgZHVyYXRpb246IDAuMyxcbiAgICAgICAgICAgICAgICAgICAgICBlYXNlOiAncG93ZXIyLm91dCdcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gU3RhcnQgYW5pbWF0aW9uIGxvb3BcbiAgICAgICAgY29uc29sZS5sb2coJ1tIZXJvVG9Db250YWN0SGVhZGVyXSBTdGFydGluZyBraW5ldGljIHBob25lIGFuaW1hdGlvbicpXG4gICAgICAgIHNldEludGVydmFsKGFuaW1hdGVGbGlwLCAzMDAwKVxuICAgICAgICBcbiAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKHBob25lTGluaylcbiAgICAgICAgaGVhZGVyUGhvbmUuYXBwZW5kQ2hpbGQoY29udGFpbmVyKVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdvdG9TZWN0aW9uKGluZGV4OiBudW1iZXIsIGRpcmVjdGlvbjogbnVtYmVyKSB7XG4gICAgICBjb25zb2xlLmxvZygnW0hlcm9Ub0NvbnRhY3RIZWFkZXJdIGdvdG9TZWN0aW9uIGNhbGxlZDonLCB7XG4gICAgICAgIHRhcmdldEluZGV4OiBpbmRleCxcbiAgICAgICAgZGlyZWN0aW9uOiBkaXJlY3Rpb24gPiAwID8gJ2Rvd24nIDogJ3VwJyxcbiAgICAgICAgY3VycmVudEluZGV4OiBjdXJyZW50SW5kZXhSZWYuY3VycmVudCxcbiAgICAgICAgYW5pbWF0aW5nOiBhbmltYXRpbmdSZWYuY3VycmVudCxcbiAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICAgIH0pXG4gICAgICBcbiAgICAgIC8vIENSSVRJQ0FMOiBCbG9jayBpZiBhbmltYXRpbmcgb3Igc2FtZSBzZWN0aW9uIChmb2xsb3dpbmcgZ2lzdCBwYXR0ZXJuIGV4YWN0bHkpXG4gICAgICBpZiAoYW5pbWF0aW5nUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdbSGVyb1RvQ29udGFjdEhlYWRlcl0gQkxPQ0tFRDogQW5pbWF0aW9uIGFscmVhZHkgaW4gcHJvZ3Jlc3MnKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIFxuICAgICAgYW5pbWF0aW5nUmVmLmN1cnJlbnQgPSB0cnVlXG4gICAgICBpbmRleCA9IHdyYXAoaW5kZXgpXG5cbiAgICAgIGxldCB0bCA9IGdzYXAudGltZWxpbmUoe1xuICAgICAgICBkZWZhdWx0czogeyBcbiAgICAgICAgICBkdXJhdGlvbjogc2l0ZUNvbmZpZy5tb3Rpb25TeXN0ZW0uYW5pbWF0aW9uRHVyYXRpb24gLyAxMDAwLCBcbiAgICAgICAgICBlYXNlOiBzaXRlQ29uZmlnLm1vdGlvblN5c3RlbS5lYXNpbmcgXG4gICAgICAgIH0sXG4gICAgICAgIG9uQ29tcGxldGU6ICgpID0+IHtcbiAgICAgICAgICBhbmltYXRpbmdSZWYuY3VycmVudCA9IGZhbHNlXG4gICAgICAgICAgY29uc29sZS5sb2coJ1tIZXJvVG9Db250YWN0SGVhZGVyXSBBbmltYXRpb24gY29tcGxldGU6Jywge1xuICAgICAgICAgICAgbmV3SW5kZXg6IGluZGV4LFxuICAgICAgICAgICAgc2VjdGlvbjogaW5kZXggPT09IDAgPyAnaGVybycgOiAnaGVhZGVyJyxcbiAgICAgICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfSlcblxuICAgICAgLy8gRVhBQ1RMWSBsaWtlIHRoZSBnaXN0OiBTZXQgQUxMIHNlY3Rpb25zIHRvIGJhc2Ugc3RhdGUgZmlyc3RcbiAgICAgIGdzYXAuc2V0KFtoZXJvRWxlbWVudHMsIGhlYWRlclJlZi5jdXJyZW50XSwgeyB6SW5kZXg6IDAsIGF1dG9BbHBoYTogMCB9KVxuICAgICAgXG4gICAgICBpZiAoaW5kZXggPT09IDEpIHsgLy8gR29pbmcgdG8gaGVhZGVyXG4gICAgICAgIGNvbnNvbGUubG9nKCdbSGVyb1RvQ29udGFjdEhlYWRlcl0gVHJhbnNpdGlvbmluZzogaGVybyAtPiBoZWFkZXInKVxuICAgICAgICAvLyBTZXQgY3VycmVudCAoaGVybykgdmlzaWJsZSwgbmV4dCAoaGVhZGVyKSByZWFkeSB0byBhbmltYXRlIGluXG4gICAgICAgIGdzYXAuc2V0KGhlcm9FbGVtZW50cywgeyB6SW5kZXg6IDEsIGF1dG9BbHBoYTogMSB9KVxuICAgICAgICBnc2FwLnNldChoZWFkZXJSZWYuY3VycmVudCwgeyB6SW5kZXg6IDIsIGF1dG9BbHBoYTogMSB9KVxuICAgICAgICBcbiAgICAgICAgdGwudG8oaGVyb0VsZW1lbnRzLCB7XG4gICAgICAgICAgYXV0b0FscGhhOiAwLFxuICAgICAgICAgIHk6IC0yMCxcbiAgICAgICAgICBzdGFnZ2VyOiBzaXRlQ29uZmlnLm1vdGlvblN5c3RlbS5zdGFnZ2VyRGVsYXlcbiAgICAgICAgfSwgMClcbiAgICAgICAgLmZyb21UbyhoZWFkZXJSZWYuY3VycmVudCwgXG4gICAgICAgICAgeyB5OiAtMTAwLCBhdXRvQWxwaGE6IDAgfSxcbiAgICAgICAgICB7IHk6IDAsIGF1dG9BbHBoYTogMSB9LCAwLjIpXG4gICAgICB9IGVsc2UgeyAvLyBHb2luZyB0byBoZXJvXG4gICAgICAgIGNvbnNvbGUubG9nKCdbSGVyb1RvQ29udGFjdEhlYWRlcl0gVHJhbnNpdGlvbmluZzogaGVhZGVyIC0+IGhlcm8nKVxuICAgICAgICAvLyBTZXQgY3VycmVudCAoaGVhZGVyKSB2aXNpYmxlLCBuZXh0IChoZXJvKSByZWFkeSB0byBhbmltYXRlIGluICBcbiAgICAgICAgZ3NhcC5zZXQoaGVhZGVyUmVmLmN1cnJlbnQsIHsgekluZGV4OiAxLCBhdXRvQWxwaGE6IDEgfSlcbiAgICAgICAgZ3NhcC5zZXQoaGVyb0VsZW1lbnRzLCB7IHpJbmRleDogMiwgYXV0b0FscGhhOiAxIH0pXG4gICAgICAgIFxuICAgICAgICAvLyBBbmltYXRlIHNjcm9sbCB0byB0b3AgYXMgcGFydCBvZiB0aGUgdHJhbnNpdGlvblxuICAgICAgICBjb25zb2xlLmxvZygnW0hlcm9Ub0NvbnRhY3RIZWFkZXJdIEFuaW1hdGluZyBzY3JvbGwgdG8gdG9wJylcbiAgICAgICAgdGwudG8od2luZG93LCB7XG4gICAgICAgICAgc2Nyb2xsVG86IDAsXG4gICAgICAgICAgZHVyYXRpb246IHNpdGVDb25maWcubW90aW9uU3lzdGVtLmFuaW1hdGlvbkR1cmF0aW9uIC8gMTAwMCxcbiAgICAgICAgICBlYXNlOiBzaXRlQ29uZmlnLm1vdGlvblN5c3RlbS5lYXNpbmdcbiAgICAgICAgfSwgMClcbiAgICAgICAgLnRvKGhlYWRlclJlZi5jdXJyZW50LCB7XG4gICAgICAgICAgeTogLTEwMCxcbiAgICAgICAgICBhdXRvQWxwaGE6IDBcbiAgICAgICAgfSwgMClcbiAgICAgICAgLmZyb21UbyhoZXJvRWxlbWVudHMsXG4gICAgICAgICAgeyB5OiAtMjAsIGF1dG9BbHBoYTogMCB9LFxuICAgICAgICAgIHsgeTogMCwgYXV0b0FscGhhOiAxLCBzdGFnZ2VyOiBzaXRlQ29uZmlnLm1vdGlvblN5c3RlbS5zdGFnZ2VyRGVsYXkgfSwgMC4yKVxuICAgICAgfVxuXG4gICAgICBjdXJyZW50SW5kZXhSZWYuY3VycmVudCA9IGluZGV4XG4gICAgfVxuXG4gICAgLy8gU3RvcmUgb2JzZXJ2ZXIgaW5zdGFuY2UgZm9yIGNsZWFudXBcbiAgICBsZXQgb2JzZXJ2ZXI6IGFueSA9IG51bGxcbiAgICBcbiAgICAvLyBEZWxheSBPYnNlcnZlciBjcmVhdGlvbiB0byBhbGxvdyBicm93c2VyIHNjcm9sbCByZXN0b3JhdGlvbiB0byBjb21wbGV0ZVxuICAgIGNvbnN0IG9ic2VydmVyVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgY29uc29sZS5sb2coJ1tIZXJvVG9Db250YWN0SGVhZGVyXSBDcmVhdGluZyBPYnNlcnZlciBhZnRlciBkZWxheScpXG4gICAgICBjb25zb2xlLmxvZygnW0hlcm9Ub0NvbnRhY3RIZWFkZXJdIFByZS1PYnNlcnZlciBzY3JvbGwgcG9zaXRpb246Jywgd2luZG93LnNjcm9sbFkpXG4gICAgICBcbiAgICAgIC8vIEZvcmNlIHNjcm9sbCB0byB0b3AgQUdBSU4gYmVmb3JlIGNyZWF0aW5nIE9ic2VydmVyXG4gICAgICB3aW5kb3cuc2Nyb2xsVG8oMCwgMClcbiAgICAgIGNvbnNvbGUubG9nKCdbSGVyb1RvQ29udGFjdEhlYWRlcl0gRm9yY2UgcmVzZXQgc2Nyb2xsIHRvOicsIHdpbmRvdy5zY3JvbGxZKVxuICAgICAgXG4gICAgICBvYnNlcnZlciA9IE9ic2VydmVyLmNyZWF0ZSh7XG4gICAgICB0eXBlOiBcIndoZWVsLHRvdWNoLHBvaW50ZXJcIixcbiAgICAgIHByZXZlbnREZWZhdWx0OiB0cnVlLFxuICAgICAgd2hlZWxTcGVlZDogLTEsXG4gICAgICBvblVwOiAoKSA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdbT2JzZXJ2ZXJdIFNjcm9sbCBET1dOIGRldGVjdGVkOicsIHtcbiAgICAgICAgICBzY3JvbGxZOiB3aW5kb3cuc2Nyb2xsWSxcbiAgICAgICAgICBjdXJyZW50SW5kZXg6IGN1cnJlbnRJbmRleFJlZi5jdXJyZW50LFxuICAgICAgICAgIGFuaW1hdGluZzogYW5pbWF0aW5nUmVmLmN1cnJlbnQsXG4gICAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICAgICAgfSlcbiAgICAgICAgaWYgKGFuaW1hdGluZ1JlZi5jdXJyZW50KSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKCdbT2JzZXJ2ZXJdIEJMT0NLRUQ6IEFuaW1hdGlvbiBpbiBwcm9ncmVzcycpXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1cnJlbnRJbmRleFJlZi5jdXJyZW50ID49IHNlY3Rpb25zLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ1tPYnNlcnZlcl0gQkxPQ0tFRDogQWxyZWFkeSBhdCBsYXN0IHNlY3Rpb24nKVxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIGdvdG9TZWN0aW9uKGN1cnJlbnRJbmRleFJlZi5jdXJyZW50ICsgMSwgKzEpXG4gICAgICB9LFxuICAgICAgb25Eb3duOiAoKSA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdbT2JzZXJ2ZXJdIFNjcm9sbCBVUCBkZXRlY3RlZDonLCB7XG4gICAgICAgICAgc2Nyb2xsWTogd2luZG93LnNjcm9sbFksXG4gICAgICAgICAgY3VycmVudEluZGV4OiBjdXJyZW50SW5kZXhSZWYuY3VycmVudCxcbiAgICAgICAgICBhbmltYXRpbmc6IGFuaW1hdGluZ1JlZi5jdXJyZW50LFxuICAgICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgICAgIH0pXG4gICAgICAgIGlmIChhbmltYXRpbmdSZWYuY3VycmVudCkge1xuICAgICAgICAgIGNvbnNvbGUud2FybignW09ic2VydmVyXSBCTE9DS0VEOiBBbmltYXRpb24gaW4gcHJvZ3Jlc3MnKVxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIGlmIChjdXJyZW50SW5kZXhSZWYuY3VycmVudCA8PSAwKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKCdbT2JzZXJ2ZXJdIEJMT0NLRUQ6IEFscmVhZHkgYXQgZmlyc3Qgc2VjdGlvbicpXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgZ290b1NlY3Rpb24oY3VycmVudEluZGV4UmVmLmN1cnJlbnQgLSAxLCAtMSlcbiAgICAgIH0sXG4gICAgICB0b2xlcmFuY2U6IDEwLFxuICAgICAgZGVib3VuY2U6IHRydWUgLy8gUHJldmVudCByYXBpZCBmaXJpbmdcbiAgICB9KVxuICAgICAgY29uc29sZS5sb2coJ1tIZXJvVG9Db250YWN0SGVhZGVyXSBPYnNlcnZlciBjcmVhdGVkIHN1Y2Nlc3NmdWxseScpXG4gICAgfSwgMTAwKSAvLyAxMDBtcyBkZWxheSB0byBsZXQgYnJvd3NlciByZXN0b3JlIHNjcm9sbFxuXG4gICAgLy8gRXhwb3NlIGZvciB0ZXN0aW5nXG4gICAgOyh3aW5kb3cgYXMgYW55KS50ZXN0R290b1NlY3Rpb24gPSAoc2VjdGlvbjogc3RyaW5nKSA9PiB7XG4gICAgICBjb25zdCB0YXJnZXRJbmRleCA9IHNlY3Rpb24gPT09ICdoZWFkZXInID8gMSA6IDBcbiAgICAgIGNvbnN0IGRpcmVjdGlvbiA9IHRhcmdldEluZGV4ID4gY3VycmVudEluZGV4UmVmLmN1cnJlbnQgPyAxIDogLTFcbiAgICAgIGdvdG9TZWN0aW9uKHRhcmdldEluZGV4LCBkaXJlY3Rpb24pXG4gICAgfVxuXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGNvbnNvbGUubG9nKCdbSGVyb1RvQ29udGFjdEhlYWRlcl0gQ2xlYW5pbmcgdXAgb3JjaGVzdHJhdG9yJylcbiAgICAgIFxuICAgICAgLy8gQ2xlYXIgdGltZW91dCBpZiBzdGlsbCBwZW5kaW5nXG4gICAgICBjbGVhclRpbWVvdXQob2JzZXJ2ZXJUaW1lb3V0KVxuICAgICAgXG4gICAgICAvLyBLaWxsIG9ic2VydmVyXG4gICAgICBpZiAob2JzZXJ2ZXIpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ1tIZXJvVG9Db250YWN0SGVhZGVyXSBLaWxsaW5nIE9ic2VydmVyJylcbiAgICAgICAgb2JzZXJ2ZXIua2lsbCgpXG4gICAgICB9XG4gICAgICBcbiAgICAgIGlmIChoZWFkZXJSZWYuY3VycmVudD8ucGFyZW50Tm9kZSkge1xuICAgICAgICBjb25zb2xlLmxvZygnW0hlcm9Ub0NvbnRhY3RIZWFkZXJdIFJlbW92aW5nIGhlYWRlciBmcm9tIERPTScpXG4gICAgICAgIGhlYWRlclJlZi5jdXJyZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoaGVhZGVyUmVmLmN1cnJlbnQpXG4gICAgICB9XG4gICAgfVxuICB9LCBbZ2V0RWxlbWVudF0pXG5cbiAgcmV0dXJuIG51bGxcbn0iXSwiZmlsZSI6Ii9ob21lL3dpbGwvbG9jYWxfZGV2L3BvcnRmb2xpby9wYWNrYWdlcy9tb3Rpb24tc3lzdGVtL3NyYy9vcmNoZXN0cmF0b3JzL0hlcm9Ub0NvbnRhY3RIZWFkZXJPcmNoZXN0cmF0b3IudHN4In0=",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 51293,
            "count": 1
          },
          {
            "startOffset": 342,
            "endOffset": 378,
            "count": 0
          },
          {
            "startOffset": 515,
            "endOffset": 686,
            "count": 0
          },
          {
            "startOffset": 1202,
            "endOffset": 1236,
            "count": 0
          }
        ]
      },
      {
        "functionName": "window.$RefreshReg$",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 791,
            "endOffset": 962,
            "count": 1
          }
        ]
      },
      {
        "functionName": "HeroToContactHeaderOrchestrator",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 2276,
            "endOffset": 15188,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 2501,
            "endOffset": 15155,
            "count": 2
          },
          {
            "startOffset": 2817,
            "endOffset": 2828,
            "count": 0
          },
          {
            "startOffset": 2947,
            "endOffset": 3075,
            "count": 0
          },
          {
            "startOffset": 3234,
            "endOffset": 3243,
            "count": 1
          },
          {
            "startOffset": 3291,
            "endOffset": 3300,
            "count": 1
          },
          {
            "startOffset": 3348,
            "endOffset": 3357,
            "count": 1
          },
          {
            "startOffset": 3417,
            "endOffset": 3426,
            "count": 1
          },
          {
            "startOffset": 3478,
            "endOffset": 3487,
            "count": 1
          },
          {
            "startOffset": 3507,
            "endOffset": 3520,
            "count": 1
          },
          {
            "startOffset": 3521,
            "endOffset": 3534,
            "count": 1
          },
          {
            "startOffset": 3536,
            "endOffset": 3926,
            "count": 1
          },
          {
            "startOffset": 3928,
            "endOffset": 10106,
            "count": 1
          },
          {
            "startOffset": 6521,
            "endOffset": 6621,
            "count": 0
          },
          {
            "startOffset": 10106,
            "endOffset": 15154,
            "count": 1
          }
        ]
      },
      {
        "functionName": "createFlipStructure",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7643,
            "endOffset": 8761,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7724,
            "endOffset": 8749,
            "count": 12
          }
        ]
      },
      {
        "functionName": "animateFlip",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 8831,
            "endOffset": 9887,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 9139,
            "endOffset": 9875,
            "count": 12
          },
          {
            "startOffset": 9325,
            "endOffset": 9849,
            "count": 8
          }
        ]
      },
      {
        "functionName": "onComplete",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 9563,
            "endOffset": 9813,
            "count": 8
          }
        ]
      },
      {
        "functionName": "gotoSection",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10111,
            "endOffset": 12513,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 12578,
            "endOffset": 14481,
            "count": 1
          }
        ]
      },
      {
        "functionName": "onUp",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13002,
            "endOffset": 13657,
            "count": 0
          }
        ]
      },
      {
        "functionName": "onDown",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13675,
            "endOffset": 14312,
            "count": 0
          }
        ]
      },
      {
        "functionName": "window.testGotoSection",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14518,
            "endOffset": 14709,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14722,
            "endOffset": 15150,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15265,
            "endOffset": 15310,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15583,
            "endOffset": 16081,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15810,
            "endOffset": 16075,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5173/@fs/home/will/local_dev/portfolio/packages/motion-system/src/components/KineticText.tsx?t=1750724128976",
    "scriptId": "37",
    "source": "import { createHotContext as __vite__createHotContext } from \"/@vite/client\";import.meta.hot = __vite__createHotContext(\"/@fs/home/will/local_dev/portfolio/packages/motion-system/src/components/KineticText.tsx\");import __vite__cjsImport0_react_jsxDevRuntime from \"/node_modules/.vite/deps/react_jsx-dev-runtime.js?v=a50bb159\"; const jsxDEV = __vite__cjsImport0_react_jsxDevRuntime[\"jsxDEV\"];\nimport RefreshRuntime from \"/@react-refresh\";\nconst inWebWorker = typeof WorkerGlobalScope !== \"undefined\" && self instanceof WorkerGlobalScope;\nlet prevRefreshReg;\nlet prevRefreshSig;\nif (import.meta.hot && !inWebWorker) {\n  if (!window.__vite_plugin_react_preamble_installed__) {\n    throw new Error(\"@vitejs/plugin-react can't detect preamble. Something is wrong. See https://github.com/vitejs/vite-plugin-react/pull/11#discussion_r430879201\");\n  }\n  prevRefreshReg = window.$RefreshReg$;\n  prevRefreshSig = window.$RefreshSig$;\n  window.$RefreshReg$ = (type, id) => {\n    RefreshRuntime.register(type, \"/home/will/local_dev/portfolio/packages/motion-system/src/components/KineticText.tsx \" + id);\n  };\n  window.$RefreshSig$ = RefreshRuntime.createSignatureFunctionForTransform;\n}\nvar _s = $RefreshSig$();\nimport __vite__cjsImport3_react from \"/node_modules/.vite/deps/react.js?v=a50bb159\"; const useRef = __vite__cjsImport3_react[\"useRef\"]; const useEffect = __vite__cjsImport3_react[\"useEffect\"]; const useState = __vite__cjsImport3_react[\"useState\"];\nimport { motion, AnimatePresence } from \"/node_modules/.vite/deps/framer-motion.js?v=a50bb159\";\nimport { useMotion } from \"/@fs/home/will/local_dev/portfolio/packages/motion-system/src/providers/MotionProvider.tsx?t=1750724128976\";\nexport const KineticText = ({\n  id,\n  heroText,\n  headerText,\n  className = \"\",\n  morphThreshold = 0.5,\n  style = {}\n}) => {\n  _s();\n  const elementRef = useRef(null);\n  const { registerElement, currentChapter, chapterProgress } = useMotion();\n  const [displayText, setDisplayText] = useState(heroText);\n  const [isMorphing, setIsMorphing] = useState(false);\n  useEffect(() => {\n    registerElement(id, elementRef);\n  }, [id, registerElement]);\n  useEffect(\n    () => {\n      if (currentChapter === \"morph\") {\n        if (chapterProgress >= morphThreshold && displayText === heroText) {\n          setIsMorphing(true);\n          setTimeout(() => {\n            setDisplayText(headerText);\n            setIsMorphing(false);\n          }, 150);\n        } else if (chapterProgress < morphThreshold && displayText === headerText) {\n          setIsMorphing(true);\n          setTimeout(() => {\n            setDisplayText(heroText);\n            setIsMorphing(false);\n          }, 150);\n        }\n      } else if (currentChapter === \"hero\" && displayText !== heroText) {\n        setDisplayText(heroText);\n      } else if ((currentChapter === \"sticky\" || currentChapter === \"footer\") && displayText !== headerText) {\n        setDisplayText(headerText);\n      }\n    },\n    [\n      currentChapter,\n      chapterProgress,\n      morphThreshold,\n      displayText,\n      heroText,\n      headerText\n    ]\n  );\n  const characters = displayText.split(\"\").map((char, index) => ({\n    char,\n    key: `${displayText}-${index}`\n  }));\n  return /* @__PURE__ */ jsxDEV(\n    \"span\",\n    {\n      ref: elementRef,\n      className,\n      style: {\n        display: \"inline-block\",\n        position: \"relative\",\n        ...style\n      },\n      children: /* @__PURE__ */ jsxDEV(AnimatePresence, { mode: \"wait\", children: isMorphing ? /* @__PURE__ */ jsxDEV(\n        motion.span,\n        {\n          initial: { opacity: 1 },\n          animate: { opacity: 0 },\n          exit: { opacity: 1 },\n          transition: { duration: 0.15 },\n          style: { display: \"inline-block\" },\n          children: displayText\n        },\n        \"morphing\",\n        false,\n        {\n          fileName: \"/home/will/local_dev/portfolio/packages/motion-system/src/components/KineticText.tsx\",\n          lineNumber: 86,\n          columnNumber: 9\n        },\n        this\n      ) : /* @__PURE__ */ jsxDEV(\n        motion.span,\n        {\n          initial: { opacity: 0 },\n          animate: { opacity: 1 },\n          transition: { duration: 0.15 },\n          style: { display: \"inline-block\" },\n          children: characters.map(\n            ({ char, key }, index) => /* @__PURE__ */ jsxDEV(\n              motion.span,\n              {\n                initial: {\n                  y: isMorphing ? 10 : 0,\n                  opacity: 0,\n                  scale: 0.8\n                },\n                animate: {\n                  y: 0,\n                  opacity: 1,\n                  scale: 1\n                },\n                transition: {\n                  duration: 0.3,\n                  delay: index * 0.01,\n                  ease: [0.22, 1, 0.36, 1]\n                },\n                style: {\n                  display: \"inline-block\",\n                  whiteSpace: char === \" \" ? \"pre\" : \"normal\"\n                },\n                children: char\n              },\n              key,\n              false,\n              {\n                fileName: \"/home/will/local_dev/portfolio/packages/motion-system/src/components/KineticText.tsx\",\n                lineNumber: 105,\n                columnNumber: 11\n              },\n              this\n            )\n          )\n        },\n        displayText,\n        false,\n        {\n          fileName: \"/home/will/local_dev/portfolio/packages/motion-system/src/components/KineticText.tsx\",\n          lineNumber: 97,\n          columnNumber: 9\n        },\n        this\n      ) }, void 0, false, {\n        fileName: \"/home/will/local_dev/portfolio/packages/motion-system/src/components/KineticText.tsx\",\n        lineNumber: 84,\n        columnNumber: 7\n      }, this)\n    },\n    void 0,\n    false,\n    {\n      fileName: \"/home/will/local_dev/portfolio/packages/motion-system/src/components/KineticText.tsx\",\n      lineNumber: 75,\n      columnNumber: 5\n    },\n    this\n  );\n};\n_s(KineticText, \"2Pn+gGivnnOzflyhXgCmXr23BFA=\", false, function() {\n  return [useMotion];\n});\n_c = KineticText;\nvar _c;\n$RefreshReg$(_c, \"KineticText\");\nif (import.meta.hot && !inWebWorker) {\n  window.$RefreshReg$ = prevRefreshReg;\n  window.$RefreshSig$ = prevRefreshSig;\n  RefreshRuntime.__hmr_import(import.meta.url).then((currentExports) => {\n    RefreshRuntime.registerExportsForReactRefresh(\"/home/will/local_dev/portfolio/packages/motion-system/src/components/KineticText.tsx\", currentExports);\n    import.meta.hot.accept((nextExports) => {\n      if (!nextExports)\n        return;\n      const invalidateMessage = RefreshRuntime.validateRefreshBoundaryAndEnqueueUpdate(currentExports, nextExports);\n      if (invalidateMessage)\n        import.meta.hot.invalidate(invalidateMessage);\n    });\n  });\n}\n\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJtYXBwaW5ncyI6IkFBcUZVOzJCQXJGVjtBQUFnQkEsTUFBUUMsY0FBV0MsT0FBUSxzQkFBZTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUMxRCxTQUFTQyxRQUFRQyx1QkFBdUI7QUFDeEMsU0FBU0MsaUJBQWlCO0FBV25CLGFBQU1DLGNBQTBDQSxDQUFDO0FBQUEsRUFDdERDO0FBQUFBLEVBQ0FDO0FBQUFBLEVBQ0FDO0FBQUFBLEVBQ0FDLFlBQVk7QUFBQSxFQUNaQyxpQkFBaUI7QUFBQSxFQUNqQkMsUUFBUSxDQUFDO0FBQ1gsTUFBTTtBQUFBQyxLQUFBO0FBQ0osUUFBTUMsYUFBYWQsT0FBd0IsSUFBSTtBQUMvQyxRQUFNLEVBQUVlLGlCQUFpQkMsZ0JBQWdCQyxnQkFBZ0IsSUFBSVosVUFBVTtBQUN2RSxRQUFNLENBQUNhLGFBQWFDLGNBQWMsSUFBSWpCLFNBQVNNLFFBQVE7QUFDdkQsUUFBTSxDQUFDWSxZQUFZQyxhQUFhLElBQUluQixTQUFTLEtBQUs7QUFHbERELFlBQVUsTUFBTTtBQUNkYyxvQkFBZ0JSLElBQUlPLFVBQVU7QUFBQSxFQUNoQyxHQUFHLENBQUNQLElBQUlRLGVBQWUsQ0FBQztBQUd4QmQ7QUFBQUEsSUFBVSxNQUFNO0FBQ2QsVUFBSWUsbUJBQW1CLFNBQVM7QUFDOUIsWUFBSUMsbUJBQW1CTixrQkFBa0JPLGdCQUFnQlYsVUFBVTtBQUNqRWEsd0JBQWMsSUFBSTtBQUNsQkMscUJBQVcsTUFBTTtBQUNmSCwyQkFBZVYsVUFBVTtBQUN6QlksMEJBQWMsS0FBSztBQUFBLFVBQ3JCLEdBQUcsR0FBRztBQUFBLFFBQ1IsV0FDRUosa0JBQWtCTixrQkFDbEJPLGdCQUFnQlQsWUFDaEI7QUFDQVksd0JBQWMsSUFBSTtBQUNsQkMscUJBQVcsTUFBTTtBQUNmSCwyQkFBZVgsUUFBUTtBQUN2QmEsMEJBQWMsS0FBSztBQUFBLFVBQ3JCLEdBQUcsR0FBRztBQUFBLFFBQ1I7QUFBQSxNQUNGLFdBQVdMLG1CQUFtQixVQUFVRSxnQkFBZ0JWLFVBQVU7QUFDaEVXLHVCQUFlWCxRQUFRO0FBQUEsTUFDekIsWUFDR1EsbUJBQW1CLFlBQVlBLG1CQUFtQixhQUNuREUsZ0JBQWdCVCxZQUNoQjtBQUNBVSx1QkFBZVYsVUFBVTtBQUFBLE1BQzNCO0FBQUEsSUFDRjtBQUFBLElBQUc7QUFBQSxNQUNETztBQUFBQSxNQUNBQztBQUFBQSxNQUNBTjtBQUFBQSxNQUNBTztBQUFBQSxNQUNBVjtBQUFBQSxNQUNBQztBQUFBQSxJQUFVO0FBQUEsRUFDWDtBQUdELFFBQU1jLGFBQWFMLFlBQVlNLE1BQU0sRUFBRSxFQUFFQyxJQUFJLENBQUNDLE1BQU1DLFdBQVc7QUFBQSxJQUM3REQ7QUFBQUEsSUFDQUUsS0FBSyxHQUFHVixXQUFXLElBQUlTLEtBQUs7QUFBQSxFQUM5QixFQUFFO0FBRUYsU0FDRTtBQUFBLElBQUM7QUFBQTtBQUFBLE1BQ0MsS0FBS2I7QUFBQUEsTUFDTDtBQUFBLE1BQ0EsT0FBTztBQUFBLFFBQ0xlLFNBQVM7QUFBQSxRQUNUQyxVQUFVO0FBQUEsUUFDVixHQUFHbEI7QUFBQUEsTUFDTDtBQUFBLE1BRUEsaUNBQUMsbUJBQWdCLE1BQUssUUFDbkJRLHVCQUNDO0FBQUEsUUFBQyxPQUFPO0FBQUEsUUFBUDtBQUFBLFVBRUMsU0FBUyxFQUFFVyxTQUFTLEVBQUU7QUFBQSxVQUN0QixTQUFTLEVBQUVBLFNBQVMsRUFBRTtBQUFBLFVBQ3RCLE1BQU0sRUFBRUEsU0FBUyxFQUFFO0FBQUEsVUFDbkIsWUFBWSxFQUFFQyxVQUFVLEtBQUs7QUFBQSxVQUM3QixPQUFPLEVBQUVILFNBQVMsZUFBZTtBQUFBLFVBRWhDWDtBQUFBQTtBQUFBQSxRQVBHO0FBQUEsUUFETjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BU0EsSUFFQTtBQUFBLFFBQUMsT0FBTztBQUFBLFFBQVA7QUFBQSxVQUVDLFNBQVMsRUFBRWEsU0FBUyxFQUFFO0FBQUEsVUFDdEIsU0FBUyxFQUFFQSxTQUFTLEVBQUU7QUFBQSxVQUN0QixZQUFZLEVBQUVDLFVBQVUsS0FBSztBQUFBLFVBQzdCLE9BQU8sRUFBRUgsU0FBUyxlQUFlO0FBQUEsVUFFaENOLHFCQUFXRTtBQUFBQSxZQUFJLENBQUMsRUFBRUMsTUFBTUUsSUFBSSxHQUFHRCxVQUM5QjtBQUFBLGNBQUMsT0FBTztBQUFBLGNBQVA7QUFBQSxnQkFFQyxTQUFTO0FBQUEsa0JBQ1BNLEdBQUdiLGFBQWEsS0FBSztBQUFBLGtCQUNyQlcsU0FBUztBQUFBLGtCQUNURyxPQUFPO0FBQUEsZ0JBQ1Q7QUFBQSxnQkFDQSxTQUFTO0FBQUEsa0JBQ1BELEdBQUc7QUFBQSxrQkFDSEYsU0FBUztBQUFBLGtCQUNURyxPQUFPO0FBQUEsZ0JBQ1Q7QUFBQSxnQkFDQSxZQUFZO0FBQUEsa0JBQ1ZGLFVBQVU7QUFBQSxrQkFDVkcsT0FBT1IsUUFBUTtBQUFBLGtCQUNmUyxNQUFNLENBQUMsTUFBTSxHQUFHLE1BQU0sQ0FBQztBQUFBLGdCQUN6QjtBQUFBLGdCQUNBLE9BQU87QUFBQSxrQkFDTFAsU0FBUztBQUFBLGtCQUNUUSxZQUFZWCxTQUFTLE1BQU0sUUFBUTtBQUFBLGdCQUNyQztBQUFBLGdCQUVDQTtBQUFBQTtBQUFBQSxjQXJCSUU7QUFBQUEsY0FEUDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBdUJBO0FBQUEsVUFDRDtBQUFBO0FBQUEsUUEvQklWO0FBQUFBLFFBRFA7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQWlDQSxLQTlDSjtBQUFBO0FBQUE7QUFBQTtBQUFBLGFBZ0RBO0FBQUE7QUFBQSxJQXpERjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUEwREE7QUFFSjtBQUFDTCxHQXpIWVAsYUFBdUM7QUFBQSxVQVNXRCxTQUFTO0FBQUE7QUFBQWlDLEtBVDNEaEM7QUFBdUMsSUFBQWdDO0FBQUFDLGFBQUFELElBQUEiLCJuYW1lcyI6WyJ1c2VSZWYiLCJ1c2VFZmZlY3QiLCJ1c2VTdGF0ZSIsIm1vdGlvbiIsIkFuaW1hdGVQcmVzZW5jZSIsInVzZU1vdGlvbiIsIktpbmV0aWNUZXh0IiwiaWQiLCJoZXJvVGV4dCIsImhlYWRlclRleHQiLCJjbGFzc05hbWUiLCJtb3JwaFRocmVzaG9sZCIsInN0eWxlIiwiX3MiLCJlbGVtZW50UmVmIiwicmVnaXN0ZXJFbGVtZW50IiwiY3VycmVudENoYXB0ZXIiLCJjaGFwdGVyUHJvZ3Jlc3MiLCJkaXNwbGF5VGV4dCIsInNldERpc3BsYXlUZXh0IiwiaXNNb3JwaGluZyIsInNldElzTW9ycGhpbmciLCJzZXRUaW1lb3V0IiwiY2hhcmFjdGVycyIsInNwbGl0IiwibWFwIiwiY2hhciIsImluZGV4Iiwia2V5IiwiZGlzcGxheSIsInBvc2l0aW9uIiwib3BhY2l0eSIsImR1cmF0aW9uIiwieSIsInNjYWxlIiwiZGVsYXkiLCJlYXNlIiwid2hpdGVTcGFjZSIsIl9jIiwiJFJlZnJlc2hSZWckIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VzIjpbIktpbmV0aWNUZXh0LnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QsIHsgdXNlUmVmLCB1c2VFZmZlY3QsIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgeyBtb3Rpb24sIEFuaW1hdGVQcmVzZW5jZSB9IGZyb20gJ2ZyYW1lci1tb3Rpb24nXG5pbXBvcnQgeyB1c2VNb3Rpb24gfSBmcm9tICcuLi9wcm92aWRlcnMvTW90aW9uUHJvdmlkZXInXG5cbmludGVyZmFjZSBLaW5ldGljVGV4dFByb3BzIHtcbiAgaWQ6IHN0cmluZ1xuICBoZXJvVGV4dDogc3RyaW5nXG4gIGhlYWRlclRleHQ6IHN0cmluZ1xuICBjbGFzc05hbWU/OiBzdHJpbmdcbiAgbW9ycGhUaHJlc2hvbGQ/OiBudW1iZXIgLy8gMC0xLCB3aGVuIHRvIHRyaWdnZXIgbW9ycGhcbiAgc3R5bGU/OiBSZWFjdC5DU1NQcm9wZXJ0aWVzXG59XG5cbmV4cG9ydCBjb25zdCBLaW5ldGljVGV4dDogUmVhY3QuRkM8S2luZXRpY1RleHRQcm9wcz4gPSAoe1xuICBpZCxcbiAgaGVyb1RleHQsXG4gIGhlYWRlclRleHQsXG4gIGNsYXNzTmFtZSA9ICcnLFxuICBtb3JwaFRocmVzaG9sZCA9IDAuNSxcbiAgc3R5bGUgPSB7fSxcbn0pID0+IHtcbiAgY29uc3QgZWxlbWVudFJlZiA9IHVzZVJlZjxIVE1MU3BhbkVsZW1lbnQ+KG51bGwpXG4gIGNvbnN0IHsgcmVnaXN0ZXJFbGVtZW50LCBjdXJyZW50Q2hhcHRlciwgY2hhcHRlclByb2dyZXNzIH0gPSB1c2VNb3Rpb24oKVxuICBjb25zdCBbZGlzcGxheVRleHQsIHNldERpc3BsYXlUZXh0XSA9IHVzZVN0YXRlKGhlcm9UZXh0KVxuICBjb25zdCBbaXNNb3JwaGluZywgc2V0SXNNb3JwaGluZ10gPSB1c2VTdGF0ZShmYWxzZSlcblxuICAvLyBSZWdpc3RlciBlbGVtZW50IHdpdGggbW90aW9uIHN5c3RlbVxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIHJlZ2lzdGVyRWxlbWVudChpZCwgZWxlbWVudFJlZilcbiAgfSwgW2lkLCByZWdpc3RlckVsZW1lbnRdKVxuXG4gIC8vIEhhbmRsZSB0ZXh0IG1vcnBoaW5nIGJhc2VkIG9uIHNjcm9sbCBzdGF0ZVxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChjdXJyZW50Q2hhcHRlciA9PT0gJ21vcnBoJykge1xuICAgICAgaWYgKGNoYXB0ZXJQcm9ncmVzcyA+PSBtb3JwaFRocmVzaG9sZCAmJiBkaXNwbGF5VGV4dCA9PT0gaGVyb1RleHQpIHtcbiAgICAgICAgc2V0SXNNb3JwaGluZyh0cnVlKVxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBzZXREaXNwbGF5VGV4dChoZWFkZXJUZXh0KVxuICAgICAgICAgIHNldElzTW9ycGhpbmcoZmFsc2UpXG4gICAgICAgIH0sIDE1MClcbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIGNoYXB0ZXJQcm9ncmVzcyA8IG1vcnBoVGhyZXNob2xkICYmXG4gICAgICAgIGRpc3BsYXlUZXh0ID09PSBoZWFkZXJUZXh0XG4gICAgICApIHtcbiAgICAgICAgc2V0SXNNb3JwaGluZyh0cnVlKVxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBzZXREaXNwbGF5VGV4dChoZXJvVGV4dClcbiAgICAgICAgICBzZXRJc01vcnBoaW5nKGZhbHNlKVxuICAgICAgICB9LCAxNTApXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjdXJyZW50Q2hhcHRlciA9PT0gJ2hlcm8nICYmIGRpc3BsYXlUZXh0ICE9PSBoZXJvVGV4dCkge1xuICAgICAgc2V0RGlzcGxheVRleHQoaGVyb1RleHQpXG4gICAgfSBlbHNlIGlmIChcbiAgICAgIChjdXJyZW50Q2hhcHRlciA9PT0gJ3N0aWNreScgfHwgY3VycmVudENoYXB0ZXIgPT09ICdmb290ZXInKSAmJlxuICAgICAgZGlzcGxheVRleHQgIT09IGhlYWRlclRleHRcbiAgICApIHtcbiAgICAgIHNldERpc3BsYXlUZXh0KGhlYWRlclRleHQpXG4gICAgfVxuICB9LCBbXG4gICAgY3VycmVudENoYXB0ZXIsXG4gICAgY2hhcHRlclByb2dyZXNzLFxuICAgIG1vcnBoVGhyZXNob2xkLFxuICAgIGRpc3BsYXlUZXh0LFxuICAgIGhlcm9UZXh0LFxuICAgIGhlYWRlclRleHQsXG4gIF0pXG5cbiAgLy8gU3BsaXQgdGV4dCBpbnRvIGNoYXJhY3RlcnMgZm9yIGFuaW1hdGlvblxuICBjb25zdCBjaGFyYWN0ZXJzID0gZGlzcGxheVRleHQuc3BsaXQoJycpLm1hcCgoY2hhciwgaW5kZXgpID0+ICh7XG4gICAgY2hhcixcbiAgICBrZXk6IGAke2Rpc3BsYXlUZXh0fS0ke2luZGV4fWAsXG4gIH0pKVxuXG4gIHJldHVybiAoXG4gICAgPHNwYW5cbiAgICAgIHJlZj17ZWxlbWVudFJlZn1cbiAgICAgIGNsYXNzTmFtZT17Y2xhc3NOYW1lfVxuICAgICAgc3R5bGU9e3tcbiAgICAgICAgZGlzcGxheTogJ2lubGluZS1ibG9jaycsXG4gICAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuICAgICAgICAuLi5zdHlsZSxcbiAgICAgIH19XG4gICAgPlxuICAgICAgPEFuaW1hdGVQcmVzZW5jZSBtb2RlPVwid2FpdFwiPlxuICAgICAgICB7aXNNb3JwaGluZyA/IChcbiAgICAgICAgICA8bW90aW9uLnNwYW5cbiAgICAgICAgICAgIGtleT1cIm1vcnBoaW5nXCJcbiAgICAgICAgICAgIGluaXRpYWw9e3sgb3BhY2l0eTogMSB9fVxuICAgICAgICAgICAgYW5pbWF0ZT17eyBvcGFjaXR5OiAwIH19XG4gICAgICAgICAgICBleGl0PXt7IG9wYWNpdHk6IDEgfX1cbiAgICAgICAgICAgIHRyYW5zaXRpb249e3sgZHVyYXRpb246IDAuMTUgfX1cbiAgICAgICAgICAgIHN0eWxlPXt7IGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snIH19XG4gICAgICAgICAgPlxuICAgICAgICAgICAge2Rpc3BsYXlUZXh0fVxuICAgICAgICAgIDwvbW90aW9uLnNwYW4+XG4gICAgICAgICkgOiAoXG4gICAgICAgICAgPG1vdGlvbi5zcGFuXG4gICAgICAgICAgICBrZXk9e2Rpc3BsYXlUZXh0fVxuICAgICAgICAgICAgaW5pdGlhbD17eyBvcGFjaXR5OiAwIH19XG4gICAgICAgICAgICBhbmltYXRlPXt7IG9wYWNpdHk6IDEgfX1cbiAgICAgICAgICAgIHRyYW5zaXRpb249e3sgZHVyYXRpb246IDAuMTUgfX1cbiAgICAgICAgICAgIHN0eWxlPXt7IGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snIH19XG4gICAgICAgICAgPlxuICAgICAgICAgICAge2NoYXJhY3RlcnMubWFwKCh7IGNoYXIsIGtleSB9LCBpbmRleCkgPT4gKFxuICAgICAgICAgICAgICA8bW90aW9uLnNwYW5cbiAgICAgICAgICAgICAgICBrZXk9e2tleX1cbiAgICAgICAgICAgICAgICBpbml0aWFsPXt7XG4gICAgICAgICAgICAgICAgICB5OiBpc01vcnBoaW5nID8gMTAgOiAwLFxuICAgICAgICAgICAgICAgICAgb3BhY2l0eTogMCxcbiAgICAgICAgICAgICAgICAgIHNjYWxlOiAwLjgsXG4gICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICBhbmltYXRlPXt7XG4gICAgICAgICAgICAgICAgICB5OiAwLFxuICAgICAgICAgICAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgICAgICAgICAgIHNjYWxlOiAxLFxuICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgICAgdHJhbnNpdGlvbj17e1xuICAgICAgICAgICAgICAgICAgZHVyYXRpb246IDAuMyxcbiAgICAgICAgICAgICAgICAgIGRlbGF5OiBpbmRleCAqIDAuMDEsXG4gICAgICAgICAgICAgICAgICBlYXNlOiBbMC4yMiwgMSwgMC4zNiwgMV0sXG4gICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICBzdHlsZT17e1xuICAgICAgICAgICAgICAgICAgZGlzcGxheTogJ2lubGluZS1ibG9jaycsXG4gICAgICAgICAgICAgICAgICB3aGl0ZVNwYWNlOiBjaGFyID09PSAnICcgPyAncHJlJyA6ICdub3JtYWwnLFxuICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICB7Y2hhcn1cbiAgICAgICAgICAgICAgPC9tb3Rpb24uc3Bhbj5cbiAgICAgICAgICAgICkpfVxuICAgICAgICAgIDwvbW90aW9uLnNwYW4+XG4gICAgICAgICl9XG4gICAgICA8L0FuaW1hdGVQcmVzZW5jZT5cbiAgICA8L3NwYW4+XG4gIClcbn1cbiJdLCJmaWxlIjoiL2hvbWUvd2lsbC9sb2NhbF9kZXYvcG9ydGZvbGlvL3BhY2thZ2VzL21vdGlvbi1zeXN0ZW0vc3JjL2NvbXBvbmVudHMvS2luZXRpY1RleHQudHN4In0=",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 16269,
            "count": 1
          },
          {
            "startOffset": 499,
            "endOffset": 535,
            "count": 0
          },
          {
            "startOffset": 672,
            "endOffset": 843,
            "count": 0
          }
        ]
      },
      {
        "functionName": "window.$RefreshReg$",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 948,
            "endOffset": 1096,
            "count": 1
          }
        ]
      },
      {
        "functionName": "KineticText",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1708,
            "endOffset": 5940,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 5997,
            "endOffset": 6033,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 6266,
            "endOffset": 6741,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 6470,
            "endOffset": 6735,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5173/src/components/KineticPhone/index.ts",
    "scriptId": "39",
    "source": "export { KineticPhone } from \"/src/components/KineticPhone/KineticPhone.tsx\";\n\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImluZGV4LnRzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB7IEtpbmV0aWNQaG9uZSB9IGZyb20gJy4vS2luZXRpY1Bob25lJ1xuIl0sIm1hcHBpbmdzIjoiQUFBQSxTQUFTLG9CQUFvQjsiLCJuYW1lcyI6W119",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 325,
            "count": 1
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5173/@fs/home/will/local_dev/portfolio/packages/motion-system/src/components/ContactHeader.tsx?t=1750724128976",
    "scriptId": "38",
    "source": "import { createHotContext as __vite__createHotContext } from \"/@vite/client\";import.meta.hot = __vite__createHotContext(\"/@fs/home/will/local_dev/portfolio/packages/motion-system/src/components/ContactHeader.tsx\");import __vite__cjsImport0_react_jsxDevRuntime from \"/node_modules/.vite/deps/react_jsx-dev-runtime.js?v=a50bb159\"; const jsxDEV = __vite__cjsImport0_react_jsxDevRuntime[\"jsxDEV\"];\nimport RefreshRuntime from \"/@react-refresh\";\nconst inWebWorker = typeof WorkerGlobalScope !== \"undefined\" && self instanceof WorkerGlobalScope;\nlet prevRefreshReg;\nlet prevRefreshSig;\nif (import.meta.hot && !inWebWorker) {\n  if (!window.__vite_plugin_react_preamble_installed__) {\n    throw new Error(\"@vitejs/plugin-react can't detect preamble. Something is wrong. See https://github.com/vitejs/vite-plugin-react/pull/11#discussion_r430879201\");\n  }\n  prevRefreshReg = window.$RefreshReg$;\n  prevRefreshSig = window.$RefreshSig$;\n  window.$RefreshReg$ = (type, id) => {\n    RefreshRuntime.register(type, \"/home/will/local_dev/portfolio/packages/motion-system/src/components/ContactHeader.tsx \" + id);\n  };\n  window.$RefreshSig$ = RefreshRuntime.createSignatureFunctionForTransform;\n}\nvar _s = $RefreshSig$();\nimport __vite__cjsImport3_react from \"/node_modules/.vite/deps/react.js?v=a50bb159\"; const useRef = __vite__cjsImport3_react[\"useRef\"]; const useEffect = __vite__cjsImport3_react[\"useEffect\"]; const useState = __vite__cjsImport3_react[\"useState\"];\nimport { motion, AnimatePresence } from \"/node_modules/.vite/deps/framer-motion.js?v=a50bb159\";\nimport { useMotion } from \"/@fs/home/will/local_dev/portfolio/packages/motion-system/src/providers/MotionProvider.tsx?t=1750724128976\";\nexport const ContactHeader = ({\n  className = \"\",\n  onThemeClick\n}) => {\n  _s();\n  const headerRef = useRef(null);\n  const { currentChapter, scrollProgress } = useMotion();\n  const [isVisible, setIsVisible] = useState(false);\n  const [email, setEmail] = useState(\"hello@rydesigns.love\");\n  useEffect(() => {\n    const emails = [\n      { threshold: 0, email: \"hello@rydesigns.love\" },\n      { threshold: 0.25, email: \"curious@rydesigns.love\" },\n      { threshold: 0.5, email: \"interested@rydesigns.love\" },\n      { threshold: 0.75, email: \"letschat@rydesigns.love\" },\n      { threshold: 0.9, email: \"hireme@rydesigns.love\" }\n    ];\n    const currentEmail = emails.reverse().find((e) => scrollProgress >= e.threshold)?.email || emails[0].email;\n    if (currentEmail !== email) {\n      setEmail(currentEmail);\n    }\n  }, [scrollProgress, email]);\n  useEffect(() => {\n    const shouldBeVisible = currentChapter === \"sticky\" || currentChapter === \"footer\";\n    setIsVisible(shouldBeVisible);\n  }, [currentChapter]);\n  return /* @__PURE__ */ jsxDEV(AnimatePresence, { children: isVisible && /* @__PURE__ */ jsxDEV(\n    motion.header,\n    {\n      ref: headerRef,\n      className: `contact-header ${className}`,\n      initial: { y: -100, opacity: 0 },\n      animate: { y: 0, opacity: 1 },\n      exit: { y: -100, opacity: 0 },\n      transition: {\n        type: \"spring\",\n        stiffness: 300,\n        damping: 30\n      },\n      style: {\n        position: \"fixed\",\n        top: 0,\n        left: 0,\n        right: 0,\n        zIndex: 1e3,\n        backgroundColor: \"var(--color-background, #fff)\",\n        borderBottom: \"1px solid var(--color-border, #eee)\",\n        padding: \"1rem 2rem\"\n      },\n      children: /* @__PURE__ */ jsxDEV(\n        \"div\",\n        {\n          style: {\n            display: \"flex\",\n            alignItems: \"center\",\n            justifyContent: \"space-between\",\n            maxWidth: \"1200px\",\n            margin: \"0 auto\"\n          },\n          children: [\n            /* @__PURE__ */ jsxDEV(\"div\", { style: { display: \"flex\", alignItems: \"center\", gap: \"1rem\" }, children: [\n              /* @__PURE__ */ jsxDEV(\n                motion.button,\n                {\n                  onClick: onThemeClick,\n                  whileHover: { scale: 1.05 },\n                  whileTap: { scale: 0.95 },\n                  style: {\n                    background: \"none\",\n                    border: \"none\",\n                    cursor: \"pointer\",\n                    padding: 0,\n                    display: \"inline-flex\",\n                    alignItems: \"center\"\n                  },\n                  children: /* @__PURE__ */ jsxDEV(\n                    \"span\",\n                    {\n                      id: \"header-name\",\n                      style: {\n                        fontSize: \"1.5rem\",\n                        fontWeight: 700,\n                        fontFamily: \"var(--font-display)\"\n                      },\n                      children: [\n                        /* @__PURE__ */ jsxDEV(\"span\", { style: { textDecoration: \"underline\" }, children: \"r\" }, void 0, false, {\n                          fileName: \"/home/will/local_dev/portfolio/packages/motion-system/src/components/ContactHeader.tsx\",\n                          lineNumber: 102,\n                          columnNumber: 19\n                        }, this),\n                        \"y designs \"\n                      ]\n                    },\n                    void 0,\n                    true,\n                    {\n                      fileName: \"/home/will/local_dev/portfolio/packages/motion-system/src/components/ContactHeader.tsx\",\n                      lineNumber: 94,\n                      columnNumber: 17\n                    },\n                    this\n                  )\n                },\n                void 0,\n                false,\n                {\n                  fileName: \"/home/will/local_dev/portfolio/packages/motion-system/src/components/ContactHeader.tsx\",\n                  lineNumber: 81,\n                  columnNumber: 15\n                },\n                this\n              ),\n              /* @__PURE__ */ jsxDEV(\n                \"span\",\n                {\n                  id: \"header-title\",\n                  style: {\n                    fontSize: \"0.875rem\",\n                    opacity: 0.7,\n                    fontFamily: \"var(--font-body)\"\n                  },\n                  children: \"IR Student  MSU\"\n                },\n                void 0,\n                false,\n                {\n                  fileName: \"/home/will/local_dev/portfolio/packages/motion-system/src/components/ContactHeader.tsx\",\n                  lineNumber: 107,\n                  columnNumber: 15\n                },\n                this\n              )\n            ] }, void 0, true, {\n              fileName: \"/home/will/local_dev/portfolio/packages/motion-system/src/components/ContactHeader.tsx\",\n              lineNumber: 80,\n              columnNumber: 13\n            }, this),\n            /* @__PURE__ */ jsxDEV(\"div\", { style: { display: \"flex\", alignItems: \"center\", gap: \"2rem\" }, children: [\n              /* @__PURE__ */ jsxDEV(\n                motion.a,\n                {\n                  id: \"header-email\",\n                  href: `mailto:${email}`,\n                  whileHover: { scale: 1.05 },\n                  transition: { type: \"spring\", stiffness: 400, damping: 30 },\n                  style: {\n                    color: \"var(--color-text)\",\n                    textDecoration: \"none\",\n                    fontSize: \"0.875rem\",\n                    fontFamily: \"var(--font-body)\"\n                  },\n                  children: /* @__PURE__ */ jsxDEV(AnimatePresence, { mode: \"wait\", children: /* @__PURE__ */ jsxDEV(\n                    motion.span,\n                    {\n                      initial: { opacity: 0, y: 10 },\n                      animate: { opacity: 1, y: 0 },\n                      exit: { opacity: 0, y: -10 },\n                      transition: { duration: 0.2 },\n                      children: email\n                    },\n                    email,\n                    false,\n                    {\n                      fileName: \"/home/will/local_dev/portfolio/packages/motion-system/src/components/ContactHeader.tsx\",\n                      lineNumber: 134,\n                      columnNumber: 19\n                    },\n                    this\n                  ) }, void 0, false, {\n                    fileName: \"/home/will/local_dev/portfolio/packages/motion-system/src/components/ContactHeader.tsx\",\n                    lineNumber: 133,\n                    columnNumber: 17\n                  }, this)\n                },\n                void 0,\n                false,\n                {\n                  fileName: \"/home/will/local_dev/portfolio/packages/motion-system/src/components/ContactHeader.tsx\",\n                  lineNumber: 121,\n                  columnNumber: 15\n                },\n                this\n              ),\n              /* @__PURE__ */ jsxDEV(\n                motion.a,\n                {\n                  id: \"header-phone\",\n                  href: \"tel:+15176457698\",\n                  whileHover: { scale: 1.05 },\n                  transition: { type: \"spring\", stiffness: 400, damping: 30 },\n                  style: {\n                    color: \"var(--color-text)\",\n                    textDecoration: \"none\",\n                    fontSize: \"0.875rem\",\n                    fontFamily: \"var(--font-body)\"\n                  },\n                  children: \"(517) 645-7698\"\n                },\n                void 0,\n                false,\n                {\n                  fileName: \"/home/will/local_dev/portfolio/packages/motion-system/src/components/ContactHeader.tsx\",\n                  lineNumber: 146,\n                  columnNumber: 15\n                },\n                this\n              )\n            ] }, void 0, true, {\n              fileName: \"/home/will/local_dev/portfolio/packages/motion-system/src/components/ContactHeader.tsx\",\n              lineNumber: 120,\n              columnNumber: 13\n            }, this)\n          ]\n        },\n        void 0,\n        true,\n        {\n          fileName: \"/home/will/local_dev/portfolio/packages/motion-system/src/components/ContactHeader.tsx\",\n          lineNumber: 70,\n          columnNumber: 11\n        },\n        this\n      )\n    },\n    void 0,\n    false,\n    {\n      fileName: \"/home/will/local_dev/portfolio/packages/motion-system/src/components/ContactHeader.tsx\",\n      lineNumber: 48,\n      columnNumber: 7\n    },\n    this\n  ) }, void 0, false, {\n    fileName: \"/home/will/local_dev/portfolio/packages/motion-system/src/components/ContactHeader.tsx\",\n    lineNumber: 46,\n    columnNumber: 5\n  }, this);\n};\n_s(ContactHeader, \"3a5Z0Cp/WG74Wa6hBu9oTzQVJF8=\", false, function() {\n  return [useMotion];\n});\n_c = ContactHeader;\nvar _c;\n$RefreshReg$(_c, \"ContactHeader\");\nif (import.meta.hot && !inWebWorker) {\n  window.$RefreshReg$ = prevRefreshReg;\n  window.$RefreshSig$ = prevRefreshSig;\n  RefreshRuntime.__hmr_import(import.meta.url).then((currentExports) => {\n    RefreshRuntime.registerExportsForReactRefresh(\"/home/will/local_dev/portfolio/packages/motion-system/src/components/ContactHeader.tsx\", currentExports);\n    import.meta.hot.accept((nextExports) => {\n      if (!nextExports)\n        return;\n      const invalidateMessage = RefreshRuntime.validateRefreshBoundaryAndEnqueueUpdate(currentExports, nextExports);\n      if (invalidateMessage)\n        import.meta.hot.invalidate(invalidateMessage);\n    });\n  });\n}\n\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJtYXBwaW5ncyI6IkFBcUdrQjsyQkFyR2xCO0FBQWdCQSxNQUFRQyxjQUFXQyxPQUFRLHNCQUFlO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQzFELFNBQVNDLFFBQVFDLHVCQUF1QjtBQUN4QyxTQUFTQyxpQkFBaUI7QUFPbkIsYUFBTUMsZ0JBQThDQSxDQUFDO0FBQUEsRUFDMURDLFlBQVk7QUFBQSxFQUNaQztBQUNGLE1BQU07QUFBQUMsS0FBQTtBQUNKLFFBQU1DLFlBQVlWLE9BQW9CLElBQUk7QUFDMUMsUUFBTSxFQUFFVyxnQkFBZ0JDLGVBQWUsSUFBSVAsVUFBVTtBQUNyRCxRQUFNLENBQUNRLFdBQVdDLFlBQVksSUFBSVosU0FBUyxLQUFLO0FBQ2hELFFBQU0sQ0FBQ2EsT0FBT0MsUUFBUSxJQUFJZCxTQUFTLHNCQUFzQjtBQUd6REQsWUFBVSxNQUFNO0FBQ2QsVUFBTWdCLFNBQVM7QUFBQSxNQUNiLEVBQUVDLFdBQVcsR0FBR0gsT0FBTyx1QkFBdUI7QUFBQSxNQUM5QyxFQUFFRyxXQUFXLE1BQU1ILE9BQU8seUJBQXlCO0FBQUEsTUFDbkQsRUFBRUcsV0FBVyxLQUFLSCxPQUFPLDRCQUE0QjtBQUFBLE1BQ3JELEVBQUVHLFdBQVcsTUFBTUgsT0FBTywwQkFBMEI7QUFBQSxNQUNwRCxFQUFFRyxXQUFXLEtBQUtILE9BQU8sd0JBQXdCO0FBQUEsSUFBQztBQUdwRCxVQUFNSSxlQUNKRixPQUFPRyxRQUFRLEVBQUVDLEtBQUssQ0FBQ0MsTUFBTVYsa0JBQWtCVSxFQUFFSixTQUFTLEdBQUdILFNBQzdERSxPQUFPLENBQUMsRUFBRUY7QUFFWixRQUFJSSxpQkFBaUJKLE9BQU87QUFDMUJDLGVBQVNHLFlBQVk7QUFBQSxJQUN2QjtBQUFBLEVBQ0YsR0FBRyxDQUFDUCxnQkFBZ0JHLEtBQUssQ0FBQztBQUcxQmQsWUFBVSxNQUFNO0FBQ2QsVUFBTXNCLGtCQUNKWixtQkFBbUIsWUFBWUEsbUJBQW1CO0FBQ3BERyxpQkFBYVMsZUFBZTtBQUFBLEVBQzlCLEdBQUcsQ0FBQ1osY0FBYyxDQUFDO0FBRW5CLFNBQ0UsdUJBQUMsbUJBQ0VFLHVCQUNDO0FBQUEsSUFBQyxPQUFPO0FBQUEsSUFBUDtBQUFBLE1BQ0MsS0FBS0g7QUFBQUEsTUFDTCxXQUFXLGtCQUFrQkgsU0FBUztBQUFBLE1BQ3RDLFNBQVMsRUFBRWlCLEdBQUcsTUFBTUMsU0FBUyxFQUFFO0FBQUEsTUFDL0IsU0FBUyxFQUFFRCxHQUFHLEdBQUdDLFNBQVMsRUFBRTtBQUFBLE1BQzVCLE1BQU0sRUFBRUQsR0FBRyxNQUFNQyxTQUFTLEVBQUU7QUFBQSxNQUM1QixZQUFZO0FBQUEsUUFDVkMsTUFBTTtBQUFBLFFBQ05DLFdBQVc7QUFBQSxRQUNYQyxTQUFTO0FBQUEsTUFDWDtBQUFBLE1BQ0EsT0FBTztBQUFBLFFBQ0xDLFVBQVU7QUFBQSxRQUNWQyxLQUFLO0FBQUEsUUFDTEMsTUFBTTtBQUFBLFFBQ05DLE9BQU87QUFBQSxRQUNQQyxRQUFRO0FBQUEsUUFDUkMsaUJBQWlCO0FBQUEsUUFDakJDLGNBQWM7QUFBQSxRQUNkQyxTQUFTO0FBQUEsTUFDWDtBQUFBLE1BRUE7QUFBQSxRQUFDO0FBQUE7QUFBQSxVQUNDLE9BQU87QUFBQSxZQUNMQyxTQUFTO0FBQUEsWUFDVEMsWUFBWTtBQUFBLFlBQ1pDLGdCQUFnQjtBQUFBLFlBQ2hCQyxVQUFVO0FBQUEsWUFDVkMsUUFBUTtBQUFBLFVBQ1Y7QUFBQSxVQUdBO0FBQUEsbUNBQUMsU0FBSSxPQUFPLEVBQUVKLFNBQVMsUUFBUUMsWUFBWSxVQUFVSSxLQUFLLE9BQU8sR0FDL0Q7QUFBQTtBQUFBLGdCQUFDLE9BQU87QUFBQSxnQkFBUDtBQUFBLGtCQUNDLFNBQVNsQztBQUFBQSxrQkFDVCxZQUFZLEVBQUVtQyxPQUFPLEtBQUs7QUFBQSxrQkFDMUIsVUFBVSxFQUFFQSxPQUFPLEtBQUs7QUFBQSxrQkFDeEIsT0FBTztBQUFBLG9CQUNMQyxZQUFZO0FBQUEsb0JBQ1pDLFFBQVE7QUFBQSxvQkFDUkMsUUFBUTtBQUFBLG9CQUNSVixTQUFTO0FBQUEsb0JBQ1RDLFNBQVM7QUFBQSxvQkFDVEMsWUFBWTtBQUFBLGtCQUNkO0FBQUEsa0JBRUE7QUFBQSxvQkFBQztBQUFBO0FBQUEsc0JBQ0MsSUFBRztBQUFBLHNCQUNILE9BQU87QUFBQSx3QkFDTFMsVUFBVTtBQUFBLHdCQUNWQyxZQUFZO0FBQUEsd0JBQ1pDLFlBQVk7QUFBQSxzQkFDZDtBQUFBLHNCQUVBO0FBQUEsK0NBQUMsVUFBSyxPQUFPLEVBQUVDLGdCQUFnQixZQUFZLEdBQUcsaUJBQTlDO0FBQUE7QUFBQTtBQUFBO0FBQUEsK0JBQStDO0FBQUEsd0JBQU87QUFBQTtBQUFBO0FBQUEsb0JBUnhEO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxrQkFVQTtBQUFBO0FBQUEsZ0JBdkJGO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxjQXdCQTtBQUFBLGNBRUE7QUFBQSxnQkFBQztBQUFBO0FBQUEsa0JBQ0MsSUFBRztBQUFBLGtCQUNILE9BQU87QUFBQSxvQkFDTEgsVUFBVTtBQUFBLG9CQUNWdEIsU0FBUztBQUFBLG9CQUNUd0IsWUFBWTtBQUFBLGtCQUNkO0FBQUEsa0JBQUU7QUFBQTtBQUFBLGdCQU5KO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxjQVNBO0FBQUEsaUJBcENGO0FBQUE7QUFBQTtBQUFBO0FBQUEsbUJBcUNBO0FBQUEsWUFHQSx1QkFBQyxTQUFJLE9BQU8sRUFBRVosU0FBUyxRQUFRQyxZQUFZLFVBQVVJLEtBQUssT0FBTyxHQUMvRDtBQUFBO0FBQUEsZ0JBQUMsT0FBTztBQUFBLGdCQUFQO0FBQUEsa0JBQ0MsSUFBRztBQUFBLGtCQUNILE1BQU0sVUFBVTNCLEtBQUs7QUFBQSxrQkFDckIsWUFBWSxFQUFFNEIsT0FBTyxLQUFLO0FBQUEsa0JBQzFCLFlBQVksRUFBRWpCLE1BQU0sVUFBVUMsV0FBVyxLQUFLQyxTQUFTLEdBQUc7QUFBQSxrQkFDMUQsT0FBTztBQUFBLG9CQUNMdUIsT0FBTztBQUFBLG9CQUNQRCxnQkFBZ0I7QUFBQSxvQkFDaEJILFVBQVU7QUFBQSxvQkFDVkUsWUFBWTtBQUFBLGtCQUNkO0FBQUEsa0JBRUEsaUNBQUMsbUJBQWdCLE1BQUssUUFDcEI7QUFBQSxvQkFBQyxPQUFPO0FBQUEsb0JBQVA7QUFBQSxzQkFFQyxTQUFTLEVBQUV4QixTQUFTLEdBQUdELEdBQUcsR0FBRztBQUFBLHNCQUM3QixTQUFTLEVBQUVDLFNBQVMsR0FBR0QsR0FBRyxFQUFFO0FBQUEsc0JBQzVCLE1BQU0sRUFBRUMsU0FBUyxHQUFHRCxHQUFHLElBQUk7QUFBQSxzQkFDM0IsWUFBWSxFQUFFNEIsVUFBVSxJQUFJO0FBQUEsc0JBRTNCckM7QUFBQUE7QUFBQUEsb0JBTklBO0FBQUFBLG9CQURQO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsa0JBUUEsS0FURjtBQUFBO0FBQUE7QUFBQTtBQUFBLHlCQVVBO0FBQUE7QUFBQSxnQkF0QkY7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLGNBdUJBO0FBQUEsY0FFQTtBQUFBLGdCQUFDLE9BQU87QUFBQSxnQkFBUDtBQUFBLGtCQUNDLElBQUc7QUFBQSxrQkFDSCxNQUFLO0FBQUEsa0JBQ0wsWUFBWSxFQUFFNEIsT0FBTyxLQUFLO0FBQUEsa0JBQzFCLFlBQVksRUFBRWpCLE1BQU0sVUFBVUMsV0FBVyxLQUFLQyxTQUFTLEdBQUc7QUFBQSxrQkFDMUQsT0FBTztBQUFBLG9CQUNMdUIsT0FBTztBQUFBLG9CQUNQRCxnQkFBZ0I7QUFBQSxvQkFDaEJILFVBQVU7QUFBQSxvQkFDVkUsWUFBWTtBQUFBLGtCQUNkO0FBQUEsa0JBQUU7QUFBQTtBQUFBLGdCQVZKO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxjQWFBO0FBQUEsaUJBdkNGO0FBQUE7QUFBQTtBQUFBO0FBQUEsbUJBd0NBO0FBQUE7QUFBQTtBQUFBLFFBMUZGO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQTJGQTtBQUFBO0FBQUEsSUFqSEY7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBa0hBLEtBcEhKO0FBQUE7QUFBQTtBQUFBO0FBQUEsU0FzSEE7QUFFSjtBQUFDeEMsR0E1SllILGVBQTJDO0FBQUEsVUFLWEQsU0FBUztBQUFBO0FBQUFnRCxLQUx6Qy9DO0FBQTJDLElBQUErQztBQUFBQyxhQUFBRCxJQUFBIiwibmFtZXMiOlsidXNlUmVmIiwidXNlRWZmZWN0IiwidXNlU3RhdGUiLCJtb3Rpb24iLCJBbmltYXRlUHJlc2VuY2UiLCJ1c2VNb3Rpb24iLCJDb250YWN0SGVhZGVyIiwiY2xhc3NOYW1lIiwib25UaGVtZUNsaWNrIiwiX3MiLCJoZWFkZXJSZWYiLCJjdXJyZW50Q2hhcHRlciIsInNjcm9sbFByb2dyZXNzIiwiaXNWaXNpYmxlIiwic2V0SXNWaXNpYmxlIiwiZW1haWwiLCJzZXRFbWFpbCIsImVtYWlscyIsInRocmVzaG9sZCIsImN1cnJlbnRFbWFpbCIsInJldmVyc2UiLCJmaW5kIiwiZSIsInNob3VsZEJlVmlzaWJsZSIsInkiLCJvcGFjaXR5IiwidHlwZSIsInN0aWZmbmVzcyIsImRhbXBpbmciLCJwb3NpdGlvbiIsInRvcCIsImxlZnQiLCJyaWdodCIsInpJbmRleCIsImJhY2tncm91bmRDb2xvciIsImJvcmRlckJvdHRvbSIsInBhZGRpbmciLCJkaXNwbGF5IiwiYWxpZ25JdGVtcyIsImp1c3RpZnlDb250ZW50IiwibWF4V2lkdGgiLCJtYXJnaW4iLCJnYXAiLCJzY2FsZSIsImJhY2tncm91bmQiLCJib3JkZXIiLCJjdXJzb3IiLCJmb250U2l6ZSIsImZvbnRXZWlnaHQiLCJmb250RmFtaWx5IiwidGV4dERlY29yYXRpb24iLCJjb2xvciIsImR1cmF0aW9uIiwiX2MiLCIkUmVmcmVzaFJlZyQiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZXMiOlsiQ29udGFjdEhlYWRlci50c3giXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0LCB7IHVzZVJlZiwgdXNlRWZmZWN0LCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHsgbW90aW9uLCBBbmltYXRlUHJlc2VuY2UgfSBmcm9tICdmcmFtZXItbW90aW9uJ1xuaW1wb3J0IHsgdXNlTW90aW9uIH0gZnJvbSAnLi4vcHJvdmlkZXJzL01vdGlvblByb3ZpZGVyJ1xuXG5pbnRlcmZhY2UgQ29udGFjdEhlYWRlclByb3BzIHtcbiAgY2xhc3NOYW1lPzogc3RyaW5nXG4gIG9uVGhlbWVDbGljaz86ICgpID0+IHZvaWRcbn1cblxuZXhwb3J0IGNvbnN0IENvbnRhY3RIZWFkZXI6IFJlYWN0LkZDPENvbnRhY3RIZWFkZXJQcm9wcz4gPSAoe1xuICBjbGFzc05hbWUgPSAnJyxcbiAgb25UaGVtZUNsaWNrLFxufSkgPT4ge1xuICBjb25zdCBoZWFkZXJSZWYgPSB1c2VSZWY8SFRNTEVsZW1lbnQ+KG51bGwpXG4gIGNvbnN0IHsgY3VycmVudENoYXB0ZXIsIHNjcm9sbFByb2dyZXNzIH0gPSB1c2VNb3Rpb24oKVxuICBjb25zdCBbaXNWaXNpYmxlLCBzZXRJc1Zpc2libGVdID0gdXNlU3RhdGUoZmFsc2UpXG4gIGNvbnN0IFtlbWFpbCwgc2V0RW1haWxdID0gdXNlU3RhdGUoJ2hlbGxvQHJ5ZGVzaWducy5sb3ZlJylcblxuICAvLyBEeW5hbWljIGVtYWlsIGJhc2VkIG9uIHNjcm9sbCBwcm9ncmVzc1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGVtYWlscyA9IFtcbiAgICAgIHsgdGhyZXNob2xkOiAwLCBlbWFpbDogJ2hlbGxvQHJ5ZGVzaWducy5sb3ZlJyB9LFxuICAgICAgeyB0aHJlc2hvbGQ6IDAuMjUsIGVtYWlsOiAnY3VyaW91c0ByeWRlc2lnbnMubG92ZScgfSxcbiAgICAgIHsgdGhyZXNob2xkOiAwLjUsIGVtYWlsOiAnaW50ZXJlc3RlZEByeWRlc2lnbnMubG92ZScgfSxcbiAgICAgIHsgdGhyZXNob2xkOiAwLjc1LCBlbWFpbDogJ2xldHNjaGF0QHJ5ZGVzaWducy5sb3ZlJyB9LFxuICAgICAgeyB0aHJlc2hvbGQ6IDAuOSwgZW1haWw6ICdoaXJlbWVAcnlkZXNpZ25zLmxvdmUnIH0sXG4gICAgXVxuXG4gICAgY29uc3QgY3VycmVudEVtYWlsID1cbiAgICAgIGVtYWlscy5yZXZlcnNlKCkuZmluZCgoZSkgPT4gc2Nyb2xsUHJvZ3Jlc3MgPj0gZS50aHJlc2hvbGQpPy5lbWFpbCB8fFxuICAgICAgZW1haWxzWzBdLmVtYWlsXG5cbiAgICBpZiAoY3VycmVudEVtYWlsICE9PSBlbWFpbCkge1xuICAgICAgc2V0RW1haWwoY3VycmVudEVtYWlsKVxuICAgIH1cbiAgfSwgW3Njcm9sbFByb2dyZXNzLCBlbWFpbF0pXG5cbiAgLy8gVmlzaWJpbGl0eSBiYXNlZCBvbiBjaGFwdGVyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3Qgc2hvdWxkQmVWaXNpYmxlID1cbiAgICAgIGN1cnJlbnRDaGFwdGVyID09PSAnc3RpY2t5JyB8fCBjdXJyZW50Q2hhcHRlciA9PT0gJ2Zvb3RlcidcbiAgICBzZXRJc1Zpc2libGUoc2hvdWxkQmVWaXNpYmxlKVxuICB9LCBbY3VycmVudENoYXB0ZXJdKVxuXG4gIHJldHVybiAoXG4gICAgPEFuaW1hdGVQcmVzZW5jZT5cbiAgICAgIHtpc1Zpc2libGUgJiYgKFxuICAgICAgICA8bW90aW9uLmhlYWRlclxuICAgICAgICAgIHJlZj17aGVhZGVyUmVmfVxuICAgICAgICAgIGNsYXNzTmFtZT17YGNvbnRhY3QtaGVhZGVyICR7Y2xhc3NOYW1lfWB9XG4gICAgICAgICAgaW5pdGlhbD17eyB5OiAtMTAwLCBvcGFjaXR5OiAwIH19XG4gICAgICAgICAgYW5pbWF0ZT17eyB5OiAwLCBvcGFjaXR5OiAxIH19XG4gICAgICAgICAgZXhpdD17eyB5OiAtMTAwLCBvcGFjaXR5OiAwIH19XG4gICAgICAgICAgdHJhbnNpdGlvbj17e1xuICAgICAgICAgICAgdHlwZTogJ3NwcmluZycsXG4gICAgICAgICAgICBzdGlmZm5lc3M6IDMwMCxcbiAgICAgICAgICAgIGRhbXBpbmc6IDMwLFxuICAgICAgICAgIH19XG4gICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgIHBvc2l0aW9uOiAnZml4ZWQnLFxuICAgICAgICAgICAgdG9wOiAwLFxuICAgICAgICAgICAgbGVmdDogMCxcbiAgICAgICAgICAgIHJpZ2h0OiAwLFxuICAgICAgICAgICAgekluZGV4OiAxMDAwLFxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAndmFyKC0tY29sb3ItYmFja2dyb3VuZCwgI2ZmZiknLFxuICAgICAgICAgICAgYm9yZGVyQm90dG9tOiAnMXB4IHNvbGlkIHZhcigtLWNvbG9yLWJvcmRlciwgI2VlZSknLFxuICAgICAgICAgICAgcGFkZGluZzogJzFyZW0gMnJlbScsXG4gICAgICAgICAgfX1cbiAgICAgICAgPlxuICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgICAgIGRpc3BsYXk6ICdmbGV4JyxcbiAgICAgICAgICAgICAgYWxpZ25JdGVtczogJ2NlbnRlcicsXG4gICAgICAgICAgICAgIGp1c3RpZnlDb250ZW50OiAnc3BhY2UtYmV0d2VlbicsXG4gICAgICAgICAgICAgIG1heFdpZHRoOiAnMTIwMHB4JyxcbiAgICAgICAgICAgICAgbWFyZ2luOiAnMCBhdXRvJyxcbiAgICAgICAgICAgIH19XG4gICAgICAgICAgPlxuICAgICAgICAgICAgey8qIE5hbWUgd2l0aCB0aGVtZSB0cmlnZ2VyICovfVxuICAgICAgICAgICAgPGRpdiBzdHlsZT17eyBkaXNwbGF5OiAnZmxleCcsIGFsaWduSXRlbXM6ICdjZW50ZXInLCBnYXA6ICcxcmVtJyB9fT5cbiAgICAgICAgICAgICAgPG1vdGlvbi5idXR0b25cbiAgICAgICAgICAgICAgICBvbkNsaWNrPXtvblRoZW1lQ2xpY2t9XG4gICAgICAgICAgICAgICAgd2hpbGVIb3Zlcj17eyBzY2FsZTogMS4wNSB9fVxuICAgICAgICAgICAgICAgIHdoaWxlVGFwPXt7IHNjYWxlOiAwLjk1IH19XG4gICAgICAgICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgICAgICAgIGJhY2tncm91bmQ6ICdub25lJyxcbiAgICAgICAgICAgICAgICAgIGJvcmRlcjogJ25vbmUnLFxuICAgICAgICAgICAgICAgICAgY3Vyc29yOiAncG9pbnRlcicsXG4gICAgICAgICAgICAgICAgICBwYWRkaW5nOiAwLFxuICAgICAgICAgICAgICAgICAgZGlzcGxheTogJ2lubGluZS1mbGV4JyxcbiAgICAgICAgICAgICAgICAgIGFsaWduSXRlbXM6ICdjZW50ZXInLFxuICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICA8c3BhblxuICAgICAgICAgICAgICAgICAgaWQ9XCJoZWFkZXItbmFtZVwiXG4gICAgICAgICAgICAgICAgICBzdHlsZT17e1xuICAgICAgICAgICAgICAgICAgICBmb250U2l6ZTogJzEuNXJlbScsXG4gICAgICAgICAgICAgICAgICAgIGZvbnRXZWlnaHQ6IDcwMCxcbiAgICAgICAgICAgICAgICAgICAgZm9udEZhbWlseTogJ3ZhcigtLWZvbnQtZGlzcGxheSknLFxuICAgICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICA8c3BhbiBzdHlsZT17eyB0ZXh0RGVjb3JhdGlvbjogJ3VuZGVybGluZScgfX0+cjwvc3Bhbj55XG4gICAgICAgICAgICAgICAgICBkZXNpZ25zIOKdpO+4j1xuICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICAgPC9tb3Rpb24uYnV0dG9uPlxuXG4gICAgICAgICAgICAgIDxzcGFuXG4gICAgICAgICAgICAgICAgaWQ9XCJoZWFkZXItdGl0bGVcIlxuICAgICAgICAgICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgICAgICAgICBmb250U2l6ZTogJzAuODc1cmVtJyxcbiAgICAgICAgICAgICAgICAgIG9wYWNpdHk6IDAuNyxcbiAgICAgICAgICAgICAgICAgIGZvbnRGYW1pbHk6ICd2YXIoLS1mb250LWJvZHkpJyxcbiAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgSVIgU3R1ZGVudCDigKIgTVNVXG4gICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgICB7LyogQ29udGFjdCBpbmZvICovfVxuICAgICAgICAgICAgPGRpdiBzdHlsZT17eyBkaXNwbGF5OiAnZmxleCcsIGFsaWduSXRlbXM6ICdjZW50ZXInLCBnYXA6ICcycmVtJyB9fT5cbiAgICAgICAgICAgICAgPG1vdGlvbi5hXG4gICAgICAgICAgICAgICAgaWQ9XCJoZWFkZXItZW1haWxcIlxuICAgICAgICAgICAgICAgIGhyZWY9e2BtYWlsdG86JHtlbWFpbH1gfVxuICAgICAgICAgICAgICAgIHdoaWxlSG92ZXI9e3sgc2NhbGU6IDEuMDUgfX1cbiAgICAgICAgICAgICAgICB0cmFuc2l0aW9uPXt7IHR5cGU6ICdzcHJpbmcnLCBzdGlmZm5lc3M6IDQwMCwgZGFtcGluZzogMzAgfX1cbiAgICAgICAgICAgICAgICBzdHlsZT17e1xuICAgICAgICAgICAgICAgICAgY29sb3I6ICd2YXIoLS1jb2xvci10ZXh0KScsXG4gICAgICAgICAgICAgICAgICB0ZXh0RGVjb3JhdGlvbjogJ25vbmUnLFxuICAgICAgICAgICAgICAgICAgZm9udFNpemU6ICcwLjg3NXJlbScsXG4gICAgICAgICAgICAgICAgICBmb250RmFtaWx5OiAndmFyKC0tZm9udC1ib2R5KScsXG4gICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIDxBbmltYXRlUHJlc2VuY2UgbW9kZT1cIndhaXRcIj5cbiAgICAgICAgICAgICAgICAgIDxtb3Rpb24uc3BhblxuICAgICAgICAgICAgICAgICAgICBrZXk9e2VtYWlsfVxuICAgICAgICAgICAgICAgICAgICBpbml0aWFsPXt7IG9wYWNpdHk6IDAsIHk6IDEwIH19XG4gICAgICAgICAgICAgICAgICAgIGFuaW1hdGU9e3sgb3BhY2l0eTogMSwgeTogMCB9fVxuICAgICAgICAgICAgICAgICAgICBleGl0PXt7IG9wYWNpdHk6IDAsIHk6IC0xMCB9fVxuICAgICAgICAgICAgICAgICAgICB0cmFuc2l0aW9uPXt7IGR1cmF0aW9uOiAwLjIgfX1cbiAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAge2VtYWlsfVxuICAgICAgICAgICAgICAgICAgPC9tb3Rpb24uc3Bhbj5cbiAgICAgICAgICAgICAgICA8L0FuaW1hdGVQcmVzZW5jZT5cbiAgICAgICAgICAgICAgPC9tb3Rpb24uYT5cblxuICAgICAgICAgICAgICA8bW90aW9uLmFcbiAgICAgICAgICAgICAgICBpZD1cImhlYWRlci1waG9uZVwiXG4gICAgICAgICAgICAgICAgaHJlZj1cInRlbDorMTUxNzY0NTc2OThcIlxuICAgICAgICAgICAgICAgIHdoaWxlSG92ZXI9e3sgc2NhbGU6IDEuMDUgfX1cbiAgICAgICAgICAgICAgICB0cmFuc2l0aW9uPXt7IHR5cGU6ICdzcHJpbmcnLCBzdGlmZm5lc3M6IDQwMCwgZGFtcGluZzogMzAgfX1cbiAgICAgICAgICAgICAgICBzdHlsZT17e1xuICAgICAgICAgICAgICAgICAgY29sb3I6ICd2YXIoLS1jb2xvci10ZXh0KScsXG4gICAgICAgICAgICAgICAgICB0ZXh0RGVjb3JhdGlvbjogJ25vbmUnLFxuICAgICAgICAgICAgICAgICAgZm9udFNpemU6ICcwLjg3NXJlbScsXG4gICAgICAgICAgICAgICAgICBmb250RmFtaWx5OiAndmFyKC0tZm9udC1ib2R5KScsXG4gICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICg1MTcpIDY0NS03Njk4XG4gICAgICAgICAgICAgIDwvbW90aW9uLmE+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9tb3Rpb24uaGVhZGVyPlxuICAgICAgKX1cbiAgICA8L0FuaW1hdGVQcmVzZW5jZT5cbiAgKVxufVxuIl0sImZpbGUiOiIvaG9tZS93aWxsL2xvY2FsX2Rldi9wb3J0Zm9saW8vcGFja2FnZXMvbW90aW9uLXN5c3RlbS9zcmMvY29tcG9uZW50cy9Db250YWN0SGVhZGVyLnRzeCJ9",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 24771,
            "count": 1
          },
          {
            "startOffset": 501,
            "endOffset": 537,
            "count": 0
          },
          {
            "startOffset": 674,
            "endOffset": 845,
            "count": 0
          }
        ]
      },
      {
        "functionName": "window.$RefreshReg$",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 950,
            "endOffset": 1100,
            "count": 1
          }
        ]
      },
      {
        "functionName": "ContactHeader",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1714,
            "endOffset": 10454,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10513,
            "endOffset": 10549,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10786,
            "endOffset": 11263,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10992,
            "endOffset": 11257,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5173/node_modules/.vite/deps/chunk-HJ66XTML.js?v=a50bb159",
    "scriptId": "32",
    "source": "// ../../node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/gsap-core.js\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return self;\n}\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\nvar _config = {\n  autoSleep: 120,\n  force3D: \"auto\",\n  nullTargetWarn: 1,\n  units: {\n    lineHeight: \"\"\n  }\n};\nvar _defaults = {\n  duration: 0.5,\n  overwrite: false,\n  delay: 0\n};\nvar _suppressOverwrites;\nvar _reverting;\nvar _context;\nvar _bigNum = 1e8;\nvar _tinyNum = 1 / _bigNum;\nvar _2PI = Math.PI * 2;\nvar _HALF_PI = _2PI / 4;\nvar _gsID = 0;\nvar _sqrt = Math.sqrt;\nvar _cos = Math.cos;\nvar _sin = Math.sin;\nvar _isString = function _isString2(value) {\n  return typeof value === \"string\";\n};\nvar _isFunction = function _isFunction2(value) {\n  return typeof value === \"function\";\n};\nvar _isNumber = function _isNumber2(value) {\n  return typeof value === \"number\";\n};\nvar _isUndefined = function _isUndefined2(value) {\n  return typeof value === \"undefined\";\n};\nvar _isObject = function _isObject2(value) {\n  return typeof value === \"object\";\n};\nvar _isNotFalse = function _isNotFalse2(value) {\n  return value !== false;\n};\nvar _windowExists = function _windowExists2() {\n  return typeof window !== \"undefined\";\n};\nvar _isFuncOrString = function _isFuncOrString2(value) {\n  return _isFunction(value) || _isString(value);\n};\nvar _isTypedArray = typeof ArrayBuffer === \"function\" && ArrayBuffer.isView || function() {\n};\nvar _isArray = Array.isArray;\nvar _strictNumExp = /(?:-?\\.?\\d|\\.)+/gi;\nvar _numExp = /[-+=.]*\\d+[.e\\-+]*\\d*[e\\-+]*\\d*/g;\nvar _numWithUnitExp = /[-+=.]*\\d+[.e-]*\\d*[a-z%]*/g;\nvar _complexStringNumExp = /[-+=.]*\\d+\\.?\\d*(?:e-|e\\+)?\\d*/gi;\nvar _relExp = /[+-]=-?[.\\d]+/;\nvar _delimitedValueExp = /[^,'\"\\[\\]\\s]+/gi;\nvar _unitExp = /^[+\\-=e\\s\\d]*\\d+[.\\d]*([a-z]*|%)\\s*$/i;\nvar _globalTimeline;\nvar _win;\nvar _coreInitted;\nvar _doc;\nvar _globals = {};\nvar _installScope = {};\nvar _coreReady;\nvar _install = function _install2(scope) {\n  return (_installScope = _merge(scope, _globals)) && gsap;\n};\nvar _missingPlugin = function _missingPlugin2(property, value) {\n  return console.warn(\"Invalid property\", property, \"set to\", value, \"Missing plugin? gsap.registerPlugin()\");\n};\nvar _warn = function _warn2(message, suppress) {\n  return !suppress && console.warn(message);\n};\nvar _addGlobal = function _addGlobal2(name, obj) {\n  return name && (_globals[name] = obj) && _installScope && (_installScope[name] = obj) || _globals;\n};\nvar _emptyFunc = function _emptyFunc2() {\n  return 0;\n};\nvar _startAtRevertConfig = {\n  suppressEvents: true,\n  isStart: true,\n  kill: false\n};\nvar _revertConfigNoKill = {\n  suppressEvents: true,\n  kill: false\n};\nvar _revertConfig = {\n  suppressEvents: true\n};\nvar _reservedProps = {};\nvar _lazyTweens = [];\nvar _lazyLookup = {};\nvar _lastRenderedFrame;\nvar _plugins = {};\nvar _effects = {};\nvar _nextGCFrame = 30;\nvar _harnessPlugins = [];\nvar _callbackNames = \"\";\nvar _harness = function _harness2(targets) {\n  var target = targets[0], harnessPlugin, i;\n  _isObject(target) || _isFunction(target) || (targets = [targets]);\n  if (!(harnessPlugin = (target._gsap || {}).harness)) {\n    i = _harnessPlugins.length;\n    while (i-- && !_harnessPlugins[i].targetTest(target)) {\n    }\n    harnessPlugin = _harnessPlugins[i];\n  }\n  i = targets.length;\n  while (i--) {\n    targets[i] && (targets[i]._gsap || (targets[i]._gsap = new GSCache(targets[i], harnessPlugin))) || targets.splice(i, 1);\n  }\n  return targets;\n};\nvar _getCache = function _getCache2(target) {\n  return target._gsap || _harness(toArray(target))[0]._gsap;\n};\nvar _getProperty = function _getProperty2(target, property, v) {\n  return (v = target[property]) && _isFunction(v) ? target[property]() : _isUndefined(v) && target.getAttribute && target.getAttribute(property) || v;\n};\nvar _forEachName = function _forEachName2(names, func) {\n  return (names = names.split(\",\")).forEach(func) || names;\n};\nvar _round = function _round2(value) {\n  return Math.round(value * 1e5) / 1e5 || 0;\n};\nvar _roundPrecise = function _roundPrecise2(value) {\n  return Math.round(value * 1e7) / 1e7 || 0;\n};\nvar _parseRelative = function _parseRelative2(start, value) {\n  var operator = value.charAt(0), end = parseFloat(value.substr(2));\n  start = parseFloat(start);\n  return operator === \"+\" ? start + end : operator === \"-\" ? start - end : operator === \"*\" ? start * end : start / end;\n};\nvar _arrayContainsAny = function _arrayContainsAny2(toSearch, toFind) {\n  var l = toFind.length, i = 0;\n  for (; toSearch.indexOf(toFind[i]) < 0 && ++i < l; ) {\n  }\n  return i < l;\n};\nvar _lazyRender = function _lazyRender2() {\n  var l = _lazyTweens.length, a = _lazyTweens.slice(0), i, tween;\n  _lazyLookup = {};\n  _lazyTweens.length = 0;\n  for (i = 0; i < l; i++) {\n    tween = a[i];\n    tween && tween._lazy && (tween.render(tween._lazy[0], tween._lazy[1], true)._lazy = 0);\n  }\n};\nvar _lazySafeRender = function _lazySafeRender2(animation, time, suppressEvents, force) {\n  _lazyTweens.length && !_reverting && _lazyRender();\n  animation.render(time, suppressEvents, force || _reverting && time < 0 && (animation._initted || animation._startAt));\n  _lazyTweens.length && !_reverting && _lazyRender();\n};\nvar _numericIfPossible = function _numericIfPossible2(value) {\n  var n = parseFloat(value);\n  return (n || n === 0) && (value + \"\").match(_delimitedValueExp).length < 2 ? n : _isString(value) ? value.trim() : value;\n};\nvar _passThrough = function _passThrough2(p) {\n  return p;\n};\nvar _setDefaults = function _setDefaults2(obj, defaults2) {\n  for (var p in defaults2) {\n    p in obj || (obj[p] = defaults2[p]);\n  }\n  return obj;\n};\nvar _setKeyframeDefaults = function _setKeyframeDefaults2(excludeDuration) {\n  return function(obj, defaults2) {\n    for (var p in defaults2) {\n      p in obj || p === \"duration\" && excludeDuration || p === \"ease\" || (obj[p] = defaults2[p]);\n    }\n  };\n};\nvar _merge = function _merge2(base, toMerge) {\n  for (var p in toMerge) {\n    base[p] = toMerge[p];\n  }\n  return base;\n};\nvar _mergeDeep = function _mergeDeep2(base, toMerge) {\n  for (var p in toMerge) {\n    p !== \"__proto__\" && p !== \"constructor\" && p !== \"prototype\" && (base[p] = _isObject(toMerge[p]) ? _mergeDeep2(base[p] || (base[p] = {}), toMerge[p]) : toMerge[p]);\n  }\n  return base;\n};\nvar _copyExcluding = function _copyExcluding2(obj, excluding) {\n  var copy = {}, p;\n  for (p in obj) {\n    p in excluding || (copy[p] = obj[p]);\n  }\n  return copy;\n};\nvar _inheritDefaults = function _inheritDefaults2(vars) {\n  var parent = vars.parent || _globalTimeline, func = vars.keyframes ? _setKeyframeDefaults(_isArray(vars.keyframes)) : _setDefaults;\n  if (_isNotFalse(vars.inherit)) {\n    while (parent) {\n      func(vars, parent.vars.defaults);\n      parent = parent.parent || parent._dp;\n    }\n  }\n  return vars;\n};\nvar _arraysMatch = function _arraysMatch2(a1, a2) {\n  var i = a1.length, match = i === a2.length;\n  while (match && i-- && a1[i] === a2[i]) {\n  }\n  return i < 0;\n};\nvar _addLinkedListItem = function _addLinkedListItem2(parent, child, firstProp, lastProp, sortBy) {\n  if (firstProp === void 0) {\n    firstProp = \"_first\";\n  }\n  if (lastProp === void 0) {\n    lastProp = \"_last\";\n  }\n  var prev = parent[lastProp], t;\n  if (sortBy) {\n    t = child[sortBy];\n    while (prev && prev[sortBy] > t) {\n      prev = prev._prev;\n    }\n  }\n  if (prev) {\n    child._next = prev._next;\n    prev._next = child;\n  } else {\n    child._next = parent[firstProp];\n    parent[firstProp] = child;\n  }\n  if (child._next) {\n    child._next._prev = child;\n  } else {\n    parent[lastProp] = child;\n  }\n  child._prev = prev;\n  child.parent = child._dp = parent;\n  return child;\n};\nvar _removeLinkedListItem = function _removeLinkedListItem2(parent, child, firstProp, lastProp) {\n  if (firstProp === void 0) {\n    firstProp = \"_first\";\n  }\n  if (lastProp === void 0) {\n    lastProp = \"_last\";\n  }\n  var prev = child._prev, next = child._next;\n  if (prev) {\n    prev._next = next;\n  } else if (parent[firstProp] === child) {\n    parent[firstProp] = next;\n  }\n  if (next) {\n    next._prev = prev;\n  } else if (parent[lastProp] === child) {\n    parent[lastProp] = prev;\n  }\n  child._next = child._prev = child.parent = null;\n};\nvar _removeFromParent = function _removeFromParent2(child, onlyIfParentHasAutoRemove) {\n  child.parent && (!onlyIfParentHasAutoRemove || child.parent.autoRemoveChildren) && child.parent.remove && child.parent.remove(child);\n  child._act = 0;\n};\nvar _uncache = function _uncache2(animation, child) {\n  if (animation && (!child || child._end > animation._dur || child._start < 0)) {\n    var a = animation;\n    while (a) {\n      a._dirty = 1;\n      a = a.parent;\n    }\n  }\n  return animation;\n};\nvar _recacheAncestors = function _recacheAncestors2(animation) {\n  var parent = animation.parent;\n  while (parent && parent.parent) {\n    parent._dirty = 1;\n    parent.totalDuration();\n    parent = parent.parent;\n  }\n  return animation;\n};\nvar _rewindStartAt = function _rewindStartAt2(tween, totalTime, suppressEvents, force) {\n  return tween._startAt && (_reverting ? tween._startAt.revert(_revertConfigNoKill) : tween.vars.immediateRender && !tween.vars.autoRevert || tween._startAt.render(totalTime, true, force));\n};\nvar _hasNoPausedAncestors = function _hasNoPausedAncestors2(animation) {\n  return !animation || animation._ts && _hasNoPausedAncestors2(animation.parent);\n};\nvar _elapsedCycleDuration = function _elapsedCycleDuration2(animation) {\n  return animation._repeat ? _animationCycle(animation._tTime, animation = animation.duration() + animation._rDelay) * animation : 0;\n};\nvar _animationCycle = function _animationCycle2(tTime, cycleDuration) {\n  var whole = Math.floor(tTime /= cycleDuration);\n  return tTime && whole === tTime ? whole - 1 : whole;\n};\nvar _parentToChildTotalTime = function _parentToChildTotalTime2(parentTime, child) {\n  return (parentTime - child._start) * child._ts + (child._ts >= 0 ? 0 : child._dirty ? child.totalDuration() : child._tDur);\n};\nvar _setEnd = function _setEnd2(animation) {\n  return animation._end = _roundPrecise(animation._start + (animation._tDur / Math.abs(animation._ts || animation._rts || _tinyNum) || 0));\n};\nvar _alignPlayhead = function _alignPlayhead2(animation, totalTime) {\n  var parent = animation._dp;\n  if (parent && parent.smoothChildTiming && animation._ts) {\n    animation._start = _roundPrecise(parent._time - (animation._ts > 0 ? totalTime / animation._ts : ((animation._dirty ? animation.totalDuration() : animation._tDur) - totalTime) / -animation._ts));\n    _setEnd(animation);\n    parent._dirty || _uncache(parent, animation);\n  }\n  return animation;\n};\nvar _postAddChecks = function _postAddChecks2(timeline2, child) {\n  var t;\n  if (child._time || !child._dur && child._initted || child._start < timeline2._time && (child._dur || !child.add)) {\n    t = _parentToChildTotalTime(timeline2.rawTime(), child);\n    if (!child._dur || _clamp(0, child.totalDuration(), t) - child._tTime > _tinyNum) {\n      child.render(t, true);\n    }\n  }\n  if (_uncache(timeline2, child)._dp && timeline2._initted && timeline2._time >= timeline2._dur && timeline2._ts) {\n    if (timeline2._dur < timeline2.duration()) {\n      t = timeline2;\n      while (t._dp) {\n        t.rawTime() >= 0 && t.totalTime(t._tTime);\n        t = t._dp;\n      }\n    }\n    timeline2._zTime = -_tinyNum;\n  }\n};\nvar _addToTimeline = function _addToTimeline2(timeline2, child, position, skipChecks) {\n  child.parent && _removeFromParent(child);\n  child._start = _roundPrecise((_isNumber(position) ? position : position || timeline2 !== _globalTimeline ? _parsePosition(timeline2, position, child) : timeline2._time) + child._delay);\n  child._end = _roundPrecise(child._start + (child.totalDuration() / Math.abs(child.timeScale()) || 0));\n  _addLinkedListItem(timeline2, child, \"_first\", \"_last\", timeline2._sort ? \"_start\" : 0);\n  _isFromOrFromStart(child) || (timeline2._recent = child);\n  skipChecks || _postAddChecks(timeline2, child);\n  timeline2._ts < 0 && _alignPlayhead(timeline2, timeline2._tTime);\n  return timeline2;\n};\nvar _scrollTrigger = function _scrollTrigger2(animation, trigger) {\n  return (_globals.ScrollTrigger || _missingPlugin(\"scrollTrigger\", trigger)) && _globals.ScrollTrigger.create(trigger, animation);\n};\nvar _attemptInitTween = function _attemptInitTween2(tween, time, force, suppressEvents, tTime) {\n  _initTween(tween, time, tTime);\n  if (!tween._initted) {\n    return 1;\n  }\n  if (!force && tween._pt && !_reverting && (tween._dur && tween.vars.lazy !== false || !tween._dur && tween.vars.lazy) && _lastRenderedFrame !== _ticker.frame) {\n    _lazyTweens.push(tween);\n    tween._lazy = [tTime, suppressEvents];\n    return 1;\n  }\n};\nvar _parentPlayheadIsBeforeStart = function _parentPlayheadIsBeforeStart2(_ref) {\n  var parent = _ref.parent;\n  return parent && parent._ts && parent._initted && !parent._lock && (parent.rawTime() < 0 || _parentPlayheadIsBeforeStart2(parent));\n};\nvar _isFromOrFromStart = function _isFromOrFromStart2(_ref2) {\n  var data = _ref2.data;\n  return data === \"isFromStart\" || data === \"isStart\";\n};\nvar _renderZeroDurationTween = function _renderZeroDurationTween2(tween, totalTime, suppressEvents, force) {\n  var prevRatio = tween.ratio, ratio = totalTime < 0 || !totalTime && (!tween._start && _parentPlayheadIsBeforeStart(tween) && !(!tween._initted && _isFromOrFromStart(tween)) || (tween._ts < 0 || tween._dp._ts < 0) && !_isFromOrFromStart(tween)) ? 0 : 1, repeatDelay = tween._rDelay, tTime = 0, pt, iteration, prevIteration;\n  if (repeatDelay && tween._repeat) {\n    tTime = _clamp(0, tween._tDur, totalTime);\n    iteration = _animationCycle(tTime, repeatDelay);\n    tween._yoyo && iteration & 1 && (ratio = 1 - ratio);\n    if (iteration !== _animationCycle(tween._tTime, repeatDelay)) {\n      prevRatio = 1 - ratio;\n      tween.vars.repeatRefresh && tween._initted && tween.invalidate();\n    }\n  }\n  if (ratio !== prevRatio || _reverting || force || tween._zTime === _tinyNum || !totalTime && tween._zTime) {\n    if (!tween._initted && _attemptInitTween(tween, totalTime, force, suppressEvents, tTime)) {\n      return;\n    }\n    prevIteration = tween._zTime;\n    tween._zTime = totalTime || (suppressEvents ? _tinyNum : 0);\n    suppressEvents || (suppressEvents = totalTime && !prevIteration);\n    tween.ratio = ratio;\n    tween._from && (ratio = 1 - ratio);\n    tween._time = 0;\n    tween._tTime = tTime;\n    pt = tween._pt;\n    while (pt) {\n      pt.r(ratio, pt.d);\n      pt = pt._next;\n    }\n    totalTime < 0 && _rewindStartAt(tween, totalTime, suppressEvents, true);\n    tween._onUpdate && !suppressEvents && _callback(tween, \"onUpdate\");\n    tTime && tween._repeat && !suppressEvents && tween.parent && _callback(tween, \"onRepeat\");\n    if ((totalTime >= tween._tDur || totalTime < 0) && tween.ratio === ratio) {\n      ratio && _removeFromParent(tween, 1);\n      if (!suppressEvents && !_reverting) {\n        _callback(tween, ratio ? \"onComplete\" : \"onReverseComplete\", true);\n        tween._prom && tween._prom();\n      }\n    }\n  } else if (!tween._zTime) {\n    tween._zTime = totalTime;\n  }\n};\nvar _findNextPauseTween = function _findNextPauseTween2(animation, prevTime, time) {\n  var child;\n  if (time > prevTime) {\n    child = animation._first;\n    while (child && child._start <= time) {\n      if (child.data === \"isPause\" && child._start > prevTime) {\n        return child;\n      }\n      child = child._next;\n    }\n  } else {\n    child = animation._last;\n    while (child && child._start >= time) {\n      if (child.data === \"isPause\" && child._start < prevTime) {\n        return child;\n      }\n      child = child._prev;\n    }\n  }\n};\nvar _setDuration = function _setDuration2(animation, duration, skipUncache, leavePlayhead) {\n  var repeat = animation._repeat, dur = _roundPrecise(duration) || 0, totalProgress = animation._tTime / animation._tDur;\n  totalProgress && !leavePlayhead && (animation._time *= dur / animation._dur);\n  animation._dur = dur;\n  animation._tDur = !repeat ? dur : repeat < 0 ? 1e10 : _roundPrecise(dur * (repeat + 1) + animation._rDelay * repeat);\n  totalProgress > 0 && !leavePlayhead && _alignPlayhead(animation, animation._tTime = animation._tDur * totalProgress);\n  animation.parent && _setEnd(animation);\n  skipUncache || _uncache(animation.parent, animation);\n  return animation;\n};\nvar _onUpdateTotalDuration = function _onUpdateTotalDuration2(animation) {\n  return animation instanceof Timeline ? _uncache(animation) : _setDuration(animation, animation._dur);\n};\nvar _zeroPosition = {\n  _start: 0,\n  endTime: _emptyFunc,\n  totalDuration: _emptyFunc\n};\nvar _parsePosition = function _parsePosition2(animation, position, percentAnimation) {\n  var labels = animation.labels, recent = animation._recent || _zeroPosition, clippedDuration = animation.duration() >= _bigNum ? recent.endTime(false) : animation._dur, i, offset, isPercent;\n  if (_isString(position) && (isNaN(position) || position in labels)) {\n    offset = position.charAt(0);\n    isPercent = position.substr(-1) === \"%\";\n    i = position.indexOf(\"=\");\n    if (offset === \"<\" || offset === \">\") {\n      i >= 0 && (position = position.replace(/=/, \"\"));\n      return (offset === \"<\" ? recent._start : recent.endTime(recent._repeat >= 0)) + (parseFloat(position.substr(1)) || 0) * (isPercent ? (i < 0 ? recent : percentAnimation).totalDuration() / 100 : 1);\n    }\n    if (i < 0) {\n      position in labels || (labels[position] = clippedDuration);\n      return labels[position];\n    }\n    offset = parseFloat(position.charAt(i - 1) + position.substr(i + 1));\n    if (isPercent && percentAnimation) {\n      offset = offset / 100 * (_isArray(percentAnimation) ? percentAnimation[0] : percentAnimation).totalDuration();\n    }\n    return i > 1 ? _parsePosition2(animation, position.substr(0, i - 1), percentAnimation) + offset : clippedDuration + offset;\n  }\n  return position == null ? clippedDuration : +position;\n};\nvar _createTweenType = function _createTweenType2(type, params, timeline2) {\n  var isLegacy = _isNumber(params[1]), varsIndex = (isLegacy ? 2 : 1) + (type < 2 ? 0 : 1), vars = params[varsIndex], irVars, parent;\n  isLegacy && (vars.duration = params[1]);\n  vars.parent = timeline2;\n  if (type) {\n    irVars = vars;\n    parent = timeline2;\n    while (parent && !(\"immediateRender\" in irVars)) {\n      irVars = parent.vars.defaults || {};\n      parent = _isNotFalse(parent.vars.inherit) && parent.parent;\n    }\n    vars.immediateRender = _isNotFalse(irVars.immediateRender);\n    type < 2 ? vars.runBackwards = 1 : vars.startAt = params[varsIndex - 1];\n  }\n  return new Tween(params[0], vars, params[varsIndex + 1]);\n};\nvar _conditionalReturn = function _conditionalReturn2(value, func) {\n  return value || value === 0 ? func(value) : func;\n};\nvar _clamp = function _clamp2(min, max, value) {\n  return value < min ? min : value > max ? max : value;\n};\nvar getUnit = function getUnit2(value, v) {\n  return !_isString(value) || !(v = _unitExp.exec(value)) ? \"\" : v[1];\n};\nvar clamp = function clamp2(min, max, value) {\n  return _conditionalReturn(value, function(v) {\n    return _clamp(min, max, v);\n  });\n};\nvar _slice = [].slice;\nvar _isArrayLike = function _isArrayLike2(value, nonEmpty) {\n  return value && _isObject(value) && \"length\" in value && (!nonEmpty && !value.length || value.length - 1 in value && _isObject(value[0])) && !value.nodeType && value !== _win;\n};\nvar _flatten = function _flatten2(ar, leaveStrings, accumulator) {\n  if (accumulator === void 0) {\n    accumulator = [];\n  }\n  return ar.forEach(function(value) {\n    var _accumulator;\n    return _isString(value) && !leaveStrings || _isArrayLike(value, 1) ? (_accumulator = accumulator).push.apply(_accumulator, toArray(value)) : accumulator.push(value);\n  }) || accumulator;\n};\nvar toArray = function toArray2(value, scope, leaveStrings) {\n  return _context && !scope && _context.selector ? _context.selector(value) : _isString(value) && !leaveStrings && (_coreInitted || !_wake()) ? _slice.call((scope || _doc).querySelectorAll(value), 0) : _isArray(value) ? _flatten(value, leaveStrings) : _isArrayLike(value) ? _slice.call(value, 0) : value ? [value] : [];\n};\nvar selector = function selector2(value) {\n  value = toArray(value)[0] || _warn(\"Invalid scope\") || {};\n  return function(v) {\n    var el = value.current || value.nativeElement || value;\n    return toArray(v, el.querySelectorAll ? el : el === value ? _warn(\"Invalid scope\") || _doc.createElement(\"div\") : value);\n  };\n};\nvar shuffle = function shuffle2(a) {\n  return a.sort(function() {\n    return 0.5 - Math.random();\n  });\n};\nvar distribute = function distribute2(v) {\n  if (_isFunction(v)) {\n    return v;\n  }\n  var vars = _isObject(v) ? v : {\n    each: v\n  }, ease = _parseEase(vars.ease), from = vars.from || 0, base = parseFloat(vars.base) || 0, cache = {}, isDecimal = from > 0 && from < 1, ratios = isNaN(from) || isDecimal, axis = vars.axis, ratioX = from, ratioY = from;\n  if (_isString(from)) {\n    ratioX = ratioY = {\n      center: 0.5,\n      edges: 0.5,\n      end: 1\n    }[from] || 0;\n  } else if (!isDecimal && ratios) {\n    ratioX = from[0];\n    ratioY = from[1];\n  }\n  return function(i, target, a) {\n    var l = (a || vars).length, distances = cache[l], originX, originY, x, y, d, j, max, min, wrapAt;\n    if (!distances) {\n      wrapAt = vars.grid === \"auto\" ? 0 : (vars.grid || [1, _bigNum])[1];\n      if (!wrapAt) {\n        max = -_bigNum;\n        while (max < (max = a[wrapAt++].getBoundingClientRect().left) && wrapAt < l) {\n        }\n        wrapAt < l && wrapAt--;\n      }\n      distances = cache[l] = [];\n      originX = ratios ? Math.min(wrapAt, l) * ratioX - 0.5 : from % wrapAt;\n      originY = wrapAt === _bigNum ? 0 : ratios ? l * ratioY / wrapAt - 0.5 : from / wrapAt | 0;\n      max = 0;\n      min = _bigNum;\n      for (j = 0; j < l; j++) {\n        x = j % wrapAt - originX;\n        y = originY - (j / wrapAt | 0);\n        distances[j] = d = !axis ? _sqrt(x * x + y * y) : Math.abs(axis === \"y\" ? y : x);\n        d > max && (max = d);\n        d < min && (min = d);\n      }\n      from === \"random\" && shuffle(distances);\n      distances.max = max - min;\n      distances.min = min;\n      distances.v = l = (parseFloat(vars.amount) || parseFloat(vars.each) * (wrapAt > l ? l - 1 : !axis ? Math.max(wrapAt, l / wrapAt) : axis === \"y\" ? l / wrapAt : wrapAt) || 0) * (from === \"edges\" ? -1 : 1);\n      distances.b = l < 0 ? base - l : base;\n      distances.u = getUnit(vars.amount || vars.each) || 0;\n      ease = ease && l < 0 ? _invertEase(ease) : ease;\n    }\n    l = (distances[i] - distances.min) / distances.max || 0;\n    return _roundPrecise(distances.b + (ease ? ease(l) : l) * distances.v) + distances.u;\n  };\n};\nvar _roundModifier = function _roundModifier2(v) {\n  var p = Math.pow(10, ((v + \"\").split(\".\")[1] || \"\").length);\n  return function(raw) {\n    var n = _roundPrecise(Math.round(parseFloat(raw) / v) * v * p);\n    return (n - n % 1) / p + (_isNumber(raw) ? 0 : getUnit(raw));\n  };\n};\nvar snap = function snap2(snapTo, value) {\n  var isArray = _isArray(snapTo), radius, is2D;\n  if (!isArray && _isObject(snapTo)) {\n    radius = isArray = snapTo.radius || _bigNum;\n    if (snapTo.values) {\n      snapTo = toArray(snapTo.values);\n      if (is2D = !_isNumber(snapTo[0])) {\n        radius *= radius;\n      }\n    } else {\n      snapTo = _roundModifier(snapTo.increment);\n    }\n  }\n  return _conditionalReturn(value, !isArray ? _roundModifier(snapTo) : _isFunction(snapTo) ? function(raw) {\n    is2D = snapTo(raw);\n    return Math.abs(is2D - raw) <= radius ? is2D : raw;\n  } : function(raw) {\n    var x = parseFloat(is2D ? raw.x : raw), y = parseFloat(is2D ? raw.y : 0), min = _bigNum, closest = 0, i = snapTo.length, dx, dy;\n    while (i--) {\n      if (is2D) {\n        dx = snapTo[i].x - x;\n        dy = snapTo[i].y - y;\n        dx = dx * dx + dy * dy;\n      } else {\n        dx = Math.abs(snapTo[i] - x);\n      }\n      if (dx < min) {\n        min = dx;\n        closest = i;\n      }\n    }\n    closest = !radius || min <= radius ? snapTo[closest] : raw;\n    return is2D || closest === raw || _isNumber(raw) ? closest : closest + getUnit(raw);\n  });\n};\nvar random = function random2(min, max, roundingIncrement, returnFunction) {\n  return _conditionalReturn(_isArray(min) ? !max : roundingIncrement === true ? !!(roundingIncrement = 0) : !returnFunction, function() {\n    return _isArray(min) ? min[~~(Math.random() * min.length)] : (roundingIncrement = roundingIncrement || 1e-5) && (returnFunction = roundingIncrement < 1 ? Math.pow(10, (roundingIncrement + \"\").length - 2) : 1) && Math.floor(Math.round((min - roundingIncrement / 2 + Math.random() * (max - min + roundingIncrement * 0.99)) / roundingIncrement) * roundingIncrement * returnFunction) / returnFunction;\n  });\n};\nvar pipe = function pipe2() {\n  for (var _len = arguments.length, functions = new Array(_len), _key = 0; _key < _len; _key++) {\n    functions[_key] = arguments[_key];\n  }\n  return function(value) {\n    return functions.reduce(function(v, f) {\n      return f(v);\n    }, value);\n  };\n};\nvar unitize = function unitize2(func, unit) {\n  return function(value) {\n    return func(parseFloat(value)) + (unit || getUnit(value));\n  };\n};\nvar normalize = function normalize2(min, max, value) {\n  return mapRange(min, max, 0, 1, value);\n};\nvar _wrapArray = function _wrapArray2(a, wrapper, value) {\n  return _conditionalReturn(value, function(index) {\n    return a[~~wrapper(index)];\n  });\n};\nvar wrap = function wrap2(min, max, value) {\n  var range = max - min;\n  return _isArray(min) ? _wrapArray(min, wrap2(0, min.length), max) : _conditionalReturn(value, function(value2) {\n    return (range + (value2 - min) % range) % range + min;\n  });\n};\nvar wrapYoyo = function wrapYoyo2(min, max, value) {\n  var range = max - min, total = range * 2;\n  return _isArray(min) ? _wrapArray(min, wrapYoyo2(0, min.length - 1), max) : _conditionalReturn(value, function(value2) {\n    value2 = (total + (value2 - min) % total) % total || 0;\n    return min + (value2 > range ? total - value2 : value2);\n  });\n};\nvar _replaceRandom = function _replaceRandom2(value) {\n  var prev = 0, s = \"\", i, nums, end, isArray;\n  while (~(i = value.indexOf(\"random(\", prev))) {\n    end = value.indexOf(\")\", i);\n    isArray = value.charAt(i + 7) === \"[\";\n    nums = value.substr(i + 7, end - i - 7).match(isArray ? _delimitedValueExp : _strictNumExp);\n    s += value.substr(prev, i - prev) + random(isArray ? nums : +nums[0], isArray ? 0 : +nums[1], +nums[2] || 1e-5);\n    prev = end + 1;\n  }\n  return s + value.substr(prev, value.length - prev);\n};\nvar mapRange = function mapRange2(inMin, inMax, outMin, outMax, value) {\n  var inRange = inMax - inMin, outRange = outMax - outMin;\n  return _conditionalReturn(value, function(value2) {\n    return outMin + ((value2 - inMin) / inRange * outRange || 0);\n  });\n};\nvar interpolate = function interpolate2(start, end, progress, mutate) {\n  var func = isNaN(start + end) ? 0 : function(p2) {\n    return (1 - p2) * start + p2 * end;\n  };\n  if (!func) {\n    var isString = _isString(start), master = {}, p, i, interpolators, l, il;\n    progress === true && (mutate = 1) && (progress = null);\n    if (isString) {\n      start = {\n        p: start\n      };\n      end = {\n        p: end\n      };\n    } else if (_isArray(start) && !_isArray(end)) {\n      interpolators = [];\n      l = start.length;\n      il = l - 2;\n      for (i = 1; i < l; i++) {\n        interpolators.push(interpolate2(start[i - 1], start[i]));\n      }\n      l--;\n      func = function func2(p2) {\n        p2 *= l;\n        var i2 = Math.min(il, ~~p2);\n        return interpolators[i2](p2 - i2);\n      };\n      progress = end;\n    } else if (!mutate) {\n      start = _merge(_isArray(start) ? [] : {}, start);\n    }\n    if (!interpolators) {\n      for (p in end) {\n        _addPropTween.call(master, start, p, \"get\", end[p]);\n      }\n      func = function func2(p2) {\n        return _renderPropTweens(p2, master) || (isString ? start.p : start);\n      };\n    }\n  }\n  return _conditionalReturn(progress, func);\n};\nvar _getLabelInDirection = function _getLabelInDirection2(timeline2, fromTime, backward) {\n  var labels = timeline2.labels, min = _bigNum, p, distance, label;\n  for (p in labels) {\n    distance = labels[p] - fromTime;\n    if (distance < 0 === !!backward && distance && min > (distance = Math.abs(distance))) {\n      label = p;\n      min = distance;\n    }\n  }\n  return label;\n};\nvar _callback = function _callback2(animation, type, executeLazyFirst) {\n  var v = animation.vars, callback = v[type], prevContext = _context, context3 = animation._ctx, params, scope, result;\n  if (!callback) {\n    return;\n  }\n  params = v[type + \"Params\"];\n  scope = v.callbackScope || animation;\n  executeLazyFirst && _lazyTweens.length && _lazyRender();\n  context3 && (_context = context3);\n  result = params ? callback.apply(scope, params) : callback.call(scope);\n  _context = prevContext;\n  return result;\n};\nvar _interrupt = function _interrupt2(animation) {\n  _removeFromParent(animation);\n  animation.scrollTrigger && animation.scrollTrigger.kill(!!_reverting);\n  animation.progress() < 1 && _callback(animation, \"onInterrupt\");\n  return animation;\n};\nvar _quickTween;\nvar _registerPluginQueue = [];\nvar _createPlugin = function _createPlugin2(config3) {\n  if (!config3)\n    return;\n  config3 = !config3.name && config3[\"default\"] || config3;\n  if (_windowExists() || config3.headless) {\n    var name = config3.name, isFunc = _isFunction(config3), Plugin = name && !isFunc && config3.init ? function() {\n      this._props = [];\n    } : config3, instanceDefaults = {\n      init: _emptyFunc,\n      render: _renderPropTweens,\n      add: _addPropTween,\n      kill: _killPropTweensOf,\n      modifier: _addPluginModifier,\n      rawVars: 0\n    }, statics = {\n      targetTest: 0,\n      get: 0,\n      getSetter: _getSetter,\n      aliases: {},\n      register: 0\n    };\n    _wake();\n    if (config3 !== Plugin) {\n      if (_plugins[name]) {\n        return;\n      }\n      _setDefaults(Plugin, _setDefaults(_copyExcluding(config3, instanceDefaults), statics));\n      _merge(Plugin.prototype, _merge(instanceDefaults, _copyExcluding(config3, statics)));\n      _plugins[Plugin.prop = name] = Plugin;\n      if (config3.targetTest) {\n        _harnessPlugins.push(Plugin);\n        _reservedProps[name] = 1;\n      }\n      name = (name === \"css\" ? \"CSS\" : name.charAt(0).toUpperCase() + name.substr(1)) + \"Plugin\";\n    }\n    _addGlobal(name, Plugin);\n    config3.register && config3.register(gsap, Plugin, PropTween);\n  } else {\n    _registerPluginQueue.push(config3);\n  }\n};\nvar _255 = 255;\nvar _colorLookup = {\n  aqua: [0, _255, _255],\n  lime: [0, _255, 0],\n  silver: [192, 192, 192],\n  black: [0, 0, 0],\n  maroon: [128, 0, 0],\n  teal: [0, 128, 128],\n  blue: [0, 0, _255],\n  navy: [0, 0, 128],\n  white: [_255, _255, _255],\n  olive: [128, 128, 0],\n  yellow: [_255, _255, 0],\n  orange: [_255, 165, 0],\n  gray: [128, 128, 128],\n  purple: [128, 0, 128],\n  green: [0, 128, 0],\n  red: [_255, 0, 0],\n  pink: [_255, 192, 203],\n  cyan: [0, _255, _255],\n  transparent: [_255, _255, _255, 0]\n};\nvar _hue = function _hue2(h, m1, m2) {\n  h += h < 0 ? 1 : h > 1 ? -1 : 0;\n  return (h * 6 < 1 ? m1 + (m2 - m1) * h * 6 : h < 0.5 ? m2 : h * 3 < 2 ? m1 + (m2 - m1) * (2 / 3 - h) * 6 : m1) * _255 + 0.5 | 0;\n};\nvar splitColor = function splitColor2(v, toHSL, forceAlpha) {\n  var a = !v ? _colorLookup.black : _isNumber(v) ? [v >> 16, v >> 8 & _255, v & _255] : 0, r, g, b, h, s, l, max, min, d, wasHSL;\n  if (!a) {\n    if (v.substr(-1) === \",\") {\n      v = v.substr(0, v.length - 1);\n    }\n    if (_colorLookup[v]) {\n      a = _colorLookup[v];\n    } else if (v.charAt(0) === \"#\") {\n      if (v.length < 6) {\n        r = v.charAt(1);\n        g = v.charAt(2);\n        b = v.charAt(3);\n        v = \"#\" + r + r + g + g + b + b + (v.length === 5 ? v.charAt(4) + v.charAt(4) : \"\");\n      }\n      if (v.length === 9) {\n        a = parseInt(v.substr(1, 6), 16);\n        return [a >> 16, a >> 8 & _255, a & _255, parseInt(v.substr(7), 16) / 255];\n      }\n      v = parseInt(v.substr(1), 16);\n      a = [v >> 16, v >> 8 & _255, v & _255];\n    } else if (v.substr(0, 3) === \"hsl\") {\n      a = wasHSL = v.match(_strictNumExp);\n      if (!toHSL) {\n        h = +a[0] % 360 / 360;\n        s = +a[1] / 100;\n        l = +a[2] / 100;\n        g = l <= 0.5 ? l * (s + 1) : l + s - l * s;\n        r = l * 2 - g;\n        a.length > 3 && (a[3] *= 1);\n        a[0] = _hue(h + 1 / 3, r, g);\n        a[1] = _hue(h, r, g);\n        a[2] = _hue(h - 1 / 3, r, g);\n      } else if (~v.indexOf(\"=\")) {\n        a = v.match(_numExp);\n        forceAlpha && a.length < 4 && (a[3] = 1);\n        return a;\n      }\n    } else {\n      a = v.match(_strictNumExp) || _colorLookup.transparent;\n    }\n    a = a.map(Number);\n  }\n  if (toHSL && !wasHSL) {\n    r = a[0] / _255;\n    g = a[1] / _255;\n    b = a[2] / _255;\n    max = Math.max(r, g, b);\n    min = Math.min(r, g, b);\n    l = (max + min) / 2;\n    if (max === min) {\n      h = s = 0;\n    } else {\n      d = max - min;\n      s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n      h = max === r ? (g - b) / d + (g < b ? 6 : 0) : max === g ? (b - r) / d + 2 : (r - g) / d + 4;\n      h *= 60;\n    }\n    a[0] = ~~(h + 0.5);\n    a[1] = ~~(s * 100 + 0.5);\n    a[2] = ~~(l * 100 + 0.5);\n  }\n  forceAlpha && a.length < 4 && (a[3] = 1);\n  return a;\n};\nvar _colorOrderData = function _colorOrderData2(v) {\n  var values = [], c = [], i = -1;\n  v.split(_colorExp).forEach(function(v2) {\n    var a = v2.match(_numWithUnitExp) || [];\n    values.push.apply(values, a);\n    c.push(i += a.length + 1);\n  });\n  values.c = c;\n  return values;\n};\nvar _formatColors = function _formatColors2(s, toHSL, orderMatchData) {\n  var result = \"\", colors = (s + result).match(_colorExp), type = toHSL ? \"hsla(\" : \"rgba(\", i = 0, c, shell, d, l;\n  if (!colors) {\n    return s;\n  }\n  colors = colors.map(function(color) {\n    return (color = splitColor(color, toHSL, 1)) && type + (toHSL ? color[0] + \",\" + color[1] + \"%,\" + color[2] + \"%,\" + color[3] : color.join(\",\")) + \")\";\n  });\n  if (orderMatchData) {\n    d = _colorOrderData(s);\n    c = orderMatchData.c;\n    if (c.join(result) !== d.c.join(result)) {\n      shell = s.replace(_colorExp, \"1\").split(_numWithUnitExp);\n      l = shell.length - 1;\n      for (; i < l; i++) {\n        result += shell[i] + (~c.indexOf(i) ? colors.shift() || type + \"0,0,0,0)\" : (d.length ? d : colors.length ? colors : orderMatchData).shift());\n      }\n    }\n  }\n  if (!shell) {\n    shell = s.split(_colorExp);\n    l = shell.length - 1;\n    for (; i < l; i++) {\n      result += shell[i] + colors[i];\n    }\n  }\n  return result + shell[l];\n};\nvar _colorExp = function() {\n  var s = \"(?:\\\\b(?:(?:rgb|rgba|hsl|hsla)\\\\(.+?\\\\))|\\\\B#(?:[0-9a-f]{3,4}){1,2}\\\\b\", p;\n  for (p in _colorLookup) {\n    s += \"|\" + p + \"\\\\b\";\n  }\n  return new RegExp(s + \")\", \"gi\");\n}();\nvar _hslExp = /hsl[a]?\\(/;\nvar _colorStringFilter = function _colorStringFilter2(a) {\n  var combined = a.join(\" \"), toHSL;\n  _colorExp.lastIndex = 0;\n  if (_colorExp.test(combined)) {\n    toHSL = _hslExp.test(combined);\n    a[1] = _formatColors(a[1], toHSL);\n    a[0] = _formatColors(a[0], toHSL, _colorOrderData(a[1]));\n    return true;\n  }\n};\nvar _tickerActive;\nvar _ticker = function() {\n  var _getTime = Date.now, _lagThreshold = 500, _adjustedLag = 33, _startTime = _getTime(), _lastUpdate = _startTime, _gap = 1e3 / 240, _nextTime = _gap, _listeners2 = [], _id, _req, _raf, _self, _delta, _i, _tick = function _tick2(v) {\n    var elapsed = _getTime() - _lastUpdate, manual = v === true, overlap, dispatch, time, frame;\n    (elapsed > _lagThreshold || elapsed < 0) && (_startTime += elapsed - _adjustedLag);\n    _lastUpdate += elapsed;\n    time = _lastUpdate - _startTime;\n    overlap = time - _nextTime;\n    if (overlap > 0 || manual) {\n      frame = ++_self.frame;\n      _delta = time - _self.time * 1e3;\n      _self.time = time = time / 1e3;\n      _nextTime += overlap + (overlap >= _gap ? 4 : _gap - overlap);\n      dispatch = 1;\n    }\n    manual || (_id = _req(_tick2));\n    if (dispatch) {\n      for (_i = 0; _i < _listeners2.length; _i++) {\n        _listeners2[_i](time, _delta, frame, v);\n      }\n    }\n  };\n  _self = {\n    time: 0,\n    frame: 0,\n    tick: function tick() {\n      _tick(true);\n    },\n    deltaRatio: function deltaRatio(fps) {\n      return _delta / (1e3 / (fps || 60));\n    },\n    wake: function wake() {\n      if (_coreReady) {\n        if (!_coreInitted && _windowExists()) {\n          _win = _coreInitted = window;\n          _doc = _win.document || {};\n          _globals.gsap = gsap;\n          (_win.gsapVersions || (_win.gsapVersions = [])).push(gsap.version);\n          _install(_installScope || _win.GreenSockGlobals || !_win.gsap && _win || {});\n          _registerPluginQueue.forEach(_createPlugin);\n        }\n        _raf = typeof requestAnimationFrame !== \"undefined\" && requestAnimationFrame;\n        _id && _self.sleep();\n        _req = _raf || function(f) {\n          return setTimeout(f, _nextTime - _self.time * 1e3 + 1 | 0);\n        };\n        _tickerActive = 1;\n        _tick(2);\n      }\n    },\n    sleep: function sleep() {\n      (_raf ? cancelAnimationFrame : clearTimeout)(_id);\n      _tickerActive = 0;\n      _req = _emptyFunc;\n    },\n    lagSmoothing: function lagSmoothing(threshold, adjustedLag) {\n      _lagThreshold = threshold || Infinity;\n      _adjustedLag = Math.min(adjustedLag || 33, _lagThreshold);\n    },\n    fps: function fps(_fps) {\n      _gap = 1e3 / (_fps || 240);\n      _nextTime = _self.time * 1e3 + _gap;\n    },\n    add: function add(callback, once, prioritize) {\n      var func = once ? function(t, d, f, v) {\n        callback(t, d, f, v);\n        _self.remove(func);\n      } : callback;\n      _self.remove(callback);\n      _listeners2[prioritize ? \"unshift\" : \"push\"](func);\n      _wake();\n      return func;\n    },\n    remove: function remove(callback, i) {\n      ~(i = _listeners2.indexOf(callback)) && _listeners2.splice(i, 1) && _i >= i && _i--;\n    },\n    _listeners: _listeners2\n  };\n  return _self;\n}();\nvar _wake = function _wake2() {\n  return !_tickerActive && _ticker.wake();\n};\nvar _easeMap = {};\nvar _customEaseExp = /^[\\d.\\-M][\\d.\\-,\\s]/;\nvar _quotesExp = /[\"']/g;\nvar _parseObjectInString = function _parseObjectInString2(value) {\n  var obj = {}, split = value.substr(1, value.length - 3).split(\":\"), key = split[0], i = 1, l = split.length, index, val, parsedVal;\n  for (; i < l; i++) {\n    val = split[i];\n    index = i !== l - 1 ? val.lastIndexOf(\",\") : val.length;\n    parsedVal = val.substr(0, index);\n    obj[key] = isNaN(parsedVal) ? parsedVal.replace(_quotesExp, \"\").trim() : +parsedVal;\n    key = val.substr(index + 1).trim();\n  }\n  return obj;\n};\nvar _valueInParentheses = function _valueInParentheses2(value) {\n  var open = value.indexOf(\"(\") + 1, close = value.indexOf(\")\"), nested = value.indexOf(\"(\", open);\n  return value.substring(open, ~nested && nested < close ? value.indexOf(\")\", close + 1) : close);\n};\nvar _configEaseFromString = function _configEaseFromString2(name) {\n  var split = (name + \"\").split(\"(\"), ease = _easeMap[split[0]];\n  return ease && split.length > 1 && ease.config ? ease.config.apply(null, ~name.indexOf(\"{\") ? [_parseObjectInString(split[1])] : _valueInParentheses(name).split(\",\").map(_numericIfPossible)) : _easeMap._CE && _customEaseExp.test(name) ? _easeMap._CE(\"\", name) : ease;\n};\nvar _invertEase = function _invertEase2(ease) {\n  return function(p) {\n    return 1 - ease(1 - p);\n  };\n};\nvar _propagateYoyoEase = function _propagateYoyoEase2(timeline2, isYoyo) {\n  var child = timeline2._first, ease;\n  while (child) {\n    if (child instanceof Timeline) {\n      _propagateYoyoEase2(child, isYoyo);\n    } else if (child.vars.yoyoEase && (!child._yoyo || !child._repeat) && child._yoyo !== isYoyo) {\n      if (child.timeline) {\n        _propagateYoyoEase2(child.timeline, isYoyo);\n      } else {\n        ease = child._ease;\n        child._ease = child._yEase;\n        child._yEase = ease;\n        child._yoyo = isYoyo;\n      }\n    }\n    child = child._next;\n  }\n};\nvar _parseEase = function _parseEase2(ease, defaultEase) {\n  return !ease ? defaultEase : (_isFunction(ease) ? ease : _easeMap[ease] || _configEaseFromString(ease)) || defaultEase;\n};\nvar _insertEase = function _insertEase2(names, easeIn, easeOut, easeInOut) {\n  if (easeOut === void 0) {\n    easeOut = function easeOut2(p) {\n      return 1 - easeIn(1 - p);\n    };\n  }\n  if (easeInOut === void 0) {\n    easeInOut = function easeInOut2(p) {\n      return p < 0.5 ? easeIn(p * 2) / 2 : 1 - easeIn((1 - p) * 2) / 2;\n    };\n  }\n  var ease = {\n    easeIn,\n    easeOut,\n    easeInOut\n  }, lowercaseName;\n  _forEachName(names, function(name) {\n    _easeMap[name] = _globals[name] = ease;\n    _easeMap[lowercaseName = name.toLowerCase()] = easeOut;\n    for (var p in ease) {\n      _easeMap[lowercaseName + (p === \"easeIn\" ? \".in\" : p === \"easeOut\" ? \".out\" : \".inOut\")] = _easeMap[name + \".\" + p] = ease[p];\n    }\n  });\n  return ease;\n};\nvar _easeInOutFromOut = function _easeInOutFromOut2(easeOut) {\n  return function(p) {\n    return p < 0.5 ? (1 - easeOut(1 - p * 2)) / 2 : 0.5 + easeOut((p - 0.5) * 2) / 2;\n  };\n};\nvar _configElastic = function _configElastic2(type, amplitude, period) {\n  var p1 = amplitude >= 1 ? amplitude : 1, p2 = (period || (type ? 0.3 : 0.45)) / (amplitude < 1 ? amplitude : 1), p3 = p2 / _2PI * (Math.asin(1 / p1) || 0), easeOut = function easeOut2(p) {\n    return p === 1 ? 1 : p1 * Math.pow(2, -10 * p) * _sin((p - p3) * p2) + 1;\n  }, ease = type === \"out\" ? easeOut : type === \"in\" ? function(p) {\n    return 1 - easeOut(1 - p);\n  } : _easeInOutFromOut(easeOut);\n  p2 = _2PI / p2;\n  ease.config = function(amplitude2, period2) {\n    return _configElastic2(type, amplitude2, period2);\n  };\n  return ease;\n};\nvar _configBack = function _configBack2(type, overshoot) {\n  if (overshoot === void 0) {\n    overshoot = 1.70158;\n  }\n  var easeOut = function easeOut2(p) {\n    return p ? --p * p * ((overshoot + 1) * p + overshoot) + 1 : 0;\n  }, ease = type === \"out\" ? easeOut : type === \"in\" ? function(p) {\n    return 1 - easeOut(1 - p);\n  } : _easeInOutFromOut(easeOut);\n  ease.config = function(overshoot2) {\n    return _configBack2(type, overshoot2);\n  };\n  return ease;\n};\n_forEachName(\"Linear,Quad,Cubic,Quart,Quint,Strong\", function(name, i) {\n  var power = i < 5 ? i + 1 : i;\n  _insertEase(name + \",Power\" + (power - 1), i ? function(p) {\n    return Math.pow(p, power);\n  } : function(p) {\n    return p;\n  }, function(p) {\n    return 1 - Math.pow(1 - p, power);\n  }, function(p) {\n    return p < 0.5 ? Math.pow(p * 2, power) / 2 : 1 - Math.pow((1 - p) * 2, power) / 2;\n  });\n});\n_easeMap.Linear.easeNone = _easeMap.none = _easeMap.Linear.easeIn;\n_insertEase(\"Elastic\", _configElastic(\"in\"), _configElastic(\"out\"), _configElastic());\n(function(n, c) {\n  var n1 = 1 / c, n2 = 2 * n1, n3 = 2.5 * n1, easeOut = function easeOut2(p) {\n    return p < n1 ? n * p * p : p < n2 ? n * Math.pow(p - 1.5 / c, 2) + 0.75 : p < n3 ? n * (p -= 2.25 / c) * p + 0.9375 : n * Math.pow(p - 2.625 / c, 2) + 0.984375;\n  };\n  _insertEase(\"Bounce\", function(p) {\n    return 1 - easeOut(1 - p);\n  }, easeOut);\n})(7.5625, 2.75);\n_insertEase(\"Expo\", function(p) {\n  return p ? Math.pow(2, 10 * (p - 1)) : 0;\n});\n_insertEase(\"Circ\", function(p) {\n  return -(_sqrt(1 - p * p) - 1);\n});\n_insertEase(\"Sine\", function(p) {\n  return p === 1 ? 1 : -_cos(p * _HALF_PI) + 1;\n});\n_insertEase(\"Back\", _configBack(\"in\"), _configBack(\"out\"), _configBack());\n_easeMap.SteppedEase = _easeMap.steps = _globals.SteppedEase = {\n  config: function config(steps, immediateStart) {\n    if (steps === void 0) {\n      steps = 1;\n    }\n    var p1 = 1 / steps, p2 = steps + (immediateStart ? 0 : 1), p3 = immediateStart ? 1 : 0, max = 1 - _tinyNum;\n    return function(p) {\n      return ((p2 * _clamp(0, max, p) | 0) + p3) * p1;\n    };\n  }\n};\n_defaults.ease = _easeMap[\"quad.out\"];\n_forEachName(\"onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt\", function(name) {\n  return _callbackNames += name + \",\" + name + \"Params,\";\n});\nvar GSCache = function GSCache2(target, harness) {\n  this.id = _gsID++;\n  target._gsap = this;\n  this.target = target;\n  this.harness = harness;\n  this.get = harness ? harness.get : _getProperty;\n  this.set = harness ? harness.getSetter : _getSetter;\n};\nvar Animation = function() {\n  function Animation2(vars) {\n    this.vars = vars;\n    this._delay = +vars.delay || 0;\n    if (this._repeat = vars.repeat === Infinity ? -2 : vars.repeat || 0) {\n      this._rDelay = vars.repeatDelay || 0;\n      this._yoyo = !!vars.yoyo || !!vars.yoyoEase;\n    }\n    this._ts = 1;\n    _setDuration(this, +vars.duration, 1, 1);\n    this.data = vars.data;\n    if (_context) {\n      this._ctx = _context;\n      _context.data.push(this);\n    }\n    _tickerActive || _ticker.wake();\n  }\n  var _proto = Animation2.prototype;\n  _proto.delay = function delay(value) {\n    if (value || value === 0) {\n      this.parent && this.parent.smoothChildTiming && this.startTime(this._start + value - this._delay);\n      this._delay = value;\n      return this;\n    }\n    return this._delay;\n  };\n  _proto.duration = function duration(value) {\n    return arguments.length ? this.totalDuration(this._repeat > 0 ? value + (value + this._rDelay) * this._repeat : value) : this.totalDuration() && this._dur;\n  };\n  _proto.totalDuration = function totalDuration(value) {\n    if (!arguments.length) {\n      return this._tDur;\n    }\n    this._dirty = 0;\n    return _setDuration(this, this._repeat < 0 ? value : (value - this._repeat * this._rDelay) / (this._repeat + 1));\n  };\n  _proto.totalTime = function totalTime(_totalTime, suppressEvents) {\n    _wake();\n    if (!arguments.length) {\n      return this._tTime;\n    }\n    var parent = this._dp;\n    if (parent && parent.smoothChildTiming && this._ts) {\n      _alignPlayhead(this, _totalTime);\n      !parent._dp || parent.parent || _postAddChecks(parent, this);\n      while (parent && parent.parent) {\n        if (parent.parent._time !== parent._start + (parent._ts >= 0 ? parent._tTime / parent._ts : (parent.totalDuration() - parent._tTime) / -parent._ts)) {\n          parent.totalTime(parent._tTime, true);\n        }\n        parent = parent.parent;\n      }\n      if (!this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && _totalTime < this._tDur || this._ts < 0 && _totalTime > 0 || !this._tDur && !_totalTime)) {\n        _addToTimeline(this._dp, this, this._start - this._delay);\n      }\n    }\n    if (this._tTime !== _totalTime || !this._dur && !suppressEvents || this._initted && Math.abs(this._zTime) === _tinyNum || !_totalTime && !this._initted && (this.add || this._ptLookup)) {\n      this._ts || (this._pTime = _totalTime);\n      _lazySafeRender(this, _totalTime, suppressEvents);\n    }\n    return this;\n  };\n  _proto.time = function time(value, suppressEvents) {\n    return arguments.length ? this.totalTime(Math.min(this.totalDuration(), value + _elapsedCycleDuration(this)) % (this._dur + this._rDelay) || (value ? this._dur : 0), suppressEvents) : this._time;\n  };\n  _proto.totalProgress = function totalProgress(value, suppressEvents) {\n    return arguments.length ? this.totalTime(this.totalDuration() * value, suppressEvents) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.rawTime() > 0 ? 1 : 0;\n  };\n  _proto.progress = function progress(value, suppressEvents) {\n    return arguments.length ? this.totalTime(this.duration() * (this._yoyo && !(this.iteration() & 1) ? 1 - value : value) + _elapsedCycleDuration(this), suppressEvents) : this.duration() ? Math.min(1, this._time / this._dur) : this.rawTime() > 0 ? 1 : 0;\n  };\n  _proto.iteration = function iteration(value, suppressEvents) {\n    var cycleDuration = this.duration() + this._rDelay;\n    return arguments.length ? this.totalTime(this._time + (value - 1) * cycleDuration, suppressEvents) : this._repeat ? _animationCycle(this._tTime, cycleDuration) + 1 : 1;\n  };\n  _proto.timeScale = function timeScale(value, suppressEvents) {\n    if (!arguments.length) {\n      return this._rts === -_tinyNum ? 0 : this._rts;\n    }\n    if (this._rts === value) {\n      return this;\n    }\n    var tTime = this.parent && this._ts ? _parentToChildTotalTime(this.parent._time, this) : this._tTime;\n    this._rts = +value || 0;\n    this._ts = this._ps || value === -_tinyNum ? 0 : this._rts;\n    this.totalTime(_clamp(-Math.abs(this._delay), this._tDur, tTime), suppressEvents !== false);\n    _setEnd(this);\n    return _recacheAncestors(this);\n  };\n  _proto.paused = function paused(value) {\n    if (!arguments.length) {\n      return this._ps;\n    }\n    if (this._ps !== value) {\n      this._ps = value;\n      if (value) {\n        this._pTime = this._tTime || Math.max(-this._delay, this.rawTime());\n        this._ts = this._act = 0;\n      } else {\n        _wake();\n        this._ts = this._rts;\n        this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, this.progress() === 1 && Math.abs(this._zTime) !== _tinyNum && (this._tTime -= _tinyNum));\n      }\n    }\n    return this;\n  };\n  _proto.startTime = function startTime(value) {\n    if (arguments.length) {\n      this._start = value;\n      var parent = this.parent || this._dp;\n      parent && (parent._sort || !this.parent) && _addToTimeline(parent, this, value - this._delay);\n      return this;\n    }\n    return this._start;\n  };\n  _proto.endTime = function endTime(includeRepeats) {\n    return this._start + (_isNotFalse(includeRepeats) ? this.totalDuration() : this.duration()) / Math.abs(this._ts || 1);\n  };\n  _proto.rawTime = function rawTime(wrapRepeats) {\n    var parent = this.parent || this._dp;\n    return !parent ? this._tTime : wrapRepeats && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : !this._ts ? this._tTime : _parentToChildTotalTime(parent.rawTime(wrapRepeats), this);\n  };\n  _proto.revert = function revert(config3) {\n    if (config3 === void 0) {\n      config3 = _revertConfig;\n    }\n    var prevIsReverting = _reverting;\n    _reverting = config3;\n    if (this._initted || this._startAt) {\n      this.timeline && this.timeline.revert(config3);\n      this.totalTime(-0.01, config3.suppressEvents);\n    }\n    this.data !== \"nested\" && config3.kill !== false && this.kill();\n    _reverting = prevIsReverting;\n    return this;\n  };\n  _proto.globalTime = function globalTime(rawTime) {\n    var animation = this, time = arguments.length ? rawTime : animation.rawTime();\n    while (animation) {\n      time = animation._start + time / (Math.abs(animation._ts) || 1);\n      animation = animation._dp;\n    }\n    return !this.parent && this._sat ? this._sat.globalTime(rawTime) : time;\n  };\n  _proto.repeat = function repeat(value) {\n    if (arguments.length) {\n      this._repeat = value === Infinity ? -2 : value;\n      return _onUpdateTotalDuration(this);\n    }\n    return this._repeat === -2 ? Infinity : this._repeat;\n  };\n  _proto.repeatDelay = function repeatDelay(value) {\n    if (arguments.length) {\n      var time = this._time;\n      this._rDelay = value;\n      _onUpdateTotalDuration(this);\n      return time ? this.time(time) : this;\n    }\n    return this._rDelay;\n  };\n  _proto.yoyo = function yoyo(value) {\n    if (arguments.length) {\n      this._yoyo = value;\n      return this;\n    }\n    return this._yoyo;\n  };\n  _proto.seek = function seek(position, suppressEvents) {\n    return this.totalTime(_parsePosition(this, position), _isNotFalse(suppressEvents));\n  };\n  _proto.restart = function restart(includeDelay, suppressEvents) {\n    return this.play().totalTime(includeDelay ? -this._delay : 0, _isNotFalse(suppressEvents));\n  };\n  _proto.play = function play(from, suppressEvents) {\n    from != null && this.seek(from, suppressEvents);\n    return this.reversed(false).paused(false);\n  };\n  _proto.reverse = function reverse(from, suppressEvents) {\n    from != null && this.seek(from || this.totalDuration(), suppressEvents);\n    return this.reversed(true).paused(false);\n  };\n  _proto.pause = function pause(atTime, suppressEvents) {\n    atTime != null && this.seek(atTime, suppressEvents);\n    return this.paused(true);\n  };\n  _proto.resume = function resume() {\n    return this.paused(false);\n  };\n  _proto.reversed = function reversed(value) {\n    if (arguments.length) {\n      !!value !== this.reversed() && this.timeScale(-this._rts || (value ? -_tinyNum : 0));\n      return this;\n    }\n    return this._rts < 0;\n  };\n  _proto.invalidate = function invalidate() {\n    this._initted = this._act = 0;\n    this._zTime = -_tinyNum;\n    return this;\n  };\n  _proto.isActive = function isActive() {\n    var parent = this.parent || this._dp, start = this._start, rawTime;\n    return !!(!parent || this._ts && this._initted && parent.isActive() && (rawTime = parent.rawTime(true)) >= start && rawTime < this.endTime(true) - _tinyNum);\n  };\n  _proto.eventCallback = function eventCallback(type, callback, params) {\n    var vars = this.vars;\n    if (arguments.length > 1) {\n      if (!callback) {\n        delete vars[type];\n      } else {\n        vars[type] = callback;\n        params && (vars[type + \"Params\"] = params);\n        type === \"onUpdate\" && (this._onUpdate = callback);\n      }\n      return this;\n    }\n    return vars[type];\n  };\n  _proto.then = function then(onFulfilled) {\n    var self = this;\n    return new Promise(function(resolve) {\n      var f = _isFunction(onFulfilled) ? onFulfilled : _passThrough, _resolve = function _resolve2() {\n        var _then = self.then;\n        self.then = null;\n        _isFunction(f) && (f = f(self)) && (f.then || f === self) && (self.then = _then);\n        resolve(f);\n        self.then = _then;\n      };\n      if (self._initted && self.totalProgress() === 1 && self._ts >= 0 || !self._tTime && self._ts < 0) {\n        _resolve();\n      } else {\n        self._prom = _resolve;\n      }\n    });\n  };\n  _proto.kill = function kill() {\n    _interrupt(this);\n  };\n  return Animation2;\n}();\n_setDefaults(Animation.prototype, {\n  _time: 0,\n  _start: 0,\n  _end: 0,\n  _tTime: 0,\n  _tDur: 0,\n  _dirty: 0,\n  _repeat: 0,\n  _yoyo: false,\n  parent: null,\n  _initted: false,\n  _rDelay: 0,\n  _ts: 1,\n  _dp: 0,\n  ratio: 0,\n  _zTime: -_tinyNum,\n  _prom: 0,\n  _ps: false,\n  _rts: 1\n});\nvar Timeline = function(_Animation) {\n  _inheritsLoose(Timeline2, _Animation);\n  function Timeline2(vars, position) {\n    var _this;\n    if (vars === void 0) {\n      vars = {};\n    }\n    _this = _Animation.call(this, vars) || this;\n    _this.labels = {};\n    _this.smoothChildTiming = !!vars.smoothChildTiming;\n    _this.autoRemoveChildren = !!vars.autoRemoveChildren;\n    _this._sort = _isNotFalse(vars.sortChildren);\n    _globalTimeline && _addToTimeline(vars.parent || _globalTimeline, _assertThisInitialized(_this), position);\n    vars.reversed && _this.reverse();\n    vars.paused && _this.paused(true);\n    vars.scrollTrigger && _scrollTrigger(_assertThisInitialized(_this), vars.scrollTrigger);\n    return _this;\n  }\n  var _proto2 = Timeline2.prototype;\n  _proto2.to = function to(targets, vars, position) {\n    _createTweenType(0, arguments, this);\n    return this;\n  };\n  _proto2.from = function from(targets, vars, position) {\n    _createTweenType(1, arguments, this);\n    return this;\n  };\n  _proto2.fromTo = function fromTo(targets, fromVars, toVars, position) {\n    _createTweenType(2, arguments, this);\n    return this;\n  };\n  _proto2.set = function set(targets, vars, position) {\n    vars.duration = 0;\n    vars.parent = this;\n    _inheritDefaults(vars).repeatDelay || (vars.repeat = 0);\n    vars.immediateRender = !!vars.immediateRender;\n    new Tween(targets, vars, _parsePosition(this, position), 1);\n    return this;\n  };\n  _proto2.call = function call(callback, params, position) {\n    return _addToTimeline(this, Tween.delayedCall(0, callback, params), position);\n  };\n  _proto2.staggerTo = function staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams) {\n    vars.duration = duration;\n    vars.stagger = vars.stagger || stagger;\n    vars.onComplete = onCompleteAll;\n    vars.onCompleteParams = onCompleteAllParams;\n    vars.parent = this;\n    new Tween(targets, vars, _parsePosition(this, position));\n    return this;\n  };\n  _proto2.staggerFrom = function staggerFrom(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams) {\n    vars.runBackwards = 1;\n    _inheritDefaults(vars).immediateRender = _isNotFalse(vars.immediateRender);\n    return this.staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams);\n  };\n  _proto2.staggerFromTo = function staggerFromTo(targets, duration, fromVars, toVars, stagger, position, onCompleteAll, onCompleteAllParams) {\n    toVars.startAt = fromVars;\n    _inheritDefaults(toVars).immediateRender = _isNotFalse(toVars.immediateRender);\n    return this.staggerTo(targets, duration, toVars, stagger, position, onCompleteAll, onCompleteAllParams);\n  };\n  _proto2.render = function render3(totalTime, suppressEvents, force) {\n    var prevTime = this._time, tDur = this._dirty ? this.totalDuration() : this._tDur, dur = this._dur, tTime = totalTime <= 0 ? 0 : _roundPrecise(totalTime), crossingStart = this._zTime < 0 !== totalTime < 0 && (this._initted || !dur), time, child, next, iteration, cycleDuration, prevPaused, pauseTween, timeScale, prevStart, prevIteration, yoyo, isYoyo;\n    this !== _globalTimeline && tTime > tDur && totalTime >= 0 && (tTime = tDur);\n    if (tTime !== this._tTime || force || crossingStart) {\n      if (prevTime !== this._time && dur) {\n        tTime += this._time - prevTime;\n        totalTime += this._time - prevTime;\n      }\n      time = tTime;\n      prevStart = this._start;\n      timeScale = this._ts;\n      prevPaused = !timeScale;\n      if (crossingStart) {\n        dur || (prevTime = this._zTime);\n        (totalTime || !suppressEvents) && (this._zTime = totalTime);\n      }\n      if (this._repeat) {\n        yoyo = this._yoyo;\n        cycleDuration = dur + this._rDelay;\n        if (this._repeat < -1 && totalTime < 0) {\n          return this.totalTime(cycleDuration * 100 + totalTime, suppressEvents, force);\n        }\n        time = _roundPrecise(tTime % cycleDuration);\n        if (tTime === tDur) {\n          iteration = this._repeat;\n          time = dur;\n        } else {\n          iteration = ~~(tTime / cycleDuration);\n          if (iteration && iteration === tTime / cycleDuration) {\n            time = dur;\n            iteration--;\n          }\n          time > dur && (time = dur);\n        }\n        prevIteration = _animationCycle(this._tTime, cycleDuration);\n        !prevTime && this._tTime && prevIteration !== iteration && this._tTime - prevIteration * cycleDuration - this._dur <= 0 && (prevIteration = iteration);\n        if (yoyo && iteration & 1) {\n          time = dur - time;\n          isYoyo = 1;\n        }\n        if (iteration !== prevIteration && !this._lock) {\n          var rewinding = yoyo && prevIteration & 1, doesWrap = rewinding === (yoyo && iteration & 1);\n          iteration < prevIteration && (rewinding = !rewinding);\n          prevTime = rewinding ? 0 : tTime % dur ? dur : tTime;\n          this._lock = 1;\n          this.render(prevTime || (isYoyo ? 0 : _roundPrecise(iteration * cycleDuration)), suppressEvents, !dur)._lock = 0;\n          this._tTime = tTime;\n          !suppressEvents && this.parent && _callback(this, \"onRepeat\");\n          this.vars.repeatRefresh && !isYoyo && (this.invalidate()._lock = 1);\n          if (prevTime && prevTime !== this._time || prevPaused !== !this._ts || this.vars.onRepeat && !this.parent && !this._act) {\n            return this;\n          }\n          dur = this._dur;\n          tDur = this._tDur;\n          if (doesWrap) {\n            this._lock = 2;\n            prevTime = rewinding ? dur : -1e-4;\n            this.render(prevTime, true);\n            this.vars.repeatRefresh && !isYoyo && this.invalidate();\n          }\n          this._lock = 0;\n          if (!this._ts && !prevPaused) {\n            return this;\n          }\n          _propagateYoyoEase(this, isYoyo);\n        }\n      }\n      if (this._hasPause && !this._forcing && this._lock < 2) {\n        pauseTween = _findNextPauseTween(this, _roundPrecise(prevTime), _roundPrecise(time));\n        if (pauseTween) {\n          tTime -= time - (time = pauseTween._start);\n        }\n      }\n      this._tTime = tTime;\n      this._time = time;\n      this._act = !timeScale;\n      if (!this._initted) {\n        this._onUpdate = this.vars.onUpdate;\n        this._initted = 1;\n        this._zTime = totalTime;\n        prevTime = 0;\n      }\n      if (!prevTime && time && !suppressEvents && !iteration) {\n        _callback(this, \"onStart\");\n        if (this._tTime !== tTime) {\n          return this;\n        }\n      }\n      if (time >= prevTime && totalTime >= 0) {\n        child = this._first;\n        while (child) {\n          next = child._next;\n          if ((child._act || time >= child._start) && child._ts && pauseTween !== child) {\n            if (child.parent !== this) {\n              return this.render(totalTime, suppressEvents, force);\n            }\n            child.render(child._ts > 0 ? (time - child._start) * child._ts : (child._dirty ? child.totalDuration() : child._tDur) + (time - child._start) * child._ts, suppressEvents, force);\n            if (time !== this._time || !this._ts && !prevPaused) {\n              pauseTween = 0;\n              next && (tTime += this._zTime = -_tinyNum);\n              break;\n            }\n          }\n          child = next;\n        }\n      } else {\n        child = this._last;\n        var adjustedTime = totalTime < 0 ? totalTime : time;\n        while (child) {\n          next = child._prev;\n          if ((child._act || adjustedTime <= child._end) && child._ts && pauseTween !== child) {\n            if (child.parent !== this) {\n              return this.render(totalTime, suppressEvents, force);\n            }\n            child.render(child._ts > 0 ? (adjustedTime - child._start) * child._ts : (child._dirty ? child.totalDuration() : child._tDur) + (adjustedTime - child._start) * child._ts, suppressEvents, force || _reverting && (child._initted || child._startAt));\n            if (time !== this._time || !this._ts && !prevPaused) {\n              pauseTween = 0;\n              next && (tTime += this._zTime = adjustedTime ? -_tinyNum : _tinyNum);\n              break;\n            }\n          }\n          child = next;\n        }\n      }\n      if (pauseTween && !suppressEvents) {\n        this.pause();\n        pauseTween.render(time >= prevTime ? 0 : -_tinyNum)._zTime = time >= prevTime ? 1 : -1;\n        if (this._ts) {\n          this._start = prevStart;\n          _setEnd(this);\n          return this.render(totalTime, suppressEvents, force);\n        }\n      }\n      this._onUpdate && !suppressEvents && _callback(this, \"onUpdate\", true);\n      if (tTime === tDur && this._tTime >= this.totalDuration() || !tTime && prevTime) {\n        if (prevStart === this._start || Math.abs(timeScale) !== Math.abs(this._ts)) {\n          if (!this._lock) {\n            (totalTime || !dur) && (tTime === tDur && this._ts > 0 || !tTime && this._ts < 0) && _removeFromParent(this, 1);\n            if (!suppressEvents && !(totalTime < 0 && !prevTime) && (tTime || prevTime || !tDur)) {\n              _callback(this, tTime === tDur && totalTime >= 0 ? \"onComplete\" : \"onReverseComplete\", true);\n              this._prom && !(tTime < tDur && this.timeScale() > 0) && this._prom();\n            }\n          }\n        }\n      }\n    }\n    return this;\n  };\n  _proto2.add = function add(child, position) {\n    var _this2 = this;\n    _isNumber(position) || (position = _parsePosition(this, position, child));\n    if (!(child instanceof Animation)) {\n      if (_isArray(child)) {\n        child.forEach(function(obj) {\n          return _this2.add(obj, position);\n        });\n        return this;\n      }\n      if (_isString(child)) {\n        return this.addLabel(child, position);\n      }\n      if (_isFunction(child)) {\n        child = Tween.delayedCall(0, child);\n      } else {\n        return this;\n      }\n    }\n    return this !== child ? _addToTimeline(this, child, position) : this;\n  };\n  _proto2.getChildren = function getChildren(nested, tweens, timelines, ignoreBeforeTime) {\n    if (nested === void 0) {\n      nested = true;\n    }\n    if (tweens === void 0) {\n      tweens = true;\n    }\n    if (timelines === void 0) {\n      timelines = true;\n    }\n    if (ignoreBeforeTime === void 0) {\n      ignoreBeforeTime = -_bigNum;\n    }\n    var a = [], child = this._first;\n    while (child) {\n      if (child._start >= ignoreBeforeTime) {\n        if (child instanceof Tween) {\n          tweens && a.push(child);\n        } else {\n          timelines && a.push(child);\n          nested && a.push.apply(a, child.getChildren(true, tweens, timelines));\n        }\n      }\n      child = child._next;\n    }\n    return a;\n  };\n  _proto2.getById = function getById2(id) {\n    var animations = this.getChildren(1, 1, 1), i = animations.length;\n    while (i--) {\n      if (animations[i].vars.id === id) {\n        return animations[i];\n      }\n    }\n  };\n  _proto2.remove = function remove(child) {\n    if (_isString(child)) {\n      return this.removeLabel(child);\n    }\n    if (_isFunction(child)) {\n      return this.killTweensOf(child);\n    }\n    _removeLinkedListItem(this, child);\n    if (child === this._recent) {\n      this._recent = this._last;\n    }\n    return _uncache(this);\n  };\n  _proto2.totalTime = function totalTime(_totalTime2, suppressEvents) {\n    if (!arguments.length) {\n      return this._tTime;\n    }\n    this._forcing = 1;\n    if (!this._dp && this._ts) {\n      this._start = _roundPrecise(_ticker.time - (this._ts > 0 ? _totalTime2 / this._ts : (this.totalDuration() - _totalTime2) / -this._ts));\n    }\n    _Animation.prototype.totalTime.call(this, _totalTime2, suppressEvents);\n    this._forcing = 0;\n    return this;\n  };\n  _proto2.addLabel = function addLabel(label, position) {\n    this.labels[label] = _parsePosition(this, position);\n    return this;\n  };\n  _proto2.removeLabel = function removeLabel(label) {\n    delete this.labels[label];\n    return this;\n  };\n  _proto2.addPause = function addPause(position, callback, params) {\n    var t = Tween.delayedCall(0, callback || _emptyFunc, params);\n    t.data = \"isPause\";\n    this._hasPause = 1;\n    return _addToTimeline(this, t, _parsePosition(this, position));\n  };\n  _proto2.removePause = function removePause(position) {\n    var child = this._first;\n    position = _parsePosition(this, position);\n    while (child) {\n      if (child._start === position && child.data === \"isPause\") {\n        _removeFromParent(child);\n      }\n      child = child._next;\n    }\n  };\n  _proto2.killTweensOf = function killTweensOf(targets, props, onlyActive) {\n    var tweens = this.getTweensOf(targets, onlyActive), i = tweens.length;\n    while (i--) {\n      _overwritingTween !== tweens[i] && tweens[i].kill(targets, props);\n    }\n    return this;\n  };\n  _proto2.getTweensOf = function getTweensOf2(targets, onlyActive) {\n    var a = [], parsedTargets = toArray(targets), child = this._first, isGlobalTime = _isNumber(onlyActive), children;\n    while (child) {\n      if (child instanceof Tween) {\n        if (_arrayContainsAny(child._targets, parsedTargets) && (isGlobalTime ? (!_overwritingTween || child._initted && child._ts) && child.globalTime(0) <= onlyActive && child.globalTime(child.totalDuration()) > onlyActive : !onlyActive || child.isActive())) {\n          a.push(child);\n        }\n      } else if ((children = child.getTweensOf(parsedTargets, onlyActive)).length) {\n        a.push.apply(a, children);\n      }\n      child = child._next;\n    }\n    return a;\n  };\n  _proto2.tweenTo = function tweenTo(position, vars) {\n    vars = vars || {};\n    var tl = this, endTime = _parsePosition(tl, position), _vars = vars, startAt = _vars.startAt, _onStart = _vars.onStart, onStartParams = _vars.onStartParams, immediateRender = _vars.immediateRender, initted, tween = Tween.to(tl, _setDefaults({\n      ease: vars.ease || \"none\",\n      lazy: false,\n      immediateRender: false,\n      time: endTime,\n      overwrite: \"auto\",\n      duration: vars.duration || Math.abs((endTime - (startAt && \"time\" in startAt ? startAt.time : tl._time)) / tl.timeScale()) || _tinyNum,\n      onStart: function onStart() {\n        tl.pause();\n        if (!initted) {\n          var duration = vars.duration || Math.abs((endTime - (startAt && \"time\" in startAt ? startAt.time : tl._time)) / tl.timeScale());\n          tween._dur !== duration && _setDuration(tween, duration, 0, 1).render(tween._time, true, true);\n          initted = 1;\n        }\n        _onStart && _onStart.apply(tween, onStartParams || []);\n      }\n    }, vars));\n    return immediateRender ? tween.render(0) : tween;\n  };\n  _proto2.tweenFromTo = function tweenFromTo(fromPosition, toPosition, vars) {\n    return this.tweenTo(toPosition, _setDefaults({\n      startAt: {\n        time: _parsePosition(this, fromPosition)\n      }\n    }, vars));\n  };\n  _proto2.recent = function recent() {\n    return this._recent;\n  };\n  _proto2.nextLabel = function nextLabel(afterTime) {\n    if (afterTime === void 0) {\n      afterTime = this._time;\n    }\n    return _getLabelInDirection(this, _parsePosition(this, afterTime));\n  };\n  _proto2.previousLabel = function previousLabel(beforeTime) {\n    if (beforeTime === void 0) {\n      beforeTime = this._time;\n    }\n    return _getLabelInDirection(this, _parsePosition(this, beforeTime), 1);\n  };\n  _proto2.currentLabel = function currentLabel(value) {\n    return arguments.length ? this.seek(value, true) : this.previousLabel(this._time + _tinyNum);\n  };\n  _proto2.shiftChildren = function shiftChildren(amount, adjustLabels, ignoreBeforeTime) {\n    if (ignoreBeforeTime === void 0) {\n      ignoreBeforeTime = 0;\n    }\n    var child = this._first, labels = this.labels, p;\n    while (child) {\n      if (child._start >= ignoreBeforeTime) {\n        child._start += amount;\n        child._end += amount;\n      }\n      child = child._next;\n    }\n    if (adjustLabels) {\n      for (p in labels) {\n        if (labels[p] >= ignoreBeforeTime) {\n          labels[p] += amount;\n        }\n      }\n    }\n    return _uncache(this);\n  };\n  _proto2.invalidate = function invalidate(soft) {\n    var child = this._first;\n    this._lock = 0;\n    while (child) {\n      child.invalidate(soft);\n      child = child._next;\n    }\n    return _Animation.prototype.invalidate.call(this, soft);\n  };\n  _proto2.clear = function clear(includeLabels) {\n    if (includeLabels === void 0) {\n      includeLabels = true;\n    }\n    var child = this._first, next;\n    while (child) {\n      next = child._next;\n      this.remove(child);\n      child = next;\n    }\n    this._dp && (this._time = this._tTime = this._pTime = 0);\n    includeLabels && (this.labels = {});\n    return _uncache(this);\n  };\n  _proto2.totalDuration = function totalDuration(value) {\n    var max = 0, self = this, child = self._last, prevStart = _bigNum, prev, start, parent;\n    if (arguments.length) {\n      return self.timeScale((self._repeat < 0 ? self.duration() : self.totalDuration()) / (self.reversed() ? -value : value));\n    }\n    if (self._dirty) {\n      parent = self.parent;\n      while (child) {\n        prev = child._prev;\n        child._dirty && child.totalDuration();\n        start = child._start;\n        if (start > prevStart && self._sort && child._ts && !self._lock) {\n          self._lock = 1;\n          _addToTimeline(self, child, start - child._delay, 1)._lock = 0;\n        } else {\n          prevStart = start;\n        }\n        if (start < 0 && child._ts) {\n          max -= start;\n          if (!parent && !self._dp || parent && parent.smoothChildTiming) {\n            self._start += start / self._ts;\n            self._time -= start;\n            self._tTime -= start;\n          }\n          self.shiftChildren(-start, false, -Infinity);\n          prevStart = 0;\n        }\n        child._end > max && child._ts && (max = child._end);\n        child = prev;\n      }\n      _setDuration(self, self === _globalTimeline && self._time > max ? self._time : max, 1, 1);\n      self._dirty = 0;\n    }\n    return self._tDur;\n  };\n  Timeline2.updateRoot = function updateRoot(time) {\n    if (_globalTimeline._ts) {\n      _lazySafeRender(_globalTimeline, _parentToChildTotalTime(time, _globalTimeline));\n      _lastRenderedFrame = _ticker.frame;\n    }\n    if (_ticker.frame >= _nextGCFrame) {\n      _nextGCFrame += _config.autoSleep || 120;\n      var child = _globalTimeline._first;\n      if (!child || !child._ts) {\n        if (_config.autoSleep && _ticker._listeners.length < 2) {\n          while (child && !child._ts) {\n            child = child._next;\n          }\n          child || _ticker.sleep();\n        }\n      }\n    }\n  };\n  return Timeline2;\n}(Animation);\n_setDefaults(Timeline.prototype, {\n  _lock: 0,\n  _hasPause: 0,\n  _forcing: 0\n});\nvar _addComplexStringPropTween = function _addComplexStringPropTween2(target, prop, start, end, setter, stringFilter, funcParam) {\n  var pt = new PropTween(this._pt, target, prop, 0, 1, _renderComplexString, null, setter), index = 0, matchIndex = 0, result, startNums, color, endNum, chunk, startNum, hasRandom, a;\n  pt.b = start;\n  pt.e = end;\n  start += \"\";\n  end += \"\";\n  if (hasRandom = ~end.indexOf(\"random(\")) {\n    end = _replaceRandom(end);\n  }\n  if (stringFilter) {\n    a = [start, end];\n    stringFilter(a, target, prop);\n    start = a[0];\n    end = a[1];\n  }\n  startNums = start.match(_complexStringNumExp) || [];\n  while (result = _complexStringNumExp.exec(end)) {\n    endNum = result[0];\n    chunk = end.substring(index, result.index);\n    if (color) {\n      color = (color + 1) % 5;\n    } else if (chunk.substr(-5) === \"rgba(\") {\n      color = 1;\n    }\n    if (endNum !== startNums[matchIndex++]) {\n      startNum = parseFloat(startNums[matchIndex - 1]) || 0;\n      pt._pt = {\n        _next: pt._pt,\n        p: chunk || matchIndex === 1 ? chunk : \",\",\n        //note: SVG spec allows omission of comma/space when a negative sign is wedged between two numbers, like 2.5-5.3 instead of 2.5,-5.3 but when tweening, the negative value may switch to positive, so we insert the comma just in case.\n        s: startNum,\n        c: endNum.charAt(1) === \"=\" ? _parseRelative(startNum, endNum) - startNum : parseFloat(endNum) - startNum,\n        m: color && color < 4 ? Math.round : 0\n      };\n      index = _complexStringNumExp.lastIndex;\n    }\n  }\n  pt.c = index < end.length ? end.substring(index, end.length) : \"\";\n  pt.fp = funcParam;\n  if (_relExp.test(end) || hasRandom) {\n    pt.e = 0;\n  }\n  this._pt = pt;\n  return pt;\n};\nvar _addPropTween = function _addPropTween2(target, prop, start, end, index, targets, modifier, stringFilter, funcParam, optional) {\n  _isFunction(end) && (end = end(index || 0, target, targets));\n  var currentValue = target[prop], parsedStart = start !== \"get\" ? start : !_isFunction(currentValue) ? currentValue : funcParam ? target[prop.indexOf(\"set\") || !_isFunction(target[\"get\" + prop.substr(3)]) ? prop : \"get\" + prop.substr(3)](funcParam) : target[prop](), setter = !_isFunction(currentValue) ? _setterPlain : funcParam ? _setterFuncWithParam : _setterFunc, pt;\n  if (_isString(end)) {\n    if (~end.indexOf(\"random(\")) {\n      end = _replaceRandom(end);\n    }\n    if (end.charAt(1) === \"=\") {\n      pt = _parseRelative(parsedStart, end) + (getUnit(parsedStart) || 0);\n      if (pt || pt === 0) {\n        end = pt;\n      }\n    }\n  }\n  if (!optional || parsedStart !== end || _forceAllPropTweens) {\n    if (!isNaN(parsedStart * end) && end !== \"\") {\n      pt = new PropTween(this._pt, target, prop, +parsedStart || 0, end - (parsedStart || 0), typeof currentValue === \"boolean\" ? _renderBoolean : _renderPlain, 0, setter);\n      funcParam && (pt.fp = funcParam);\n      modifier && pt.modifier(modifier, this, target);\n      return this._pt = pt;\n    }\n    !currentValue && !(prop in target) && _missingPlugin(prop, end);\n    return _addComplexStringPropTween.call(this, target, prop, parsedStart, end, setter, stringFilter || _config.stringFilter, funcParam);\n  }\n};\nvar _processVars = function _processVars2(vars, index, target, targets, tween) {\n  _isFunction(vars) && (vars = _parseFuncOrString(vars, tween, index, target, targets));\n  if (!_isObject(vars) || vars.style && vars.nodeType || _isArray(vars) || _isTypedArray(vars)) {\n    return _isString(vars) ? _parseFuncOrString(vars, tween, index, target, targets) : vars;\n  }\n  var copy = {}, p;\n  for (p in vars) {\n    copy[p] = _parseFuncOrString(vars[p], tween, index, target, targets);\n  }\n  return copy;\n};\nvar _checkPlugin = function _checkPlugin2(property, vars, tween, index, target, targets) {\n  var plugin, pt, ptLookup, i;\n  if (_plugins[property] && (plugin = new _plugins[property]()).init(target, plugin.rawVars ? vars[property] : _processVars(vars[property], index, target, targets, tween), tween, index, targets) !== false) {\n    tween._pt = pt = new PropTween(tween._pt, target, property, 0, 1, plugin.render, plugin, 0, plugin.priority);\n    if (tween !== _quickTween) {\n      ptLookup = tween._ptLookup[tween._targets.indexOf(target)];\n      i = plugin._props.length;\n      while (i--) {\n        ptLookup[plugin._props[i]] = pt;\n      }\n    }\n  }\n  return plugin;\n};\nvar _overwritingTween;\nvar _forceAllPropTweens;\nvar _initTween = function _initTween2(tween, time, tTime) {\n  var vars = tween.vars, ease = vars.ease, startAt = vars.startAt, immediateRender = vars.immediateRender, lazy = vars.lazy, onUpdate = vars.onUpdate, runBackwards = vars.runBackwards, yoyoEase = vars.yoyoEase, keyframes = vars.keyframes, autoRevert = vars.autoRevert, dur = tween._dur, prevStartAt = tween._startAt, targets = tween._targets, parent = tween.parent, fullTargets = parent && parent.data === \"nested\" ? parent.vars.targets : targets, autoOverwrite = tween._overwrite === \"auto\" && !_suppressOverwrites, tl = tween.timeline, cleanVars, i, p, pt, target, hasPriority, gsData, harness, plugin, ptLookup, index, harnessVars, overwritten;\n  tl && (!keyframes || !ease) && (ease = \"none\");\n  tween._ease = _parseEase(ease, _defaults.ease);\n  tween._yEase = yoyoEase ? _invertEase(_parseEase(yoyoEase === true ? ease : yoyoEase, _defaults.ease)) : 0;\n  if (yoyoEase && tween._yoyo && !tween._repeat) {\n    yoyoEase = tween._yEase;\n    tween._yEase = tween._ease;\n    tween._ease = yoyoEase;\n  }\n  tween._from = !tl && !!vars.runBackwards;\n  if (!tl || keyframes && !vars.stagger) {\n    harness = targets[0] ? _getCache(targets[0]).harness : 0;\n    harnessVars = harness && vars[harness.prop];\n    cleanVars = _copyExcluding(vars, _reservedProps);\n    if (prevStartAt) {\n      prevStartAt._zTime < 0 && prevStartAt.progress(1);\n      time < 0 && runBackwards && immediateRender && !autoRevert ? prevStartAt.render(-1, true) : prevStartAt.revert(runBackwards && dur ? _revertConfigNoKill : _startAtRevertConfig);\n      prevStartAt._lazy = 0;\n    }\n    if (startAt) {\n      _removeFromParent(tween._startAt = Tween.set(targets, _setDefaults({\n        data: \"isStart\",\n        overwrite: false,\n        parent,\n        immediateRender: true,\n        lazy: !prevStartAt && _isNotFalse(lazy),\n        startAt: null,\n        delay: 0,\n        onUpdate: onUpdate && function() {\n          return _callback(tween, \"onUpdate\");\n        },\n        stagger: 0\n      }, startAt)));\n      tween._startAt._dp = 0;\n      tween._startAt._sat = tween;\n      time < 0 && (_reverting || !immediateRender && !autoRevert) && tween._startAt.revert(_revertConfigNoKill);\n      if (immediateRender) {\n        if (dur && time <= 0 && tTime <= 0) {\n          time && (tween._zTime = time);\n          return;\n        }\n      }\n    } else if (runBackwards && dur) {\n      if (!prevStartAt) {\n        time && (immediateRender = false);\n        p = _setDefaults({\n          overwrite: false,\n          data: \"isFromStart\",\n          //we tag the tween with as \"isFromStart\" so that if [inside a plugin] we need to only do something at the very END of a tween, we have a way of identifying this tween as merely the one that's setting the beginning values for a \"from()\" tween. For example, clearProps in CSSPlugin should only get applied at the very END of a tween and without this tag, from(...{height:100, clearProps:\"height\", delay:1}) would wipe the height at the beginning of the tween and after 1 second, it'd kick back in.\n          lazy: immediateRender && !prevStartAt && _isNotFalse(lazy),\n          immediateRender,\n          //zero-duration tweens render immediately by default, but if we're not specifically instructed to render this tween immediately, we should skip this and merely _init() to record the starting values (rendering them immediately would push them to completion which is wasteful in that case - we'd have to render(-1) immediately after)\n          stagger: 0,\n          parent\n          //ensures that nested tweens that had a stagger are handled properly, like gsap.from(\".class\", {y: gsap.utils.wrap([-100,100]), stagger: 0.5})\n        }, cleanVars);\n        harnessVars && (p[harness.prop] = harnessVars);\n        _removeFromParent(tween._startAt = Tween.set(targets, p));\n        tween._startAt._dp = 0;\n        tween._startAt._sat = tween;\n        time < 0 && (_reverting ? tween._startAt.revert(_revertConfigNoKill) : tween._startAt.render(-1, true));\n        tween._zTime = time;\n        if (!immediateRender) {\n          _initTween2(tween._startAt, _tinyNum, _tinyNum);\n        } else if (!time) {\n          return;\n        }\n      }\n    }\n    tween._pt = tween._ptCache = 0;\n    lazy = dur && _isNotFalse(lazy) || lazy && !dur;\n    for (i = 0; i < targets.length; i++) {\n      target = targets[i];\n      gsData = target._gsap || _harness(targets)[i]._gsap;\n      tween._ptLookup[i] = ptLookup = {};\n      _lazyLookup[gsData.id] && _lazyTweens.length && _lazyRender();\n      index = fullTargets === targets ? i : fullTargets.indexOf(target);\n      if (harness && (plugin = new harness()).init(target, harnessVars || cleanVars, tween, index, fullTargets) !== false) {\n        tween._pt = pt = new PropTween(tween._pt, target, plugin.name, 0, 1, plugin.render, plugin, 0, plugin.priority);\n        plugin._props.forEach(function(name) {\n          ptLookup[name] = pt;\n        });\n        plugin.priority && (hasPriority = 1);\n      }\n      if (!harness || harnessVars) {\n        for (p in cleanVars) {\n          if (_plugins[p] && (plugin = _checkPlugin(p, cleanVars, tween, index, target, fullTargets))) {\n            plugin.priority && (hasPriority = 1);\n          } else {\n            ptLookup[p] = pt = _addPropTween.call(tween, target, p, \"get\", cleanVars[p], index, fullTargets, 0, vars.stringFilter);\n          }\n        }\n      }\n      tween._op && tween._op[i] && tween.kill(target, tween._op[i]);\n      if (autoOverwrite && tween._pt) {\n        _overwritingTween = tween;\n        _globalTimeline.killTweensOf(target, ptLookup, tween.globalTime(time));\n        overwritten = !tween.parent;\n        _overwritingTween = 0;\n      }\n      tween._pt && lazy && (_lazyLookup[gsData.id] = 1);\n    }\n    hasPriority && _sortPropTweensByPriority(tween);\n    tween._onInit && tween._onInit(tween);\n  }\n  tween._onUpdate = onUpdate;\n  tween._initted = (!tween._op || tween._pt) && !overwritten;\n  keyframes && time <= 0 && tl.render(_bigNum, true, true);\n};\nvar _updatePropTweens = function _updatePropTweens2(tween, property, value, start, startIsRelative, ratio, time, skipRecursion) {\n  var ptCache = (tween._pt && tween._ptCache || (tween._ptCache = {}))[property], pt, rootPT, lookup, i;\n  if (!ptCache) {\n    ptCache = tween._ptCache[property] = [];\n    lookup = tween._ptLookup;\n    i = tween._targets.length;\n    while (i--) {\n      pt = lookup[i][property];\n      if (pt && pt.d && pt.d._pt) {\n        pt = pt.d._pt;\n        while (pt && pt.p !== property && pt.fp !== property) {\n          pt = pt._next;\n        }\n      }\n      if (!pt) {\n        _forceAllPropTweens = 1;\n        tween.vars[property] = \"+=0\";\n        _initTween(tween, time);\n        _forceAllPropTweens = 0;\n        return skipRecursion ? _warn(property + \" not eligible for reset\") : 1;\n      }\n      ptCache.push(pt);\n    }\n  }\n  i = ptCache.length;\n  while (i--) {\n    rootPT = ptCache[i];\n    pt = rootPT._pt || rootPT;\n    pt.s = (start || start === 0) && !startIsRelative ? start : pt.s + (start || 0) + ratio * pt.c;\n    pt.c = value - pt.s;\n    rootPT.e && (rootPT.e = _round(value) + getUnit(rootPT.e));\n    rootPT.b && (rootPT.b = pt.s + getUnit(rootPT.b));\n  }\n};\nvar _addAliasesToVars = function _addAliasesToVars2(targets, vars) {\n  var harness = targets[0] ? _getCache(targets[0]).harness : 0, propertyAliases = harness && harness.aliases, copy, p, i, aliases;\n  if (!propertyAliases) {\n    return vars;\n  }\n  copy = _merge({}, vars);\n  for (p in propertyAliases) {\n    if (p in copy) {\n      aliases = propertyAliases[p].split(\",\");\n      i = aliases.length;\n      while (i--) {\n        copy[aliases[i]] = copy[p];\n      }\n    }\n  }\n  return copy;\n};\nvar _parseKeyframe = function _parseKeyframe2(prop, obj, allProps, easeEach) {\n  var ease = obj.ease || easeEach || \"power1.inOut\", p, a;\n  if (_isArray(obj)) {\n    a = allProps[prop] || (allProps[prop] = []);\n    obj.forEach(function(value, i) {\n      return a.push({\n        t: i / (obj.length - 1) * 100,\n        v: value,\n        e: ease\n      });\n    });\n  } else {\n    for (p in obj) {\n      a = allProps[p] || (allProps[p] = []);\n      p === \"ease\" || a.push({\n        t: parseFloat(prop),\n        v: obj[p],\n        e: ease\n      });\n    }\n  }\n};\nvar _parseFuncOrString = function _parseFuncOrString2(value, tween, i, target, targets) {\n  return _isFunction(value) ? value.call(tween, i, target, targets) : _isString(value) && ~value.indexOf(\"random(\") ? _replaceRandom(value) : value;\n};\nvar _staggerTweenProps = _callbackNames + \"repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert\";\nvar _staggerPropsToSkip = {};\n_forEachName(_staggerTweenProps + \",id,stagger,delay,duration,paused,scrollTrigger\", function(name) {\n  return _staggerPropsToSkip[name] = 1;\n});\nvar Tween = function(_Animation2) {\n  _inheritsLoose(Tween2, _Animation2);\n  function Tween2(targets, vars, position, skipInherit) {\n    var _this3;\n    if (typeof vars === \"number\") {\n      position.duration = vars;\n      vars = position;\n      position = null;\n    }\n    _this3 = _Animation2.call(this, skipInherit ? vars : _inheritDefaults(vars)) || this;\n    var _this3$vars = _this3.vars, duration = _this3$vars.duration, delay = _this3$vars.delay, immediateRender = _this3$vars.immediateRender, stagger = _this3$vars.stagger, overwrite = _this3$vars.overwrite, keyframes = _this3$vars.keyframes, defaults2 = _this3$vars.defaults, scrollTrigger = _this3$vars.scrollTrigger, yoyoEase = _this3$vars.yoyoEase, parent = vars.parent || _globalTimeline, parsedTargets = (_isArray(targets) || _isTypedArray(targets) ? _isNumber(targets[0]) : \"length\" in vars) ? [targets] : toArray(targets), tl, i, copy, l, p, curTarget, staggerFunc, staggerVarsToMerge;\n    _this3._targets = parsedTargets.length ? _harness(parsedTargets) : _warn(\"GSAP target \" + targets + \" not found. https://gsap.com\", !_config.nullTargetWarn) || [];\n    _this3._ptLookup = [];\n    _this3._overwrite = overwrite;\n    if (keyframes || stagger || _isFuncOrString(duration) || _isFuncOrString(delay)) {\n      vars = _this3.vars;\n      tl = _this3.timeline = new Timeline({\n        data: \"nested\",\n        defaults: defaults2 || {},\n        targets: parent && parent.data === \"nested\" ? parent.vars.targets : parsedTargets\n      });\n      tl.kill();\n      tl.parent = tl._dp = _assertThisInitialized(_this3);\n      tl._start = 0;\n      if (stagger || _isFuncOrString(duration) || _isFuncOrString(delay)) {\n        l = parsedTargets.length;\n        staggerFunc = stagger && distribute(stagger);\n        if (_isObject(stagger)) {\n          for (p in stagger) {\n            if (~_staggerTweenProps.indexOf(p)) {\n              staggerVarsToMerge || (staggerVarsToMerge = {});\n              staggerVarsToMerge[p] = stagger[p];\n            }\n          }\n        }\n        for (i = 0; i < l; i++) {\n          copy = _copyExcluding(vars, _staggerPropsToSkip);\n          copy.stagger = 0;\n          yoyoEase && (copy.yoyoEase = yoyoEase);\n          staggerVarsToMerge && _merge(copy, staggerVarsToMerge);\n          curTarget = parsedTargets[i];\n          copy.duration = +_parseFuncOrString(duration, _assertThisInitialized(_this3), i, curTarget, parsedTargets);\n          copy.delay = (+_parseFuncOrString(delay, _assertThisInitialized(_this3), i, curTarget, parsedTargets) || 0) - _this3._delay;\n          if (!stagger && l === 1 && copy.delay) {\n            _this3._delay = delay = copy.delay;\n            _this3._start += delay;\n            copy.delay = 0;\n          }\n          tl.to(curTarget, copy, staggerFunc ? staggerFunc(i, curTarget, parsedTargets) : 0);\n          tl._ease = _easeMap.none;\n        }\n        tl.duration() ? duration = delay = 0 : _this3.timeline = 0;\n      } else if (keyframes) {\n        _inheritDefaults(_setDefaults(tl.vars.defaults, {\n          ease: \"none\"\n        }));\n        tl._ease = _parseEase(keyframes.ease || vars.ease || \"none\");\n        var time = 0, a, kf, v;\n        if (_isArray(keyframes)) {\n          keyframes.forEach(function(frame) {\n            return tl.to(parsedTargets, frame, \">\");\n          });\n          tl.duration();\n        } else {\n          copy = {};\n          for (p in keyframes) {\n            p === \"ease\" || p === \"easeEach\" || _parseKeyframe(p, keyframes[p], copy, keyframes.easeEach);\n          }\n          for (p in copy) {\n            a = copy[p].sort(function(a2, b) {\n              return a2.t - b.t;\n            });\n            time = 0;\n            for (i = 0; i < a.length; i++) {\n              kf = a[i];\n              v = {\n                ease: kf.e,\n                duration: (kf.t - (i ? a[i - 1].t : 0)) / 100 * duration\n              };\n              v[p] = kf.v;\n              tl.to(parsedTargets, v, time);\n              time += v.duration;\n            }\n          }\n          tl.duration() < duration && tl.to({}, {\n            duration: duration - tl.duration()\n          });\n        }\n      }\n      duration || _this3.duration(duration = tl.duration());\n    } else {\n      _this3.timeline = 0;\n    }\n    if (overwrite === true && !_suppressOverwrites) {\n      _overwritingTween = _assertThisInitialized(_this3);\n      _globalTimeline.killTweensOf(parsedTargets);\n      _overwritingTween = 0;\n    }\n    _addToTimeline(parent, _assertThisInitialized(_this3), position);\n    vars.reversed && _this3.reverse();\n    vars.paused && _this3.paused(true);\n    if (immediateRender || !duration && !keyframes && _this3._start === _roundPrecise(parent._time) && _isNotFalse(immediateRender) && _hasNoPausedAncestors(_assertThisInitialized(_this3)) && parent.data !== \"nested\") {\n      _this3._tTime = -_tinyNum;\n      _this3.render(Math.max(0, -delay) || 0);\n    }\n    scrollTrigger && _scrollTrigger(_assertThisInitialized(_this3), scrollTrigger);\n    return _this3;\n  }\n  var _proto3 = Tween2.prototype;\n  _proto3.render = function render3(totalTime, suppressEvents, force) {\n    var prevTime = this._time, tDur = this._tDur, dur = this._dur, isNegative = totalTime < 0, tTime = totalTime > tDur - _tinyNum && !isNegative ? tDur : totalTime < _tinyNum ? 0 : totalTime, time, pt, iteration, cycleDuration, prevIteration, isYoyo, ratio, timeline2, yoyoEase;\n    if (!dur) {\n      _renderZeroDurationTween(this, totalTime, suppressEvents, force);\n    } else if (tTime !== this._tTime || !totalTime || force || !this._initted && this._tTime || this._startAt && this._zTime < 0 !== isNegative) {\n      time = tTime;\n      timeline2 = this.timeline;\n      if (this._repeat) {\n        cycleDuration = dur + this._rDelay;\n        if (this._repeat < -1 && isNegative) {\n          return this.totalTime(cycleDuration * 100 + totalTime, suppressEvents, force);\n        }\n        time = _roundPrecise(tTime % cycleDuration);\n        if (tTime === tDur) {\n          iteration = this._repeat;\n          time = dur;\n        } else {\n          iteration = ~~(tTime / cycleDuration);\n          if (iteration && iteration === _roundPrecise(tTime / cycleDuration)) {\n            time = dur;\n            iteration--;\n          }\n          time > dur && (time = dur);\n        }\n        isYoyo = this._yoyo && iteration & 1;\n        if (isYoyo) {\n          yoyoEase = this._yEase;\n          time = dur - time;\n        }\n        prevIteration = _animationCycle(this._tTime, cycleDuration);\n        if (time === prevTime && !force && this._initted && iteration === prevIteration) {\n          this._tTime = tTime;\n          return this;\n        }\n        if (iteration !== prevIteration) {\n          timeline2 && this._yEase && _propagateYoyoEase(timeline2, isYoyo);\n          if (this.vars.repeatRefresh && !isYoyo && !this._lock && this._time !== cycleDuration && this._initted) {\n            this._lock = force = 1;\n            this.render(_roundPrecise(cycleDuration * iteration), true).invalidate()._lock = 0;\n          }\n        }\n      }\n      if (!this._initted) {\n        if (_attemptInitTween(this, isNegative ? totalTime : time, force, suppressEvents, tTime)) {\n          this._tTime = 0;\n          return this;\n        }\n        if (prevTime !== this._time && !(force && this.vars.repeatRefresh && iteration !== prevIteration)) {\n          return this;\n        }\n        if (dur !== this._dur) {\n          return this.render(totalTime, suppressEvents, force);\n        }\n      }\n      this._tTime = tTime;\n      this._time = time;\n      if (!this._act && this._ts) {\n        this._act = 1;\n        this._lazy = 0;\n      }\n      this.ratio = ratio = (yoyoEase || this._ease)(time / dur);\n      if (this._from) {\n        this.ratio = ratio = 1 - ratio;\n      }\n      if (time && !prevTime && !suppressEvents && !iteration) {\n        _callback(this, \"onStart\");\n        if (this._tTime !== tTime) {\n          return this;\n        }\n      }\n      pt = this._pt;\n      while (pt) {\n        pt.r(ratio, pt.d);\n        pt = pt._next;\n      }\n      timeline2 && timeline2.render(totalTime < 0 ? totalTime : timeline2._dur * timeline2._ease(time / this._dur), suppressEvents, force) || this._startAt && (this._zTime = totalTime);\n      if (this._onUpdate && !suppressEvents) {\n        isNegative && _rewindStartAt(this, totalTime, suppressEvents, force);\n        _callback(this, \"onUpdate\");\n      }\n      this._repeat && iteration !== prevIteration && this.vars.onRepeat && !suppressEvents && this.parent && _callback(this, \"onRepeat\");\n      if ((tTime === this._tDur || !tTime) && this._tTime === tTime) {\n        isNegative && !this._onUpdate && _rewindStartAt(this, totalTime, true, true);\n        (totalTime || !dur) && (tTime === this._tDur && this._ts > 0 || !tTime && this._ts < 0) && _removeFromParent(this, 1);\n        if (!suppressEvents && !(isNegative && !prevTime) && (tTime || prevTime || isYoyo)) {\n          _callback(this, tTime === tDur ? \"onComplete\" : \"onReverseComplete\", true);\n          this._prom && !(tTime < tDur && this.timeScale() > 0) && this._prom();\n        }\n      }\n    }\n    return this;\n  };\n  _proto3.targets = function targets() {\n    return this._targets;\n  };\n  _proto3.invalidate = function invalidate(soft) {\n    (!soft || !this.vars.runBackwards) && (this._startAt = 0);\n    this._pt = this._op = this._onUpdate = this._lazy = this.ratio = 0;\n    this._ptLookup = [];\n    this.timeline && this.timeline.invalidate(soft);\n    return _Animation2.prototype.invalidate.call(this, soft);\n  };\n  _proto3.resetTo = function resetTo(property, value, start, startIsRelative, skipRecursion) {\n    _tickerActive || _ticker.wake();\n    this._ts || this.play();\n    var time = Math.min(this._dur, (this._dp._time - this._start) * this._ts), ratio;\n    this._initted || _initTween(this, time);\n    ratio = this._ease(time / this._dur);\n    if (_updatePropTweens(this, property, value, start, startIsRelative, ratio, time, skipRecursion)) {\n      return this.resetTo(property, value, start, startIsRelative, 1);\n    }\n    _alignPlayhead(this, 0);\n    this.parent || _addLinkedListItem(this._dp, this, \"_first\", \"_last\", this._dp._sort ? \"_start\" : 0);\n    return this.render(0);\n  };\n  _proto3.kill = function kill(targets, vars) {\n    if (vars === void 0) {\n      vars = \"all\";\n    }\n    if (!targets && (!vars || vars === \"all\")) {\n      this._lazy = this._pt = 0;\n      return this.parent ? _interrupt(this) : this;\n    }\n    if (this.timeline) {\n      var tDur = this.timeline.totalDuration();\n      this.timeline.killTweensOf(targets, vars, _overwritingTween && _overwritingTween.vars.overwrite !== true)._first || _interrupt(this);\n      this.parent && tDur !== this.timeline.totalDuration() && _setDuration(this, this._dur * this.timeline._tDur / tDur, 0, 1);\n      return this;\n    }\n    var parsedTargets = this._targets, killingTargets = targets ? toArray(targets) : parsedTargets, propTweenLookup = this._ptLookup, firstPT = this._pt, overwrittenProps, curLookup, curOverwriteProps, props, p, pt, i;\n    if ((!vars || vars === \"all\") && _arraysMatch(parsedTargets, killingTargets)) {\n      vars === \"all\" && (this._pt = 0);\n      return _interrupt(this);\n    }\n    overwrittenProps = this._op = this._op || [];\n    if (vars !== \"all\") {\n      if (_isString(vars)) {\n        p = {};\n        _forEachName(vars, function(name) {\n          return p[name] = 1;\n        });\n        vars = p;\n      }\n      vars = _addAliasesToVars(parsedTargets, vars);\n    }\n    i = parsedTargets.length;\n    while (i--) {\n      if (~killingTargets.indexOf(parsedTargets[i])) {\n        curLookup = propTweenLookup[i];\n        if (vars === \"all\") {\n          overwrittenProps[i] = vars;\n          props = curLookup;\n          curOverwriteProps = {};\n        } else {\n          curOverwriteProps = overwrittenProps[i] = overwrittenProps[i] || {};\n          props = vars;\n        }\n        for (p in props) {\n          pt = curLookup && curLookup[p];\n          if (pt) {\n            if (!(\"kill\" in pt.d) || pt.d.kill(p) === true) {\n              _removeLinkedListItem(this, pt, \"_pt\");\n            }\n            delete curLookup[p];\n          }\n          if (curOverwriteProps !== \"all\") {\n            curOverwriteProps[p] = 1;\n          }\n        }\n      }\n    }\n    this._initted && !this._pt && firstPT && _interrupt(this);\n    return this;\n  };\n  Tween2.to = function to(targets, vars) {\n    return new Tween2(targets, vars, arguments[2]);\n  };\n  Tween2.from = function from(targets, vars) {\n    return _createTweenType(1, arguments);\n  };\n  Tween2.delayedCall = function delayedCall(delay, callback, params, scope) {\n    return new Tween2(callback, 0, {\n      immediateRender: false,\n      lazy: false,\n      overwrite: false,\n      delay,\n      onComplete: callback,\n      onReverseComplete: callback,\n      onCompleteParams: params,\n      onReverseCompleteParams: params,\n      callbackScope: scope\n    });\n  };\n  Tween2.fromTo = function fromTo(targets, fromVars, toVars) {\n    return _createTweenType(2, arguments);\n  };\n  Tween2.set = function set(targets, vars) {\n    vars.duration = 0;\n    vars.repeatDelay || (vars.repeat = 0);\n    return new Tween2(targets, vars);\n  };\n  Tween2.killTweensOf = function killTweensOf(targets, props, onlyActive) {\n    return _globalTimeline.killTweensOf(targets, props, onlyActive);\n  };\n  return Tween2;\n}(Animation);\n_setDefaults(Tween.prototype, {\n  _targets: [],\n  _lazy: 0,\n  _startAt: 0,\n  _op: 0,\n  _onInit: 0\n});\n_forEachName(\"staggerTo,staggerFrom,staggerFromTo\", function(name) {\n  Tween[name] = function() {\n    var tl = new Timeline(), params = _slice.call(arguments, 0);\n    params.splice(name === \"staggerFromTo\" ? 5 : 4, 0, 0);\n    return tl[name].apply(tl, params);\n  };\n});\nvar _setterPlain = function _setterPlain2(target, property, value) {\n  return target[property] = value;\n};\nvar _setterFunc = function _setterFunc2(target, property, value) {\n  return target[property](value);\n};\nvar _setterFuncWithParam = function _setterFuncWithParam2(target, property, value, data) {\n  return target[property](data.fp, value);\n};\nvar _setterAttribute = function _setterAttribute2(target, property, value) {\n  return target.setAttribute(property, value);\n};\nvar _getSetter = function _getSetter2(target, property) {\n  return _isFunction(target[property]) ? _setterFunc : _isUndefined(target[property]) && target.setAttribute ? _setterAttribute : _setterPlain;\n};\nvar _renderPlain = function _renderPlain2(ratio, data) {\n  return data.set(data.t, data.p, Math.round((data.s + data.c * ratio) * 1e6) / 1e6, data);\n};\nvar _renderBoolean = function _renderBoolean2(ratio, data) {\n  return data.set(data.t, data.p, !!(data.s + data.c * ratio), data);\n};\nvar _renderComplexString = function _renderComplexString2(ratio, data) {\n  var pt = data._pt, s = \"\";\n  if (!ratio && data.b) {\n    s = data.b;\n  } else if (ratio === 1 && data.e) {\n    s = data.e;\n  } else {\n    while (pt) {\n      s = pt.p + (pt.m ? pt.m(pt.s + pt.c * ratio) : Math.round((pt.s + pt.c * ratio) * 1e4) / 1e4) + s;\n      pt = pt._next;\n    }\n    s += data.c;\n  }\n  data.set(data.t, data.p, s, data);\n};\nvar _renderPropTweens = function _renderPropTweens2(ratio, data) {\n  var pt = data._pt;\n  while (pt) {\n    pt.r(ratio, pt.d);\n    pt = pt._next;\n  }\n};\nvar _addPluginModifier = function _addPluginModifier2(modifier, tween, target, property) {\n  var pt = this._pt, next;\n  while (pt) {\n    next = pt._next;\n    pt.p === property && pt.modifier(modifier, tween, target);\n    pt = next;\n  }\n};\nvar _killPropTweensOf = function _killPropTweensOf2(property) {\n  var pt = this._pt, hasNonDependentRemaining, next;\n  while (pt) {\n    next = pt._next;\n    if (pt.p === property && !pt.op || pt.op === property) {\n      _removeLinkedListItem(this, pt, \"_pt\");\n    } else if (!pt.dep) {\n      hasNonDependentRemaining = 1;\n    }\n    pt = next;\n  }\n  return !hasNonDependentRemaining;\n};\nvar _setterWithModifier = function _setterWithModifier2(target, property, value, data) {\n  data.mSet(target, property, data.m.call(data.tween, value, data.mt), data);\n};\nvar _sortPropTweensByPriority = function _sortPropTweensByPriority2(parent) {\n  var pt = parent._pt, next, pt2, first, last;\n  while (pt) {\n    next = pt._next;\n    pt2 = first;\n    while (pt2 && pt2.pr > pt.pr) {\n      pt2 = pt2._next;\n    }\n    if (pt._prev = pt2 ? pt2._prev : last) {\n      pt._prev._next = pt;\n    } else {\n      first = pt;\n    }\n    if (pt._next = pt2) {\n      pt2._prev = pt;\n    } else {\n      last = pt;\n    }\n    pt = next;\n  }\n  parent._pt = first;\n};\nvar PropTween = function() {\n  function PropTween2(next, target, prop, start, change, renderer, data, setter, priority) {\n    this.t = target;\n    this.s = start;\n    this.c = change;\n    this.p = prop;\n    this.r = renderer || _renderPlain;\n    this.d = data || this;\n    this.set = setter || _setterPlain;\n    this.pr = priority || 0;\n    this._next = next;\n    if (next) {\n      next._prev = this;\n    }\n  }\n  var _proto4 = PropTween2.prototype;\n  _proto4.modifier = function modifier(func, tween, target) {\n    this.mSet = this.mSet || this.set;\n    this.set = _setterWithModifier;\n    this.m = func;\n    this.mt = target;\n    this.tween = tween;\n  };\n  return PropTween2;\n}();\n_forEachName(_callbackNames + \"parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger\", function(name) {\n  return _reservedProps[name] = 1;\n});\n_globals.TweenMax = _globals.TweenLite = Tween;\n_globals.TimelineLite = _globals.TimelineMax = Timeline;\n_globalTimeline = new Timeline({\n  sortChildren: false,\n  defaults: _defaults,\n  autoRemoveChildren: true,\n  id: \"root\",\n  smoothChildTiming: true\n});\n_config.stringFilter = _colorStringFilter;\nvar _media = [];\nvar _listeners = {};\nvar _emptyArray = [];\nvar _lastMediaTime = 0;\nvar _contextID = 0;\nvar _dispatch = function _dispatch2(type) {\n  return (_listeners[type] || _emptyArray).map(function(f) {\n    return f();\n  });\n};\nvar _onMediaChange = function _onMediaChange2() {\n  var time = Date.now(), matches = [];\n  if (time - _lastMediaTime > 2) {\n    _dispatch(\"matchMediaInit\");\n    _media.forEach(function(c) {\n      var queries = c.queries, conditions = c.conditions, match, p, anyMatch, toggled;\n      for (p in queries) {\n        match = _win.matchMedia(queries[p]).matches;\n        match && (anyMatch = 1);\n        if (match !== conditions[p]) {\n          conditions[p] = match;\n          toggled = 1;\n        }\n      }\n      if (toggled) {\n        c.revert();\n        anyMatch && matches.push(c);\n      }\n    });\n    _dispatch(\"matchMediaRevert\");\n    matches.forEach(function(c) {\n      return c.onMatch(c, function(func) {\n        return c.add(null, func);\n      });\n    });\n    _lastMediaTime = time;\n    _dispatch(\"matchMedia\");\n  }\n};\nvar Context = function() {\n  function Context2(func, scope) {\n    this.selector = scope && selector(scope);\n    this.data = [];\n    this._r = [];\n    this.isReverted = false;\n    this.id = _contextID++;\n    func && this.add(func);\n  }\n  var _proto5 = Context2.prototype;\n  _proto5.add = function add(name, func, scope) {\n    if (_isFunction(name)) {\n      scope = func;\n      func = name;\n      name = _isFunction;\n    }\n    var self = this, f = function f2() {\n      var prev = _context, prevSelector = self.selector, result;\n      prev && prev !== self && prev.data.push(self);\n      scope && (self.selector = selector(scope));\n      _context = self;\n      result = func.apply(self, arguments);\n      _isFunction(result) && self._r.push(result);\n      _context = prev;\n      self.selector = prevSelector;\n      self.isReverted = false;\n      return result;\n    };\n    self.last = f;\n    return name === _isFunction ? f(self, function(func2) {\n      return self.add(null, func2);\n    }) : name ? self[name] = f : f;\n  };\n  _proto5.ignore = function ignore(func) {\n    var prev = _context;\n    _context = null;\n    func(this);\n    _context = prev;\n  };\n  _proto5.getTweens = function getTweens() {\n    var a = [];\n    this.data.forEach(function(e) {\n      return e instanceof Context2 ? a.push.apply(a, e.getTweens()) : e instanceof Tween && !(e.parent && e.parent.data === \"nested\") && a.push(e);\n    });\n    return a;\n  };\n  _proto5.clear = function clear() {\n    this._r.length = this.data.length = 0;\n  };\n  _proto5.kill = function kill(revert, matchMedia2) {\n    var _this4 = this;\n    if (revert) {\n      (function() {\n        var tweens = _this4.getTweens(), i2 = _this4.data.length, t;\n        while (i2--) {\n          t = _this4.data[i2];\n          if (t.data === \"isFlip\") {\n            t.revert();\n            t.getChildren(true, true, false).forEach(function(tween) {\n              return tweens.splice(tweens.indexOf(tween), 1);\n            });\n          }\n        }\n        tweens.map(function(t2) {\n          return {\n            g: t2._dur || t2._delay || t2._sat && !t2._sat.vars.immediateRender ? t2.globalTime(0) : -Infinity,\n            t: t2\n          };\n        }).sort(function(a, b) {\n          return b.g - a.g || -Infinity;\n        }).forEach(function(o) {\n          return o.t.revert(revert);\n        });\n        i2 = _this4.data.length;\n        while (i2--) {\n          t = _this4.data[i2];\n          if (t instanceof Timeline) {\n            if (t.data !== \"nested\") {\n              t.scrollTrigger && t.scrollTrigger.revert();\n              t.kill();\n            }\n          } else {\n            !(t instanceof Tween) && t.revert && t.revert(revert);\n          }\n        }\n        _this4._r.forEach(function(f) {\n          return f(revert, _this4);\n        });\n        _this4.isReverted = true;\n      })();\n    } else {\n      this.data.forEach(function(e) {\n        return e.kill && e.kill();\n      });\n    }\n    this.clear();\n    if (matchMedia2) {\n      var i = _media.length;\n      while (i--) {\n        _media[i].id === this.id && _media.splice(i, 1);\n      }\n    }\n  };\n  _proto5.revert = function revert(config3) {\n    this.kill(config3 || {});\n  };\n  return Context2;\n}();\nvar MatchMedia = function() {\n  function MatchMedia2(scope) {\n    this.contexts = [];\n    this.scope = scope;\n    _context && _context.data.push(this);\n  }\n  var _proto6 = MatchMedia2.prototype;\n  _proto6.add = function add(conditions, func, scope) {\n    _isObject(conditions) || (conditions = {\n      matches: conditions\n    });\n    var context3 = new Context(0, scope || this.scope), cond = context3.conditions = {}, mq, p, active;\n    _context && !context3.selector && (context3.selector = _context.selector);\n    this.contexts.push(context3);\n    func = context3.add(\"onMatch\", func);\n    context3.queries = conditions;\n    for (p in conditions) {\n      if (p === \"all\") {\n        active = 1;\n      } else {\n        mq = _win.matchMedia(conditions[p]);\n        if (mq) {\n          _media.indexOf(context3) < 0 && _media.push(context3);\n          (cond[p] = mq.matches) && (active = 1);\n          mq.addListener ? mq.addListener(_onMediaChange) : mq.addEventListener(\"change\", _onMediaChange);\n        }\n      }\n    }\n    active && func(context3, function(f) {\n      return context3.add(null, f);\n    });\n    return this;\n  };\n  _proto6.revert = function revert(config3) {\n    this.kill(config3 || {});\n  };\n  _proto6.kill = function kill(revert) {\n    this.contexts.forEach(function(c) {\n      return c.kill(revert, true);\n    });\n  };\n  return MatchMedia2;\n}();\nvar _gsap = {\n  registerPlugin: function registerPlugin() {\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n    args.forEach(function(config3) {\n      return _createPlugin(config3);\n    });\n  },\n  timeline: function timeline(vars) {\n    return new Timeline(vars);\n  },\n  getTweensOf: function getTweensOf(targets, onlyActive) {\n    return _globalTimeline.getTweensOf(targets, onlyActive);\n  },\n  getProperty: function getProperty(target, property, unit, uncache) {\n    _isString(target) && (target = toArray(target)[0]);\n    var getter = _getCache(target || {}).get, format = unit ? _passThrough : _numericIfPossible;\n    unit === \"native\" && (unit = \"\");\n    return !target ? target : !property ? function(property2, unit2, uncache2) {\n      return format((_plugins[property2] && _plugins[property2].get || getter)(target, property2, unit2, uncache2));\n    } : format((_plugins[property] && _plugins[property].get || getter)(target, property, unit, uncache));\n  },\n  quickSetter: function quickSetter(target, property, unit) {\n    target = toArray(target);\n    if (target.length > 1) {\n      var setters = target.map(function(t) {\n        return gsap.quickSetter(t, property, unit);\n      }), l = setters.length;\n      return function(value) {\n        var i = l;\n        while (i--) {\n          setters[i](value);\n        }\n      };\n    }\n    target = target[0] || {};\n    var Plugin = _plugins[property], cache = _getCache(target), p = cache.harness && (cache.harness.aliases || {})[property] || property, setter = Plugin ? function(value) {\n      var p2 = new Plugin();\n      _quickTween._pt = 0;\n      p2.init(target, unit ? value + unit : value, _quickTween, 0, [target]);\n      p2.render(1, p2);\n      _quickTween._pt && _renderPropTweens(1, _quickTween);\n    } : cache.set(target, p);\n    return Plugin ? setter : function(value) {\n      return setter(target, p, unit ? value + unit : value, cache, 1);\n    };\n  },\n  quickTo: function quickTo(target, property, vars) {\n    var _merge22;\n    var tween = gsap.to(target, _merge((_merge22 = {}, _merge22[property] = \"+=0.1\", _merge22.paused = true, _merge22), vars || {})), func = function func2(value, start, startIsRelative) {\n      return tween.resetTo(property, value, start, startIsRelative);\n    };\n    func.tween = tween;\n    return func;\n  },\n  isTweening: function isTweening(targets) {\n    return _globalTimeline.getTweensOf(targets, true).length > 0;\n  },\n  defaults: function defaults(value) {\n    value && value.ease && (value.ease = _parseEase(value.ease, _defaults.ease));\n    return _mergeDeep(_defaults, value || {});\n  },\n  config: function config2(value) {\n    return _mergeDeep(_config, value || {});\n  },\n  registerEffect: function registerEffect(_ref3) {\n    var name = _ref3.name, effect = _ref3.effect, plugins = _ref3.plugins, defaults2 = _ref3.defaults, extendTimeline = _ref3.extendTimeline;\n    (plugins || \"\").split(\",\").forEach(function(pluginName) {\n      return pluginName && !_plugins[pluginName] && !_globals[pluginName] && _warn(name + \" effect requires \" + pluginName + \" plugin.\");\n    });\n    _effects[name] = function(targets, vars, tl) {\n      return effect(toArray(targets), _setDefaults(vars || {}, defaults2), tl);\n    };\n    if (extendTimeline) {\n      Timeline.prototype[name] = function(targets, vars, position) {\n        return this.add(_effects[name](targets, _isObject(vars) ? vars : (position = vars) && {}, this), position);\n      };\n    }\n  },\n  registerEase: function registerEase(name, ease) {\n    _easeMap[name] = _parseEase(ease);\n  },\n  parseEase: function parseEase(ease, defaultEase) {\n    return arguments.length ? _parseEase(ease, defaultEase) : _easeMap;\n  },\n  getById: function getById(id) {\n    return _globalTimeline.getById(id);\n  },\n  exportRoot: function exportRoot(vars, includeDelayedCalls) {\n    if (vars === void 0) {\n      vars = {};\n    }\n    var tl = new Timeline(vars), child, next;\n    tl.smoothChildTiming = _isNotFalse(vars.smoothChildTiming);\n    _globalTimeline.remove(tl);\n    tl._dp = 0;\n    tl._time = tl._tTime = _globalTimeline._time;\n    child = _globalTimeline._first;\n    while (child) {\n      next = child._next;\n      if (includeDelayedCalls || !(!child._dur && child instanceof Tween && child.vars.onComplete === child._targets[0])) {\n        _addToTimeline(tl, child, child._start - child._delay);\n      }\n      child = next;\n    }\n    _addToTimeline(_globalTimeline, tl, 0);\n    return tl;\n  },\n  context: function context(func, scope) {\n    return func ? new Context(func, scope) : _context;\n  },\n  matchMedia: function matchMedia(scope) {\n    return new MatchMedia(scope);\n  },\n  matchMediaRefresh: function matchMediaRefresh() {\n    return _media.forEach(function(c) {\n      var cond = c.conditions, found, p;\n      for (p in cond) {\n        if (cond[p]) {\n          cond[p] = false;\n          found = 1;\n        }\n      }\n      found && c.revert();\n    }) || _onMediaChange();\n  },\n  addEventListener: function addEventListener(type, callback) {\n    var a = _listeners[type] || (_listeners[type] = []);\n    ~a.indexOf(callback) || a.push(callback);\n  },\n  removeEventListener: function removeEventListener(type, callback) {\n    var a = _listeners[type], i = a && a.indexOf(callback);\n    i >= 0 && a.splice(i, 1);\n  },\n  utils: {\n    wrap,\n    wrapYoyo,\n    distribute,\n    random,\n    snap,\n    normalize,\n    getUnit,\n    clamp,\n    splitColor,\n    toArray,\n    selector,\n    mapRange,\n    pipe,\n    unitize,\n    interpolate,\n    shuffle\n  },\n  install: _install,\n  effects: _effects,\n  ticker: _ticker,\n  updateRoot: Timeline.updateRoot,\n  plugins: _plugins,\n  globalTimeline: _globalTimeline,\n  core: {\n    PropTween,\n    globals: _addGlobal,\n    Tween,\n    Timeline,\n    Animation,\n    getCache: _getCache,\n    _removeLinkedListItem,\n    reverting: function reverting() {\n      return _reverting;\n    },\n    context: function context2(toAdd) {\n      if (toAdd && _context) {\n        _context.data.push(toAdd);\n        toAdd._ctx = _context;\n      }\n      return _context;\n    },\n    suppressOverwrites: function suppressOverwrites(value) {\n      return _suppressOverwrites = value;\n    }\n  }\n};\n_forEachName(\"to,from,fromTo,delayedCall,set,killTweensOf\", function(name) {\n  return _gsap[name] = Tween[name];\n});\n_ticker.add(Timeline.updateRoot);\n_quickTween = _gsap.to({}, {\n  duration: 0\n});\nvar _getPluginPropTween = function _getPluginPropTween2(plugin, prop) {\n  var pt = plugin._pt;\n  while (pt && pt.p !== prop && pt.op !== prop && pt.fp !== prop) {\n    pt = pt._next;\n  }\n  return pt;\n};\nvar _addModifiers = function _addModifiers2(tween, modifiers) {\n  var targets = tween._targets, p, i, pt;\n  for (p in modifiers) {\n    i = targets.length;\n    while (i--) {\n      pt = tween._ptLookup[i][p];\n      if (pt && (pt = pt.d)) {\n        if (pt._pt) {\n          pt = _getPluginPropTween(pt, p);\n        }\n        pt && pt.modifier && pt.modifier(modifiers[p], tween, targets[i], p);\n      }\n    }\n  }\n};\nvar _buildModifierPlugin = function _buildModifierPlugin2(name, modifier) {\n  return {\n    name,\n    rawVars: 1,\n    //don't pre-process function-based values or \"random()\" strings.\n    init: function init4(target, vars, tween) {\n      tween._onInit = function(tween2) {\n        var temp, p;\n        if (_isString(vars)) {\n          temp = {};\n          _forEachName(vars, function(name2) {\n            return temp[name2] = 1;\n          });\n          vars = temp;\n        }\n        if (modifier) {\n          temp = {};\n          for (p in vars) {\n            temp[p] = modifier(vars[p]);\n          }\n          vars = temp;\n        }\n        _addModifiers(tween2, vars);\n      };\n    }\n  };\n};\nvar gsap = _gsap.registerPlugin({\n  name: \"attr\",\n  init: function init(target, vars, tween, index, targets) {\n    var p, pt, v;\n    this.tween = tween;\n    for (p in vars) {\n      v = target.getAttribute(p) || \"\";\n      pt = this.add(target, \"setAttribute\", (v || 0) + \"\", vars[p], index, targets, 0, 0, p);\n      pt.op = p;\n      pt.b = v;\n      this._props.push(p);\n    }\n  },\n  render: function render(ratio, data) {\n    var pt = data._pt;\n    while (pt) {\n      _reverting ? pt.set(pt.t, pt.p, pt.b, pt) : pt.r(ratio, pt.d);\n      pt = pt._next;\n    }\n  }\n}, {\n  name: \"endArray\",\n  init: function init2(target, value) {\n    var i = value.length;\n    while (i--) {\n      this.add(target, i, target[i] || 0, value[i], 0, 0, 0, 0, 0, 1);\n    }\n  }\n}, _buildModifierPlugin(\"roundProps\", _roundModifier), _buildModifierPlugin(\"modifiers\"), _buildModifierPlugin(\"snap\", snap)) || _gsap;\nTween.version = Timeline.version = gsap.version = \"3.12.5\";\n_coreReady = 1;\n_windowExists() && _wake();\nvar Power0 = _easeMap.Power0;\nvar Power1 = _easeMap.Power1;\nvar Power2 = _easeMap.Power2;\nvar Power3 = _easeMap.Power3;\nvar Power4 = _easeMap.Power4;\nvar Linear = _easeMap.Linear;\nvar Quad = _easeMap.Quad;\nvar Cubic = _easeMap.Cubic;\nvar Quart = _easeMap.Quart;\nvar Quint = _easeMap.Quint;\nvar Strong = _easeMap.Strong;\nvar Elastic = _easeMap.Elastic;\nvar Back = _easeMap.Back;\nvar SteppedEase = _easeMap.SteppedEase;\nvar Bounce = _easeMap.Bounce;\nvar Sine = _easeMap.Sine;\nvar Expo = _easeMap.Expo;\nvar Circ = _easeMap.Circ;\n\n// ../../node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/CSSPlugin.js\nvar _win2;\nvar _doc2;\nvar _docElement;\nvar _pluginInitted;\nvar _tempDiv;\nvar _tempDivStyler;\nvar _recentSetterPlugin;\nvar _reverting2;\nvar _windowExists3 = function _windowExists4() {\n  return typeof window !== \"undefined\";\n};\nvar _transformProps = {};\nvar _RAD2DEG = 180 / Math.PI;\nvar _DEG2RAD = Math.PI / 180;\nvar _atan2 = Math.atan2;\nvar _bigNum2 = 1e8;\nvar _capsExp = /([A-Z])/g;\nvar _horizontalExp = /(left|right|width|margin|padding|x)/i;\nvar _complexExp = /[\\s,\\(]\\S/;\nvar _propertyAliases = {\n  autoAlpha: \"opacity,visibility\",\n  scale: \"scaleX,scaleY\",\n  alpha: \"opacity\"\n};\nvar _renderCSSProp = function _renderCSSProp2(ratio, data) {\n  return data.set(data.t, data.p, Math.round((data.s + data.c * ratio) * 1e4) / 1e4 + data.u, data);\n};\nvar _renderPropWithEnd = function _renderPropWithEnd2(ratio, data) {\n  return data.set(data.t, data.p, ratio === 1 ? data.e : Math.round((data.s + data.c * ratio) * 1e4) / 1e4 + data.u, data);\n};\nvar _renderCSSPropWithBeginning = function _renderCSSPropWithBeginning2(ratio, data) {\n  return data.set(data.t, data.p, ratio ? Math.round((data.s + data.c * ratio) * 1e4) / 1e4 + data.u : data.b, data);\n};\nvar _renderRoundedCSSProp = function _renderRoundedCSSProp2(ratio, data) {\n  var value = data.s + data.c * ratio;\n  data.set(data.t, data.p, ~~(value + (value < 0 ? -0.5 : 0.5)) + data.u, data);\n};\nvar _renderNonTweeningValue = function _renderNonTweeningValue2(ratio, data) {\n  return data.set(data.t, data.p, ratio ? data.e : data.b, data);\n};\nvar _renderNonTweeningValueOnlyAtEnd = function _renderNonTweeningValueOnlyAtEnd2(ratio, data) {\n  return data.set(data.t, data.p, ratio !== 1 ? data.b : data.e, data);\n};\nvar _setterCSSStyle = function _setterCSSStyle2(target, property, value) {\n  return target.style[property] = value;\n};\nvar _setterCSSProp = function _setterCSSProp2(target, property, value) {\n  return target.style.setProperty(property, value);\n};\nvar _setterTransform = function _setterTransform2(target, property, value) {\n  return target._gsap[property] = value;\n};\nvar _setterScale = function _setterScale2(target, property, value) {\n  return target._gsap.scaleX = target._gsap.scaleY = value;\n};\nvar _setterScaleWithRender = function _setterScaleWithRender2(target, property, value, data, ratio) {\n  var cache = target._gsap;\n  cache.scaleX = cache.scaleY = value;\n  cache.renderTransform(ratio, cache);\n};\nvar _setterTransformWithRender = function _setterTransformWithRender2(target, property, value, data, ratio) {\n  var cache = target._gsap;\n  cache[property] = value;\n  cache.renderTransform(ratio, cache);\n};\nvar _transformProp = \"transform\";\nvar _transformOriginProp = _transformProp + \"Origin\";\nvar _saveStyle = function _saveStyle2(property, isNotCSS) {\n  var _this = this;\n  var target = this.target, style = target.style, cache = target._gsap;\n  if (property in _transformProps && style) {\n    this.tfm = this.tfm || {};\n    if (property !== \"transform\") {\n      property = _propertyAliases[property] || property;\n      ~property.indexOf(\",\") ? property.split(\",\").forEach(function(a) {\n        return _this.tfm[a] = _get(target, a);\n      }) : this.tfm[property] = cache.x ? cache[property] : _get(target, property);\n      property === _transformOriginProp && (this.tfm.zOrigin = cache.zOrigin);\n    } else {\n      return _propertyAliases.transform.split(\",\").forEach(function(p) {\n        return _saveStyle2.call(_this, p, isNotCSS);\n      });\n    }\n    if (this.props.indexOf(_transformProp) >= 0) {\n      return;\n    }\n    if (cache.svg) {\n      this.svgo = target.getAttribute(\"data-svg-origin\");\n      this.props.push(_transformOriginProp, isNotCSS, \"\");\n    }\n    property = _transformProp;\n  }\n  (style || isNotCSS) && this.props.push(property, isNotCSS, style[property]);\n};\nvar _removeIndependentTransforms = function _removeIndependentTransforms2(style) {\n  if (style.translate) {\n    style.removeProperty(\"translate\");\n    style.removeProperty(\"scale\");\n    style.removeProperty(\"rotate\");\n  }\n};\nvar _revertStyle = function _revertStyle2() {\n  var props = this.props, target = this.target, style = target.style, cache = target._gsap, i, p;\n  for (i = 0; i < props.length; i += 3) {\n    props[i + 1] ? target[props[i]] = props[i + 2] : props[i + 2] ? style[props[i]] = props[i + 2] : style.removeProperty(props[i].substr(0, 2) === \"--\" ? props[i] : props[i].replace(_capsExp, \"-$1\").toLowerCase());\n  }\n  if (this.tfm) {\n    for (p in this.tfm) {\n      cache[p] = this.tfm[p];\n    }\n    if (cache.svg) {\n      cache.renderTransform();\n      target.setAttribute(\"data-svg-origin\", this.svgo || \"\");\n    }\n    i = _reverting2();\n    if ((!i || !i.isStart) && !style[_transformProp]) {\n      _removeIndependentTransforms(style);\n      if (cache.zOrigin && style[_transformOriginProp]) {\n        style[_transformOriginProp] += \" \" + cache.zOrigin + \"px\";\n        cache.zOrigin = 0;\n        cache.renderTransform();\n      }\n      cache.uncache = 1;\n    }\n  }\n};\nvar _getStyleSaver = function _getStyleSaver2(target, properties) {\n  var saver = {\n    target,\n    props: [],\n    revert: _revertStyle,\n    save: _saveStyle\n  };\n  target._gsap || gsap.core.getCache(target);\n  properties && properties.split(\",\").forEach(function(p) {\n    return saver.save(p);\n  });\n  return saver;\n};\nvar _supports3D;\nvar _createElement = function _createElement2(type, ns) {\n  var e = _doc2.createElementNS ? _doc2.createElementNS((ns || \"http://www.w3.org/1999/xhtml\").replace(/^https/, \"http\"), type) : _doc2.createElement(type);\n  return e && e.style ? e : _doc2.createElement(type);\n};\nvar _getComputedProperty = function _getComputedProperty2(target, property, skipPrefixFallback) {\n  var cs = getComputedStyle(target);\n  return cs[property] || cs.getPropertyValue(property.replace(_capsExp, \"-$1\").toLowerCase()) || cs.getPropertyValue(property) || !skipPrefixFallback && _getComputedProperty2(target, _checkPropPrefix(property) || property, 1) || \"\";\n};\nvar _prefixes = \"O,Moz,ms,Ms,Webkit\".split(\",\");\nvar _checkPropPrefix = function _checkPropPrefix2(property, element, preferPrefix) {\n  var e = element || _tempDiv, s = e.style, i = 5;\n  if (property in s && !preferPrefix) {\n    return property;\n  }\n  property = property.charAt(0).toUpperCase() + property.substr(1);\n  while (i-- && !(_prefixes[i] + property in s)) {\n  }\n  return i < 0 ? null : (i === 3 ? \"ms\" : i >= 0 ? _prefixes[i] : \"\") + property;\n};\nvar _initCore = function _initCore2() {\n  if (_windowExists3() && window.document) {\n    _win2 = window;\n    _doc2 = _win2.document;\n    _docElement = _doc2.documentElement;\n    _tempDiv = _createElement(\"div\") || {\n      style: {}\n    };\n    _tempDivStyler = _createElement(\"div\");\n    _transformProp = _checkPropPrefix(_transformProp);\n    _transformOriginProp = _transformProp + \"Origin\";\n    _tempDiv.style.cssText = \"border-width:0;line-height:0;position:absolute;padding:0\";\n    _supports3D = !!_checkPropPrefix(\"perspective\");\n    _reverting2 = gsap.core.reverting;\n    _pluginInitted = 1;\n  }\n};\nvar _getBBoxHack = function _getBBoxHack2(swapIfPossible) {\n  var svg = _createElement(\"svg\", this.ownerSVGElement && this.ownerSVGElement.getAttribute(\"xmlns\") || \"http://www.w3.org/2000/svg\"), oldParent = this.parentNode, oldSibling = this.nextSibling, oldCSS = this.style.cssText, bbox;\n  _docElement.appendChild(svg);\n  svg.appendChild(this);\n  this.style.display = \"block\";\n  if (swapIfPossible) {\n    try {\n      bbox = this.getBBox();\n      this._gsapBBox = this.getBBox;\n      this.getBBox = _getBBoxHack2;\n    } catch (e) {\n    }\n  } else if (this._gsapBBox) {\n    bbox = this._gsapBBox();\n  }\n  if (oldParent) {\n    if (oldSibling) {\n      oldParent.insertBefore(this, oldSibling);\n    } else {\n      oldParent.appendChild(this);\n    }\n  }\n  _docElement.removeChild(svg);\n  this.style.cssText = oldCSS;\n  return bbox;\n};\nvar _getAttributeFallbacks = function _getAttributeFallbacks2(target, attributesArray) {\n  var i = attributesArray.length;\n  while (i--) {\n    if (target.hasAttribute(attributesArray[i])) {\n      return target.getAttribute(attributesArray[i]);\n    }\n  }\n};\nvar _getBBox = function _getBBox2(target) {\n  var bounds;\n  try {\n    bounds = target.getBBox();\n  } catch (error) {\n    bounds = _getBBoxHack.call(target, true);\n  }\n  bounds && (bounds.width || bounds.height) || target.getBBox === _getBBoxHack || (bounds = _getBBoxHack.call(target, true));\n  return bounds && !bounds.width && !bounds.x && !bounds.y ? {\n    x: +_getAttributeFallbacks(target, [\"x\", \"cx\", \"x1\"]) || 0,\n    y: +_getAttributeFallbacks(target, [\"y\", \"cy\", \"y1\"]) || 0,\n    width: 0,\n    height: 0\n  } : bounds;\n};\nvar _isSVG = function _isSVG2(e) {\n  return !!(e.getCTM && (!e.parentNode || e.ownerSVGElement) && _getBBox(e));\n};\nvar _removeProperty = function _removeProperty2(target, property) {\n  if (property) {\n    var style = target.style, first2Chars;\n    if (property in _transformProps && property !== _transformOriginProp) {\n      property = _transformProp;\n    }\n    if (style.removeProperty) {\n      first2Chars = property.substr(0, 2);\n      if (first2Chars === \"ms\" || property.substr(0, 6) === \"webkit\") {\n        property = \"-\" + property;\n      }\n      style.removeProperty(first2Chars === \"--\" ? property : property.replace(_capsExp, \"-$1\").toLowerCase());\n    } else {\n      style.removeAttribute(property);\n    }\n  }\n};\nvar _addNonTweeningPT = function _addNonTweeningPT2(plugin, target, property, beginning, end, onlySetAtEnd) {\n  var pt = new PropTween(plugin._pt, target, property, 0, 1, onlySetAtEnd ? _renderNonTweeningValueOnlyAtEnd : _renderNonTweeningValue);\n  plugin._pt = pt;\n  pt.b = beginning;\n  pt.e = end;\n  plugin._props.push(property);\n  return pt;\n};\nvar _nonConvertibleUnits = {\n  deg: 1,\n  rad: 1,\n  turn: 1\n};\nvar _nonStandardLayouts = {\n  grid: 1,\n  flex: 1\n};\nvar _convertToUnit = function _convertToUnit2(target, property, value, unit) {\n  var curValue = parseFloat(value) || 0, curUnit = (value + \"\").trim().substr((curValue + \"\").length) || \"px\", style = _tempDiv.style, horizontal = _horizontalExp.test(property), isRootSVG = target.tagName.toLowerCase() === \"svg\", measureProperty = (isRootSVG ? \"client\" : \"offset\") + (horizontal ? \"Width\" : \"Height\"), amount = 100, toPixels = unit === \"px\", toPercent = unit === \"%\", px, parent, cache, isSVG;\n  if (unit === curUnit || !curValue || _nonConvertibleUnits[unit] || _nonConvertibleUnits[curUnit]) {\n    return curValue;\n  }\n  curUnit !== \"px\" && !toPixels && (curValue = _convertToUnit2(target, property, value, \"px\"));\n  isSVG = target.getCTM && _isSVG(target);\n  if ((toPercent || curUnit === \"%\") && (_transformProps[property] || ~property.indexOf(\"adius\"))) {\n    px = isSVG ? target.getBBox()[horizontal ? \"width\" : \"height\"] : target[measureProperty];\n    return _round(toPercent ? curValue / px * amount : curValue / 100 * px);\n  }\n  style[horizontal ? \"width\" : \"height\"] = amount + (toPixels ? curUnit : unit);\n  parent = ~property.indexOf(\"adius\") || unit === \"em\" && target.appendChild && !isRootSVG ? target : target.parentNode;\n  if (isSVG) {\n    parent = (target.ownerSVGElement || {}).parentNode;\n  }\n  if (!parent || parent === _doc2 || !parent.appendChild) {\n    parent = _doc2.body;\n  }\n  cache = parent._gsap;\n  if (cache && toPercent && cache.width && horizontal && cache.time === _ticker.time && !cache.uncache) {\n    return _round(curValue / cache.width * amount);\n  } else {\n    if (toPercent && (property === \"height\" || property === \"width\")) {\n      var v = target.style[property];\n      target.style[property] = amount + unit;\n      px = target[measureProperty];\n      v ? target.style[property] = v : _removeProperty(target, property);\n    } else {\n      (toPercent || curUnit === \"%\") && !_nonStandardLayouts[_getComputedProperty(parent, \"display\")] && (style.position = _getComputedProperty(target, \"position\"));\n      parent === target && (style.position = \"static\");\n      parent.appendChild(_tempDiv);\n      px = _tempDiv[measureProperty];\n      parent.removeChild(_tempDiv);\n      style.position = \"absolute\";\n    }\n    if (horizontal && toPercent) {\n      cache = _getCache(parent);\n      cache.time = _ticker.time;\n      cache.width = parent[measureProperty];\n    }\n  }\n  return _round(toPixels ? px * curValue / amount : px && curValue ? amount / px * curValue : 0);\n};\nvar _get = function _get2(target, property, unit, uncache) {\n  var value;\n  _pluginInitted || _initCore();\n  if (property in _propertyAliases && property !== \"transform\") {\n    property = _propertyAliases[property];\n    if (~property.indexOf(\",\")) {\n      property = property.split(\",\")[0];\n    }\n  }\n  if (_transformProps[property] && property !== \"transform\") {\n    value = _parseTransform(target, uncache);\n    value = property !== \"transformOrigin\" ? value[property] : value.svg ? value.origin : _firstTwoOnly(_getComputedProperty(target, _transformOriginProp)) + \" \" + value.zOrigin + \"px\";\n  } else {\n    value = target.style[property];\n    if (!value || value === \"auto\" || uncache || ~(value + \"\").indexOf(\"calc(\")) {\n      value = _specialProps[property] && _specialProps[property](target, property, unit) || _getComputedProperty(target, property) || _getProperty(target, property) || (property === \"opacity\" ? 1 : 0);\n    }\n  }\n  return unit && !~(value + \"\").trim().indexOf(\" \") ? _convertToUnit(target, property, value, unit) + unit : value;\n};\nvar _tweenComplexCSSString = function _tweenComplexCSSString2(target, prop, start, end) {\n  if (!start || start === \"none\") {\n    var p = _checkPropPrefix(prop, target, 1), s = p && _getComputedProperty(target, p, 1);\n    if (s && s !== start) {\n      prop = p;\n      start = s;\n    } else if (prop === \"borderColor\") {\n      start = _getComputedProperty(target, \"borderTopColor\");\n    }\n  }\n  var pt = new PropTween(this._pt, target.style, prop, 0, 1, _renderComplexString), index = 0, matchIndex = 0, a, result, startValues, startNum, color, startValue, endValue, endNum, chunk, endUnit, startUnit, endValues;\n  pt.b = start;\n  pt.e = end;\n  start += \"\";\n  end += \"\";\n  if (end === \"auto\") {\n    startValue = target.style[prop];\n    target.style[prop] = end;\n    end = _getComputedProperty(target, prop) || end;\n    startValue ? target.style[prop] = startValue : _removeProperty(target, prop);\n  }\n  a = [start, end];\n  _colorStringFilter(a);\n  start = a[0];\n  end = a[1];\n  startValues = start.match(_numWithUnitExp) || [];\n  endValues = end.match(_numWithUnitExp) || [];\n  if (endValues.length) {\n    while (result = _numWithUnitExp.exec(end)) {\n      endValue = result[0];\n      chunk = end.substring(index, result.index);\n      if (color) {\n        color = (color + 1) % 5;\n      } else if (chunk.substr(-5) === \"rgba(\" || chunk.substr(-5) === \"hsla(\") {\n        color = 1;\n      }\n      if (endValue !== (startValue = startValues[matchIndex++] || \"\")) {\n        startNum = parseFloat(startValue) || 0;\n        startUnit = startValue.substr((startNum + \"\").length);\n        endValue.charAt(1) === \"=\" && (endValue = _parseRelative(startNum, endValue) + startUnit);\n        endNum = parseFloat(endValue);\n        endUnit = endValue.substr((endNum + \"\").length);\n        index = _numWithUnitExp.lastIndex - endUnit.length;\n        if (!endUnit) {\n          endUnit = endUnit || _config.units[prop] || startUnit;\n          if (index === end.length) {\n            end += endUnit;\n            pt.e += endUnit;\n          }\n        }\n        if (startUnit !== endUnit) {\n          startNum = _convertToUnit(target, prop, startValue, endUnit) || 0;\n        }\n        pt._pt = {\n          _next: pt._pt,\n          p: chunk || matchIndex === 1 ? chunk : \",\",\n          //note: SVG spec allows omission of comma/space when a negative sign is wedged between two numbers, like 2.5-5.3 instead of 2.5,-5.3 but when tweening, the negative value may switch to positive, so we insert the comma just in case.\n          s: startNum,\n          c: endNum - startNum,\n          m: color && color < 4 || prop === \"zIndex\" ? Math.round : 0\n        };\n      }\n    }\n    pt.c = index < end.length ? end.substring(index, end.length) : \"\";\n  } else {\n    pt.r = prop === \"display\" && end === \"none\" ? _renderNonTweeningValueOnlyAtEnd : _renderNonTweeningValue;\n  }\n  _relExp.test(end) && (pt.e = 0);\n  this._pt = pt;\n  return pt;\n};\nvar _keywordToPercent = {\n  top: \"0%\",\n  bottom: \"100%\",\n  left: \"0%\",\n  right: \"100%\",\n  center: \"50%\"\n};\nvar _convertKeywordsToPercentages = function _convertKeywordsToPercentages2(value) {\n  var split = value.split(\" \"), x = split[0], y = split[1] || \"50%\";\n  if (x === \"top\" || x === \"bottom\" || y === \"left\" || y === \"right\") {\n    value = x;\n    x = y;\n    y = value;\n  }\n  split[0] = _keywordToPercent[x] || x;\n  split[1] = _keywordToPercent[y] || y;\n  return split.join(\" \");\n};\nvar _renderClearProps = function _renderClearProps2(ratio, data) {\n  if (data.tween && data.tween._time === data.tween._dur) {\n    var target = data.t, style = target.style, props = data.u, cache = target._gsap, prop, clearTransforms, i;\n    if (props === \"all\" || props === true) {\n      style.cssText = \"\";\n      clearTransforms = 1;\n    } else {\n      props = props.split(\",\");\n      i = props.length;\n      while (--i > -1) {\n        prop = props[i];\n        if (_transformProps[prop]) {\n          clearTransforms = 1;\n          prop = prop === \"transformOrigin\" ? _transformOriginProp : _transformProp;\n        }\n        _removeProperty(target, prop);\n      }\n    }\n    if (clearTransforms) {\n      _removeProperty(target, _transformProp);\n      if (cache) {\n        cache.svg && target.removeAttribute(\"transform\");\n        _parseTransform(target, 1);\n        cache.uncache = 1;\n        _removeIndependentTransforms(style);\n      }\n    }\n  }\n};\nvar _specialProps = {\n  clearProps: function clearProps(plugin, target, property, endValue, tween) {\n    if (tween.data !== \"isFromStart\") {\n      var pt = plugin._pt = new PropTween(plugin._pt, target, property, 0, 0, _renderClearProps);\n      pt.u = endValue;\n      pt.pr = -10;\n      pt.tween = tween;\n      plugin._props.push(property);\n      return 1;\n    }\n  }\n  /* className feature (about 0.4kb gzipped).\n  , className(plugin, target, property, endValue, tween) {\n  \tlet _renderClassName = (ratio, data) => {\n  \t\t\tdata.css.render(ratio, data.css);\n  \t\t\tif (!ratio || ratio === 1) {\n  \t\t\t\tlet inline = data.rmv,\n  \t\t\t\t\ttarget = data.t,\n  \t\t\t\t\tp;\n  \t\t\t\ttarget.setAttribute(\"class\", ratio ? data.e : data.b);\n  \t\t\t\tfor (p in inline) {\n  \t\t\t\t\t_removeProperty(target, p);\n  \t\t\t\t}\n  \t\t\t}\n  \t\t},\n  \t\t_getAllStyles = (target) => {\n  \t\t\tlet styles = {},\n  \t\t\t\tcomputed = getComputedStyle(target),\n  \t\t\t\tp;\n  \t\t\tfor (p in computed) {\n  \t\t\t\tif (isNaN(p) && p !== \"cssText\" && p !== \"length\") {\n  \t\t\t\t\tstyles[p] = computed[p];\n  \t\t\t\t}\n  \t\t\t}\n  \t\t\t_setDefaults(styles, _parseTransform(target, 1));\n  \t\t\treturn styles;\n  \t\t},\n  \t\tstartClassList = target.getAttribute(\"class\"),\n  \t\tstyle = target.style,\n  \t\tcssText = style.cssText,\n  \t\tcache = target._gsap,\n  \t\tclassPT = cache.classPT,\n  \t\tinlineToRemoveAtEnd = {},\n  \t\tdata = {t:target, plugin:plugin, rmv:inlineToRemoveAtEnd, b:startClassList, e:(endValue.charAt(1) !== \"=\") ? endValue : startClassList.replace(new RegExp(\"(?:\\\\s|^)\" + endValue.substr(2) + \"(?![\\\\w-])\"), \"\") + ((endValue.charAt(0) === \"+\") ? \" \" + endValue.substr(2) : \"\")},\n  \t\tchangingVars = {},\n  \t\tstartVars = _getAllStyles(target),\n  \t\ttransformRelated = /(transform|perspective)/i,\n  \t\tendVars, p;\n  \tif (classPT) {\n  \t\tclassPT.r(1, classPT.d);\n  \t\t_removeLinkedListItem(classPT.d.plugin, classPT, \"_pt\");\n  \t}\n  \ttarget.setAttribute(\"class\", data.e);\n  \tendVars = _getAllStyles(target, true);\n  \ttarget.setAttribute(\"class\", startClassList);\n  \tfor (p in endVars) {\n  \t\tif (endVars[p] !== startVars[p] && !transformRelated.test(p)) {\n  \t\t\tchangingVars[p] = endVars[p];\n  \t\t\tif (!style[p] && style[p] !== \"0\") {\n  \t\t\t\tinlineToRemoveAtEnd[p] = 1;\n  \t\t\t}\n  \t\t}\n  \t}\n  \tcache.classPT = plugin._pt = new PropTween(plugin._pt, target, \"className\", 0, 0, _renderClassName, data, 0, -11);\n  \tif (style.cssText !== cssText) { //only apply if things change. Otherwise, in cases like a background-image that's pulled dynamically, it could cause a refresh. See https://gsap.com/forums/topic/20368-possible-gsap-bug-switching-classnames-in-chrome/.\n  \t\tstyle.cssText = cssText; //we recorded cssText before we swapped classes and ran _getAllStyles() because in cases when a className tween is overwritten, we remove all the related tweening properties from that class change (otherwise class-specific stuff can't override properties we've directly set on the target's style object due to specificity).\n  \t}\n  \t_parseTransform(target, true); //to clear the caching of transforms\n  \tdata.css = new gsap.plugins.css();\n  \tdata.css.init(target, changingVars, tween);\n  \tplugin._props.push(...data.css._props);\n  \treturn 1;\n  }\n  */\n};\nvar _identity2DMatrix = [1, 0, 0, 1, 0, 0];\nvar _rotationalProperties = {};\nvar _isNullTransform = function _isNullTransform2(value) {\n  return value === \"matrix(1, 0, 0, 1, 0, 0)\" || value === \"none\" || !value;\n};\nvar _getComputedTransformMatrixAsArray = function _getComputedTransformMatrixAsArray2(target) {\n  var matrixString = _getComputedProperty(target, _transformProp);\n  return _isNullTransform(matrixString) ? _identity2DMatrix : matrixString.substr(7).match(_numExp).map(_round);\n};\nvar _getMatrix = function _getMatrix2(target, force2D) {\n  var cache = target._gsap || _getCache(target), style = target.style, matrix = _getComputedTransformMatrixAsArray(target), parent, nextSibling, temp, addedToDOM;\n  if (cache.svg && target.getAttribute(\"transform\")) {\n    temp = target.transform.baseVal.consolidate().matrix;\n    matrix = [temp.a, temp.b, temp.c, temp.d, temp.e, temp.f];\n    return matrix.join(\",\") === \"1,0,0,1,0,0\" ? _identity2DMatrix : matrix;\n  } else if (matrix === _identity2DMatrix && !target.offsetParent && target !== _docElement && !cache.svg) {\n    temp = style.display;\n    style.display = \"block\";\n    parent = target.parentNode;\n    if (!parent || !target.offsetParent) {\n      addedToDOM = 1;\n      nextSibling = target.nextElementSibling;\n      _docElement.appendChild(target);\n    }\n    matrix = _getComputedTransformMatrixAsArray(target);\n    temp ? style.display = temp : _removeProperty(target, \"display\");\n    if (addedToDOM) {\n      nextSibling ? parent.insertBefore(target, nextSibling) : parent ? parent.appendChild(target) : _docElement.removeChild(target);\n    }\n  }\n  return force2D && matrix.length > 6 ? [matrix[0], matrix[1], matrix[4], matrix[5], matrix[12], matrix[13]] : matrix;\n};\nvar _applySVGOrigin = function _applySVGOrigin2(target, origin, originIsAbsolute, smooth, matrixArray, pluginToAddPropTweensTo) {\n  var cache = target._gsap, matrix = matrixArray || _getMatrix(target, true), xOriginOld = cache.xOrigin || 0, yOriginOld = cache.yOrigin || 0, xOffsetOld = cache.xOffset || 0, yOffsetOld = cache.yOffset || 0, a = matrix[0], b = matrix[1], c = matrix[2], d = matrix[3], tx = matrix[4], ty = matrix[5], originSplit = origin.split(\" \"), xOrigin = parseFloat(originSplit[0]) || 0, yOrigin = parseFloat(originSplit[1]) || 0, bounds, determinant, x, y;\n  if (!originIsAbsolute) {\n    bounds = _getBBox(target);\n    xOrigin = bounds.x + (~originSplit[0].indexOf(\"%\") ? xOrigin / 100 * bounds.width : xOrigin);\n    yOrigin = bounds.y + (~(originSplit[1] || originSplit[0]).indexOf(\"%\") ? yOrigin / 100 * bounds.height : yOrigin);\n  } else if (matrix !== _identity2DMatrix && (determinant = a * d - b * c)) {\n    x = xOrigin * (d / determinant) + yOrigin * (-c / determinant) + (c * ty - d * tx) / determinant;\n    y = xOrigin * (-b / determinant) + yOrigin * (a / determinant) - (a * ty - b * tx) / determinant;\n    xOrigin = x;\n    yOrigin = y;\n  }\n  if (smooth || smooth !== false && cache.smooth) {\n    tx = xOrigin - xOriginOld;\n    ty = yOrigin - yOriginOld;\n    cache.xOffset = xOffsetOld + (tx * a + ty * c) - tx;\n    cache.yOffset = yOffsetOld + (tx * b + ty * d) - ty;\n  } else {\n    cache.xOffset = cache.yOffset = 0;\n  }\n  cache.xOrigin = xOrigin;\n  cache.yOrigin = yOrigin;\n  cache.smooth = !!smooth;\n  cache.origin = origin;\n  cache.originIsAbsolute = !!originIsAbsolute;\n  target.style[_transformOriginProp] = \"0px 0px\";\n  if (pluginToAddPropTweensTo) {\n    _addNonTweeningPT(pluginToAddPropTweensTo, cache, \"xOrigin\", xOriginOld, xOrigin);\n    _addNonTweeningPT(pluginToAddPropTweensTo, cache, \"yOrigin\", yOriginOld, yOrigin);\n    _addNonTweeningPT(pluginToAddPropTweensTo, cache, \"xOffset\", xOffsetOld, cache.xOffset);\n    _addNonTweeningPT(pluginToAddPropTweensTo, cache, \"yOffset\", yOffsetOld, cache.yOffset);\n  }\n  target.setAttribute(\"data-svg-origin\", xOrigin + \" \" + yOrigin);\n};\nvar _parseTransform = function _parseTransform2(target, uncache) {\n  var cache = target._gsap || new GSCache(target);\n  if (\"x\" in cache && !uncache && !cache.uncache) {\n    return cache;\n  }\n  var style = target.style, invertedScaleX = cache.scaleX < 0, px = \"px\", deg = \"deg\", cs = getComputedStyle(target), origin = _getComputedProperty(target, _transformOriginProp) || \"0\", x, y, z, scaleX, scaleY, rotation, rotationX, rotationY, skewX, skewY, perspective, xOrigin, yOrigin, matrix, angle, cos, sin, a, b, c, d, a12, a22, t1, t2, t3, a13, a23, a33, a42, a43, a32;\n  x = y = z = rotation = rotationX = rotationY = skewX = skewY = perspective = 0;\n  scaleX = scaleY = 1;\n  cache.svg = !!(target.getCTM && _isSVG(target));\n  if (cs.translate) {\n    if (cs.translate !== \"none\" || cs.scale !== \"none\" || cs.rotate !== \"none\") {\n      style[_transformProp] = (cs.translate !== \"none\" ? \"translate3d(\" + (cs.translate + \" 0 0\").split(\" \").slice(0, 3).join(\", \") + \") \" : \"\") + (cs.rotate !== \"none\" ? \"rotate(\" + cs.rotate + \") \" : \"\") + (cs.scale !== \"none\" ? \"scale(\" + cs.scale.split(\" \").join(\",\") + \") \" : \"\") + (cs[_transformProp] !== \"none\" ? cs[_transformProp] : \"\");\n    }\n    style.scale = style.rotate = style.translate = \"none\";\n  }\n  matrix = _getMatrix(target, cache.svg);\n  if (cache.svg) {\n    if (cache.uncache) {\n      t2 = target.getBBox();\n      origin = cache.xOrigin - t2.x + \"px \" + (cache.yOrigin - t2.y) + \"px\";\n      t1 = \"\";\n    } else {\n      t1 = !uncache && target.getAttribute(\"data-svg-origin\");\n    }\n    _applySVGOrigin(target, t1 || origin, !!t1 || cache.originIsAbsolute, cache.smooth !== false, matrix);\n  }\n  xOrigin = cache.xOrigin || 0;\n  yOrigin = cache.yOrigin || 0;\n  if (matrix !== _identity2DMatrix) {\n    a = matrix[0];\n    b = matrix[1];\n    c = matrix[2];\n    d = matrix[3];\n    x = a12 = matrix[4];\n    y = a22 = matrix[5];\n    if (matrix.length === 6) {\n      scaleX = Math.sqrt(a * a + b * b);\n      scaleY = Math.sqrt(d * d + c * c);\n      rotation = a || b ? _atan2(b, a) * _RAD2DEG : 0;\n      skewX = c || d ? _atan2(c, d) * _RAD2DEG + rotation : 0;\n      skewX && (scaleY *= Math.abs(Math.cos(skewX * _DEG2RAD)));\n      if (cache.svg) {\n        x -= xOrigin - (xOrigin * a + yOrigin * c);\n        y -= yOrigin - (xOrigin * b + yOrigin * d);\n      }\n    } else {\n      a32 = matrix[6];\n      a42 = matrix[7];\n      a13 = matrix[8];\n      a23 = matrix[9];\n      a33 = matrix[10];\n      a43 = matrix[11];\n      x = matrix[12];\n      y = matrix[13];\n      z = matrix[14];\n      angle = _atan2(a32, a33);\n      rotationX = angle * _RAD2DEG;\n      if (angle) {\n        cos = Math.cos(-angle);\n        sin = Math.sin(-angle);\n        t1 = a12 * cos + a13 * sin;\n        t2 = a22 * cos + a23 * sin;\n        t3 = a32 * cos + a33 * sin;\n        a13 = a12 * -sin + a13 * cos;\n        a23 = a22 * -sin + a23 * cos;\n        a33 = a32 * -sin + a33 * cos;\n        a43 = a42 * -sin + a43 * cos;\n        a12 = t1;\n        a22 = t2;\n        a32 = t3;\n      }\n      angle = _atan2(-c, a33);\n      rotationY = angle * _RAD2DEG;\n      if (angle) {\n        cos = Math.cos(-angle);\n        sin = Math.sin(-angle);\n        t1 = a * cos - a13 * sin;\n        t2 = b * cos - a23 * sin;\n        t3 = c * cos - a33 * sin;\n        a43 = d * sin + a43 * cos;\n        a = t1;\n        b = t2;\n        c = t3;\n      }\n      angle = _atan2(b, a);\n      rotation = angle * _RAD2DEG;\n      if (angle) {\n        cos = Math.cos(angle);\n        sin = Math.sin(angle);\n        t1 = a * cos + b * sin;\n        t2 = a12 * cos + a22 * sin;\n        b = b * cos - a * sin;\n        a22 = a22 * cos - a12 * sin;\n        a = t1;\n        a12 = t2;\n      }\n      if (rotationX && Math.abs(rotationX) + Math.abs(rotation) > 359.9) {\n        rotationX = rotation = 0;\n        rotationY = 180 - rotationY;\n      }\n      scaleX = _round(Math.sqrt(a * a + b * b + c * c));\n      scaleY = _round(Math.sqrt(a22 * a22 + a32 * a32));\n      angle = _atan2(a12, a22);\n      skewX = Math.abs(angle) > 2e-4 ? angle * _RAD2DEG : 0;\n      perspective = a43 ? 1 / (a43 < 0 ? -a43 : a43) : 0;\n    }\n    if (cache.svg) {\n      t1 = target.getAttribute(\"transform\");\n      cache.forceCSS = target.setAttribute(\"transform\", \"\") || !_isNullTransform(_getComputedProperty(target, _transformProp));\n      t1 && target.setAttribute(\"transform\", t1);\n    }\n  }\n  if (Math.abs(skewX) > 90 && Math.abs(skewX) < 270) {\n    if (invertedScaleX) {\n      scaleX *= -1;\n      skewX += rotation <= 0 ? 180 : -180;\n      rotation += rotation <= 0 ? 180 : -180;\n    } else {\n      scaleY *= -1;\n      skewX += skewX <= 0 ? 180 : -180;\n    }\n  }\n  uncache = uncache || cache.uncache;\n  cache.x = x - ((cache.xPercent = x && (!uncache && cache.xPercent || (Math.round(target.offsetWidth / 2) === Math.round(-x) ? -50 : 0))) ? target.offsetWidth * cache.xPercent / 100 : 0) + px;\n  cache.y = y - ((cache.yPercent = y && (!uncache && cache.yPercent || (Math.round(target.offsetHeight / 2) === Math.round(-y) ? -50 : 0))) ? target.offsetHeight * cache.yPercent / 100 : 0) + px;\n  cache.z = z + px;\n  cache.scaleX = _round(scaleX);\n  cache.scaleY = _round(scaleY);\n  cache.rotation = _round(rotation) + deg;\n  cache.rotationX = _round(rotationX) + deg;\n  cache.rotationY = _round(rotationY) + deg;\n  cache.skewX = skewX + deg;\n  cache.skewY = skewY + deg;\n  cache.transformPerspective = perspective + px;\n  if (cache.zOrigin = parseFloat(origin.split(\" \")[2]) || !uncache && cache.zOrigin || 0) {\n    style[_transformOriginProp] = _firstTwoOnly(origin);\n  }\n  cache.xOffset = cache.yOffset = 0;\n  cache.force3D = _config.force3D;\n  cache.renderTransform = cache.svg ? _renderSVGTransforms : _supports3D ? _renderCSSTransforms : _renderNon3DTransforms;\n  cache.uncache = 0;\n  return cache;\n};\nvar _firstTwoOnly = function _firstTwoOnly2(value) {\n  return (value = value.split(\" \"))[0] + \" \" + value[1];\n};\nvar _addPxTranslate = function _addPxTranslate2(target, start, value) {\n  var unit = getUnit(start);\n  return _round(parseFloat(start) + parseFloat(_convertToUnit(target, \"x\", value + \"px\", unit))) + unit;\n};\nvar _renderNon3DTransforms = function _renderNon3DTransforms2(ratio, cache) {\n  cache.z = \"0px\";\n  cache.rotationY = cache.rotationX = \"0deg\";\n  cache.force3D = 0;\n  _renderCSSTransforms(ratio, cache);\n};\nvar _zeroDeg = \"0deg\";\nvar _zeroPx = \"0px\";\nvar _endParenthesis = \") \";\nvar _renderCSSTransforms = function _renderCSSTransforms2(ratio, cache) {\n  var _ref = cache || this, xPercent = _ref.xPercent, yPercent = _ref.yPercent, x = _ref.x, y = _ref.y, z = _ref.z, rotation = _ref.rotation, rotationY = _ref.rotationY, rotationX = _ref.rotationX, skewX = _ref.skewX, skewY = _ref.skewY, scaleX = _ref.scaleX, scaleY = _ref.scaleY, transformPerspective = _ref.transformPerspective, force3D = _ref.force3D, target = _ref.target, zOrigin = _ref.zOrigin, transforms = \"\", use3D = force3D === \"auto\" && ratio && ratio !== 1 || force3D === true;\n  if (zOrigin && (rotationX !== _zeroDeg || rotationY !== _zeroDeg)) {\n    var angle = parseFloat(rotationY) * _DEG2RAD, a13 = Math.sin(angle), a33 = Math.cos(angle), cos;\n    angle = parseFloat(rotationX) * _DEG2RAD;\n    cos = Math.cos(angle);\n    x = _addPxTranslate(target, x, a13 * cos * -zOrigin);\n    y = _addPxTranslate(target, y, -Math.sin(angle) * -zOrigin);\n    z = _addPxTranslate(target, z, a33 * cos * -zOrigin + zOrigin);\n  }\n  if (transformPerspective !== _zeroPx) {\n    transforms += \"perspective(\" + transformPerspective + _endParenthesis;\n  }\n  if (xPercent || yPercent) {\n    transforms += \"translate(\" + xPercent + \"%, \" + yPercent + \"%) \";\n  }\n  if (use3D || x !== _zeroPx || y !== _zeroPx || z !== _zeroPx) {\n    transforms += z !== _zeroPx || use3D ? \"translate3d(\" + x + \", \" + y + \", \" + z + \") \" : \"translate(\" + x + \", \" + y + _endParenthesis;\n  }\n  if (rotation !== _zeroDeg) {\n    transforms += \"rotate(\" + rotation + _endParenthesis;\n  }\n  if (rotationY !== _zeroDeg) {\n    transforms += \"rotateY(\" + rotationY + _endParenthesis;\n  }\n  if (rotationX !== _zeroDeg) {\n    transforms += \"rotateX(\" + rotationX + _endParenthesis;\n  }\n  if (skewX !== _zeroDeg || skewY !== _zeroDeg) {\n    transforms += \"skew(\" + skewX + \", \" + skewY + _endParenthesis;\n  }\n  if (scaleX !== 1 || scaleY !== 1) {\n    transforms += \"scale(\" + scaleX + \", \" + scaleY + _endParenthesis;\n  }\n  target.style[_transformProp] = transforms || \"translate(0, 0)\";\n};\nvar _renderSVGTransforms = function _renderSVGTransforms2(ratio, cache) {\n  var _ref2 = cache || this, xPercent = _ref2.xPercent, yPercent = _ref2.yPercent, x = _ref2.x, y = _ref2.y, rotation = _ref2.rotation, skewX = _ref2.skewX, skewY = _ref2.skewY, scaleX = _ref2.scaleX, scaleY = _ref2.scaleY, target = _ref2.target, xOrigin = _ref2.xOrigin, yOrigin = _ref2.yOrigin, xOffset = _ref2.xOffset, yOffset = _ref2.yOffset, forceCSS = _ref2.forceCSS, tx = parseFloat(x), ty = parseFloat(y), a11, a21, a12, a22, temp;\n  rotation = parseFloat(rotation);\n  skewX = parseFloat(skewX);\n  skewY = parseFloat(skewY);\n  if (skewY) {\n    skewY = parseFloat(skewY);\n    skewX += skewY;\n    rotation += skewY;\n  }\n  if (rotation || skewX) {\n    rotation *= _DEG2RAD;\n    skewX *= _DEG2RAD;\n    a11 = Math.cos(rotation) * scaleX;\n    a21 = Math.sin(rotation) * scaleX;\n    a12 = Math.sin(rotation - skewX) * -scaleY;\n    a22 = Math.cos(rotation - skewX) * scaleY;\n    if (skewX) {\n      skewY *= _DEG2RAD;\n      temp = Math.tan(skewX - skewY);\n      temp = Math.sqrt(1 + temp * temp);\n      a12 *= temp;\n      a22 *= temp;\n      if (skewY) {\n        temp = Math.tan(skewY);\n        temp = Math.sqrt(1 + temp * temp);\n        a11 *= temp;\n        a21 *= temp;\n      }\n    }\n    a11 = _round(a11);\n    a21 = _round(a21);\n    a12 = _round(a12);\n    a22 = _round(a22);\n  } else {\n    a11 = scaleX;\n    a22 = scaleY;\n    a21 = a12 = 0;\n  }\n  if (tx && !~(x + \"\").indexOf(\"px\") || ty && !~(y + \"\").indexOf(\"px\")) {\n    tx = _convertToUnit(target, \"x\", x, \"px\");\n    ty = _convertToUnit(target, \"y\", y, \"px\");\n  }\n  if (xOrigin || yOrigin || xOffset || yOffset) {\n    tx = _round(tx + xOrigin - (xOrigin * a11 + yOrigin * a12) + xOffset);\n    ty = _round(ty + yOrigin - (xOrigin * a21 + yOrigin * a22) + yOffset);\n  }\n  if (xPercent || yPercent) {\n    temp = target.getBBox();\n    tx = _round(tx + xPercent / 100 * temp.width);\n    ty = _round(ty + yPercent / 100 * temp.height);\n  }\n  temp = \"matrix(\" + a11 + \",\" + a21 + \",\" + a12 + \",\" + a22 + \",\" + tx + \",\" + ty + \")\";\n  target.setAttribute(\"transform\", temp);\n  forceCSS && (target.style[_transformProp] = temp);\n};\nvar _addRotationalPropTween = function _addRotationalPropTween2(plugin, target, property, startNum, endValue) {\n  var cap = 360, isString = _isString(endValue), endNum = parseFloat(endValue) * (isString && ~endValue.indexOf(\"rad\") ? _RAD2DEG : 1), change = endNum - startNum, finalValue = startNum + change + \"deg\", direction, pt;\n  if (isString) {\n    direction = endValue.split(\"_\")[1];\n    if (direction === \"short\") {\n      change %= cap;\n      if (change !== change % (cap / 2)) {\n        change += change < 0 ? cap : -cap;\n      }\n    }\n    if (direction === \"cw\" && change < 0) {\n      change = (change + cap * _bigNum2) % cap - ~~(change / cap) * cap;\n    } else if (direction === \"ccw\" && change > 0) {\n      change = (change - cap * _bigNum2) % cap - ~~(change / cap) * cap;\n    }\n  }\n  plugin._pt = pt = new PropTween(plugin._pt, target, property, startNum, change, _renderPropWithEnd);\n  pt.e = finalValue;\n  pt.u = \"deg\";\n  plugin._props.push(property);\n  return pt;\n};\nvar _assign = function _assign2(target, source) {\n  for (var p in source) {\n    target[p] = source[p];\n  }\n  return target;\n};\nvar _addRawTransformPTs = function _addRawTransformPTs2(plugin, transforms, target) {\n  var startCache = _assign({}, target._gsap), exclude = \"perspective,force3D,transformOrigin,svgOrigin\", style = target.style, endCache, p, startValue, endValue, startNum, endNum, startUnit, endUnit;\n  if (startCache.svg) {\n    startValue = target.getAttribute(\"transform\");\n    target.setAttribute(\"transform\", \"\");\n    style[_transformProp] = transforms;\n    endCache = _parseTransform(target, 1);\n    _removeProperty(target, _transformProp);\n    target.setAttribute(\"transform\", startValue);\n  } else {\n    startValue = getComputedStyle(target)[_transformProp];\n    style[_transformProp] = transforms;\n    endCache = _parseTransform(target, 1);\n    style[_transformProp] = startValue;\n  }\n  for (p in _transformProps) {\n    startValue = startCache[p];\n    endValue = endCache[p];\n    if (startValue !== endValue && exclude.indexOf(p) < 0) {\n      startUnit = getUnit(startValue);\n      endUnit = getUnit(endValue);\n      startNum = startUnit !== endUnit ? _convertToUnit(target, p, startValue, endUnit) : parseFloat(startValue);\n      endNum = parseFloat(endValue);\n      plugin._pt = new PropTween(plugin._pt, endCache, p, startNum, endNum - startNum, _renderCSSProp);\n      plugin._pt.u = endUnit || 0;\n      plugin._props.push(p);\n    }\n  }\n  _assign(endCache, startCache);\n};\n_forEachName(\"padding,margin,Width,Radius\", function(name, index) {\n  var t = \"Top\", r = \"Right\", b = \"Bottom\", l = \"Left\", props = (index < 3 ? [t, r, b, l] : [t + l, t + r, b + r, b + l]).map(function(side) {\n    return index < 2 ? name + side : \"border\" + side + name;\n  });\n  _specialProps[index > 1 ? \"border\" + name : name] = function(plugin, target, property, endValue, tween) {\n    var a, vars;\n    if (arguments.length < 4) {\n      a = props.map(function(prop) {\n        return _get(plugin, prop, property);\n      });\n      vars = a.join(\" \");\n      return vars.split(a[0]).length === 5 ? a[0] : vars;\n    }\n    a = (endValue + \"\").split(\" \");\n    vars = {};\n    props.forEach(function(prop, i) {\n      return vars[prop] = a[i] = a[i] || a[(i - 1) / 2 | 0];\n    });\n    plugin.init(target, vars, tween);\n  };\n});\nvar CSSPlugin = {\n  name: \"css\",\n  register: _initCore,\n  targetTest: function targetTest(target) {\n    return target.style && target.nodeType;\n  },\n  init: function init3(target, vars, tween, index, targets) {\n    var props = this._props, style = target.style, startAt = tween.vars.startAt, startValue, endValue, endNum, startNum, type, specialProp, p, startUnit, endUnit, relative, isTransformRelated, transformPropTween, cache, smooth, hasPriority, inlineProps;\n    _pluginInitted || _initCore();\n    this.styles = this.styles || _getStyleSaver(target);\n    inlineProps = this.styles.props;\n    this.tween = tween;\n    for (p in vars) {\n      if (p === \"autoRound\") {\n        continue;\n      }\n      endValue = vars[p];\n      if (_plugins[p] && _checkPlugin(p, vars, tween, index, target, targets)) {\n        continue;\n      }\n      type = typeof endValue;\n      specialProp = _specialProps[p];\n      if (type === \"function\") {\n        endValue = endValue.call(tween, index, target, targets);\n        type = typeof endValue;\n      }\n      if (type === \"string\" && ~endValue.indexOf(\"random(\")) {\n        endValue = _replaceRandom(endValue);\n      }\n      if (specialProp) {\n        specialProp(this, target, p, endValue, tween) && (hasPriority = 1);\n      } else if (p.substr(0, 2) === \"--\") {\n        startValue = (getComputedStyle(target).getPropertyValue(p) + \"\").trim();\n        endValue += \"\";\n        _colorExp.lastIndex = 0;\n        if (!_colorExp.test(startValue)) {\n          startUnit = getUnit(startValue);\n          endUnit = getUnit(endValue);\n        }\n        endUnit ? startUnit !== endUnit && (startValue = _convertToUnit(target, p, startValue, endUnit) + endUnit) : startUnit && (endValue += startUnit);\n        this.add(style, \"setProperty\", startValue, endValue, index, targets, 0, 0, p);\n        props.push(p);\n        inlineProps.push(p, 0, style[p]);\n      } else if (type !== \"undefined\") {\n        if (startAt && p in startAt) {\n          startValue = typeof startAt[p] === \"function\" ? startAt[p].call(tween, index, target, targets) : startAt[p];\n          _isString(startValue) && ~startValue.indexOf(\"random(\") && (startValue = _replaceRandom(startValue));\n          getUnit(startValue + \"\") || startValue === \"auto\" || (startValue += _config.units[p] || getUnit(_get(target, p)) || \"\");\n          (startValue + \"\").charAt(1) === \"=\" && (startValue = _get(target, p));\n        } else {\n          startValue = _get(target, p);\n        }\n        startNum = parseFloat(startValue);\n        relative = type === \"string\" && endValue.charAt(1) === \"=\" && endValue.substr(0, 2);\n        relative && (endValue = endValue.substr(2));\n        endNum = parseFloat(endValue);\n        if (p in _propertyAliases) {\n          if (p === \"autoAlpha\") {\n            if (startNum === 1 && _get(target, \"visibility\") === \"hidden\" && endNum) {\n              startNum = 0;\n            }\n            inlineProps.push(\"visibility\", 0, style.visibility);\n            _addNonTweeningPT(this, style, \"visibility\", startNum ? \"inherit\" : \"hidden\", endNum ? \"inherit\" : \"hidden\", !endNum);\n          }\n          if (p !== \"scale\" && p !== \"transform\") {\n            p = _propertyAliases[p];\n            ~p.indexOf(\",\") && (p = p.split(\",\")[0]);\n          }\n        }\n        isTransformRelated = p in _transformProps;\n        if (isTransformRelated) {\n          this.styles.save(p);\n          if (!transformPropTween) {\n            cache = target._gsap;\n            cache.renderTransform && !vars.parseTransform || _parseTransform(target, vars.parseTransform);\n            smooth = vars.smoothOrigin !== false && cache.smooth;\n            transformPropTween = this._pt = new PropTween(this._pt, style, _transformProp, 0, 1, cache.renderTransform, cache, 0, -1);\n            transformPropTween.dep = 1;\n          }\n          if (p === \"scale\") {\n            this._pt = new PropTween(this._pt, cache, \"scaleY\", cache.scaleY, (relative ? _parseRelative(cache.scaleY, relative + endNum) : endNum) - cache.scaleY || 0, _renderCSSProp);\n            this._pt.u = 0;\n            props.push(\"scaleY\", p);\n            p += \"X\";\n          } else if (p === \"transformOrigin\") {\n            inlineProps.push(_transformOriginProp, 0, style[_transformOriginProp]);\n            endValue = _convertKeywordsToPercentages(endValue);\n            if (cache.svg) {\n              _applySVGOrigin(target, endValue, 0, smooth, 0, this);\n            } else {\n              endUnit = parseFloat(endValue.split(\" \")[2]) || 0;\n              endUnit !== cache.zOrigin && _addNonTweeningPT(this, cache, \"zOrigin\", cache.zOrigin, endUnit);\n              _addNonTweeningPT(this, style, p, _firstTwoOnly(startValue), _firstTwoOnly(endValue));\n            }\n            continue;\n          } else if (p === \"svgOrigin\") {\n            _applySVGOrigin(target, endValue, 1, smooth, 0, this);\n            continue;\n          } else if (p in _rotationalProperties) {\n            _addRotationalPropTween(this, cache, p, startNum, relative ? _parseRelative(startNum, relative + endValue) : endValue);\n            continue;\n          } else if (p === \"smoothOrigin\") {\n            _addNonTweeningPT(this, cache, \"smooth\", cache.smooth, endValue);\n            continue;\n          } else if (p === \"force3D\") {\n            cache[p] = endValue;\n            continue;\n          } else if (p === \"transform\") {\n            _addRawTransformPTs(this, endValue, target);\n            continue;\n          }\n        } else if (!(p in style)) {\n          p = _checkPropPrefix(p) || p;\n        }\n        if (isTransformRelated || (endNum || endNum === 0) && (startNum || startNum === 0) && !_complexExp.test(endValue) && p in style) {\n          startUnit = (startValue + \"\").substr((startNum + \"\").length);\n          endNum || (endNum = 0);\n          endUnit = getUnit(endValue) || (p in _config.units ? _config.units[p] : startUnit);\n          startUnit !== endUnit && (startNum = _convertToUnit(target, p, startValue, endUnit));\n          this._pt = new PropTween(this._pt, isTransformRelated ? cache : style, p, startNum, (relative ? _parseRelative(startNum, relative + endNum) : endNum) - startNum, !isTransformRelated && (endUnit === \"px\" || p === \"zIndex\") && vars.autoRound !== false ? _renderRoundedCSSProp : _renderCSSProp);\n          this._pt.u = endUnit || 0;\n          if (startUnit !== endUnit && endUnit !== \"%\") {\n            this._pt.b = startValue;\n            this._pt.r = _renderCSSPropWithBeginning;\n          }\n        } else if (!(p in style)) {\n          if (p in target) {\n            this.add(target, p, startValue || target[p], relative ? relative + endValue : endValue, index, targets);\n          } else if (p !== \"parseTransform\") {\n            _missingPlugin(p, endValue);\n            continue;\n          }\n        } else {\n          _tweenComplexCSSString.call(this, target, p, startValue, relative ? relative + endValue : endValue);\n        }\n        isTransformRelated || (p in style ? inlineProps.push(p, 0, style[p]) : inlineProps.push(p, 1, startValue || target[p]));\n        props.push(p);\n      }\n    }\n    hasPriority && _sortPropTweensByPriority(this);\n  },\n  render: function render2(ratio, data) {\n    if (data.tween._time || !_reverting2()) {\n      var pt = data._pt;\n      while (pt) {\n        pt.r(ratio, pt.d);\n        pt = pt._next;\n      }\n    } else {\n      data.styles.revert();\n    }\n  },\n  get: _get,\n  aliases: _propertyAliases,\n  getSetter: function getSetter(target, property, plugin) {\n    var p = _propertyAliases[property];\n    p && p.indexOf(\",\") < 0 && (property = p);\n    return property in _transformProps && property !== _transformOriginProp && (target._gsap.x || _get(target, \"x\")) ? plugin && _recentSetterPlugin === plugin ? property === \"scale\" ? _setterScale : _setterTransform : (_recentSetterPlugin = plugin || {}) && (property === \"scale\" ? _setterScaleWithRender : _setterTransformWithRender) : target.style && !_isUndefined(target.style[property]) ? _setterCSSStyle : ~property.indexOf(\"-\") ? _setterCSSProp : _getSetter(target, property);\n  },\n  core: {\n    _removeProperty,\n    _getMatrix\n  }\n};\ngsap.utils.checkPrefix = _checkPropPrefix;\ngsap.core.getStyleSaver = _getStyleSaver;\n(function(positionAndScale, rotation, others, aliases) {\n  var all = _forEachName(positionAndScale + \",\" + rotation + \",\" + others, function(name) {\n    _transformProps[name] = 1;\n  });\n  _forEachName(rotation, function(name) {\n    _config.units[name] = \"deg\";\n    _rotationalProperties[name] = 1;\n  });\n  _propertyAliases[all[13]] = positionAndScale + \",\" + rotation;\n  _forEachName(aliases, function(name) {\n    var split = name.split(\":\");\n    _propertyAliases[split[1]] = all[split[0]];\n  });\n})(\"x,y,z,scale,scaleX,scaleY,xPercent,yPercent\", \"rotation,rotationX,rotationY,skewX,skewY\", \"transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective\", \"0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY\");\n_forEachName(\"x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective\", function(name) {\n  _config.units[name] = \"px\";\n});\ngsap.registerPlugin(CSSPlugin);\n\n// ../../node_modules/.pnpm/gsap@3.12.5/node_modules/gsap/index.js\nvar gsapWithCSS = gsap.registerPlugin(CSSPlugin) || gsap;\nvar TweenMaxWithCSS = gsapWithCSS.core.Tween;\n\nexport {\n  Timeline,\n  Tween,\n  Power0,\n  Power1,\n  Power2,\n  Power3,\n  Power4,\n  Linear,\n  Quad,\n  Cubic,\n  Quart,\n  Quint,\n  Strong,\n  Elastic,\n  Back,\n  SteppedEase,\n  Bounce,\n  Sine,\n  Expo,\n  Circ,\n  CSSPlugin,\n  gsapWithCSS,\n  TweenMaxWithCSS\n};\n/*! Bundled license information:\n\ngsap/gsap-core.js:\n  (*!\n   * GSAP 3.12.5\n   * https://gsap.com\n   *\n   * @license Copyright 2008-2024, GreenSock. All rights reserved.\n   * Subject to the terms at https://gsap.com/standard-license or for\n   * Club GSAP members, the agreement issued with that membership.\n   * @author: Jack Doyle, jack@greensock.com\n  *)\n\ngsap/CSSPlugin.js:\n  (*!\n   * CSSPlugin 3.12.5\n   * https://gsap.com\n   *\n   * Copyright 2008-2024, GreenSock. All rights reserved.\n   * Subject to the terms at https://gsap.com/standard-license or for\n   * Club GSAP members, the agreement issued with that membership.\n   * @author: Jack Doyle, jack@greensock.com\n  *)\n*/\n//# sourceMappingURL=chunk-HJ66XTML.js.map\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 168123,
            "count": 1
          },
          {
            "startOffset": 1638,
            "endOffset": 1655,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_assertThisInitialized",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 71,
            "endOffset": 247,
            "count": 127
          },
          {
            "startOffset": 134,
            "endOffset": 230,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_inheritsLoose",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 248,
            "endOffset": 437,
            "count": 2
          }
        ]
      },
      {
        "functionName": "_isString2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 865,
            "endOffset": 931,
            "count": 612
          }
        ]
      },
      {
        "functionName": "_isFunction2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 951,
            "endOffset": 1021,
            "count": 462
          }
        ]
      },
      {
        "functionName": "_isNumber2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1039,
            "endOffset": 1105,
            "count": 129
          }
        ]
      },
      {
        "functionName": "_isUndefined2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1126,
            "endOffset": 1198,
            "count": 50
          }
        ]
      },
      {
        "functionName": "_isObject2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1216,
            "endOffset": 1282,
            "count": 219
          }
        ]
      },
      {
        "functionName": "_isNotFalse2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1302,
            "endOffset": 1360,
            "count": 217
          }
        ]
      },
      {
        "functionName": "_windowExists2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1382,
            "endOffset": 1451,
            "count": 14
          }
        ]
      },
      {
        "functionName": "_isFuncOrString2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1475,
            "endOffset": 1560,
            "count": 210
          }
        ]
      },
      {
        "functionName": "_isTypedArray",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1641,
            "endOffset": 1655,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_install2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 2158,
            "endOffset": 2247,
            "count": 1
          }
        ]
      },
      {
        "functionName": "_missingPlugin2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2270,
            "endOffset": 2426,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_warn2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2440,
            "endOffset": 2523,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_addGlobal2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 2542,
            "endOffset": 2678,
            "count": 14
          },
          {
            "startOffset": 2590,
            "endOffset": 2615,
            "count": 12
          },
          {
            "startOffset": 2616,
            "endOffset": 2632,
            "count": 12
          },
          {
            "startOffset": 2633,
            "endOffset": 2663,
            "count": 12
          },
          {
            "startOffset": 2664,
            "endOffset": 2675,
            "count": 2
          }
        ]
      },
      {
        "functionName": "_emptyFunc2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2697,
            "endOffset": 2735,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_harness2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 3161,
            "endOffset": 3690,
            "count": 108
          },
          {
            "startOffset": 3256,
            "endOffset": 3278,
            "count": 3
          },
          {
            "startOffset": 3279,
            "endOffset": 3303,
            "count": 0
          },
          {
            "startOffset": 3343,
            "endOffset": 3348,
            "count": 33
          },
          {
            "startOffset": 3360,
            "endOffset": 3503,
            "count": 34
          },
          {
            "startOffset": 3409,
            "endOffset": 3450,
            "count": 33
          },
          {
            "startOffset": 3452,
            "endOffset": 3459,
            "count": 5
          },
          {
            "startOffset": 3540,
            "endOffset": 3670,
            "count": 114
          },
          {
            "startOffset": 3578,
            "endOffset": 3640,
            "count": 35
          },
          {
            "startOffset": 3642,
            "endOffset": 3665,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_getCache2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 3708,
            "endOffset": 3800,
            "count": 116
          },
          {
            "startOffset": 3760,
            "endOffset": 3797,
            "count": 1
          }
        ]
      },
      {
        "functionName": "_getProperty2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 3821,
            "endOffset": 4019,
            "count": 50
          },
          {
            "startOffset": 3899,
            "endOffset": 3916,
            "count": 0
          },
          {
            "startOffset": 3917,
            "endOffset": 3937,
            "count": 0
          },
          {
            "startOffset": 3979,
            "endOffset": 4011,
            "count": 46
          }
        ]
      },
      {
        "functionName": "_forEachName2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 4040,
            "endOffset": 4139,
            "count": 23
          }
        ]
      },
      {
        "functionName": "_round2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 4154,
            "endOffset": 4226,
            "count": 186
          },
          {
            "startOffset": 4219,
            "endOffset": 4223,
            "count": 112
          }
        ]
      },
      {
        "functionName": "_roundPrecise2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 4248,
            "endOffset": 4327,
            "count": 1077
          },
          {
            "startOffset": 4320,
            "endOffset": 4324,
            "count": 31
          }
        ]
      },
      {
        "functionName": "_parseRelative2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4350,
            "endOffset": 4611,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_arrayContainsAny2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4637,
            "endOffset": 4795,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_lazyRender2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 4815,
            "endOffset": 5096,
            "count": 62
          },
          {
            "startOffset": 4979,
            "endOffset": 5094,
            "count": 81
          }
        ]
      },
      {
        "functionName": "_lazySafeRender2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5120,
            "endOffset": 5418,
            "count": 257
          },
          {
            "startOffset": 5209,
            "endOffset": 5223,
            "count": 0
          },
          {
            "startOffset": 5224,
            "endOffset": 5240,
            "count": 0
          },
          {
            "startOffset": 5303,
            "endOffset": 5314,
            "count": 16
          },
          {
            "startOffset": 5315,
            "endOffset": 5360,
            "count": 16
          },
          {
            "startOffset": 5338,
            "endOffset": 5359,
            "count": 2
          },
          {
            "startOffset": 5384,
            "endOffset": 5398,
            "count": 40
          },
          {
            "startOffset": 5399,
            "endOffset": 5415,
            "count": 40
          }
        ]
      },
      {
        "functionName": "_numericIfPossible2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5445,
            "endOffset": 5637,
            "count": 6
          },
          {
            "startOffset": 5536,
            "endOffset": 5588,
            "count": 0
          },
          {
            "startOffset": 5589,
            "endOffset": 5592,
            "count": 0
          },
          {
            "startOffset": 5612,
            "endOffset": 5626,
            "count": 2
          },
          {
            "startOffset": 5627,
            "endOffset": 5634,
            "count": 4
          }
        ]
      },
      {
        "functionName": "_passThrough2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 5658,
            "endOffset": 5699,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_setDefaults2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5720,
            "endOffset": 5850,
            "count": 140
          },
          {
            "startOffset": 5788,
            "endOffset": 5834,
            "count": 520
          },
          {
            "startOffset": 5803,
            "endOffset": 5829,
            "count": 270
          },
          {
            "startOffset": 5834,
            "endOffset": 5849,
            "count": 132
          }
        ]
      },
      {
        "functionName": "_setKeyframeDefaults2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 5879,
            "endOffset": 6106,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_merge2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 6121,
            "endOffset": 6228,
            "count": 15
          },
          {
            "startOffset": 6180,
            "endOffset": 6211,
            "count": 109
          }
        ]
      },
      {
        "functionName": "_mergeDeep2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 6247,
            "endOffset": 6502,
            "count": 2
          },
          {
            "startOffset": 6310,
            "endOffset": 6485,
            "count": 1
          },
          {
            "startOffset": 6414,
            "endOffset": 6466,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_copyExcluding2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 6525,
            "endOffset": 6669,
            "count": 128
          },
          {
            "startOffset": 6605,
            "endOffset": 6652,
            "count": 862
          },
          {
            "startOffset": 6626,
            "endOffset": 6647,
            "count": 239
          }
        ]
      },
      {
        "functionName": "_inheritDefaults2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 6694,
            "endOffset": 7029,
            "count": 107
          },
          {
            "startOffset": 6756,
            "endOffset": 6774,
            "count": 95
          },
          {
            "startOffset": 6798,
            "endOffset": 6846,
            "count": 0
          },
          {
            "startOffset": 6917,
            "endOffset": 7008,
            "count": 115
          },
          {
            "startOffset": 6988,
            "endOffset": 7001,
            "count": 107
          }
        ]
      },
      {
        "functionName": "_arraysMatch2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 7050,
            "endOffset": 7194,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_addLinkedListItem2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7221,
            "endOffset": 7884,
            "count": 110
          },
          {
            "startOffset": 7324,
            "endOffset": 7355,
            "count": 0
          },
          {
            "startOffset": 7383,
            "endOffset": 7412,
            "count": 0
          },
          {
            "startOffset": 7461,
            "endOffset": 7559,
            "count": 8
          },
          {
            "startOffset": 7502,
            "endOffset": 7521,
            "count": 6
          },
          {
            "startOffset": 7523,
            "endOffset": 7555,
            "count": 0
          },
          {
            "startOffset": 7572,
            "endOffset": 7631,
            "count": 106
          },
          {
            "startOffset": 7631,
            "endOffset": 7710,
            "count": 4
          },
          {
            "startOffset": 7730,
            "endOffset": 7766,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_removeLinkedListItem2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7914,
            "endOffset": 8427,
            "count": 103
          },
          {
            "startOffset": 8159,
            "endOffset": 8187,
            "count": 101
          },
          {
            "startOffset": 8187,
            "endOffset": 8261,
            "count": 2
          },
          {
            "startOffset": 8274,
            "endOffset": 8302,
            "count": 81
          },
          {
            "startOffset": 8302,
            "endOffset": 8374,
            "count": 22
          }
        ]
      },
      {
        "functionName": "_removeFromParent2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 8453,
            "endOffset": 8672,
            "count": 114
          },
          {
            "startOffset": 8532,
            "endOffset": 8598,
            "count": 110
          },
          {
            "startOffset": 8563,
            "endOffset": 8597,
            "count": 99
          },
          {
            "startOffset": 8599,
            "endOffset": 8621,
            "count": 103
          },
          {
            "startOffset": 8622,
            "endOffset": 8651,
            "count": 103
          }
        ]
      },
      {
        "functionName": "_uncache2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 8689,
            "endOffset": 8920,
            "count": 215
          },
          {
            "startOffset": 8744,
            "endOffset": 8806,
            "count": 213
          },
          {
            "startOffset": 8755,
            "endOffset": 8785,
            "count": 110
          },
          {
            "startOffset": 8786,
            "endOffset": 8805,
            "count": 82
          },
          {
            "startOffset": 8808,
            "endOffset": 8898,
            "count": 131
          },
          {
            "startOffset": 8847,
            "endOffset": 8894,
            "count": 139
          }
        ]
      },
      {
        "functionName": "_recacheAncestors2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 8946,
            "endOffset": 9160,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_rewindStartAt2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 9183,
            "endOffset": 9442,
            "count": 23
          },
          {
            "startOffset": 9275,
            "endOffset": 9439,
            "count": 4
          },
          {
            "startOffset": 9335,
            "endOffset": 9438,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_hasNoPausedAncestors2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 9472,
            "endOffset": 9600,
            "count": 24
          },
          {
            "startOffset": 9537,
            "endOffset": 9597,
            "count": 16
          }
        ]
      },
      {
        "functionName": "_elapsedCycleDuration2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 9630,
            "endOffset": 9810,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_animationCycle2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 9834,
            "endOffset": 9990,
            "count": 240
          },
          {
            "startOffset": 9949,
            "endOffset": 9967,
            "count": 238
          },
          {
            "startOffset": 9968,
            "endOffset": 9979,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_parentToChildTotalTime2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10022,
            "endOffset": 10204,
            "count": 247
          },
          {
            "startOffset": 10148,
            "endOffset": 10200,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_setEnd2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10220,
            "endOffset": 10392,
            "count": 10
          },
          {
            "startOffset": 10352,
            "endOffset": 10369,
            "count": 0
          },
          {
            "startOffset": 10370,
            "endOffset": 10381,
            "count": 0
          },
          {
            "startOffset": 10383,
            "endOffset": 10387,
            "count": 1
          }
        ]
      },
      {
        "functionName": "_alignPlayhead2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10415,
            "endOffset": 10854,
            "count": 4
          },
          {
            "startOffset": 10654,
            "endOffset": 10751,
            "count": 0
          },
          {
            "startOffset": 10797,
            "endOffset": 10827,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_postAddChecks2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10877,
            "endOffset": 11568,
            "count": 110
          },
          {
            "startOffset": 10964,
            "endOffset": 10981,
            "count": 22
          },
          {
            "startOffset": 10982,
            "endOffset": 11045,
            "count": 109
          },
          {
            "startOffset": 11016,
            "endOffset": 11045,
            "count": 0
          },
          {
            "startOffset": 11047,
            "endOffset": 11236,
            "count": 1
          },
          {
            "startOffset": 11130,
            "endOffset": 11194,
            "count": 0
          },
          {
            "startOffset": 11274,
            "endOffset": 11295,
            "count": 8
          },
          {
            "startOffset": 11296,
            "endOffset": 11332,
            "count": 0
          },
          {
            "startOffset": 11333,
            "endOffset": 11349,
            "count": 0
          },
          {
            "startOffset": 11351,
            "endOffset": 11566,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_addToTimeline2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 11591,
            "endOffset": 12285,
            "count": 110
          },
          {
            "startOffset": 11673,
            "endOffset": 11700,
            "count": 0
          },
          {
            "startOffset": 11754,
            "endOffset": 11764,
            "count": 5
          },
          {
            "startOffset": 11765,
            "endOffset": 11871,
            "count": 105
          },
          {
            "startOffset": 11809,
            "endOffset": 11853,
            "count": 4
          },
          {
            "startOffset": 11854,
            "endOffset": 11871,
            "count": 101
          },
          {
            "startOffset": 11987,
            "endOffset": 11991,
            "count": 22
          },
          {
            "startOffset": 12069,
            "endOffset": 12079,
            "count": 8
          },
          {
            "startOffset": 12080,
            "endOffset": 12083,
            "count": 102
          },
          {
            "startOffset": 12114,
            "endOffset": 12144,
            "count": 102
          },
          {
            "startOffset": 12216,
            "endOffset": 12262,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_scrollTrigger2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12308,
            "endOffset": 12488,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_attemptInitTween2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 12514,
            "endOffset": 12918,
            "count": 112
          },
          {
            "startOffset": 12644,
            "endOffset": 12663,
            "count": 8
          },
          {
            "startOffset": 12663,
            "endOffset": 12677,
            "count": 104
          },
          {
            "startOffset": 12677,
            "endOffset": 12689,
            "count": 100
          },
          {
            "startOffset": 12690,
            "endOffset": 12704,
            "count": 96
          },
          {
            "startOffset": 12705,
            "endOffset": 12783,
            "count": 96
          },
          {
            "startOffset": 12720,
            "endOffset": 12748,
            "count": 81
          },
          {
            "startOffset": 12749,
            "endOffset": 12782,
            "count": 15
          },
          {
            "startOffset": 12784,
            "endOffset": 12823,
            "count": 89
          },
          {
            "startOffset": 12825,
            "endOffset": 12916,
            "count": 81
          }
        ]
      },
      {
        "functionName": "_parentPlayheadIsBeforeStart2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 12955,
            "endOffset": 13165,
            "count": 1
          },
          {
            "startOffset": 13079,
            "endOffset": 13095,
            "count": 0
          },
          {
            "startOffset": 13096,
            "endOffset": 13162,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_isFromOrFromStart2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13192,
            "endOffset": 13311,
            "count": 110
          },
          {
            "startOffset": 13287,
            "endOffset": 13308,
            "count": 102
          }
        ]
      },
      {
        "functionName": "_renderZeroDurationTween2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13344,
            "endOffset": 15323,
            "count": 35
          },
          {
            "startOffset": 13475,
            "endOffset": 13667,
            "count": 17
          },
          {
            "startOffset": 13489,
            "endOffset": 13667,
            "count": 16
          },
          {
            "startOffset": 13507,
            "endOffset": 13545,
            "count": 1
          },
          {
            "startOffset": 13546,
            "endOffset": 13596,
            "count": 0
          },
          {
            "startOffset": 13637,
            "endOffset": 13666,
            "count": 0
          },
          {
            "startOffset": 13668,
            "endOffset": 13671,
            "count": 18
          },
          {
            "startOffset": 13672,
            "endOffset": 13675,
            "count": 17
          },
          {
            "startOffset": 13765,
            "endOffset": 13781,
            "count": 0
          },
          {
            "startOffset": 13783,
            "endOffset": 14120,
            "count": 0
          },
          {
            "startOffset": 14147,
            "endOffset": 14160,
            "count": 9
          },
          {
            "startOffset": 14161,
            "endOffset": 14169,
            "count": 0
          },
          {
            "startOffset": 14170,
            "endOffset": 14198,
            "count": 0
          },
          {
            "startOffset": 14199,
            "endOffset": 14228,
            "count": 0
          },
          {
            "startOffset": 14256,
            "endOffset": 14324,
            "count": 17
          },
          {
            "startOffset": 14326,
            "endOffset": 14347,
            "count": 0
          },
          {
            "startOffset": 14411,
            "endOffset": 14445,
            "count": 16
          },
          {
            "startOffset": 14430,
            "endOffset": 14440,
            "count": 0
          },
          {
            "startOffset": 14466,
            "endOffset": 14515,
            "count": 22
          },
          {
            "startOffset": 14497,
            "endOffset": 14514,
            "count": 6
          },
          {
            "startOffset": 14558,
            "endOffset": 14580,
            "count": 0
          },
          {
            "startOffset": 14664,
            "endOffset": 14717,
            "count": 37
          },
          {
            "startOffset": 14736,
            "endOffset": 14793,
            "count": 18
          },
          {
            "startOffset": 14815,
            "endOffset": 14833,
            "count": 0
          },
          {
            "startOffset": 14834,
            "endOffset": 14865,
            "count": 0
          },
          {
            "startOffset": 14877,
            "endOffset": 14893,
            "count": 0
          },
          {
            "startOffset": 14894,
            "endOffset": 14912,
            "count": 0
          },
          {
            "startOffset": 14913,
            "endOffset": 14928,
            "count": 0
          },
          {
            "startOffset": 14929,
            "endOffset": 14960,
            "count": 0
          },
          {
            "startOffset": 14996,
            "endOffset": 15012,
            "count": 18
          },
          {
            "startOffset": 15054,
            "endOffset": 15084,
            "count": 17
          },
          {
            "startOffset": 15112,
            "endOffset": 15126,
            "count": 22
          },
          {
            "startOffset": 15128,
            "endOffset": 15251,
            "count": 17
          },
          {
            "startOffset": 15176,
            "endOffset": 15197,
            "count": 0
          },
          {
            "startOffset": 15226,
            "endOffset": 15242,
            "count": 0
          },
          {
            "startOffset": 15261,
            "endOffset": 15321,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_findNextPauseTween2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15351,
            "endOffset": 15867,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_setDuration2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15888,
            "endOffset": 16547,
            "count": 160
          },
          {
            "startOffset": 16026,
            "endOffset": 16030,
            "count": 22
          },
          {
            "startOffset": 16100,
            "endOffset": 16117,
            "count": 41
          },
          {
            "startOffset": 16118,
            "endOffset": 16162,
            "count": 0
          },
          {
            "startOffset": 16216,
            "endOffset": 16221,
            "count": 158
          },
          {
            "startOffset": 16222,
            "endOffset": 16306,
            "count": 2
          },
          {
            "startOffset": 16242,
            "endOffset": 16306,
            "count": 0
          },
          {
            "startOffset": 16328,
            "endOffset": 16345,
            "count": 41
          },
          {
            "startOffset": 16346,
            "endOffset": 16426,
            "count": 0
          },
          {
            "startOffset": 16447,
            "endOffset": 16468,
            "count": 6
          },
          {
            "startOffset": 16484,
            "endOffset": 16524,
            "count": 2
          }
        ]
      },
      {
        "functionName": "_onUpdateTotalDuration2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 16578,
            "endOffset": 16729,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_parsePosition2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 16841,
            "endOffset": 18137,
            "count": 4
          },
          {
            "startOffset": 16967,
            "endOffset": 16983,
            "count": 0
          },
          {
            "startOffset": 17035,
            "endOffset": 17058,
            "count": 0
          },
          {
            "startOffset": 17125,
            "endOffset": 17167,
            "count": 0
          },
          {
            "startOffset": 17169,
            "endOffset": 18078,
            "count": 0
          },
          {
            "startOffset": 18123,
            "endOffset": 18134,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_createTweenType2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 18162,
            "endOffset": 18853,
            "count": 10
          },
          {
            "startOffset": 18277,
            "endOffset": 18280,
            "count": 0
          },
          {
            "startOffset": 18302,
            "endOffset": 18305,
            "count": 0
          },
          {
            "startOffset": 18361,
            "endOffset": 18391,
            "count": 0
          },
          {
            "startOffset": 18432,
            "endOffset": 18791,
            "count": 6
          },
          {
            "startOffset": 18495,
            "endOffset": 18528,
            "count": 0
          },
          {
            "startOffset": 18530,
            "endOffset": 18646,
            "count": 0
          },
          {
            "startOffset": 18748,
            "endOffset": 18786,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_conditionalReturn2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 18880,
            "endOffset": 18977,
            "count": 2
          },
          {
            "startOffset": 18954,
            "endOffset": 18967,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_clamp2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 18992,
            "endOffset": 19085,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getUnit2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 19101,
            "endOffset": 19203,
            "count": 67
          },
          {
            "startOffset": 19158,
            "endOffset": 19188,
            "count": 15
          },
          {
            "startOffset": 19189,
            "endOffset": 19193,
            "count": 52
          },
          {
            "startOffset": 19194,
            "endOffset": 19200,
            "count": 15
          }
        ]
      },
      {
        "functionName": "clamp2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 19217,
            "endOffset": 19340,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_isArrayLike2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 19384,
            "endOffset": 19605,
            "count": 107
          },
          {
            "startOffset": 19441,
            "endOffset": 19460,
            "count": 106
          },
          {
            "startOffset": 19461,
            "endOffset": 19481,
            "count": 103
          },
          {
            "startOffset": 19482,
            "endOffset": 19565,
            "count": 2
          },
          {
            "startOffset": 19513,
            "endOffset": 19564,
            "count": 0
          },
          {
            "startOffset": 19566,
            "endOffset": 19584,
            "count": 2
          },
          {
            "startOffset": 19585,
            "endOffset": 19602,
            "count": 2
          }
        ]
      },
      {
        "functionName": "_flatten2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 19622,
            "endOffset": 19984,
            "count": 9
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 19752,
            "endOffset": 19965,
            "count": 13
          },
          {
            "startOffset": 19820,
            "endOffset": 19836,
            "count": 0
          },
          {
            "startOffset": 19863,
            "endOffset": 19934,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toArray2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 20000,
            "endOffset": 20369,
            "count": 135
          },
          {
            "startOffset": 20066,
            "endOffset": 20075,
            "count": 47
          },
          {
            "startOffset": 20076,
            "endOffset": 20096,
            "count": 27
          },
          {
            "startOffset": 20097,
            "endOffset": 20123,
            "count": 20
          },
          {
            "startOffset": 20124,
            "endOffset": 20366,
            "count": 115
          },
          {
            "startOffset": 20143,
            "endOffset": 20159,
            "count": 12
          },
          {
            "startOffset": 20160,
            "endOffset": 20189,
            "count": 12
          },
          {
            "startOffset": 20177,
            "endOffset": 20188,
            "count": 0
          },
          {
            "startOffset": 20190,
            "endOffset": 20247,
            "count": 12
          },
          {
            "startOffset": 20211,
            "endOffset": 20218,
            "count": 4
          },
          {
            "startOffset": 20248,
            "endOffset": 20366,
            "count": 103
          },
          {
            "startOffset": 20266,
            "endOffset": 20297,
            "count": 9
          },
          {
            "startOffset": 20298,
            "endOffset": 20366,
            "count": 94
          },
          {
            "startOffset": 20320,
            "endOffset": 20343,
            "count": 0
          },
          {
            "startOffset": 20352,
            "endOffset": 20361,
            "count": 93
          },
          {
            "startOffset": 20362,
            "endOffset": 20366,
            "count": 1
          }
        ]
      },
      {
        "functionName": "selector2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 20386,
            "endOffset": 20690,
            "count": 2
          },
          {
            "startOffset": 20442,
            "endOffset": 20467,
            "count": 0
          },
          {
            "startOffset": 20468,
            "endOffset": 20473,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 20484,
            "endOffset": 20687,
            "count": 20
          },
          {
            "startOffset": 20525,
            "endOffset": 20547,
            "count": 0
          },
          {
            "startOffset": 20548,
            "endOffset": 20556,
            "count": 0
          },
          {
            "startOffset": 20605,
            "endOffset": 20681,
            "count": 0
          }
        ]
      },
      {
        "functionName": "shuffle2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 20706,
            "endOffset": 20797,
            "count": 0
          }
        ]
      },
      {
        "functionName": "distribute2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 20816,
            "endOffset": 22915,
            "count": 2
          },
          {
            "startOffset": 20864,
            "endOffset": 20883,
            "count": 0
          },
          {
            "startOffset": 20910,
            "endOffset": 20913,
            "count": 0
          },
          {
            "startOffset": 21056,
            "endOffset": 21067,
            "count": 0
          },
          {
            "startOffset": 21175,
            "endOffset": 21272,
            "count": 0
          },
          {
            "startOffset": 21304,
            "endOffset": 21353,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 21363,
            "endOffset": 22912,
            "count": 4
          },
          {
            "startOffset": 21403,
            "endOffset": 21410,
            "count": 0
          },
          {
            "startOffset": 21510,
            "endOffset": 22757,
            "count": 2
          },
          {
            "startOffset": 21548,
            "endOffset": 21551,
            "count": 0
          },
          {
            "startOffset": 21605,
            "endOffset": 21767,
            "count": 0
          },
          {
            "startOffset": 21824,
            "endOffset": 21860,
            "count": 0
          },
          {
            "startOffset": 21917,
            "endOffset": 21973,
            "count": 0
          },
          {
            "startOffset": 22041,
            "endOffset": 22274,
            "count": 4
          },
          {
            "startOffset": 22173,
            "endOffset": 22205,
            "count": 0
          },
          {
            "startOffset": 22223,
            "endOffset": 22235,
            "count": 2
          },
          {
            "startOffset": 22253,
            "endOffset": 22265,
            "count": 2
          },
          {
            "startOffset": 22299,
            "endOffset": 22320,
            "count": 0
          },
          {
            "startOffset": 22478,
            "endOffset": 22553,
            "count": 0
          },
          {
            "startOffset": 22555,
            "endOffset": 22559,
            "count": 0
          },
          {
            "startOffset": 22581,
            "endOffset": 22585,
            "count": 0
          },
          {
            "startOffset": 22618,
            "endOffset": 22628,
            "count": 0
          },
          {
            "startOffset": 22715,
            "endOffset": 22723,
            "count": 0
          },
          {
            "startOffset": 22724,
            "endOffset": 22743,
            "count": 0
          },
          {
            "startOffset": 22813,
            "endOffset": 22817,
            "count": 2
          },
          {
            "startOffset": 22864,
            "endOffset": 22873,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_roundModifier2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 22938,
            "endOffset": 23196,
            "count": 0
          }
        ]
      },
      {
        "functionName": "snap2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 23209,
            "endOffset": 24357,
            "count": 0
          }
        ]
      },
      {
        "functionName": "random2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 24372,
            "endOffset": 24983,
            "count": 0
          }
        ]
      },
      {
        "functionName": "pipe2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 24996,
            "endOffset": 25268,
            "count": 0
          }
        ]
      },
      {
        "functionName": "unitize2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 25284,
            "endOffset": 25412,
            "count": 0
          }
        ]
      },
      {
        "functionName": "normalize2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 25430,
            "endOffset": 25512,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_wrapArray2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 25531,
            "endOffset": 25665,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wrap2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 25678,
            "endOffset": 25918,
            "count": 2
          },
          {
            "startOffset": 25760,
            "endOffset": 25804,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 25833,
            "endOffset": 25914,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wrapYoyo2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 25935,
            "endOffset": 26268,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_replaceRandom2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 26291,
            "endOffset": 26791,
            "count": 0
          }
        ]
      },
      {
        "functionName": "mapRange2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 26808,
            "endOffset": 27052,
            "count": 0
          }
        ]
      },
      {
        "functionName": "interpolate2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 27072,
            "endOffset": 28259,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_getLabelInDirection2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 28288,
            "endOffset": 28637,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_callback2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 28655,
            "endOffset": 29152,
            "count": 190
          },
          {
            "startOffset": 28849,
            "endOffset": 28866,
            "count": 151
          },
          {
            "startOffset": 28866,
            "endOffset": 28936,
            "count": 39
          },
          {
            "startOffset": 28957,
            "endOffset": 28978,
            "count": 39
          },
          {
            "startOffset": 28979,
            "endOffset": 28995,
            "count": 2
          },
          {
            "startOffset": 29008,
            "endOffset": 29032,
            "count": 0
          },
          {
            "startOffset": 29052,
            "endOffset": 29083,
            "count": 0
          },
          {
            "startOffset": 29084,
            "endOffset": 29106,
            "count": 39
          }
        ]
      },
      {
        "functionName": "_interrupt2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 29171,
            "endOffset": 29398,
            "count": 7
          },
          {
            "startOffset": 29263,
            "endOffset": 29308,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_createPlugin2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 29468,
            "endOffset": 30803,
            "count": 12
          },
          {
            "startOffset": 29523,
            "endOffset": 29530,
            "count": 0
          },
          {
            "startOffset": 29557,
            "endOffset": 29578,
            "count": 0
          },
          {
            "startOffset": 29613,
            "endOffset": 29632,
            "count": 0
          },
          {
            "startOffset": 29721,
            "endOffset": 29736,
            "count": 8
          },
          {
            "startOffset": 29737,
            "endOffset": 29781,
            "count": 8
          },
          {
            "startOffset": 29782,
            "endOffset": 29791,
            "count": 4
          },
          {
            "startOffset": 30149,
            "endOffset": 30649,
            "count": 8
          },
          {
            "startOffset": 30177,
            "endOffset": 30202,
            "count": 1
          },
          {
            "startOffset": 30202,
            "endOffset": 30464,
            "count": 7
          },
          {
            "startOffset": 30464,
            "endOffset": 30545,
            "count": 1
          },
          {
            "startOffset": 30545,
            "endOffset": 30575,
            "count": 7
          },
          {
            "startOffset": 30575,
            "endOffset": 30582,
            "count": 1
          },
          {
            "startOffset": 30583,
            "endOffset": 30630,
            "count": 6
          },
          {
            "startOffset": 30649,
            "endOffset": 30701,
            "count": 11
          },
          {
            "startOffset": 30701,
            "endOffset": 30745,
            "count": 6
          },
          {
            "startOffset": 30750,
            "endOffset": 30801,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Plugin",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 29739,
            "endOffset": 29781,
            "count": 104
          }
        ]
      },
      {
        "functionName": "_hue2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 31326,
            "endOffset": 31521,
            "count": 0
          }
        ]
      },
      {
        "functionName": "splitColor2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 31540,
            "endOffset": 33568,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_colorOrderData2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 33592,
            "endOffset": 33852,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_formatColors2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 33874,
            "endOffset": 34868,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 34886,
            "endOffset": 35081,
            "count": 1
          },
          {
            "startOffset": 35012,
            "endOffset": 35043,
            "count": 19
          }
        ]
      },
      {
        "functionName": "_colorStringFilter2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 35137,
            "endOffset": 35428,
            "count": 23
          },
          {
            "startOffset": 35267,
            "endOffset": 35426,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 35463,
            "endOffset": 38265,
            "count": 1
          }
        ]
      },
      {
        "functionName": "_tick2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 35692,
            "endOffset": 36404,
            "count": 245
          },
          {
            "startOffset": 35855,
            "endOffset": 35896,
            "count": 0
          },
          {
            "startOffset": 36015,
            "endOffset": 36024,
            "count": 4
          },
          {
            "startOffset": 36026,
            "endOffset": 36229,
            "count": 241
          },
          {
            "startOffset": 36185,
            "endOffset": 36201,
            "count": 0
          },
          {
            "startOffset": 36284,
            "endOffset": 36400,
            "count": 241
          }
        ]
      },
      {
        "functionName": "tick",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 36455,
            "endOffset": 36497,
            "count": 0
          }
        ]
      },
      {
        "functionName": "deltaRatio",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 36515,
            "endOffset": 36590,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wake",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 36602,
            "endOffset": 37325,
            "count": 9
          },
          {
            "startOffset": 36642,
            "endOffset": 37319,
            "count": 1
          },
          {
            "startOffset": 36763,
            "endOffset": 36768,
            "count": 0
          },
          {
            "startOffset": 36913,
            "endOffset": 36937,
            "count": 0
          },
          {
            "startOffset": 36938,
            "endOffset": 36959,
            "count": 0
          },
          {
            "startOffset": 36960,
            "endOffset": 36965,
            "count": 0
          },
          {
            "startOffset": 37131,
            "endOffset": 37147,
            "count": 0
          },
          {
            "startOffset": 37169,
            "endOffset": 37265,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_req",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 37172,
            "endOffset": 37265,
            "count": 0
          }
        ]
      },
      {
        "functionName": "sleep",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 37338,
            "endOffset": 37469,
            "count": 0
          }
        ]
      },
      {
        "functionName": "lagSmoothing",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 37489,
            "endOffset": 37652,
            "count": 0
          }
        ]
      },
      {
        "functionName": "fps",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 37663,
            "endOffset": 37766,
            "count": 0
          }
        ]
      },
      {
        "functionName": "add",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 37777,
            "endOffset": 38072,
            "count": 1
          },
          {
            "startOffset": 37842,
            "endOffset": 37932,
            "count": 0
          },
          {
            "startOffset": 38004,
            "endOffset": 38015,
            "count": 0
          }
        ]
      },
      {
        "functionName": "func",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 37844,
            "endOffset": 37932,
            "count": 0
          }
        ]
      },
      {
        "functionName": "remove",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 38086,
            "endOffset": 38213,
            "count": 1
          },
          {
            "startOffset": 38160,
            "endOffset": 38187,
            "count": 0
          },
          {
            "startOffset": 38188,
            "endOffset": 38198,
            "count": 0
          },
          {
            "startOffset": 38199,
            "endOffset": 38206,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_wake2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 38281,
            "endOffset": 38345,
            "count": 30
          },
          {
            "startOffset": 38325,
            "endOffset": 38342,
            "count": 7
          }
        ]
      },
      {
        "functionName": "_parseObjectInString2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 38463,
            "endOffset": 38927,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_valueInParentheses2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 38955,
            "endOffset": 39194,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_configEaseFromString2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 39224,
            "endOffset": 39600,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_invertEase2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 39620,
            "endOffset": 39707,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_propagateYoyoEase2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 39734,
            "endOffset": 40282,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_parseEase2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 40301,
            "endOffset": 40466,
            "count": 114
          },
          {
            "startOffset": 40358,
            "endOffset": 40371,
            "count": 6
          },
          {
            "startOffset": 40372,
            "endOffset": 40463,
            "count": 108
          },
          {
            "startOffset": 40393,
            "endOffset": 40399,
            "count": 13
          },
          {
            "startOffset": 40400,
            "endOffset": 40447,
            "count": 95
          },
          {
            "startOffset": 40417,
            "endOffset": 40447,
            "count": 0
          },
          {
            "startOffset": 40449,
            "endOffset": 40463,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_insertEase2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 40486,
            "endOffset": 41211,
            "count": 12
          },
          {
            "startOffset": 40571,
            "endOffset": 40652,
            "count": 3
          },
          {
            "startOffset": 40681,
            "endOffset": 40806,
            "count": 4
          }
        ]
      },
      {
        "functionName": "easeOut2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 40587,
            "endOffset": 40647,
            "count": 0
          }
        ]
      },
      {
        "functionName": "easeInOut2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 40699,
            "endOffset": 40801,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 40903,
            "endOffset": 41192,
            "count": 18
          },
          {
            "startOffset": 41048,
            "endOffset": 41188,
            "count": 54
          },
          {
            "startOffset": 41097,
            "endOffset": 41104,
            "count": 18
          },
          {
            "startOffset": 41105,
            "endOffset": 41142,
            "count": 36
          },
          {
            "startOffset": 41123,
            "endOffset": 41131,
            "count": 18
          },
          {
            "startOffset": 41132,
            "endOffset": 41142,
            "count": 18
          }
        ]
      },
      {
        "functionName": "_easeInOutFromOut2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 41237,
            "endOffset": 41391,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 41285,
            "endOffset": 41388,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_configElastic2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 41414,
            "endOffset": 42011,
            "count": 3
          },
          {
            "startOffset": 41492,
            "endOffset": 41503,
            "count": 0
          },
          {
            "startOffset": 41531,
            "endOffset": 41536,
            "count": 2
          },
          {
            "startOffset": 41537,
            "endOffset": 41543,
            "count": 1
          },
          {
            "startOffset": 41563,
            "endOffset": 41574,
            "count": 0
          },
          {
            "startOffset": 41617,
            "endOffset": 41621,
            "count": 0
          },
          {
            "startOffset": 41762,
            "endOffset": 41771,
            "count": 1
          },
          {
            "startOffset": 41772,
            "endOffset": 41867,
            "count": 2
          },
          {
            "startOffset": 41788,
            "endOffset": 41838,
            "count": 1
          },
          {
            "startOffset": 41839,
            "endOffset": 41867,
            "count": 1
          }
        ]
      },
      {
        "functionName": "easeOut2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 41634,
            "endOffset": 41738,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 41790,
            "endOffset": 41838,
            "count": 0
          }
        ]
      },
      {
        "functionName": "ease.config",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 41903,
            "endOffset": 41993,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_configBack2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 42031,
            "endOffset": 42475,
            "count": 3
          },
          {
            "startOffset": 42265,
            "endOffset": 42274,
            "count": 1
          },
          {
            "startOffset": 42275,
            "endOffset": 42370,
            "count": 2
          },
          {
            "startOffset": 42291,
            "endOffset": 42341,
            "count": 1
          },
          {
            "startOffset": 42342,
            "endOffset": 42370,
            "count": 1
          }
        ]
      },
      {
        "functionName": "easeOut2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 42147,
            "endOffset": 42241,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 42293,
            "endOffset": 42341,
            "count": 0
          }
        ]
      },
      {
        "functionName": "ease.config",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 42388,
            "endOffset": 42457,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 42530,
            "endOffset": 42883,
            "count": 6
          },
          {
            "startOffset": 42570,
            "endOffset": 42577,
            "count": 5
          },
          {
            "startOffset": 42578,
            "endOffset": 42581,
            "count": 1
          },
          {
            "startOffset": 42630,
            "endOffset": 42680,
            "count": 5
          },
          {
            "startOffset": 42681,
            "endOffset": 42714,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 42632,
            "endOffset": 42680,
            "count": 722
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 42683,
            "endOffset": 42714,
            "count": 131
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 42716,
            "endOffset": 42772,
            "count": 945
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 42774,
            "endOffset": 42879,
            "count": 239
          },
          {
            "startOffset": 42807,
            "endOffset": 42835,
            "count": 121
          },
          {
            "startOffset": 42836,
            "endOffset": 42874,
            "count": 118
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 43041,
            "endOffset": 43393,
            "count": 1
          }
        ]
      },
      {
        "functionName": "easeOut2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 43114,
            "endOffset": 43306,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 43332,
            "endOffset": 43380,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 43430,
            "endOffset": 43489,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 43512,
            "endOffset": 43561,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 43584,
            "endOffset": 43647,
            "count": 0
          }
        ]
      },
      {
        "functionName": "config",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 43800,
            "endOffset": 44094,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 44220,
            "endOffset": 44296,
            "count": 6
          }
        ]
      },
      {
        "functionName": "GSCache2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 44313,
            "endOffset": 44551,
            "count": 35
          },
          {
            "startOffset": 44465,
            "endOffset": 44478,
            "count": 30
          },
          {
            "startOffset": 44479,
            "endOffset": 44493,
            "count": 5
          },
          {
            "startOffset": 44516,
            "endOffset": 44535,
            "count": 30
          },
          {
            "startOffset": 44536,
            "endOffset": 44548,
            "count": 5
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 44569,
            "endOffset": 54236,
            "count": 1
          }
        ]
      },
      {
        "functionName": "Animation2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 44584,
            "endOffset": 45063,
            "count": 110
          },
          {
            "startOffset": 44664,
            "endOffset": 44668,
            "count": 65
          },
          {
            "startOffset": 44718,
            "endOffset": 44722,
            "count": 0
          },
          {
            "startOffset": 44737,
            "endOffset": 44741,
            "count": 108
          },
          {
            "startOffset": 44743,
            "endOffset": 44845,
            "count": 2
          },
          {
            "startOffset": 44820,
            "endOffset": 44838,
            "count": 0
          },
          {
            "startOffset": 44955,
            "endOffset": 45022,
            "count": 29
          },
          {
            "startOffset": 45041,
            "endOffset": 45058,
            "count": 2
          }
        ]
      },
      {
        "functionName": "delay",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 45118,
            "endOffset": 45358,
            "count": 0
          }
        ]
      },
      {
        "functionName": "duration",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 45380,
            "endOffset": 45570,
            "count": 17
          },
          {
            "startOffset": 45435,
            "endOffset": 45529,
            "count": 2
          },
          {
            "startOffset": 45473,
            "endOffset": 45520,
            "count": 0
          },
          {
            "startOffset": 45530,
            "endOffset": 45565,
            "count": 15
          },
          {
            "startOffset": 45553,
            "endOffset": 45565,
            "count": 12
          }
        ]
      },
      {
        "functionName": "totalDuration",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 45597,
            "endOffset": 45831,
            "count": 115
          },
          {
            "startOffset": 45656,
            "endOffset": 45688,
            "count": 113
          },
          {
            "startOffset": 45688,
            "endOffset": 45757,
            "count": 2
          },
          {
            "startOffset": 45757,
            "endOffset": 45764,
            "count": 0
          },
          {
            "startOffset": 45765,
            "endOffset": 45825,
            "count": 2
          }
        ]
      },
      {
        "functionName": "totalTime",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 45854,
            "endOffset": 47035,
            "count": 16
          },
          {
            "startOffset": 45943,
            "endOffset": 45976,
            "count": 0
          },
          {
            "startOffset": 46019,
            "endOffset": 46046,
            "count": 4
          },
          {
            "startOffset": 46047,
            "endOffset": 46058,
            "count": 4
          },
          {
            "startOffset": 46060,
            "endOffset": 46714,
            "count": 4
          },
          {
            "startOffset": 46120,
            "endOffset": 46136,
            "count": 0
          },
          {
            "startOffset": 46137,
            "endOffset": 46168,
            "count": 0
          },
          {
            "startOffset": 46208,
            "endOffset": 46467,
            "count": 0
          },
          {
            "startOffset": 46491,
            "endOffset": 46521,
            "count": 1
          },
          {
            "startOffset": 46522,
            "endOffset": 46630,
            "count": 1
          },
          {
            "startOffset": 46566,
            "endOffset": 46599,
            "count": 0
          },
          {
            "startOffset": 46600,
            "endOffset": 46629,
            "count": 0
          },
          {
            "startOffset": 46632,
            "endOffset": 46708,
            "count": 1
          },
          {
            "startOffset": 46750,
            "endOffset": 46782,
            "count": 0
          },
          {
            "startOffset": 46783,
            "endOffset": 46837,
            "count": 0
          },
          {
            "startOffset": 46838,
            "endOffset": 46902,
            "count": 0
          },
          {
            "startOffset": 46921,
            "endOffset": 46950,
            "count": 0
          }
        ]
      },
      {
        "functionName": "time",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 47053,
            "endOffset": 47295,
            "count": 0
          }
        ]
      },
      {
        "functionName": "totalProgress",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 47322,
            "endOffset": 47557,
            "count": 0
          }
        ]
      },
      {
        "functionName": "progress",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 47579,
            "endOffset": 47881,
            "count": 7
          },
          {
            "startOffset": 47650,
            "endOffset": 47791,
            "count": 0
          },
          {
            "startOffset": 47810,
            "endOffset": 47847,
            "count": 4
          },
          {
            "startOffset": 47848,
            "endOffset": 47876,
            "count": 3
          },
          {
            "startOffset": 47869,
            "endOffset": 47872,
            "count": 0
          }
        ]
      },
      {
        "functionName": "iteration",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 47904,
            "endOffset": 48180,
            "count": 0
          }
        ]
      },
      {
        "functionName": "timeScale",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 48203,
            "endOffset": 48746,
            "count": 110
          },
          {
            "startOffset": 48313,
            "endOffset": 48316,
            "count": 0
          },
          {
            "startOffset": 48335,
            "endOffset": 48431,
            "count": 0
          },
          {
            "startOffset": 48432,
            "endOffset": 48482,
            "count": 0
          },
          {
            "startOffset": 48483,
            "endOffset": 48496,
            "count": 0
          },
          {
            "startOffset": 48521,
            "endOffset": 48525,
            "count": 0
          },
          {
            "startOffset": 48551,
            "endOffset": 48573,
            "count": 0
          },
          {
            "startOffset": 48574,
            "endOffset": 48577,
            "count": 0
          },
          {
            "startOffset": 48578,
            "endOffset": 48589,
            "count": 0
          }
        ]
      },
      {
        "functionName": "paused",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 48766,
            "endOffset": 49336,
            "count": 4
          },
          {
            "startOffset": 48818,
            "endOffset": 48848,
            "count": 0
          },
          {
            "startOffset": 48877,
            "endOffset": 49315,
            "count": 2
          },
          {
            "startOffset": 49040,
            "endOffset": 49309,
            "count": 0
          }
        ]
      },
      {
        "functionName": "startTime",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 49359,
            "endOffset": 49639,
            "count": 0
          }
        ]
      },
      {
        "functionName": "endTime",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 49660,
            "endOffset": 49821,
            "count": 0
          }
        ]
      },
      {
        "functionName": "rawTime",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 49842,
            "endOffset": 50170,
            "count": 11
          },
          {
            "startOffset": 49903,
            "endOffset": 49914,
            "count": 9
          },
          {
            "startOffset": 49935,
            "endOffset": 49948,
            "count": 6
          },
          {
            "startOffset": 49949,
            "endOffset": 50165,
            "count": 5
          },
          {
            "startOffset": 49963,
            "endOffset": 50035,
            "count": 0
          },
          {
            "startOffset": 50036,
            "endOffset": 50078,
            "count": 0
          },
          {
            "startOffset": 50091,
            "endOffset": 50104,
            "count": 0
          }
        ]
      },
      {
        "functionName": "revert",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 50190,
            "endOffset": 50626,
            "count": 18
          },
          {
            "startOffset": 50245,
            "endOffset": 50283,
            "count": 0
          },
          {
            "startOffset": 50370,
            "endOffset": 50386,
            "count": 4
          },
          {
            "startOffset": 50388,
            "endOffset": 50502,
            "count": 16
          },
          {
            "startOffset": 50410,
            "endOffset": 50442,
            "count": 1
          },
          {
            "startOffset": 50530,
            "endOffset": 50555,
            "count": 17
          },
          {
            "startOffset": 50556,
            "endOffset": 50570,
            "count": 9
          }
        ]
      },
      {
        "functionName": "globalTime",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 50650,
            "endOffset": 50978,
            "count": 4
          },
          {
            "startOffset": 50741,
            "endOffset": 50762,
            "count": 0
          },
          {
            "startOffset": 50786,
            "endOffset": 50897,
            "count": 8
          },
          {
            "startOffset": 50852,
            "endOffset": 50856,
            "count": 0
          },
          {
            "startOffset": 50922,
            "endOffset": 50934,
            "count": 0
          },
          {
            "startOffset": 50935,
            "endOffset": 50966,
            "count": 0
          }
        ]
      },
      {
        "functionName": "repeat",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 50998,
            "endOffset": 51215,
            "count": 0
          }
        ]
      },
      {
        "functionName": "repeatDelay",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 51240,
            "endOffset": 51469,
            "count": 0
          }
        ]
      },
      {
        "functionName": "yoyo",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 51487,
            "endOffset": 51615,
            "count": 0
          }
        ]
      },
      {
        "functionName": "seek",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 51633,
            "endOffset": 51766,
            "count": 0
          }
        ]
      },
      {
        "functionName": "restart",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 51787,
            "endOffset": 51935,
            "count": 0
          }
        ]
      },
      {
        "functionName": "play",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 51953,
            "endOffset": 52094,
            "count": 0
          }
        ]
      },
      {
        "functionName": "reverse",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 52115,
            "endOffset": 52282,
            "count": 0
          }
        ]
      },
      {
        "functionName": "pause",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 52301,
            "endOffset": 52432,
            "count": 4
          },
          {
            "startOffset": 52361,
            "endOffset": 52397,
            "count": 0
          }
        ]
      },
      {
        "functionName": "resume",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 52452,
            "endOffset": 52506,
            "count": 0
          }
        ]
      },
      {
        "functionName": "reversed",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 52528,
            "endOffset": 52729,
            "count": 0
          }
        ]
      },
      {
        "functionName": "invalidate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 52753,
            "endOffset": 52861,
            "count": 0
          }
        ]
      },
      {
        "functionName": "isActive",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 52883,
            "endOffset": 53142,
            "count": 0
          }
        ]
      },
      {
        "functionName": "eventCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 53169,
            "endOffset": 53543,
            "count": 0
          }
        ]
      },
      {
        "functionName": "then",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 53561,
            "endOffset": 54151,
            "count": 0
          }
        ]
      },
      {
        "functionName": "kill",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 54169,
            "endOffset": 54212,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 54537,
            "endOffset": 73117,
            "count": 1
          }
        ]
      },
      {
        "functionName": "Timeline2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 54603,
            "endOffset": 55244,
            "count": 3
          },
          {
            "startOffset": 54680,
            "endOffset": 54704,
            "count": 0
          },
          {
            "startOffset": 54961,
            "endOffset": 55051,
            "count": 2
          },
          {
            "startOffset": 55071,
            "endOffset": 55089,
            "count": 0
          },
          {
            "startOffset": 55107,
            "endOffset": 55128,
            "count": 0
          },
          {
            "startOffset": 55153,
            "endOffset": 55221,
            "count": 0
          }
        ]
      },
      {
        "functionName": "to",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 55297,
            "endOffset": 55398,
            "count": 4
          }
        ]
      },
      {
        "functionName": "from",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 55417,
            "endOffset": 55520,
            "count": 0
          }
        ]
      },
      {
        "functionName": "fromTo",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 55541,
            "endOffset": 55658,
            "count": 0
          }
        ]
      },
      {
        "functionName": "set",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 55676,
            "endOffset": 55960,
            "count": 0
          }
        ]
      },
      {
        "functionName": "call",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 55979,
            "endOffset": 56109,
            "count": 0
          }
        ]
      },
      {
        "functionName": "staggerTo",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 56133,
            "endOffset": 56500,
            "count": 0
          }
        ]
      },
      {
        "functionName": "staggerFrom",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 56526,
            "endOffset": 56846,
            "count": 0
          }
        ]
      },
      {
        "functionName": "staggerFromTo",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 56874,
            "endOffset": 57218,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render3",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 57239,
            "endOffset": 63832,
            "count": 307
          },
          {
            "startOffset": 57342,
            "endOffset": 57364,
            "count": 42
          },
          {
            "startOffset": 57365,
            "endOffset": 57377,
            "count": 265
          },
          {
            "startOffset": 57419,
            "endOffset": 57422,
            "count": 3
          },
          {
            "startOffset": 57423,
            "endOffset": 57449,
            "count": 304
          },
          {
            "startOffset": 57501,
            "endOffset": 57527,
            "count": 4
          },
          {
            "startOffset": 57678,
            "endOffset": 57693,
            "count": 66
          },
          {
            "startOffset": 57694,
            "endOffset": 57711,
            "count": 0
          },
          {
            "startOffset": 57712,
            "endOffset": 57729,
            "count": 0
          },
          {
            "startOffset": 57761,
            "endOffset": 57769,
            "count": 3
          },
          {
            "startOffset": 57770,
            "endOffset": 57786,
            "count": 2
          },
          {
            "startOffset": 57788,
            "endOffset": 63811,
            "count": 305
          },
          {
            "startOffset": 57824,
            "endOffset": 57830,
            "count": 0
          },
          {
            "startOffset": 57832,
            "endOffset": 57925,
            "count": 0
          },
          {
            "startOffset": 58061,
            "endOffset": 58180,
            "count": 0
          },
          {
            "startOffset": 58205,
            "endOffset": 60375,
            "count": 0
          },
          {
            "startOffset": 60401,
            "endOffset": 60418,
            "count": 0
          },
          {
            "startOffset": 60419,
            "endOffset": 60436,
            "count": 0
          },
          {
            "startOffset": 60438,
            "endOffset": 60631,
            "count": 0
          },
          {
            "startOffset": 60740,
            "endOffset": 60876,
            "count": 3
          },
          {
            "startOffset": 60897,
            "endOffset": 60904,
            "count": 3
          },
          {
            "startOffset": 60905,
            "endOffset": 60923,
            "count": 2
          },
          {
            "startOffset": 60924,
            "endOffset": 60937,
            "count": 2
          },
          {
            "startOffset": 60939,
            "endOffset": 61054,
            "count": 2
          },
          {
            "startOffset": 61012,
            "endOffset": 61046,
            "count": 0
          },
          {
            "startOffset": 61101,
            "endOffset": 61834,
            "count": 304
          },
          {
            "startOffset": 61154,
            "endOffset": 61826,
            "count": 2949
          },
          {
            "startOffset": 61212,
            "endOffset": 61235,
            "count": 1042
          },
          {
            "startOffset": 61237,
            "endOffset": 61249,
            "count": 2447
          },
          {
            "startOffset": 61250,
            "endOffset": 61273,
            "count": 1995
          },
          {
            "startOffset": 61275,
            "endOffset": 61792,
            "count": 1995
          },
          {
            "startOffset": 61316,
            "endOffset": 61399,
            "count": 0
          },
          {
            "startOffset": 61475,
            "endOffset": 61565,
            "count": 0
          },
          {
            "startOffset": 61640,
            "endOffset": 61654,
            "count": 0
          },
          {
            "startOffset": 61656,
            "endOffset": 61780,
            "count": 0
          },
          {
            "startOffset": 61834,
            "endOffset": 62733,
            "count": 1
          },
          {
            "startOffset": 61923,
            "endOffset": 61929,
            "count": 0
          },
          {
            "startOffset": 61953,
            "endOffset": 62725,
            "count": 2
          },
          {
            "startOffset": 62121,
            "endOffset": 62204,
            "count": 0
          },
          {
            "startOffset": 62288,
            "endOffset": 62386,
            "count": 0
          },
          {
            "startOffset": 62410,
            "endOffset": 62461,
            "count": 0
          },
          {
            "startOffset": 62513,
            "endOffset": 62527,
            "count": 0
          },
          {
            "startOffset": 62529,
            "endOffset": 62679,
            "count": 0
          },
          {
            "startOffset": 62755,
            "endOffset": 62773,
            "count": 0
          },
          {
            "startOffset": 62775,
            "endOffset": 63060,
            "count": 0
          },
          {
            "startOffset": 63082,
            "endOffset": 63100,
            "count": 0
          },
          {
            "startOffset": 63101,
            "endOffset": 63137,
            "count": 0
          },
          {
            "startOffset": 63164,
            "endOffset": 63202,
            "count": 1
          },
          {
            "startOffset": 63203,
            "endOffset": 63224,
            "count": 304
          },
          {
            "startOffset": 63213,
            "endOffset": 63224,
            "count": 1
          },
          {
            "startOffset": 63226,
            "endOffset": 63805,
            "count": 1
          },
          {
            "startOffset": 63266,
            "endOffset": 63311,
            "count": 0
          },
          {
            "startOffset": 63367,
            "endOffset": 63374,
            "count": 0
          },
          {
            "startOffset": 63411,
            "endOffset": 63436,
            "count": 0
          },
          {
            "startOffset": 63520,
            "endOffset": 63532,
            "count": 0
          },
          {
            "startOffset": 63544,
            "endOffset": 63555,
            "count": 0
          },
          {
            "startOffset": 63556,
            "endOffset": 63564,
            "count": 0
          },
          {
            "startOffset": 63647,
            "endOffset": 63668,
            "count": 0
          },
          {
            "startOffset": 63702,
            "endOffset": 63744,
            "count": 0
          },
          {
            "startOffset": 63745,
            "endOffset": 63760,
            "count": 0
          }
        ]
      },
      {
        "functionName": "add",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 63850,
            "endOffset": 64466,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getChildren",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 64492,
            "endOffset": 65194,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getById2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 65216,
            "endOffset": 65418,
            "count": 0
          }
        ]
      },
      {
        "functionName": "remove",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 65439,
            "endOffset": 65754,
            "count": 103
          },
          {
            "startOffset": 65490,
            "endOffset": 65535,
            "count": 0
          },
          {
            "startOffset": 65564,
            "endOffset": 65610,
            "count": 0
          },
          {
            "startOffset": 65683,
            "endOffset": 65723,
            "count": 14
          }
        ]
      },
      {
        "functionName": "totalTime",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 65778,
            "endOffset": 66212,
            "count": 0
          }
        ]
      },
      {
        "functionName": "addLabel",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 66235,
            "endOffset": 66349,
            "count": 0
          }
        ]
      },
      {
        "functionName": "removeLabel",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 66375,
            "endOffset": 66456,
            "count": 0
          }
        ]
      },
      {
        "functionName": "addPause",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 66479,
            "endOffset": 66712,
            "count": 0
          }
        ]
      },
      {
        "functionName": "removePause",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 66738,
            "endOffset": 67012,
            "count": 0
          }
        ]
      },
      {
        "functionName": "killTweensOf",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 67039,
            "endOffset": 67283,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getTweensOf2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 67309,
            "endOffset": 68005,
            "count": 0
          }
        ]
      },
      {
        "functionName": "tweenTo",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 68027,
            "endOffset": 69104,
            "count": 0
          }
        ]
      },
      {
        "functionName": "tweenFromTo",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 69130,
            "endOffset": 69328,
            "count": 0
          }
        ]
      },
      {
        "functionName": "recent",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 69349,
            "endOffset": 69397,
            "count": 0
          }
        ]
      },
      {
        "functionName": "nextLabel",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 69421,
            "endOffset": 69596,
            "count": 0
          }
        ]
      },
      {
        "functionName": "previousLabel",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 69624,
            "endOffset": 69810,
            "count": 0
          }
        ]
      },
      {
        "functionName": "currentLabel",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 69837,
            "endOffset": 69969,
            "count": 0
          }
        ]
      },
      {
        "functionName": "shiftChildren",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 69997,
            "endOffset": 70538,
            "count": 0
          }
        ]
      },
      {
        "functionName": "invalidate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 70563,
            "endOffset": 70787,
            "count": 0
          }
        ]
      },
      {
        "functionName": "clear",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 70807,
            "endOffset": 71175,
            "count": 0
          }
        ]
      },
      {
        "functionName": "totalDuration",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 71203,
            "endOffset": 72493,
            "count": 55
          },
          {
            "startOffset": 71353,
            "endOffset": 71487,
            "count": 0
          },
          {
            "startOffset": 71509,
            "endOffset": 72466,
            "count": 48
          },
          {
            "startOffset": 71559,
            "endOffset": 72340,
            "count": 730
          },
          {
            "startOffset": 71610,
            "endOffset": 71634,
            "count": 0
          },
          {
            "startOffset": 71696,
            "endOffset": 71709,
            "count": 89
          },
          {
            "startOffset": 71710,
            "endOffset": 71722,
            "count": 0
          },
          {
            "startOffset": 71723,
            "endOffset": 71737,
            "count": 0
          },
          {
            "startOffset": 71739,
            "endOffset": 71850,
            "count": 0
          },
          {
            "startOffset": 71919,
            "endOffset": 71931,
            "count": 0
          },
          {
            "startOffset": 71933,
            "endOffset": 72249,
            "count": 0
          },
          {
            "startOffset": 72275,
            "endOffset": 72287,
            "count": 89
          },
          {
            "startOffset": 72288,
            "endOffset": 72309,
            "count": 82
          },
          {
            "startOffset": 72391,
            "endOffset": 72410,
            "count": 42
          },
          {
            "startOffset": 72411,
            "endOffset": 72423,
            "count": 0
          }
        ]
      },
      {
        "functionName": "updateRoot",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 72520,
            "endOffset": 73094,
            "count": 241
          },
          {
            "startOffset": 72754,
            "endOffset": 73090,
            "count": 2
          },
          {
            "startOffset": 72796,
            "endOffset": 72802,
            "count": 0
          },
          {
            "startOffset": 72969,
            "endOffset": 72982,
            "count": 4
          },
          {
            "startOffset": 73047,
            "endOffset": 73065,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_addComplexStringPropTween2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 73244,
            "endOffset": 74944,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_addPropTween2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 74966,
            "endOffset": 76417,
            "count": 2
          },
          {
            "startOffset": 75098,
            "endOffset": 75141,
            "count": 0
          },
          {
            "startOffset": 75216,
            "endOffset": 75409,
            "count": 0
          },
          {
            "startOffset": 75462,
            "endOffset": 75510,
            "count": 0
          },
          {
            "startOffset": 75538,
            "endOffset": 75785,
            "count": 0
          },
          {
            "startOffset": 75802,
            "endOffset": 75824,
            "count": 0
          },
          {
            "startOffset": 75825,
            "endOffset": 75847,
            "count": 0
          },
          {
            "startOffset": 76030,
            "endOffset": 76046,
            "count": 0
          },
          {
            "startOffset": 76091,
            "endOffset": 76113,
            "count": 0
          },
          {
            "startOffset": 76130,
            "endOffset": 76168,
            "count": 0
          },
          {
            "startOffset": 76203,
            "endOffset": 76242,
            "count": 0
          },
          {
            "startOffset": 76243,
            "endOffset": 76271,
            "count": 0
          },
          {
            "startOffset": 76375,
            "endOffset": 76398,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_processVars2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 76438,
            "endOffset": 76918,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_checkPlugin2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 76939,
            "endOffset": 77592,
            "count": 2
          },
          {
            "startOffset": 77151,
            "endOffset": 77212,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_initTween2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 77659,
            "endOffset": 83668,
            "count": 112
          },
          {
            "startOffset": 78117,
            "endOffset": 78138,
            "count": 12
          },
          {
            "startOffset": 78139,
            "endOffset": 78148,
            "count": 100
          },
          {
            "startOffset": 78194,
            "endOffset": 78217,
            "count": 0
          },
          {
            "startOffset": 78355,
            "endOffset": 78379,
            "count": 2
          },
          {
            "startOffset": 78370,
            "endOffset": 78378,
            "count": 0
          },
          {
            "startOffset": 78380,
            "endOffset": 78398,
            "count": 2
          },
          {
            "startOffset": 78476,
            "endOffset": 78554,
            "count": 0
          },
          {
            "startOffset": 78575,
            "endOffset": 78589,
            "count": 0
          },
          {
            "startOffset": 78590,
            "endOffset": 78607,
            "count": 0
          },
          {
            "startOffset": 78609,
            "endOffset": 78703,
            "count": 0
          },
          {
            "startOffset": 78724,
            "endOffset": 78746,
            "count": 110
          },
          {
            "startOffset": 78758,
            "endOffset": 78787,
            "count": 2
          },
          {
            "startOffset": 78771,
            "endOffset": 78787,
            "count": 0
          },
          {
            "startOffset": 78789,
            "endOffset": 83514,
            "count": 110
          },
          {
            "startOffset": 78848,
            "endOffset": 78851,
            "count": 0
          },
          {
            "startOffset": 78879,
            "endOffset": 78900,
            "count": 106
          },
          {
            "startOffset": 78977,
            "endOffset": 79254,
            "count": 8
          },
          {
            "startOffset": 79008,
            "endOffset": 79034,
            "count": 0
          },
          {
            "startOffset": 79051,
            "endOffset": 79066,
            "count": 4
          },
          {
            "startOffset": 79067,
            "endOffset": 79085,
            "count": 4
          },
          {
            "startOffset": 79086,
            "endOffset": 79100,
            "count": 4
          },
          {
            "startOffset": 79101,
            "endOffset": 79131,
            "count": 4
          },
          {
            "startOffset": 79132,
            "endOffset": 79218,
            "count": 4
          },
          {
            "startOffset": 79195,
            "endOffset": 79217,
            "count": 0
          },
          {
            "startOffset": 79272,
            "endOffset": 80013,
            "count": 0
          },
          {
            "startOffset": 80036,
            "endOffset": 80042,
            "count": 16
          },
          {
            "startOffset": 80044,
            "endOffset": 81855,
            "count": 16
          },
          {
            "startOffset": 80070,
            "endOffset": 81849,
            "count": 8
          },
          {
            "startOffset": 80085,
            "endOffset": 80113,
            "count": 0
          },
          {
            "startOffset": 81381,
            "endOffset": 81415,
            "count": 0
          },
          {
            "startOffset": 81570,
            "endOffset": 81664,
            "count": 0
          },
          {
            "startOffset": 81725,
            "endOffset": 81795,
            "count": 0
          },
          {
            "startOffset": 81855,
            "endOffset": 81907,
            "count": 102
          },
          {
            "startOffset": 81907,
            "endOffset": 81927,
            "count": 85
          },
          {
            "startOffset": 81928,
            "endOffset": 81943,
            "count": 17
          },
          {
            "startOffset": 81936,
            "endOffset": 81943,
            "count": 8
          },
          {
            "startOffset": 81986,
            "endOffset": 83414,
            "count": 106
          },
          {
            "startOffset": 82043,
            "endOffset": 82072,
            "count": 0
          },
          {
            "startOffset": 82145,
            "endOffset": 82166,
            "count": 32
          },
          {
            "startOffset": 82167,
            "endOffset": 82183,
            "count": 20
          },
          {
            "startOffset": 82223,
            "endOffset": 82226,
            "count": 98
          },
          {
            "startOffset": 82227,
            "endOffset": 82256,
            "count": 8
          },
          {
            "startOffset": 82276,
            "endOffset": 82379,
            "count": 102
          },
          {
            "startOffset": 82381,
            "endOffset": 82647,
            "count": 102
          },
          {
            "startOffset": 82618,
            "endOffset": 82638,
            "count": 0
          },
          {
            "startOffset": 82667,
            "endOffset": 82681,
            "count": 102
          },
          {
            "startOffset": 82683,
            "endOffset": 83051,
            "count": 4
          },
          {
            "startOffset": 82714,
            "endOffset": 83043,
            "count": 2
          },
          {
            "startOffset": 82849,
            "endOffset": 82869,
            "count": 0
          },
          {
            "startOffset": 82882,
            "endOffset": 83033,
            "count": 0
          },
          {
            "startOffset": 83068,
            "endOffset": 83083,
            "count": 0
          },
          {
            "startOffset": 83084,
            "endOffset": 83119,
            "count": 0
          },
          {
            "startOffset": 83145,
            "endOffset": 83157,
            "count": 0
          },
          {
            "startOffset": 83159,
            "endOffset": 83351,
            "count": 0
          },
          {
            "startOffset": 83368,
            "endOffset": 83375,
            "count": 104
          },
          {
            "startOffset": 83376,
            "endOffset": 83407,
            "count": 93
          },
          {
            "startOffset": 83414,
            "endOffset": 83431,
            "count": 102
          },
          {
            "startOffset": 83431,
            "endOffset": 83466,
            "count": 0
          },
          {
            "startOffset": 83486,
            "endOffset": 83509,
            "count": 0
          },
          {
            "startOffset": 83514,
            "endOffset": 83576,
            "count": 104
          },
          {
            "startOffset": 83576,
            "endOffset": 83588,
            "count": 0
          },
          {
            "startOffset": 83590,
            "endOffset": 83605,
            "count": 104
          },
          {
            "startOffset": 83619,
            "endOffset": 83631,
            "count": 0
          },
          {
            "startOffset": 83632,
            "endOffset": 83665,
            "count": 0
          }
        ]
      },
      {
        "functionName": "tween._startAt.Tween.set._setDefaults.onUpdate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 79567,
            "endOffset": 79636,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 82534,
            "endOffset": 82591,
            "count": 171
          }
        ]
      },
      {
        "functionName": "_updatePropTweens2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 83694,
            "endOffset": 84864,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_addAliasesToVars2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 84890,
            "endOffset": 85355,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_parseKeyframe2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 85378,
            "endOffset": 85910,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_parseFuncOrString2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 85937,
            "endOffset": 86152,
            "count": 8
          },
          {
            "startOffset": 86030,
            "endOffset": 86069,
            "count": 0
          },
          {
            "startOffset": 86089,
            "endOffset": 86117,
            "count": 0
          },
          {
            "startOffset": 86118,
            "endOffset": 86141,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 86372,
            "endOffset": 86430,
            "count": 24
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 86445,
            "endOffset": 99817,
            "count": 1
          }
        ]
      },
      {
        "functionName": "Tween2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 86510,
            "endOffset": 91441,
            "count": 107
          },
          {
            "startOffset": 86616,
            "endOffset": 86701,
            "count": 3
          },
          {
            "startOffset": 86750,
            "endOffset": 86756,
            "count": 0
          },
          {
            "startOffset": 87166,
            "endOffset": 87184,
            "count": 95
          },
          {
            "startOffset": 87221,
            "endOffset": 87246,
            "count": 98
          },
          {
            "startOffset": 87247,
            "endOffset": 87270,
            "count": 9
          },
          {
            "startOffset": 87271,
            "endOffset": 87289,
            "count": 98
          },
          {
            "startOffset": 87291,
            "endOffset": 87302,
            "count": 0
          },
          {
            "startOffset": 87455,
            "endOffset": 87552,
            "count": 0
          },
          {
            "startOffset": 87645,
            "endOffset": 87673,
            "count": 105
          },
          {
            "startOffset": 87674,
            "endOffset": 87699,
            "count": 105
          },
          {
            "startOffset": 87701,
            "endOffset": 90641,
            "count": 2
          },
          {
            "startOffset": 87884,
            "endOffset": 87905,
            "count": 0
          },
          {
            "startOffset": 88047,
            "endOffset": 88075,
            "count": 0
          },
          {
            "startOffset": 88076,
            "endOffset": 88101,
            "count": 0
          },
          {
            "startOffset": 88225,
            "endOffset": 88456,
            "count": 0
          },
          {
            "startOffset": 88489,
            "endOffset": 89302,
            "count": 4
          },
          {
            "startOffset": 88598,
            "endOffset": 88627,
            "count": 0
          },
          {
            "startOffset": 88658,
            "endOffset": 88693,
            "count": 0
          },
          {
            "startOffset": 88965,
            "endOffset": 88969,
            "count": 0
          },
          {
            "startOffset": 89011,
            "endOffset": 89021,
            "count": 0
          },
          {
            "startOffset": 89022,
            "endOffset": 89035,
            "count": 0
          },
          {
            "startOffset": 89037,
            "endOffset": 89162,
            "count": 0
          },
          {
            "startOffset": 89251,
            "endOffset": 89254,
            "count": 0
          },
          {
            "startOffset": 89348,
            "endOffset": 89369,
            "count": 0
          },
          {
            "startOffset": 89378,
            "endOffset": 90574,
            "count": 0
          },
          {
            "startOffset": 90641,
            "endOffset": 90681,
            "count": 105
          },
          {
            "startOffset": 90709,
            "endOffset": 90732,
            "count": 0
          },
          {
            "startOffset": 90734,
            "endOffset": 90879,
            "count": 0
          },
          {
            "startOffset": 90968,
            "endOffset": 90987,
            "count": 0
          },
          {
            "startOffset": 91005,
            "endOffset": 91027,
            "count": 0
          },
          {
            "startOffset": 91053,
            "endOffset": 91245,
            "count": 89
          },
          {
            "startOffset": 91066,
            "endOffset": 91079,
            "count": 11
          },
          {
            "startOffset": 91080,
            "endOffset": 91128,
            "count": 11
          },
          {
            "startOffset": 91129,
            "endOffset": 91160,
            "count": 8
          },
          {
            "startOffset": 91161,
            "endOffset": 91217,
            "count": 8
          },
          {
            "startOffset": 91218,
            "endOffset": 91245,
            "count": 8
          },
          {
            "startOffset": 91247,
            "endOffset": 91334,
            "count": 26
          },
          {
            "startOffset": 91353,
            "endOffset": 91417,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 89660,
            "endOffset": 89742,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 90017,
            "endOffset": 90081,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render3",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 91495,
            "endOffset": 95576,
            "count": 2125
          },
          {
            "startOffset": 91679,
            "endOffset": 91693,
            "count": 104
          },
          {
            "startOffset": 91694,
            "endOffset": 91700,
            "count": 104
          },
          {
            "startOffset": 91701,
            "endOffset": 91739,
            "count": 2021
          },
          {
            "startOffset": 91724,
            "endOffset": 91727,
            "count": 134
          },
          {
            "startOffset": 91728,
            "endOffset": 91739,
            "count": 1887
          },
          {
            "startOffset": 91842,
            "endOffset": 91921,
            "count": 35
          },
          {
            "startOffset": 91921,
            "endOffset": 95555,
            "count": 2090
          },
          {
            "startOffset": 91953,
            "endOffset": 91966,
            "count": 112
          },
          {
            "startOffset": 91967,
            "endOffset": 91975,
            "count": 34
          },
          {
            "startOffset": 91976,
            "endOffset": 92008,
            "count": 29
          },
          {
            "startOffset": 91994,
            "endOffset": 92008,
            "count": 0
          },
          {
            "startOffset": 92009,
            "endOffset": 92059,
            "count": 29
          },
          {
            "startOffset": 92026,
            "endOffset": 92059,
            "count": 6
          },
          {
            "startOffset": 92061,
            "endOffset": 95555,
            "count": 2061
          },
          {
            "startOffset": 92140,
            "endOffset": 93491,
            "count": 240
          },
          {
            "startOffset": 92216,
            "endOffset": 92229,
            "count": 0
          },
          {
            "startOffset": 92231,
            "endOffset": 92331,
            "count": 0
          },
          {
            "startOffset": 92413,
            "endOffset": 92482,
            "count": 0
          },
          {
            "startOffset": 92563,
            "endOffset": 92616,
            "count": 124
          },
          {
            "startOffset": 92618,
            "endOffset": 92680,
            "count": 0
          },
          {
            "startOffset": 92702,
            "endOffset": 92717,
            "count": 0
          },
          {
            "startOffset": 92795,
            "endOffset": 92869,
            "count": 118
          },
          {
            "startOffset": 92969,
            "endOffset": 92978,
            "count": 0
          },
          {
            "startOffset": 92979,
            "endOffset": 92995,
            "count": 0
          },
          {
            "startOffset": 92996,
            "endOffset": 93026,
            "count": 0
          },
          {
            "startOffset": 93028,
            "endOffset": 93093,
            "count": 0
          },
          {
            "startOffset": 93135,
            "endOffset": 93483,
            "count": 2
          },
          {
            "startOffset": 93157,
            "endOffset": 93171,
            "count": 0
          },
          {
            "startOffset": 93172,
            "endOffset": 93212,
            "count": 0
          },
          {
            "startOffset": 93252,
            "endOffset": 93262,
            "count": 0
          },
          {
            "startOffset": 93263,
            "endOffset": 93277,
            "count": 0
          },
          {
            "startOffset": 93278,
            "endOffset": 93309,
            "count": 0
          },
          {
            "startOffset": 93310,
            "endOffset": 93326,
            "count": 0
          },
          {
            "startOffset": 93328,
            "endOffset": 93473,
            "count": 0
          },
          {
            "startOffset": 93518,
            "endOffset": 93936,
            "count": 95
          },
          {
            "startOffset": 93567,
            "endOffset": 93578,
            "count": 4
          },
          {
            "startOffset": 93579,
            "endOffset": 93585,
            "count": 91
          },
          {
            "startOffset": 93618,
            "endOffset": 93679,
            "count": 89
          },
          {
            "startOffset": 93679,
            "endOffset": 93716,
            "count": 6
          },
          {
            "startOffset": 93716,
            "endOffset": 93785,
            "count": 0
          },
          {
            "startOffset": 93787,
            "endOffset": 93821,
            "count": 0
          },
          {
            "startOffset": 93821,
            "endOffset": 93853,
            "count": 6
          },
          {
            "startOffset": 93853,
            "endOffset": 93928,
            "count": 0
          },
          {
            "startOffset": 93936,
            "endOffset": 94010,
            "count": 1972
          },
          {
            "startOffset": 94010,
            "endOffset": 94021,
            "count": 87
          },
          {
            "startOffset": 94023,
            "endOffset": 94079,
            "count": 87
          },
          {
            "startOffset": 94079,
            "endOffset": 94130,
            "count": 1972
          },
          {
            "startOffset": 94167,
            "endOffset": 94216,
            "count": 235
          },
          {
            "startOffset": 94216,
            "endOffset": 94232,
            "count": 1972
          },
          {
            "startOffset": 94232,
            "endOffset": 94244,
            "count": 1926
          },
          {
            "startOffset": 94245,
            "endOffset": 94263,
            "count": 82
          },
          {
            "startOffset": 94264,
            "endOffset": 94277,
            "count": 82
          },
          {
            "startOffset": 94279,
            "endOffset": 94394,
            "count": 82
          },
          {
            "startOffset": 94352,
            "endOffset": 94386,
            "count": 0
          },
          {
            "startOffset": 94394,
            "endOffset": 94433,
            "count": 1972
          },
          {
            "startOffset": 94433,
            "endOffset": 94492,
            "count": 1906
          },
          {
            "startOffset": 94492,
            "endOffset": 94509,
            "count": 1972
          },
          {
            "startOffset": 94509,
            "endOffset": 94631,
            "count": 66
          },
          {
            "startOffset": 94543,
            "endOffset": 94554,
            "count": 1
          },
          {
            "startOffset": 94555,
            "endOffset": 94607,
            "count": 65
          },
          {
            "startOffset": 94632,
            "endOffset": 94677,
            "count": 1906
          },
          {
            "startOffset": 94649,
            "endOffset": 94677,
            "count": 235
          },
          {
            "startOffset": 94704,
            "endOffset": 94722,
            "count": 0
          },
          {
            "startOffset": 94724,
            "endOffset": 94848,
            "count": 0
          },
          {
            "startOffset": 94848,
            "endOffset": 94868,
            "count": 1972
          },
          {
            "startOffset": 94868,
            "endOffset": 94898,
            "count": 239
          },
          {
            "startOffset": 94899,
            "endOffset": 94920,
            "count": 2
          },
          {
            "startOffset": 94921,
            "endOffset": 94939,
            "count": 0
          },
          {
            "startOffset": 94940,
            "endOffset": 94954,
            "count": 0
          },
          {
            "startOffset": 94955,
            "endOffset": 94985,
            "count": 0
          },
          {
            "startOffset": 95019,
            "endOffset": 95028,
            "count": 1891
          },
          {
            "startOffset": 95030,
            "endOffset": 95054,
            "count": 127
          },
          {
            "startOffset": 95056,
            "endOffset": 95549,
            "count": 127
          },
          {
            "startOffset": 95077,
            "endOffset": 95095,
            "count": 5
          },
          {
            "startOffset": 95096,
            "endOffset": 95142,
            "count": 5
          },
          {
            "startOffset": 95163,
            "endOffset": 95170,
            "count": 41
          },
          {
            "startOffset": 95172,
            "endOffset": 95239,
            "count": 86
          },
          {
            "startOffset": 95197,
            "endOffset": 95212,
            "count": 81
          },
          {
            "startOffset": 95213,
            "endOffset": 95238,
            "count": 5
          },
          {
            "startOffset": 95240,
            "endOffset": 95269,
            "count": 81
          },
          {
            "startOffset": 95315,
            "endOffset": 95327,
            "count": 5
          },
          {
            "startOffset": 95329,
            "endOffset": 95361,
            "count": 122
          },
          {
            "startOffset": 95339,
            "endOffset": 95350,
            "count": 41
          },
          {
            "startOffset": 95351,
            "endOffset": 95360,
            "count": 41
          },
          {
            "startOffset": 95363,
            "endOffset": 95541,
            "count": 81
          },
          {
            "startOffset": 95421,
            "endOffset": 95442,
            "count": 0
          },
          {
            "startOffset": 95472,
            "endOffset": 95514,
            "count": 0
          },
          {
            "startOffset": 95515,
            "endOffset": 95530,
            "count": 0
          },
          {
            "startOffset": 95555,
            "endOffset": 95575,
            "count": 2036
          }
        ]
      },
      {
        "functionName": "targets",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 95598,
            "endOffset": 95648,
            "count": 0
          }
        ]
      },
      {
        "functionName": "invalidate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 95673,
            "endOffset": 95979,
            "count": 0
          }
        ]
      },
      {
        "functionName": "resetTo",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 96001,
            "endOffset": 96660,
            "count": 0
          }
        ]
      },
      {
        "functionName": "kill",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 96679,
            "endOffset": 98812,
            "count": 9
          },
          {
            "startOffset": 96870,
            "endOffset": 96888,
            "count": 5
          },
          {
            "startOffset": 96889,
            "endOffset": 96895,
            "count": 4
          },
          {
            "startOffset": 96902,
            "endOffset": 97352,
            "count": 0
          },
          {
            "startOffset": 97353,
            "endOffset": 97368,
            "count": 0
          },
          {
            "startOffset": 97504,
            "endOffset": 97521,
            "count": 0
          },
          {
            "startOffset": 97523,
            "endOffset": 97569,
            "count": 0
          },
          {
            "startOffset": 97571,
            "endOffset": 97698,
            "count": 0
          },
          {
            "startOffset": 97724,
            "endOffset": 98759,
            "count": 0
          },
          {
            "startOffset": 98760,
            "endOffset": 98770,
            "count": 0
          },
          {
            "startOffset": 98771,
            "endOffset": 98790,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 97798,
            "endOffset": 97854,
            "count": 0
          }
        ]
      },
      {
        "functionName": "to",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 98828,
            "endOffset": 98912,
            "count": 79
          }
        ]
      },
      {
        "functionName": "from",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 98930,
            "endOffset": 99007,
            "count": 6
          }
        ]
      },
      {
        "functionName": "delayedCall",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 99032,
            "endOffset": 99382,
            "count": 3
          }
        ]
      },
      {
        "functionName": "fromTo",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 99402,
            "endOffset": 99493,
            "count": 0
          }
        ]
      },
      {
        "functionName": "set",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 99510,
            "endOffset": 99647,
            "count": 15
          }
        ]
      },
      {
        "functionName": "killTweensOf",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 99673,
            "endOffset": 99797,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 99984,
            "endOffset": 100199,
            "count": 3
          }
        ]
      },
      {
        "functionName": "Tween.<computed>",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 100017,
            "endOffset": 100196,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_setterPlain2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 100221,
            "endOffset": 100307,
            "count": 2453
          }
        ]
      },
      {
        "functionName": "_setterFunc2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 100327,
            "endOffset": 100411,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_setterFuncWithParam2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 100440,
            "endOffset": 100548,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_setterAttribute2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 100573,
            "endOffset": 100675,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_getSetter2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 100694,
            "endOffset": 100880,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_renderPlain2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 100901,
            "endOffset": 101032,
            "count": 4
          }
        ]
      },
      {
        "functionName": "_renderBoolean2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 101055,
            "endOffset": 101166,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_renderComplexString2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 101195,
            "endOffset": 101585,
            "count": 10
          },
          {
            "startOffset": 101283,
            "endOffset": 101292,
            "count": 0
          },
          {
            "startOffset": 101294,
            "endOffset": 101315,
            "count": 0
          },
          {
            "startOffset": 101369,
            "endOffset": 101546,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_renderPropTweens2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 101611,
            "endOffset": 101737,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_addPluginModifier2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 101764,
            "endOffset": 101976,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_killPropTweensOf2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 102002,
            "endOffset": 102362,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_setterWithModifier2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 102390,
            "endOffset": 102532,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_sortPropTweensByPriority2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 102566,
            "endOffset": 103012,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 103030,
            "endOffset": 103692,
            "count": 1
          }
        ]
      },
      {
        "functionName": "PropTween2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 103045,
            "endOffset": 103424,
            "count": 370
          },
          {
            "startOffset": 103239,
            "endOffset": 103254,
            "count": 0
          },
          {
            "startOffset": 103274,
            "endOffset": 103281,
            "count": 173
          },
          {
            "startOffset": 103305,
            "endOffset": 103320,
            "count": 368
          },
          {
            "startOffset": 103345,
            "endOffset": 103349,
            "count": 277
          },
          {
            "startOffset": 103388,
            "endOffset": 103420,
            "count": 166
          }
        ]
      },
      {
        "functionName": "modifier",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 103484,
            "endOffset": 103668,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 103957,
            "endOffset": 104010,
            "count": 37
          }
        ]
      },
      {
        "functionName": "_dispatch2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 104432,
            "endOffset": 104544,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_onMediaChange2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 104567,
            "endOffset": 105368,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 105384,
            "endOffset": 108575,
            "count": 1
          }
        ]
      },
      {
        "functionName": "Context2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 105399,
            "endOffset": 105604,
            "count": 4
          },
          {
            "startOffset": 105458,
            "endOffset": 105476,
            "count": 2
          }
        ]
      },
      {
        "functionName": "add",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 105657,
            "endOffset": 106390,
            "count": 6
          },
          {
            "startOffset": 106358,
            "endOffset": 106385,
            "count": 0
          }
        ]
      },
      {
        "functionName": "f2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 105816,
            "endOffset": 106234,
            "count": 6
          },
          {
            "startOffset": 105908,
            "endOffset": 105924,
            "count": 0
          },
          {
            "startOffset": 105925,
            "endOffset": 105948,
            "count": 0
          },
          {
            "startOffset": 105962,
            "endOffset": 105998,
            "count": 0
          },
          {
            "startOffset": 106093,
            "endOffset": 106116,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 106297,
            "endOffset": 106356,
            "count": 0
          }
        ]
      },
      {
        "functionName": "ignore",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 106411,
            "endOffset": 106521,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getTweens",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 106545,
            "endOffset": 106793,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 106606,
            "endOffset": 106773,
            "count": 12
          },
          {
            "startOffset": 106655,
            "endOffset": 106687,
            "count": 0
          },
          {
            "startOffset": 106709,
            "endOffset": 106753,
            "count": 11
          },
          {
            "startOffset": 106723,
            "endOffset": 106752,
            "count": 6
          },
          {
            "startOffset": 106754,
            "endOffset": 106766,
            "count": 9
          }
        ]
      },
      {
        "functionName": "clear",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 106813,
            "endOffset": 106878,
            "count": 2
          }
        ]
      },
      {
        "functionName": "kill",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 106897,
            "endOffset": 108472,
            "count": 2
          },
          {
            "startOffset": 108211,
            "endOffset": 108307,
            "count": 0
          },
          {
            "startOffset": 108347,
            "endOffset": 108468,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 106982,
            "endOffset": 108201,
            "count": 2
          },
          {
            "startOffset": 107085,
            "endOffset": 107349,
            "count": 12
          },
          {
            "startOffset": 107153,
            "endOffset": 107339,
            "count": 0
          },
          {
            "startOffset": 107756,
            "endOffset": 108071,
            "count": 12
          },
          {
            "startOffset": 107826,
            "endOffset": 107975,
            "count": 1
          },
          {
            "startOffset": 107865,
            "endOffset": 107963,
            "count": 0
          },
          {
            "startOffset": 107975,
            "endOffset": 108061,
            "count": 11
          },
          {
            "startOffset": 108017,
            "endOffset": 108028,
            "count": 0
          },
          {
            "startOffset": 108029,
            "endOffset": 108048,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 107232,
            "endOffset": 107325,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 107369,
            "endOffset": 107555,
            "count": 9
          },
          {
            "startOffset": 107426,
            "endOffset": 107438,
            "count": 5
          },
          {
            "startOffset": 107439,
            "endOffset": 107482,
            "count": 5
          },
          {
            "startOffset": 107450,
            "endOffset": 107482,
            "count": 4
          },
          {
            "startOffset": 107483,
            "endOffset": 107501,
            "count": 4
          },
          {
            "startOffset": 107502,
            "endOffset": 107513,
            "count": 5
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 107562,
            "endOffset": 107629,
            "count": 17
          },
          {
            "startOffset": 107606,
            "endOffset": 107618,
            "count": 3
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 107639,
            "endOffset": 107699,
            "count": 9
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 108098,
            "endOffset": 108157,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 108243,
            "endOffset": 108299,
            "count": 0
          }
        ]
      },
      {
        "functionName": "revert",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 108493,
            "endOffset": 108553,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 108596,
            "endOffset": 109942,
            "count": 1
          }
        ]
      },
      {
        "functionName": "MatchMedia2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 108611,
            "endOffset": 108734,
            "count": 1
          },
          {
            "startOffset": 108702,
            "endOffset": 108729,
            "count": 0
          }
        ]
      },
      {
        "functionName": "add",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 108790,
            "endOffset": 109707,
            "count": 0
          }
        ]
      },
      {
        "functionName": "revert",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 109728,
            "endOffset": 109788,
            "count": 0
          }
        ]
      },
      {
        "functionName": "kill",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 109807,
            "endOffset": 109917,
            "count": 0
          }
        ]
      },
      {
        "functionName": "registerPlugin",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 109978,
            "endOffset": 110236,
            "count": 6
          },
          {
            "startOffset": 110105,
            "endOffset": 110150,
            "count": 12
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 110168,
            "endOffset": 110230,
            "count": 12
          }
        ]
      },
      {
        "functionName": "timeline",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 110250,
            "endOffset": 110310,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getTweensOf",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 110327,
            "endOffset": 110435,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getProperty",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 110452,
            "endOffset": 111007,
            "count": 6
          },
          {
            "startOffset": 110530,
            "endOffset": 110562,
            "count": 0
          },
          {
            "startOffset": 110598,
            "endOffset": 110603,
            "count": 0
          },
          {
            "startOffset": 110624,
            "endOffset": 110638,
            "count": 0
          },
          {
            "startOffset": 110683,
            "endOffset": 110697,
            "count": 0
          },
          {
            "startOffset": 110718,
            "endOffset": 110726,
            "count": 0
          },
          {
            "startOffset": 110739,
            "endOffset": 110902,
            "count": 0
          },
          {
            "startOffset": 110932,
            "endOffset": 110957,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 110741,
            "endOffset": 110902,
            "count": 0
          }
        ]
      },
      {
        "functionName": "quickSetter",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 111024,
            "endOffset": 111963,
            "count": 0
          }
        ]
      },
      {
        "functionName": "quickTo",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 111976,
            "endOffset": 112346,
            "count": 0
          }
        ]
      },
      {
        "functionName": "isTweening",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 112362,
            "endOffset": 112462,
            "count": 0
          }
        ]
      },
      {
        "functionName": "defaults",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 112476,
            "endOffset": 112635,
            "count": 0
          }
        ]
      },
      {
        "functionName": "config2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 112647,
            "endOffset": 112721,
            "count": 2
          },
          {
            "startOffset": 112710,
            "endOffset": 112715,
            "count": 1
          }
        ]
      },
      {
        "functionName": "registerEffect",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 112741,
            "endOffset": 113491,
            "count": 0
          }
        ]
      },
      {
        "functionName": "registerEase",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 113509,
            "endOffset": 113587,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parseEase",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 113602,
            "endOffset": 113717,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getById",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 113730,
            "endOffset": 113796,
            "count": 0
          }
        ]
      },
      {
        "functionName": "exportRoot",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 113812,
            "endOffset": 114485,
            "count": 0
          }
        ]
      },
      {
        "functionName": "context",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 114498,
            "endOffset": 114588,
            "count": 4
          },
          {
            "startOffset": 114573,
            "endOffset": 114583,
            "count": 0
          }
        ]
      },
      {
        "functionName": "matchMedia",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 114604,
            "endOffset": 114670,
            "count": 1
          }
        ]
      },
      {
        "functionName": "matchMediaRefresh",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 114693,
            "endOffset": 114976,
            "count": 0
          }
        ]
      },
      {
        "functionName": "addEventListener",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 114998,
            "endOffset": 115148,
            "count": 3
          }
        ]
      },
      {
        "functionName": "removeEventListener",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 115173,
            "endOffset": 115313,
            "count": 0
          }
        ]
      },
      {
        "functionName": "reverting",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 115850,
            "endOffset": 115903,
            "count": 96
          }
        ]
      },
      {
        "functionName": "context2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 115918,
            "endOffset": 116078,
            "count": 1
          },
          {
            "startOffset": 115974,
            "endOffset": 116049,
            "count": 0
          }
        ]
      },
      {
        "functionName": "suppressOverwrites",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 116104,
            "endOffset": 116188,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 116256,
            "endOffset": 116310,
            "count": 6
          }
        ]
      },
      {
        "functionName": "_getPluginPropTween2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 116420,
            "endOffset": 116594,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_addModifiers2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 116616,
            "endOffset": 117006,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_buildModifierPlugin2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 117035,
            "endOffset": 117699,
            "count": 3
          }
        ]
      },
      {
        "functionName": "init4",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 117200,
            "endOffset": 117692,
            "count": 0
          }
        ]
      },
      {
        "functionName": "init",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 117759,
            "endOffset": 118079,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 118091,
            "endOffset": 118261,
            "count": 0
          }
        ]
      },
      {
        "functionName": "init2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 118295,
            "endOffset": 118451,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_windowExists4",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 119446,
            "endOffset": 119515,
            "count": 1
          }
        ]
      },
      {
        "functionName": "_renderCSSProp2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 119896,
            "endOffset": 120038,
            "count": 739
          }
        ]
      },
      {
        "functionName": "_renderPropWithEnd2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 120065,
            "endOffset": 120234,
            "count": 1432
          },
          {
            "startOffset": 120155,
            "endOffset": 120163,
            "count": 76
          },
          {
            "startOffset": 120164,
            "endOffset": 120224,
            "count": 1356
          }
        ]
      },
      {
        "functionName": "_renderCSSPropWithBeginning2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 120270,
            "endOffset": 120442,
            "count": 9
          },
          {
            "startOffset": 120424,
            "endOffset": 120432,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_renderRoundedCSSProp2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 120472,
            "endOffset": 120640,
            "count": 1
          },
          {
            "startOffset": 120607,
            "endOffset": 120613,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_renderNonTweeningValue2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 120672,
            "endOffset": 120788,
            "count": 257
          },
          {
            "startOffset": 120770,
            "endOffset": 120778,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_renderNonTweeningValueOnlyAtEnd2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 120829,
            "endOffset": 120960,
            "count": 1
          },
          {
            "startOffset": 120933,
            "endOffset": 120941,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_setterCSSStyle2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 120984,
            "endOffset": 121079,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_setterCSSProp2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 121102,
            "endOffset": 121207,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_setterTransform2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 121232,
            "endOffset": 121328,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_setterScale2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 121349,
            "endOffset": 121460,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_setterScaleWithRender2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 121491,
            "endOffset": 121671,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_setterTransformWithRender2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 121706,
            "endOffset": 121878,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_saveStyle2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 121985,
            "endOffset": 123058,
            "count": 94
          },
          {
            "startOffset": 122190,
            "endOffset": 122195,
            "count": 93
          },
          {
            "startOffset": 122319,
            "endOffset": 122418,
            "count": 0
          },
          {
            "startOffset": 122468,
            "endOffset": 122492,
            "count": 0
          },
          {
            "startOffset": 122534,
            "endOffset": 122571,
            "count": 1
          },
          {
            "startOffset": 122578,
            "endOffset": 122727,
            "count": 0
          },
          {
            "startOffset": 122777,
            "endOffset": 122798,
            "count": 1
          },
          {
            "startOffset": 122798,
            "endOffset": 122818,
            "count": 93
          },
          {
            "startOffset": 122818,
            "endOffset": 122942,
            "count": 0
          },
          {
            "startOffset": 122942,
            "endOffset": 122987,
            "count": 93
          },
          {
            "startOffset": 122987,
            "endOffset": 122998,
            "count": 0
          },
          {
            "startOffset": 123000,
            "endOffset": 123055,
            "count": 93
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 122349,
            "endOffset": 122417,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 122645,
            "endOffset": 122719,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_removeIndependentTransforms2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 123095,
            "endOffset": 123283,
            "count": 20
          },
          {
            "startOffset": 123166,
            "endOffset": 123281,
            "count": 12
          }
        ]
      },
      {
        "functionName": "_revertStyle2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 123304,
            "endOffset": 124243,
            "count": 20
          },
          {
            "startOffset": 123469,
            "endOffset": 123690,
            "count": 40
          },
          {
            "startOffset": 123488,
            "endOffset": 123521,
            "count": 0
          },
          {
            "startOffset": 123537,
            "endOffset": 123569,
            "count": 4
          },
          {
            "startOffset": 123570,
            "endOffset": 123685,
            "count": 36
          },
          {
            "startOffset": 123624,
            "endOffset": 123634,
            "count": 0
          },
          {
            "startOffset": 123790,
            "endOffset": 123891,
            "count": 0
          },
          {
            "startOffset": 124038,
            "endOffset": 124068,
            "count": 0
          },
          {
            "startOffset": 124070,
            "endOffset": 124206,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_getStyleSaver2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 124266,
            "endOffset": 124563,
            "count": 102
          },
          {
            "startOffset": 124423,
            "endOffset": 124452,
            "count": 0
          },
          {
            "startOffset": 124467,
            "endOffset": 124544,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 124500,
            "endOffset": 124543,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_createElement2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 124603,
            "endOffset": 124853,
            "count": 2
          },
          {
            "startOffset": 124768,
            "endOffset": 124795,
            "count": 0
          },
          {
            "startOffset": 124823,
            "endOffset": 124850,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_getComputedProperty2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 124882,
            "endOffset": 125224,
            "count": 190
          },
          {
            "startOffset": 125012,
            "endOffset": 125083,
            "count": 95
          },
          {
            "startOffset": 125084,
            "endOffset": 125116,
            "count": 95
          },
          {
            "startOffset": 125117,
            "endOffset": 125215,
            "count": 95
          },
          {
            "startOffset": 125140,
            "endOffset": 125215,
            "count": 46
          },
          {
            "startOffset": 125200,
            "endOffset": 125211,
            "count": 0
          },
          {
            "startOffset": 125216,
            "endOffset": 125221,
            "count": 95
          }
        ]
      },
      {
        "functionName": "_checkPropPrefix2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 125298,
            "endOffset": 125682,
            "count": 67
          },
          {
            "startOffset": 125378,
            "endOffset": 125389,
            "count": 49
          },
          {
            "startOffset": 125449,
            "endOffset": 125475,
            "count": 49
          },
          {
            "startOffset": 125475,
            "endOffset": 125557,
            "count": 18
          },
          {
            "startOffset": 125557,
            "endOffset": 125591,
            "count": 78
          },
          {
            "startOffset": 125593,
            "endOffset": 125598,
            "count": 75
          },
          {
            "startOffset": 125598,
            "endOffset": 125614,
            "count": 18
          },
          {
            "startOffset": 125614,
            "endOffset": 125620,
            "count": 15
          },
          {
            "startOffset": 125621,
            "endOffset": 125679,
            "count": 3
          },
          {
            "startOffset": 125632,
            "endOffset": 125638,
            "count": 0
          },
          {
            "startOffset": 125663,
            "endOffset": 125667,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_initCore2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 125700,
            "endOffset": 126286,
            "count": 1
          },
          {
            "startOffset": 125895,
            "endOffset": 125921,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_getBBoxHack2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 126307,
            "endOffset": 127117,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_getAttributeFallbacks2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 127148,
            "endOffset": 127374,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_getBBox2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 127391,
            "endOffset": 127903,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_isSVG2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 127918,
            "endOffset": 128019,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_removeProperty2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 128043,
            "endOffset": 128629,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_addNonTweeningPT2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 128655,
            "endOffset": 128977,
            "count": 7
          },
          {
            "startOffset": 128815,
            "endOffset": 128849,
            "count": 1
          },
          {
            "startOffset": 128850,
            "endOffset": 128875,
            "count": 6
          }
        ]
      },
      {
        "functionName": "_convertToUnit2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 129114,
            "endOffset": 131592,
            "count": 20
          },
          {
            "startOffset": 129432,
            "endOffset": 129442,
            "count": 0
          },
          {
            "startOffset": 129469,
            "endOffset": 129478,
            "count": 5
          },
          {
            "startOffset": 129479,
            "endOffset": 129489,
            "count": 15
          },
          {
            "startOffset": 129607,
            "endOffset": 129619,
            "count": 15
          },
          {
            "startOffset": 129620,
            "endOffset": 129649,
            "count": 0
          },
          {
            "startOffset": 129650,
            "endOffset": 129682,
            "count": 0
          },
          {
            "startOffset": 129710,
            "endOffset": 129742,
            "count": 0
          },
          {
            "startOffset": 129743,
            "endOffset": 129805,
            "count": 0
          },
          {
            "startOffset": 129831,
            "endOffset": 129848,
            "count": 0
          },
          {
            "startOffset": 129867,
            "endOffset": 129885,
            "count": 0
          },
          {
            "startOffset": 129887,
            "endOffset": 129947,
            "count": 0
          },
          {
            "startOffset": 129949,
            "endOffset": 130154,
            "count": 0
          },
          {
            "startOffset": 130155,
            "endOffset": 130165,
            "count": 0
          },
          {
            "startOffset": 130188,
            "endOffset": 130197,
            "count": 0
          },
          {
            "startOffset": 130198,
            "endOffset": 130204,
            "count": 0
          },
          {
            "startOffset": 130245,
            "endOffset": 130297,
            "count": 0
          },
          {
            "startOffset": 130298,
            "endOffset": 130306,
            "count": 0
          },
          {
            "startOffset": 130307,
            "endOffset": 130326,
            "count": 0
          },
          {
            "startOffset": 130341,
            "endOffset": 130436,
            "count": 0
          },
          {
            "startOffset": 130437,
            "endOffset": 130459,
            "count": 0
          },
          {
            "startOffset": 130461,
            "endOffset": 130540,
            "count": 0
          },
          {
            "startOffset": 130541,
            "endOffset": 130555,
            "count": 0
          },
          {
            "startOffset": 130556,
            "endOffset": 130569,
            "count": 0
          },
          {
            "startOffset": 130570,
            "endOffset": 130600,
            "count": 0
          },
          {
            "startOffset": 130601,
            "endOffset": 130618,
            "count": 0
          },
          {
            "startOffset": 130620,
            "endOffset": 131542,
            "count": 0
          },
          {
            "startOffset": 131543,
            "endOffset": 131588,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_get2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 131605,
            "endOffset": 132649,
            "count": 170
          },
          {
            "startOffset": 131685,
            "endOffset": 131699,
            "count": 0
          },
          {
            "startOffset": 131736,
            "endOffset": 131763,
            "count": 82
          },
          {
            "startOffset": 131765,
            "endOffset": 131894,
            "count": 82
          },
          {
            "startOffset": 131842,
            "endOffset": 131890,
            "count": 6
          },
          {
            "startOffset": 131927,
            "endOffset": 131954,
            "count": 94
          },
          {
            "startOffset": 131956,
            "endOffset": 132193,
            "count": 94
          },
          {
            "startOffset": 132047,
            "endOffset": 132064,
            "count": 93
          },
          {
            "startOffset": 132065,
            "endOffset": 132188,
            "count": 1
          },
          {
            "startOffset": 132077,
            "endOffset": 132091,
            "count": 0
          },
          {
            "startOffset": 132193,
            "endOffset": 132531,
            "count": 76
          },
          {
            "startOffset": 132252,
            "endOffset": 132271,
            "count": 8
          },
          {
            "startOffset": 132272,
            "endOffset": 132282,
            "count": 8
          },
          {
            "startOffset": 132283,
            "endOffset": 132316,
            "count": 8
          },
          {
            "startOffset": 132318,
            "endOffset": 132527,
            "count": 68
          },
          {
            "startOffset": 132358,
            "endOffset": 132408,
            "count": 0
          },
          {
            "startOffset": 132451,
            "endOffset": 132484,
            "count": 46
          },
          {
            "startOffset": 132485,
            "endOffset": 132520,
            "count": 46
          },
          {
            "startOffset": 132512,
            "endOffset": 132515,
            "count": 3
          },
          {
            "startOffset": 132516,
            "endOffset": 132519,
            "count": 43
          },
          {
            "startOffset": 132546,
            "endOffset": 132583,
            "count": 0
          },
          {
            "startOffset": 132584,
            "endOffset": 132638,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_tweenComplexCSSString2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 132680,
            "endOffset": 135560,
            "count": 23
          },
          {
            "startOffset": 132754,
            "endOffset": 132773,
            "count": 5
          },
          {
            "startOffset": 132775,
            "endOffset": 133042,
            "count": 18
          },
          {
            "startOffset": 132830,
            "endOffset": 132867,
            "count": 3
          },
          {
            "startOffset": 132879,
            "endOffset": 132893,
            "count": 0
          },
          {
            "startOffset": 132895,
            "endOffset": 132935,
            "count": 0
          },
          {
            "startOffset": 132969,
            "endOffset": 133038,
            "count": 0
          },
          {
            "startOffset": 133343,
            "endOffset": 133550,
            "count": 0
          },
          {
            "startOffset": 133671,
            "endOffset": 133676,
            "count": 5
          },
          {
            "startOffset": 133719,
            "endOffset": 133724,
            "count": 13
          },
          {
            "startOffset": 133750,
            "endOffset": 135372,
            "count": 10
          },
          {
            "startOffset": 133799,
            "endOffset": 135297,
            "count": 16
          },
          {
            "startOffset": 133896,
            "endOffset": 133938,
            "count": 0
          },
          {
            "startOffset": 134010,
            "endOffset": 134038,
            "count": 0
          },
          {
            "startOffset": 134102,
            "endOffset": 134107,
            "count": 11
          },
          {
            "startOffset": 134258,
            "endOffset": 134320,
            "count": 0
          },
          {
            "startOffset": 134500,
            "endOffset": 134683,
            "count": 5
          },
          {
            "startOffset": 134719,
            "endOffset": 134807,
            "count": 11
          },
          {
            "startOffset": 134871,
            "endOffset": 134890,
            "count": 6
          },
          {
            "startOffset": 134899,
            "endOffset": 134904,
            "count": 0
          },
          {
            "startOffset": 135222,
            "endOffset": 135234,
            "count": 0
          },
          {
            "startOffset": 135256,
            "endOffset": 135268,
            "count": 5
          },
          {
            "startOffset": 135269,
            "endOffset": 135272,
            "count": 11
          },
          {
            "startOffset": 135328,
            "endOffset": 135362,
            "count": 5
          },
          {
            "startOffset": 135363,
            "endOffset": 135367,
            "count": 5
          },
          {
            "startOffset": 135372,
            "endOffset": 135493,
            "count": 13
          },
          {
            "startOffset": 135410,
            "endOffset": 135427,
            "count": 1
          },
          {
            "startOffset": 135428,
            "endOffset": 135462,
            "count": 0
          },
          {
            "startOffset": 135514,
            "endOffset": 135527,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_convertKeywordsToPercentages2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 135705,
            "endOffset": 136047,
            "count": 1
          },
          {
            "startOffset": 135841,
            "endOffset": 135858,
            "count": 0
          },
          {
            "startOffset": 135859,
            "endOffset": 135874,
            "count": 0
          },
          {
            "startOffset": 135875,
            "endOffset": 135891,
            "count": 0
          },
          {
            "startOffset": 136014,
            "endOffset": 136018,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_renderClearProps2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 136073,
            "endOffset": 136998,
            "count": 0
          }
        ]
      },
      {
        "functionName": "clearProps",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 137036,
            "endOffset": 137366,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_isNullTransform2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 140239,
            "endOffset": 140353,
            "count": 36
          },
          {
            "startOffset": 140341,
            "endOffset": 140350,
            "count": 1
          }
        ]
      },
      {
        "functionName": "_getComputedTransformMatrixAsArray2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 140396,
            "endOffset": 140632,
            "count": 36
          },
          {
            "startOffset": 140558,
            "endOffset": 140577,
            "count": 35
          },
          {
            "startOffset": 140578,
            "endOffset": 140629,
            "count": 1
          }
        ]
      },
      {
        "functionName": "_getMatrix2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 140651,
            "endOffset": 141872,
            "count": 36
          },
          {
            "startOffset": 140718,
            "endOffset": 140738,
            "count": 0
          },
          {
            "startOffset": 140870,
            "endOffset": 140905,
            "count": 0
          },
          {
            "startOffset": 140907,
            "endOffset": 141109,
            "count": 0
          },
          {
            "startOffset": 141148,
            "endOffset": 141171,
            "count": 35
          },
          {
            "startOffset": 141172,
            "endOffset": 141197,
            "count": 0
          },
          {
            "startOffset": 141198,
            "endOffset": 141211,
            "count": 0
          },
          {
            "startOffset": 141213,
            "endOffset": 141751,
            "count": 0
          },
          {
            "startOffset": 141769,
            "endOffset": 141789,
            "count": 0
          },
          {
            "startOffset": 141790,
            "endOffset": 141860,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_applySVGOrigin2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 141896,
            "endOffset": 143997,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_parseTransform2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 144021,
            "endOffset": 149750,
            "count": 94
          },
          {
            "startOffset": 144093,
            "endOffset": 144115,
            "count": 0
          },
          {
            "startOffset": 144136,
            "endOffset": 144147,
            "count": 70
          },
          {
            "startOffset": 144148,
            "endOffset": 144165,
            "count": 70
          },
          {
            "startOffset": 144167,
            "endOffset": 144190,
            "count": 58
          },
          {
            "startOffset": 144190,
            "endOffset": 144369,
            "count": 36
          },
          {
            "startOffset": 144369,
            "endOffset": 144375,
            "count": 0
          },
          {
            "startOffset": 144704,
            "endOffset": 144721,
            "count": 0
          },
          {
            "startOffset": 144744,
            "endOffset": 145242,
            "count": 36
          },
          {
            "startOffset": 144826,
            "endOffset": 145179,
            "count": 0
          },
          {
            "startOffset": 145242,
            "endOffset": 145302,
            "count": 36
          },
          {
            "startOffset": 145302,
            "endOffset": 145642,
            "count": 0
          },
          {
            "startOffset": 145642,
            "endOffset": 145673,
            "count": 36
          },
          {
            "startOffset": 145701,
            "endOffset": 145705,
            "count": 36
          },
          {
            "startOffset": 145743,
            "endOffset": 148337,
            "count": 1
          },
          {
            "startOffset": 146003,
            "endOffset": 146007,
            "count": 0
          },
          {
            "startOffset": 146034,
            "endOffset": 146037,
            "count": 0
          },
          {
            "startOffset": 146097,
            "endOffset": 146100,
            "count": 0
          },
          {
            "startOffset": 146114,
            "endOffset": 146165,
            "count": 0
          },
          {
            "startOffset": 146188,
            "endOffset": 146301,
            "count": 0
          },
          {
            "startOffset": 146307,
            "endOffset": 148083,
            "count": 0
          },
          {
            "startOffset": 148103,
            "endOffset": 148333,
            "count": 0
          },
          {
            "startOffset": 148337,
            "endOffset": 148365,
            "count": 36
          },
          {
            "startOffset": 148365,
            "endOffset": 148389,
            "count": 0
          },
          {
            "startOffset": 148391,
            "endOffset": 148610,
            "count": 0
          },
          {
            "startOffset": 148610,
            "endOffset": 148647,
            "count": 36
          },
          {
            "startOffset": 148686,
            "endOffset": 148786,
            "count": 0
          },
          {
            "startOffset": 148788,
            "endOffset": 148831,
            "count": 0
          },
          {
            "startOffset": 148832,
            "endOffset": 148835,
            "count": 36
          },
          {
            "startOffset": 148880,
            "endOffset": 148981,
            "count": 0
          },
          {
            "startOffset": 148983,
            "endOffset": 149027,
            "count": 0
          },
          {
            "startOffset": 149028,
            "endOffset": 149031,
            "count": 36
          },
          {
            "startOffset": 149420,
            "endOffset": 149448,
            "count": 36
          },
          {
            "startOffset": 149432,
            "endOffset": 149448,
            "count": 24
          },
          {
            "startOffset": 149449,
            "endOffset": 149453,
            "count": 36
          },
          {
            "startOffset": 149455,
            "endOffset": 149517,
            "count": 0
          },
          {
            "startOffset": 149517,
            "endOffset": 149626,
            "count": 36
          },
          {
            "startOffset": 149626,
            "endOffset": 149648,
            "count": 0
          },
          {
            "startOffset": 149649,
            "endOffset": 149710,
            "count": 36
          },
          {
            "startOffset": 149686,
            "endOffset": 149710,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_firstTwoOnly2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 149772,
            "endOffset": 149863,
            "count": 3
          }
        ]
      },
      {
        "functionName": "_addPxTranslate2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 149887,
            "endOffset": 150072,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_renderNon3DTransforms2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 150103,
            "endOffset": 150277,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_renderCSSTransforms2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 150378,
            "endOffset": 152378,
            "count": 1910
          },
          {
            "startOffset": 150444,
            "endOffset": 150451,
            "count": 0
          },
          {
            "startOffset": 150880,
            "endOffset": 150894,
            "count": 1868
          },
          {
            "startOffset": 150895,
            "endOffset": 150914,
            "count": 127
          },
          {
            "startOffset": 150930,
            "endOffset": 150983,
            "count": 0
          },
          {
            "startOffset": 150985,
            "endOffset": 151355,
            "count": 0
          },
          {
            "startOffset": 151396,
            "endOffset": 151476,
            "count": 0
          },
          {
            "startOffset": 151505,
            "endOffset": 151580,
            "count": 0
          },
          {
            "startOffset": 151593,
            "endOffset": 151609,
            "count": 127
          },
          {
            "startOffset": 151610,
            "endOffset": 151626,
            "count": 127
          },
          {
            "startOffset": 151627,
            "endOffset": 151643,
            "count": 118
          },
          {
            "startOffset": 151645,
            "endOffset": 151790,
            "count": 1792
          },
          {
            "startOffset": 151688,
            "endOffset": 151737,
            "count": 1783
          },
          {
            "startOffset": 151738,
            "endOffset": 151785,
            "count": 9
          },
          {
            "startOffset": 151820,
            "endOffset": 151883,
            "count": 0
          },
          {
            "startOffset": 151914,
            "endOffset": 151979,
            "count": 0
          },
          {
            "startOffset": 152010,
            "endOffset": 152075,
            "count": 1378
          },
          {
            "startOffset": 152124,
            "endOffset": 152197,
            "count": 0
          },
          {
            "startOffset": 152234,
            "endOffset": 152310,
            "count": 239
          },
          {
            "startOffset": 152355,
            "endOffset": 152375,
            "count": 42
          }
        ]
      },
      {
        "functionName": "_renderSVGTransforms2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 152407,
            "endOffset": 154528,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_addRotationalPropTween2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 154560,
            "endOffset": 155511,
            "count": 76
          },
          {
            "startOffset": 154733,
            "endOffset": 154760,
            "count": 0
          },
          {
            "startOffset": 154761,
            "endOffset": 154771,
            "count": 0
          },
          {
            "startOffset": 154877,
            "endOffset": 155324,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_assign2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 155527,
            "endOffset": 155638,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_addRawTransformPTs2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 155666,
            "endOffset": 157007,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 157053,
            "endOffset": 157828,
            "count": 4
          },
          {
            "startOffset": 157152,
            "endOffset": 157166,
            "count": 3
          },
          {
            "startOffset": 157167,
            "endOffset": 157197,
            "count": 1
          },
          {
            "startOffset": 157313,
            "endOffset": 157330,
            "count": 2
          },
          {
            "startOffset": 157331,
            "endOffset": 157337,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 157203,
            "endOffset": 157284,
            "count": 16
          },
          {
            "startOffset": 157241,
            "endOffset": 157254,
            "count": 8
          },
          {
            "startOffset": 157255,
            "endOffset": 157279,
            "count": 8
          }
        ]
      },
      {
        "functionName": "_specialProps.<computed>",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 157341,
            "endOffset": 157825,
            "count": 3
          },
          {
            "startOffset": 157442,
            "endOffset": 157625,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 157464,
            "endOffset": 157533,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 157695,
            "endOffset": 157781,
            "count": 12
          },
          {
            "startOffset": 157753,
            "endOffset": 157774,
            "count": 8
          }
        ]
      },
      {
        "functionName": "targetTest",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 157901,
            "endOffset": 157978,
            "count": 33
          },
          {
            "startOffset": 157955,
            "endOffset": 157973,
            "count": 28
          }
        ]
      },
      {
        "functionName": "init3",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 157988,
            "endOffset": 164972,
            "count": 105
          },
          {
            "startOffset": 158315,
            "endOffset": 158329,
            "count": 0
          },
          {
            "startOffset": 158361,
            "endOffset": 158386,
            "count": 102
          },
          {
            "startOffset": 158469,
            "endOffset": 164916,
            "count": 168
          },
          {
            "startOffset": 158500,
            "endOffset": 158527,
            "count": 0
          },
          {
            "startOffset": 158576,
            "endOffset": 158631,
            "count": 0
          },
          {
            "startOffset": 158633,
            "endOffset": 158660,
            "count": 0
          },
          {
            "startOffset": 158760,
            "endOffset": 158866,
            "count": 0
          },
          {
            "startOffset": 158895,
            "endOffset": 158926,
            "count": 35
          },
          {
            "startOffset": 158928,
            "endOffset": 158982,
            "count": 0
          },
          {
            "startOffset": 159006,
            "endOffset": 159091,
            "count": 3
          },
          {
            "startOffset": 159062,
            "endOffset": 159082,
            "count": 0
          },
          {
            "startOffset": 159091,
            "endOffset": 164910,
            "count": 165
          },
          {
            "startOffset": 159126,
            "endOffset": 159715,
            "count": 0
          },
          {
            "startOffset": 159769,
            "endOffset": 159784,
            "count": 0
          },
          {
            "startOffset": 159786,
            "endOffset": 160240,
            "count": 0
          },
          {
            "startOffset": 160378,
            "endOffset": 160407,
            "count": 34
          },
          {
            "startOffset": 160408,
            "endOffset": 160432,
            "count": 0
          },
          {
            "startOffset": 160451,
            "endOffset": 160485,
            "count": 0
          },
          {
            "startOffset": 160561,
            "endOffset": 161099,
            "count": 82
          },
          {
            "startOffset": 160596,
            "endOffset": 160934,
            "count": 6
          },
          {
            "startOffset": 160629,
            "endOffset": 160671,
            "count": 3
          },
          {
            "startOffset": 160672,
            "endOffset": 160681,
            "count": 0
          },
          {
            "startOffset": 160683,
            "endOffset": 160726,
            "count": 0
          },
          {
            "startOffset": 160870,
            "endOffset": 160880,
            "count": 0
          },
          {
            "startOffset": 160889,
            "endOffset": 160900,
            "count": 5
          },
          {
            "startOffset": 160901,
            "endOffset": 160911,
            "count": 1
          },
          {
            "startOffset": 161052,
            "endOffset": 161076,
            "count": 6
          },
          {
            "startOffset": 161183,
            "endOffset": 163296,
            "count": 94
          },
          {
            "startOffset": 161251,
            "endOffset": 161646,
            "count": 93
          },
          {
            "startOffset": 161345,
            "endOffset": 161392,
            "count": 0
          },
          {
            "startOffset": 161676,
            "endOffset": 161962,
            "count": 0
          },
          {
            "startOffset": 161997,
            "endOffset": 162589,
            "count": 1
          },
          {
            "startOffset": 162174,
            "endOffset": 162258,
            "count": 0
          },
          {
            "startOffset": 162371,
            "endOffset": 162439,
            "count": 0
          },
          {
            "startOffset": 162589,
            "endOffset": 163286,
            "count": 93
          },
          {
            "startOffset": 162618,
            "endOffset": 162720,
            "count": 0
          },
          {
            "startOffset": 162758,
            "endOffset": 162925,
            "count": 76
          },
          {
            "startOffset": 162831,
            "endOffset": 162878,
            "count": 0
          },
          {
            "startOffset": 162925,
            "endOffset": 163286,
            "count": 17
          },
          {
            "startOffset": 162957,
            "endOffset": 163070,
            "count": 0
          },
          {
            "startOffset": 163097,
            "endOffset": 163165,
            "count": 0
          },
          {
            "startOffset": 163194,
            "endOffset": 163286,
            "count": 0
          },
          {
            "startOffset": 163296,
            "endOffset": 163372,
            "count": 71
          },
          {
            "startOffset": 163321,
            "endOffset": 163372,
            "count": 0
          },
          {
            "startOffset": 163372,
            "endOffset": 163404,
            "count": 88
          },
          {
            "startOffset": 163404,
            "endOffset": 163508,
            "count": 71
          },
          {
            "startOffset": 163415,
            "endOffset": 163430,
            "count": 48
          },
          {
            "startOffset": 163432,
            "endOffset": 163463,
            "count": 54
          },
          {
            "startOffset": 163445,
            "endOffset": 163462,
            "count": 30
          },
          {
            "startOffset": 163464,
            "endOffset": 163494,
            "count": 49
          },
          {
            "startOffset": 163495,
            "endOffset": 163508,
            "count": 48
          },
          {
            "startOffset": 163510,
            "endOffset": 164318,
            "count": 65
          },
          {
            "startOffset": 163601,
            "endOffset": 163616,
            "count": 32
          },
          {
            "startOffset": 163656,
            "endOffset": 163710,
            "count": 60
          },
          {
            "startOffset": 163679,
            "endOffset": 163697,
            "count": 21
          },
          {
            "startOffset": 163698,
            "endOffset": 163709,
            "count": 39
          },
          {
            "startOffset": 163744,
            "endOffset": 163806,
            "count": 9
          },
          {
            "startOffset": 163872,
            "endOffset": 163879,
            "count": 17
          },
          {
            "startOffset": 163880,
            "endOffset": 163887,
            "count": 48
          },
          {
            "startOffset": 163912,
            "endOffset": 163957,
            "count": 0
          },
          {
            "startOffset": 164000,
            "endOffset": 164039,
            "count": 48
          },
          {
            "startOffset": 164021,
            "endOffset": 164038,
            "count": 44
          },
          {
            "startOffset": 164040,
            "endOffset": 164067,
            "count": 5
          },
          {
            "startOffset": 164068,
            "endOffset": 164091,
            "count": 5
          },
          {
            "startOffset": 164092,
            "endOffset": 164108,
            "count": 60
          },
          {
            "startOffset": 164142,
            "endOffset": 164146,
            "count": 40
          },
          {
            "startOffset": 164184,
            "endOffset": 164202,
            "count": 9
          },
          {
            "startOffset": 164204,
            "endOffset": 164308,
            "count": 9
          },
          {
            "startOffset": 164318,
            "endOffset": 164750,
            "count": 23
          },
          {
            "startOffset": 164343,
            "endOffset": 164622,
            "count": 0
          },
          {
            "startOffset": 164706,
            "endOffset": 164727,
            "count": 0
          },
          {
            "startOffset": 164750,
            "endOffset": 164778,
            "count": 88
          },
          {
            "startOffset": 164778,
            "endOffset": 164878,
            "count": 71
          },
          {
            "startOffset": 164828,
            "endOffset": 164877,
            "count": 0
          },
          {
            "startOffset": 164933,
            "endOffset": 164967,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 164984,
            "endOffset": 165214,
            "count": 1939
          },
          {
            "startOffset": 165041,
            "endOffset": 165058,
            "count": 76
          },
          {
            "startOffset": 165060,
            "endOffset": 165169,
            "count": 1919
          },
          {
            "startOffset": 165104,
            "endOffset": 165163,
            "count": 4359
          },
          {
            "startOffset": 165169,
            "endOffset": 165210,
            "count": 20
          }
        ]
      },
      {
        "functionName": "getSetter",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 165271,
            "endOffset": 165892,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 166033,
            "endOffset": 166530,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 166164,
            "endOffset": 166215,
            "count": 19
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 166243,
            "endOffset": 166333,
            "count": 5
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 166425,
            "endOffset": 166526,
            "count": 8
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 166892,
            "endOffset": 166940,
            "count": 13
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5173/src/components/CustomCursor/CustomCursor.module.css",
    "scriptId": "42",
    "source": "import { createHotContext as __vite__createHotContext } from \"/@vite/client\";import.meta.hot = __vite__createHotContext(\"/src/components/CustomCursor/CustomCursor.module.css\");import { updateStyle as __vite__updateStyle, removeStyle as __vite__removeStyle } from \"/@vite/client\"\nconst __vite__id = \"/home/will/local_dev/portfolio/apps/robin-noguier/src/components/CustomCursor/CustomCursor.module.css\"\nconst __vite__css = \"._cursor_j37tl_1 {\\n  position: fixed;\\n  width: 32px;\\n  height: 32px;\\n  border: 1.5px solid var(--text-primary);\\n  border-radius: 50%;\\n  pointer-events: none;\\n  z-index: 99999;\\n  transition:\\n    width 0.2s ease,\\n    height 0.2s ease,\\n    border-width 0.2s ease,\\n    border-color 0.2s ease,\\n    opacity 0.3s ease;\\n  opacity: 0.8;\\n  mix-blend-mode: difference;\\n  will-change: transform;\\n}\\n\\n._cursor_j37tl_1._hovering_j37tl_20 {\\n  width: 48px;\\n  height: 48px;\\n  border-width: 2px;\\n  border-color: var(--accent);\\n}\\n\\n._cursor_j37tl_1._clicking_j37tl_27 {\\n  width: 30px;\\n  height: 30px;\\n  border-width: 3px;\\n}\\n\\n._cursorDot_j37tl_33 {\\n  position: fixed;\\n  width: 4px;\\n  height: 4px;\\n  background-color: var(--text-primary);\\n  border-radius: 50%;\\n  pointer-events: none;\\n  z-index: 99999;\\n  opacity: 0.9;\\n  will-change: transform;\\n}\\n\\n/* Hide default cursor on buttons */\\nbutton {\\n  cursor: none !important;\\n}\\n\\na {\\n  cursor: none !important;\\n}\\n\\n[data-hover] {\\n  cursor: none !important;\\n}\\n\\n@media (hover: none) and (pointer: coarse) {\\n  ._cursor_j37tl_1,\\n  ._cursorDot_j37tl_33 {\\n    display: none;\\n  }\\n}\\n\\n@media (prefers-reduced-motion: reduce) {\\n  ._cursor_j37tl_1,\\n  ._cursorDot_j37tl_33 {\\n    display: none;\\n  }\\n}\\n\\n/* Keep cursor visible when modal is open */\\nbody[data-modal-open='true'] ._cursor_j37tl_1,\\nbody[data-modal-open='true'] ._cursorDot_j37tl_33 {\\n  opacity: 1;\\n  pointer-events: none;\\n}\\n\"\n__vite__updateStyle(__vite__id, __vite__css)\nexport const cursor = \"_cursor_j37tl_1\";\nexport const hovering = \"_hovering_j37tl_20\";\nexport const clicking = \"_clicking_j37tl_27\";\nexport const cursorDot = \"_cursorDot_j37tl_33\";\nexport default {\n\tcursor: cursor,\n\thovering: hovering,\n\tclicking: clicking,\n\tcursorDot: cursorDot\n};\n\nimport.meta.hot.prune(() => __vite__removeStyle(__vite__id))",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 2283,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2245,
            "endOffset": 2282,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5173/src/config/index.ts?t=1750726948502",
    "scriptId": "40",
    "source": "import siteConfig from \"/src/config/site-config.json?t=1750724128431&import\";\nexport const config = siteConfig;\nexport const generateMetadataHTML = (config2) => `\n  <!-- Essential SEO -->\n  <meta charset=\"UTF-8\">\n  <title>${config2.title}</title>\n  <meta name=\"description\" content=\"${config2.description}\">\n  <meta name=\"robots\" content=\"index, follow\">\n  <link rel=\"canonical\" href=\"${config2.canonicalUrl}\">\n\n  <!-- Mobile First -->\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n\n  <!-- Open Graph Tags -->\n  <meta property=\"og:url\" content=\"${config2.canonicalUrl}\">\n  <meta property=\"og:type\" content=\"website\">\n  <meta property=\"og:title\" content=\"${config2.siteName}\">\n  <meta property=\"og:description\" content=\"${config2.description}\">\n  <meta property=\"og:image\" content=\"${config2.ogImage}\">\n  <meta property=\"og:image:alt\" content=\"${config2.ogImageAlt}\">\n  <meta property=\"og:site_name\" content=\"${config2.siteName}\">\n  <meta property=\"og:locale\" content=\"en_US\">\n  <meta property=\"og:updated_time\" content=\"${config2.lastUpdated}\">\n\n  <!-- Twitter/X Card -->\n  <meta name=\"twitter:card\" content=\"summary_large_image\">\n  <meta name=\"twitter:site\" content=\"${config2.twitterHandle}\">\n  <meta name=\"twitter:title\" content=\"${config2.siteName}\">\n  <meta name=\"twitter:description\" content=\"${config2.description}\">\n  <meta name=\"twitter:image\" content=\"${config2.ogImage}\">\n`;\nexport const generateStructuredData = (data) => ({\n  \"@context\": \"https://schema.org\",\n  \"@type\": \"Person\",\n  name: data.personName,\n  affiliation: {\n    \"@type\": \"CollegeOrUniversity\",\n    name: data.affiliation\n  },\n  url: data.url,\n  sameAs: [data.email],\n  knowsAbout: data.knowsAbout\n});\n\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImluZGV4LnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBzaXRlQ29uZmlnIGZyb20gJy4vc2l0ZS1jb25maWcuanNvbidcblxuZXhwb3J0IGludGVyZmFjZSBTaXRlQ29uZmlnIHtcbiAgbWV0YWRhdGE6IHtcbiAgICB0aXRsZTogc3RyaW5nXG4gICAgZGVzY3JpcHRpb246IHN0cmluZ1xuICAgIGNhbm9uaWNhbFVybDogc3RyaW5nXG4gICAgb2dJbWFnZTogc3RyaW5nXG4gICAgb2dJbWFnZUFsdDogc3RyaW5nXG4gICAgc2l0ZU5hbWU6IHN0cmluZ1xuICAgIHR3aXR0ZXJIYW5kbGU6IHN0cmluZ1xuICAgIGxhc3RVcGRhdGVkOiBzdHJpbmdcbiAgfVxuICBoZXJvOiB7XG4gICAgbmFtZTogc3RyaW5nXG4gICAgdGl0bGU6IHN0cmluZ1xuICAgIGluc3RpdHV0aW9uOiBzdHJpbmdcbiAgICBlbWFpbDogc3RyaW5nXG4gICAgcGhvbmVOdW1iZXI6IHN0cmluZ1xuICB9XG4gIGhlYWRlcjoge1xuICAgIGJyYW5kTmFtZTogc3RyaW5nXG4gICAgdGFnbGluZTogc3RyaW5nXG4gICAgZW1haWw6IHN0cmluZ1xuICB9XG4gIG1vdGlvblN5c3RlbToge1xuICAgIHNlY3Rpb25zOiBzdHJpbmdbXVxuICAgIGFuaW1hdGlvbkR1cmF0aW9uOiBudW1iZXJcbiAgICBlYXNpbmc6IHN0cmluZ1xuICAgIHN0YWdnZXJEZWxheTogbnVtYmVyXG4gIH1cbiAgc3RydWN0dXJlZERhdGE6IHtcbiAgICBwZXJzb25OYW1lOiBzdHJpbmdcbiAgICBhZmZpbGlhdGlvbjogc3RyaW5nXG4gICAgdXJsOiBzdHJpbmdcbiAgICBlbWFpbDogc3RyaW5nXG4gICAga25vd3NBYm91dDogc3RyaW5nW11cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgY29uZmlnOiBTaXRlQ29uZmlnID0gc2l0ZUNvbmZpZ1xuXG4vLyBIZWxwZXIgZnVuY3Rpb24gdG8gZ2VuZXJhdGUgbWV0YWRhdGEgSFRNTFxuZXhwb3J0IGNvbnN0IGdlbmVyYXRlTWV0YWRhdGFIVE1MID0gKGNvbmZpZzogU2l0ZUNvbmZpZ1snbWV0YWRhdGEnXSkgPT4gYFxuICA8IS0tIEVzc2VudGlhbCBTRU8gLS0+XG4gIDxtZXRhIGNoYXJzZXQ9XCJVVEYtOFwiPlxuICA8dGl0bGU+JHtjb25maWcudGl0bGV9PC90aXRsZT5cbiAgPG1ldGEgbmFtZT1cImRlc2NyaXB0aW9uXCIgY29udGVudD1cIiR7Y29uZmlnLmRlc2NyaXB0aW9ufVwiPlxuICA8bWV0YSBuYW1lPVwicm9ib3RzXCIgY29udGVudD1cImluZGV4LCBmb2xsb3dcIj5cbiAgPGxpbmsgcmVsPVwiY2Fub25pY2FsXCIgaHJlZj1cIiR7Y29uZmlnLmNhbm9uaWNhbFVybH1cIj5cblxuICA8IS0tIE1vYmlsZSBGaXJzdCAtLT5cbiAgPG1ldGEgbmFtZT1cInZpZXdwb3J0XCIgY29udGVudD1cIndpZHRoPWRldmljZS13aWR0aCwgaW5pdGlhbC1zY2FsZT0xLjBcIj5cblxuICA8IS0tIE9wZW4gR3JhcGggVGFncyAtLT5cbiAgPG1ldGEgcHJvcGVydHk9XCJvZzp1cmxcIiBjb250ZW50PVwiJHtjb25maWcuY2Fub25pY2FsVXJsfVwiPlxuICA8bWV0YSBwcm9wZXJ0eT1cIm9nOnR5cGVcIiBjb250ZW50PVwid2Vic2l0ZVwiPlxuICA8bWV0YSBwcm9wZXJ0eT1cIm9nOnRpdGxlXCIgY29udGVudD1cIiR7Y29uZmlnLnNpdGVOYW1lfVwiPlxuICA8bWV0YSBwcm9wZXJ0eT1cIm9nOmRlc2NyaXB0aW9uXCIgY29udGVudD1cIiR7Y29uZmlnLmRlc2NyaXB0aW9ufVwiPlxuICA8bWV0YSBwcm9wZXJ0eT1cIm9nOmltYWdlXCIgY29udGVudD1cIiR7Y29uZmlnLm9nSW1hZ2V9XCI+XG4gIDxtZXRhIHByb3BlcnR5PVwib2c6aW1hZ2U6YWx0XCIgY29udGVudD1cIiR7Y29uZmlnLm9nSW1hZ2VBbHR9XCI+XG4gIDxtZXRhIHByb3BlcnR5PVwib2c6c2l0ZV9uYW1lXCIgY29udGVudD1cIiR7Y29uZmlnLnNpdGVOYW1lfVwiPlxuICA8bWV0YSBwcm9wZXJ0eT1cIm9nOmxvY2FsZVwiIGNvbnRlbnQ9XCJlbl9VU1wiPlxuICA8bWV0YSBwcm9wZXJ0eT1cIm9nOnVwZGF0ZWRfdGltZVwiIGNvbnRlbnQ9XCIke2NvbmZpZy5sYXN0VXBkYXRlZH1cIj5cblxuICA8IS0tIFR3aXR0ZXIvWCBDYXJkIC0tPlxuICA8bWV0YSBuYW1lPVwidHdpdHRlcjpjYXJkXCIgY29udGVudD1cInN1bW1hcnlfbGFyZ2VfaW1hZ2VcIj5cbiAgPG1ldGEgbmFtZT1cInR3aXR0ZXI6c2l0ZVwiIGNvbnRlbnQ9XCIke2NvbmZpZy50d2l0dGVySGFuZGxlfVwiPlxuICA8bWV0YSBuYW1lPVwidHdpdHRlcjp0aXRsZVwiIGNvbnRlbnQ9XCIke2NvbmZpZy5zaXRlTmFtZX1cIj5cbiAgPG1ldGEgbmFtZT1cInR3aXR0ZXI6ZGVzY3JpcHRpb25cIiBjb250ZW50PVwiJHtjb25maWcuZGVzY3JpcHRpb259XCI+XG4gIDxtZXRhIG5hbWU9XCJ0d2l0dGVyOmltYWdlXCIgY29udGVudD1cIiR7Y29uZmlnLm9nSW1hZ2V9XCI+XG5gXG5cbi8vIEhlbHBlciBmdW5jdGlvbiB0byBnZW5lcmF0ZSBzdHJ1Y3R1cmVkIGRhdGEgSlNPTi1MRFxuZXhwb3J0IGNvbnN0IGdlbmVyYXRlU3RydWN0dXJlZERhdGEgPSAoZGF0YTogU2l0ZUNvbmZpZ1snc3RydWN0dXJlZERhdGEnXSkgPT4gKHtcbiAgJ0Bjb250ZXh0JzogJ2h0dHBzOi8vc2NoZW1hLm9yZycsXG4gICdAdHlwZSc6ICdQZXJzb24nLFxuICBuYW1lOiBkYXRhLnBlcnNvbk5hbWUsXG4gIGFmZmlsaWF0aW9uOiB7XG4gICAgJ0B0eXBlJzogJ0NvbGxlZ2VPclVuaXZlcnNpdHknLFxuICAgIG5hbWU6IGRhdGEuYWZmaWxpYXRpb24sXG4gIH0sXG4gIHVybDogZGF0YS51cmwsXG4gIHNhbWVBczogW2RhdGEuZW1haWxdLFxuICBrbm93c0Fib3V0OiBkYXRhLmtub3dzQWJvdXQsXG59KVxuIl0sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLGdCQUFnQjtBQXdDaEIsYUFBTSxTQUFxQjtBQUczQixhQUFNLHVCQUF1QixDQUFDQSxZQUFtQztBQUFBO0FBQUE7QUFBQSxXQUc3REEsUUFBTyxLQUFLO0FBQUEsc0NBQ2VBLFFBQU8sV0FBVztBQUFBO0FBQUEsZ0NBRXhCQSxRQUFPLFlBQVk7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEscUNBTWRBLFFBQU8sWUFBWTtBQUFBO0FBQUEsdUNBRWpCQSxRQUFPLFFBQVE7QUFBQSw2Q0FDVEEsUUFBTyxXQUFXO0FBQUEsdUNBQ3hCQSxRQUFPLE9BQU87QUFBQSwyQ0FDVkEsUUFBTyxVQUFVO0FBQUEsMkNBQ2pCQSxRQUFPLFFBQVE7QUFBQTtBQUFBLDhDQUVaQSxRQUFPLFdBQVc7QUFBQTtBQUFBO0FBQUE7QUFBQSx1Q0FJekJBLFFBQU8sYUFBYTtBQUFBLHdDQUNuQkEsUUFBTyxRQUFRO0FBQUEsOENBQ1RBLFFBQU8sV0FBVztBQUFBLHdDQUN4QkEsUUFBTyxPQUFPO0FBQUE7QUFJL0MsYUFBTSx5QkFBeUIsQ0FBQyxVQUF3QztBQUFBLEVBQzdFLFlBQVk7QUFBQSxFQUNaLFNBQVM7QUFBQSxFQUNULE1BQU0sS0FBSztBQUFBLEVBQ1gsYUFBYTtBQUFBLElBQ1gsU0FBUztBQUFBLElBQ1QsTUFBTSxLQUFLO0FBQUEsRUFDYjtBQUFBLEVBQ0EsS0FBSyxLQUFLO0FBQUEsRUFDVixRQUFRLENBQUMsS0FBSyxLQUFLO0FBQUEsRUFDbkIsWUFBWSxLQUFLO0FBQ25COyIsIm5hbWVzIjpbImNvbmZpZyJdfQ==",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 6313,
            "count": 1
          }
        ]
      },
      {
        "functionName": "generateMetadataHTML",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 148,
            "endOffset": 1411,
            "count": 0
          }
        ]
      },
      {
        "functionName": "generateStructuredData",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1451,
            "endOffset": 1704,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5173/src/components/Hero/HeroSection.module.css?t=1750724128430",
    "scriptId": "41",
    "source": "import { createHotContext as __vite__createHotContext } from \"/@vite/client\";import.meta.hot = __vite__createHotContext(\"/src/components/Hero/HeroSection.module.css\");import { updateStyle as __vite__updateStyle, removeStyle as __vite__removeStyle } from \"/@vite/client\"\nconst __vite__id = \"/home/will/local_dev/portfolio/apps/robin-noguier/src/components/Hero/HeroSection.module.css\"\nconst __vite__css = \"._heroContainer_1cxx9_1 {\\n  position: relative;\\n  width: 100%;\\n  height: 100vh; /* Single viewport height - no scrollbar */\\n  overflow: hidden;\\n}\\n\\n._canvasWrapper_1cxx9_8 {\\n  position: fixed;\\n  top: 0;\\n  left: 0;\\n  width: 100%;\\n  height: 100vh;\\n  z-index: 1;\\n  background-color: var(--bg-primary);\\n  transition: background-color 0.3s ease;\\n}\\n\\n._overlayContent_1cxx9_19 {\\n  position: fixed;\\n  top: 40%;\\n  left: 50%;\\n  transform: translate(-50%, -50%);\\n  text-align: center;\\n  z-index: 10;\\n  pointer-events: auto;\\n  color: var(--text-primary);\\n  text-shadow: 0 2px 20px rgba(0, 0, 0, 0.5);\\n}\\n\\n._heroTitle_1cxx9_31 {\\n  font-family: var(--font-heading);\\n  font-size: clamp(3rem, 8vw, 7rem);\\n  font-weight: 700;\\n  margin: 0;\\n  letter-spacing: -0.03em;\\n  line-height: 0.9;\\n  text-transform: uppercase;\\n}\\n\\n._heroSubtitle_1cxx9_41 {\\n  font-family: var(--font-subtitle);\\n  font-size: clamp(1rem, 2vw, 1.5rem);\\n  margin-top: 2rem;\\n  opacity: 0.8;\\n  font-weight: 300;\\n  letter-spacing: 0.05em;\\n}\\n\\n._heroInstitution_1cxx9_50 {\\n  font-family: var(--font-subtitle);\\n  font-size: clamp(0.875rem, 1.5vw, 1.125rem);\\n  margin-top: 0.5rem;\\n  opacity: 0.6;\\n  font-weight: 300;\\n  letter-spacing: 0.02em;\\n  font-style: italic;\\n}\\n\\n._heroContact_1cxx9_60 {\\n  margin-top: 1.5rem;\\n  display: flex;\\n  align-items: center;\\n  gap: 1rem;\\n  flex-wrap: wrap;\\n  justify-content: center;\\n  pointer-events: auto;\\n}\\n\\n._contactPhone_1cxx9_70 {\\n  /* Inherits styles from KineticPhone component */\\n}\\n\\n._contactLink_1cxx9_74 {\\n  font-family: var(--font-subtitle);\\n  font-size: clamp(0.875rem, 1.25vw, 1.125rem);\\n  color: var(--text-primary);\\n  text-decoration: none;\\n  opacity: 0.8;\\n  transition: all 0.3s ease;\\n  letter-spacing: 0.025em;\\n  font-weight: 400;\\n  padding: 0.25rem 0.5rem;\\n  border-radius: 4px;\\n}\\n\\n._contactLink_1cxx9_74:hover {\\n  opacity: 1;\\n  background-color: rgba(255, 255, 255, 0.05);\\n}\\n\\n._contactDivider_1cxx9_92 {\\n  color: var(--text-secondary);\\n  opacity: 0.4;\\n  font-size: clamp(0.875rem, 1.25vw, 1.125rem);\\n  font-weight: 300;\\n}\\n\\n@media (max-width: 768px) {\\n  ._heroTitle_1cxx9_31 {\\n    font-size: clamp(2rem, 10vw, 4rem);\\n  }\\n\\n  ._heroSubtitle_1cxx9_41 {\\n    font-size: clamp(1.125rem, 4vw, 1.5rem);\\n    margin-top: 1.5rem;\\n  }\\n\\n  ._heroInstitution_1cxx9_50 {\\n    font-size: clamp(1rem, 3vw, 1.25rem);\\n  }\\n\\n  ._heroContact_1cxx9_60 {\\n    margin-top: 1rem;\\n    flex-direction: column;\\n    gap: 0.5rem;\\n  }\\n\\n  ._contactDivider_1cxx9_92 {\\n    display: none;\\n  }\\n\\n  ._contactLink_1cxx9_74 {\\n    font-size: clamp(0.875rem, 2.5vw, 1rem);\\n  }\\n}\\n\\n/* Scroll indicator */\\n._scrollIndicator_1cxx9_129 {\\n  position: fixed;\\n  bottom: 7.5rem;\\n  left: 50%;\\n  transform: translateX(-50%);\\n  display: flex;\\n  flex-direction: column;\\n  align-items: center;\\n  gap: 1rem;\\n  z-index: 10;\\n  color: var(--text-primary);\\n  font-size: 0.875rem;\\n  letter-spacing: 0.1em;\\n  text-transform: uppercase;\\n  opacity: 0.6;\\n}\\n\\n._scrollTextDesktop_1cxx9_146 {\\n  display: block;\\n}\\n\\n._scrollTextMobile_1cxx9_150 {\\n  display: none;\\n}\\n\\n@media (max-width: 768px) {\\n  ._scrollTextDesktop_1cxx9_146 {\\n    display: none;\\n  }\\n  \\n  ._scrollTextMobile_1cxx9_150 {\\n    display: block;\\n  }\\n}\\n\\n._scrollLine_1cxx9_164 {\\n  width: 1px;\\n  height: 60px;\\n  background: linear-gradient(to bottom, var(--text-primary), transparent);\\n  animation: _scrollPulse_1cxx9_1 2s infinite;\\n}\\n\\n@keyframes _scrollPulse_1cxx9_1 {\\n  0% {\\n    transform: scaleY(0);\\n    transform-origin: top;\\n  }\\n  50% {\\n    transform: scaleY(1);\\n    transform-origin: top;\\n  }\\n  100% {\\n    transform: scaleY(0);\\n    transform-origin: bottom;\\n  }\\n}\\n\\n/* Project previews */\\n._projectPreviews_1cxx9_187 {\\n  position: relative;\\n  pointer-events: none;\\n}\\n\\n._previewSection_1cxx9_192 {\\n  position: absolute;\\n  left: 0;\\n  width: 100%;\\n  height: 100vh;\\n  display: flex;\\n  align-items: center;\\n  justify-content: space-between;\\n  padding: 0 5rem;\\n  opacity: 0;\\n  transition: opacity 0.5s ease;\\n  z-index: 1;\\n}\\n\\n._previewContent_1cxx9_206 {\\n  flex: 1;\\n  max-width: 600px;\\n  color: var(--text-primary);\\n}\\n\\n._previewNumber_1cxx9_212 {\\n  font-size: 0.875rem;\\n  opacity: 0.5;\\n  letter-spacing: 0.2em;\\n  display: block;\\n  margin-bottom: 1rem;\\n}\\n\\n._previewTitle_1cxx9_220 {\\n  font-size: clamp(2.5rem, 5vw, 4rem);\\n  font-weight: 700;\\n  margin: 0 0 1rem 0;\\n  letter-spacing: -0.02em;\\n}\\n\\n._previewCategory_1cxx9_227 {\\n  font-size: 1.125rem;\\n  opacity: 0.7;\\n  margin-bottom: 1.5rem;\\n  text-transform: uppercase;\\n  letter-spacing: 0.1em;\\n}\\n\\n._previewDesc_1cxx9_235 {\\n  font-size: 1.125rem;\\n  line-height: 1.6;\\n  opacity: 0.8;\\n}\\n\\n._previewImage_1cxx9_241 {\\n  flex: 1;\\n  max-width: 500px;\\n  height: 600px;\\n  overflow: hidden;\\n  border-radius: 8px;\\n  box-shadow: 0 20px 80px rgba(0, 0, 0, 0.3);\\n}\\n\\n._previewImage_1cxx9_241 img {\\n  width: 100%;\\n  height: 100%;\\n  object-fit: cover;\\n}\\n\\n@media (max-width: 768px) {\\n  ._previewSection_1cxx9_192 {\\n    flex-direction: column;\\n    padding: 2rem;\\n    text-align: center;\\n  }\\n\\n  ._previewImage_1cxx9_241 {\\n    max-width: 100%;\\n    height: 400px;\\n    margin-top: 2rem;\\n  }\\n}\\n\"\n__vite__updateStyle(__vite__id, __vite__css)\nexport const heroContainer = \"_heroContainer_1cxx9_1\";\nexport const canvasWrapper = \"_canvasWrapper_1cxx9_8\";\nexport const overlayContent = \"_overlayContent_1cxx9_19\";\nexport const heroTitle = \"_heroTitle_1cxx9_31\";\nexport const heroSubtitle = \"_heroSubtitle_1cxx9_41\";\nexport const heroInstitution = \"_heroInstitution_1cxx9_50\";\nexport const heroContact = \"_heroContact_1cxx9_60\";\nexport const contactPhone = \"_contactPhone_1cxx9_70\";\nexport const contactLink = \"_contactLink_1cxx9_74\";\nexport const contactDivider = \"_contactDivider_1cxx9_92\";\nexport const scrollIndicator = \"_scrollIndicator_1cxx9_129\";\nexport const scrollTextDesktop = \"_scrollTextDesktop_1cxx9_146\";\nexport const scrollTextMobile = \"_scrollTextMobile_1cxx9_150\";\nexport const scrollLine = \"_scrollLine_1cxx9_164\";\nexport const scrollPulse = \"_scrollPulse_1cxx9_1\";\nexport const projectPreviews = \"_projectPreviews_1cxx9_187\";\nexport const previewSection = \"_previewSection_1cxx9_192\";\nexport const previewContent = \"_previewContent_1cxx9_206\";\nexport const previewNumber = \"_previewNumber_1cxx9_212\";\nexport const previewTitle = \"_previewTitle_1cxx9_220\";\nexport const previewCategory = \"_previewCategory_1cxx9_227\";\nexport const previewDesc = \"_previewDesc_1cxx9_235\";\nexport const previewImage = \"_previewImage_1cxx9_241\";\nexport default {\n\theroContainer: heroContainer,\n\tcanvasWrapper: canvasWrapper,\n\toverlayContent: overlayContent,\n\theroTitle: heroTitle,\n\theroSubtitle: heroSubtitle,\n\theroInstitution: heroInstitution,\n\theroContact: heroContact,\n\tcontactPhone: contactPhone,\n\tcontactLink: contactLink,\n\tcontactDivider: contactDivider,\n\tscrollIndicator: scrollIndicator,\n\tscrollTextDesktop: scrollTextDesktop,\n\tscrollTextMobile: scrollTextMobile,\n\tscrollLine: scrollLine,\n\tscrollPulse: scrollPulse,\n\tprojectPreviews: projectPreviews,\n\tpreviewSection: previewSection,\n\tpreviewContent: previewContent,\n\tpreviewNumber: previewNumber,\n\tpreviewTitle: previewTitle,\n\tpreviewCategory: previewCategory,\n\tpreviewDesc: previewDesc,\n\tpreviewImage: previewImage\n};\n\nimport.meta.hot.prune(() => __vite__removeStyle(__vite__id))",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 7798,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 7760,
            "endOffset": 7797,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5173/node_modules/.vite/deps/gsap_Observer.js?v=a50bb159",
    "scriptId": "45",
    "source": "import {\n  Observer,\n  _getProxyProp,\n  _getScrollFunc,\n  _getTarget,\n  _getVelocityProp,\n  _horizontal,\n  _isViewport,\n  _proxies,\n  _scrollers,\n  _vertical\n} from \"/node_modules/.vite/deps/chunk-JIUMHI3X.js?v=a50bb159\";\nimport \"/node_modules/.vite/deps/chunk-LNEMQRCO.js?v=a50bb159\";\nexport {\n  Observer,\n  _getProxyProp,\n  _getScrollFunc,\n  _getTarget,\n  _getVelocityProp,\n  _horizontal,\n  _isViewport,\n  _proxies,\n  _scrollers,\n  _vertical,\n  Observer as default\n};\n//# sourceMappingURL=gsap_Observer.js.map\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 512,
            "count": 1
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5173/node_modules/.vite/deps/@gsap_react.js?v=a50bb159",
    "scriptId": "46",
    "source": "import {\n  require_react\n} from \"/node_modules/.vite/deps/chunk-R7U5S34U.js?v=a50bb159\";\nimport {\n  gsapWithCSS\n} from \"/node_modules/.vite/deps/chunk-HJ66XTML.js?v=a50bb159\";\nimport {\n  __toESM\n} from \"/node_modules/.vite/deps/chunk-LNEMQRCO.js?v=a50bb159\";\n\n// ../../node_modules/.pnpm/@gsap+react@2.1.2_gsap@3.12.5_react@18.2.0/node_modules/@gsap/react/src/index.js\nvar import_react = __toESM(require_react());\nvar useIsomorphicLayoutEffect = typeof document !== \"undefined\" ? import_react.useLayoutEffect : import_react.useEffect;\nvar isConfig = (value) => value && !Array.isArray(value) && typeof value === \"object\";\nvar emptyArray = [];\nvar defaultConfig = {};\nvar _gsap = gsapWithCSS;\nvar useGSAP = (callback, dependencies = emptyArray) => {\n  let config = defaultConfig;\n  if (isConfig(callback)) {\n    config = callback;\n    callback = null;\n    dependencies = \"dependencies\" in config ? config.dependencies : emptyArray;\n  } else if (isConfig(dependencies)) {\n    config = dependencies;\n    dependencies = \"dependencies\" in config ? config.dependencies : emptyArray;\n  }\n  callback && typeof callback !== \"function\" && console.warn(\"First parameter must be a function or config object\");\n  const { scope, revertOnUpdate } = config, mounted = (0, import_react.useRef)(false), context = (0, import_react.useRef)(_gsap.context(() => {\n  }, scope)), contextSafe = (0, import_react.useRef)((func) => context.current.add(null, func)), deferCleanup = dependencies && dependencies.length && !revertOnUpdate;\n  deferCleanup && useIsomorphicLayoutEffect(() => {\n    mounted.current = true;\n    return () => context.current.revert();\n  }, emptyArray);\n  useIsomorphicLayoutEffect(() => {\n    callback && context.current.add(callback, scope);\n    if (!deferCleanup || !mounted.current) {\n      return () => context.current.revert();\n    }\n  }, dependencies);\n  return { context: context.current, contextSafe: contextSafe.current };\n};\nuseGSAP.register = (core) => {\n  _gsap = core;\n};\nuseGSAP.headless = true;\nexport {\n  useGSAP\n};\n/*! Bundled license information:\n\n@gsap/react/src/index.js:\n  (*!\n   * @gsap/react 2.1.2\n   * https://gsap.com\n   *\n   * Copyright 2008-2025, GreenSock. All rights reserved.\n   * Subject to the terms at https://gsap.com/standard-license or for\n   * Club GSAP members, the agreement issued with that membership.\n   * @author: Jack Doyle, jack@greensock.com\n  *)\n*/\n//# sourceMappingURL=@gsap_react.js.map\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 2434,
            "count": 1
          },
          {
            "startOffset": 509,
            "endOffset": 533,
            "count": 0
          }
        ]
      },
      {
        "functionName": "isConfig",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 550,
            "endOffset": 620,
            "count": 4
          },
          {
            "startOffset": 592,
            "endOffset": 620,
            "count": 2
          }
        ]
      },
      {
        "functionName": "useGSAP",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 706,
            "endOffset": 1931,
            "count": 2
          },
          {
            "startOffset": 805,
            "endOffset": 934,
            "count": 0
          },
          {
            "startOffset": 968,
            "endOffset": 1080,
            "count": 0
          },
          {
            "startOffset": 1126,
            "endOffset": 1196,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1334,
            "endOffset": 1345,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1395,
            "endOffset": 1436,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1554,
            "endOffset": 1636,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1601,
            "endOffset": 1631,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1679,
            "endOffset": 1840,
            "count": 2
          },
          {
            "startOffset": 1784,
            "endOffset": 1836,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1799,
            "endOffset": 1829,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useGSAP.register",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1952,
            "endOffset": 1981,
            "count": 1
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5173/node_modules/.vite/deps/lenis.js?v=a50bb159",
    "scriptId": "44",
    "source": "import {\n  __publicField\n} from \"/node_modules/.vite/deps/chunk-LNEMQRCO.js?v=a50bb159\";\n\n// ../../node_modules/.pnpm/lenis@1.3.4_react@18.2.0/node_modules/lenis/dist/lenis.mjs\nvar version = \"1.3.4\";\nfunction clamp(min, input, max) {\n  return Math.max(min, Math.min(input, max));\n}\nfunction lerp(x, y, t) {\n  return (1 - t) * x + t * y;\n}\nfunction damp(x, y, lambda, deltaTime) {\n  return lerp(x, y, 1 - Math.exp(-lambda * deltaTime));\n}\nfunction modulo(n, d) {\n  return (n % d + d) % d;\n}\nvar Animate = class {\n  constructor() {\n    __publicField(this, \"isRunning\", false);\n    __publicField(this, \"value\", 0);\n    __publicField(this, \"from\", 0);\n    __publicField(this, \"to\", 0);\n    __publicField(this, \"currentTime\", 0);\n    // These are instanciated in the fromTo method\n    __publicField(this, \"lerp\");\n    __publicField(this, \"duration\");\n    __publicField(this, \"easing\");\n    __publicField(this, \"onUpdate\");\n  }\n  /**\n   * Advance the animation by the given delta time\n   *\n   * @param deltaTime - The time in seconds to advance the animation\n   */\n  advance(deltaTime) {\n    var _a;\n    if (!this.isRunning)\n      return;\n    let completed = false;\n    if (this.duration && this.easing) {\n      this.currentTime += deltaTime;\n      const linearProgress = clamp(0, this.currentTime / this.duration, 1);\n      completed = linearProgress >= 1;\n      const easedProgress = completed ? 1 : this.easing(linearProgress);\n      this.value = this.from + (this.to - this.from) * easedProgress;\n    } else if (this.lerp) {\n      this.value = damp(this.value, this.to, this.lerp * 60, deltaTime);\n      if (Math.round(this.value) === this.to) {\n        this.value = this.to;\n        completed = true;\n      }\n    } else {\n      this.value = this.to;\n      completed = true;\n    }\n    if (completed) {\n      this.stop();\n    }\n    (_a = this.onUpdate) == null ? void 0 : _a.call(this, this.value, completed);\n  }\n  /** Stop the animation */\n  stop() {\n    this.isRunning = false;\n  }\n  /**\n   * Set up the animation from a starting value to an ending value\n   * with optional parameters for lerping, duration, easing, and onUpdate callback\n   *\n   * @param from - The starting value\n   * @param to - The ending value\n   * @param options - Options for the animation\n   */\n  fromTo(from, to, { lerp: lerp2, duration, easing, onStart, onUpdate }) {\n    this.from = this.value = from;\n    this.to = to;\n    this.lerp = lerp2;\n    this.duration = duration;\n    this.easing = easing;\n    this.currentTime = 0;\n    this.isRunning = true;\n    onStart == null ? void 0 : onStart();\n    this.onUpdate = onUpdate;\n  }\n};\nfunction debounce(callback, delay) {\n  let timer;\n  return function(...args) {\n    let context = this;\n    clearTimeout(timer);\n    timer = setTimeout(() => {\n      timer = void 0;\n      callback.apply(context, args);\n    }, delay);\n  };\n}\nvar Dimensions = class {\n  constructor(wrapper, content, { autoResize = true, debounce: debounceValue = 250 } = {}) {\n    __publicField(this, \"width\", 0);\n    __publicField(this, \"height\", 0);\n    __publicField(this, \"scrollHeight\", 0);\n    __publicField(this, \"scrollWidth\", 0);\n    // These are instanciated in the constructor as they need information from the options\n    __publicField(this, \"debouncedResize\");\n    __publicField(this, \"wrapperResizeObserver\");\n    __publicField(this, \"contentResizeObserver\");\n    __publicField(this, \"resize\", () => {\n      this.onWrapperResize();\n      this.onContentResize();\n    });\n    __publicField(this, \"onWrapperResize\", () => {\n      if (this.wrapper instanceof Window) {\n        this.width = window.innerWidth;\n        this.height = window.innerHeight;\n      } else {\n        this.width = this.wrapper.clientWidth;\n        this.height = this.wrapper.clientHeight;\n      }\n    });\n    __publicField(this, \"onContentResize\", () => {\n      if (this.wrapper instanceof Window) {\n        this.scrollHeight = this.content.scrollHeight;\n        this.scrollWidth = this.content.scrollWidth;\n      } else {\n        this.scrollHeight = this.wrapper.scrollHeight;\n        this.scrollWidth = this.wrapper.scrollWidth;\n      }\n    });\n    this.wrapper = wrapper;\n    this.content = content;\n    if (autoResize) {\n      this.debouncedResize = debounce(this.resize, debounceValue);\n      if (this.wrapper instanceof Window) {\n        window.addEventListener(\"resize\", this.debouncedResize, false);\n      } else {\n        this.wrapperResizeObserver = new ResizeObserver(this.debouncedResize);\n        this.wrapperResizeObserver.observe(this.wrapper);\n      }\n      this.contentResizeObserver = new ResizeObserver(this.debouncedResize);\n      this.contentResizeObserver.observe(this.content);\n    }\n    this.resize();\n  }\n  destroy() {\n    var _a, _b;\n    (_a = this.wrapperResizeObserver) == null ? void 0 : _a.disconnect();\n    (_b = this.contentResizeObserver) == null ? void 0 : _b.disconnect();\n    if (this.wrapper === window && this.debouncedResize) {\n      window.removeEventListener(\"resize\", this.debouncedResize, false);\n    }\n  }\n  get limit() {\n    return {\n      x: this.scrollWidth - this.width,\n      y: this.scrollHeight - this.height\n    };\n  }\n};\nvar Emitter = class {\n  constructor() {\n    __publicField(this, \"events\", {});\n  }\n  /**\n   * Emit an event with the given data\n   * @param event Event name\n   * @param args Data to pass to the event handlers\n   */\n  emit(event, ...args) {\n    var _a;\n    let callbacks = this.events[event] || [];\n    for (let i = 0, length = callbacks.length; i < length; i++) {\n      (_a = callbacks[i]) == null ? void 0 : _a.call(callbacks, ...args);\n    }\n  }\n  /**\n   * Add a callback to the event\n   * @param event Event name\n   * @param cb Callback function\n   * @returns Unsubscribe function\n   */\n  on(event, cb) {\n    var _a;\n    ((_a = this.events[event]) == null ? void 0 : _a.push(cb)) || (this.events[event] = [cb]);\n    return () => {\n      var _a2;\n      this.events[event] = (_a2 = this.events[event]) == null ? void 0 : _a2.filter((i) => cb !== i);\n    };\n  }\n  /**\n   * Remove a callback from the event\n   * @param event Event name\n   * @param callback Callback function\n   */\n  off(event, callback) {\n    var _a;\n    this.events[event] = (_a = this.events[event]) == null ? void 0 : _a.filter((i) => callback !== i);\n  }\n  /**\n   * Remove all event listeners and clean up\n   */\n  destroy() {\n    this.events = {};\n  }\n};\nvar LINE_HEIGHT = 100 / 6;\nvar listenerOptions = { passive: false };\nvar VirtualScroll = class {\n  constructor(element, options = { wheelMultiplier: 1, touchMultiplier: 1 }) {\n    __publicField(this, \"touchStart\", {\n      x: 0,\n      y: 0\n    });\n    __publicField(this, \"lastDelta\", {\n      x: 0,\n      y: 0\n    });\n    __publicField(this, \"window\", {\n      width: 0,\n      height: 0\n    });\n    __publicField(this, \"emitter\", new Emitter());\n    /**\n     * Event handler for 'touchstart' event\n     *\n     * @param event Touch event\n     */\n    __publicField(this, \"onTouchStart\", (event) => {\n      const { clientX, clientY } = event.targetTouches ? event.targetTouches[0] : event;\n      this.touchStart.x = clientX;\n      this.touchStart.y = clientY;\n      this.lastDelta = {\n        x: 0,\n        y: 0\n      };\n      this.emitter.emit(\"scroll\", {\n        deltaX: 0,\n        deltaY: 0,\n        event\n      });\n    });\n    /** Event handler for 'touchmove' event */\n    __publicField(this, \"onTouchMove\", (event) => {\n      const { clientX, clientY } = event.targetTouches ? event.targetTouches[0] : event;\n      const deltaX = -(clientX - this.touchStart.x) * this.options.touchMultiplier;\n      const deltaY = -(clientY - this.touchStart.y) * this.options.touchMultiplier;\n      this.touchStart.x = clientX;\n      this.touchStart.y = clientY;\n      this.lastDelta = {\n        x: deltaX,\n        y: deltaY\n      };\n      this.emitter.emit(\"scroll\", {\n        deltaX,\n        deltaY,\n        event\n      });\n    });\n    __publicField(this, \"onTouchEnd\", (event) => {\n      this.emitter.emit(\"scroll\", {\n        deltaX: this.lastDelta.x,\n        deltaY: this.lastDelta.y,\n        event\n      });\n    });\n    /** Event handler for 'wheel' event */\n    __publicField(this, \"onWheel\", (event) => {\n      let { deltaX, deltaY, deltaMode } = event;\n      const multiplierX = deltaMode === 1 ? LINE_HEIGHT : deltaMode === 2 ? this.window.width : 1;\n      const multiplierY = deltaMode === 1 ? LINE_HEIGHT : deltaMode === 2 ? this.window.height : 1;\n      deltaX *= multiplierX;\n      deltaY *= multiplierY;\n      deltaX *= this.options.wheelMultiplier;\n      deltaY *= this.options.wheelMultiplier;\n      this.emitter.emit(\"scroll\", { deltaX, deltaY, event });\n    });\n    __publicField(this, \"onWindowResize\", () => {\n      this.window = {\n        width: window.innerWidth,\n        height: window.innerHeight\n      };\n    });\n    this.element = element;\n    this.options = options;\n    window.addEventListener(\"resize\", this.onWindowResize, false);\n    this.onWindowResize();\n    this.element.addEventListener(\"wheel\", this.onWheel, listenerOptions);\n    this.element.addEventListener(\n      \"touchstart\",\n      this.onTouchStart,\n      listenerOptions\n    );\n    this.element.addEventListener(\n      \"touchmove\",\n      this.onTouchMove,\n      listenerOptions\n    );\n    this.element.addEventListener(\"touchend\", this.onTouchEnd, listenerOptions);\n  }\n  /**\n   * Add an event listener for the given event and callback\n   *\n   * @param event Event name\n   * @param callback Callback function\n   */\n  on(event, callback) {\n    return this.emitter.on(event, callback);\n  }\n  /** Remove all event listeners and clean up */\n  destroy() {\n    this.emitter.destroy();\n    window.removeEventListener(\"resize\", this.onWindowResize, false);\n    this.element.removeEventListener(\"wheel\", this.onWheel, listenerOptions);\n    this.element.removeEventListener(\n      \"touchstart\",\n      this.onTouchStart,\n      listenerOptions\n    );\n    this.element.removeEventListener(\n      \"touchmove\",\n      this.onTouchMove,\n      listenerOptions\n    );\n    this.element.removeEventListener(\n      \"touchend\",\n      this.onTouchEnd,\n      listenerOptions\n    );\n  }\n};\nvar defaultEasing = (t) => Math.min(1, 1.001 - Math.pow(2, -10 * t));\nvar Lenis = class {\n  constructor({\n    wrapper = window,\n    content = document.documentElement,\n    eventsTarget = wrapper,\n    smoothWheel = true,\n    syncTouch = false,\n    syncTouchLerp = 0.075,\n    touchInertiaMultiplier = 35,\n    duration,\n    // in seconds\n    easing,\n    lerp: lerp2 = 0.1,\n    infinite = false,\n    orientation = \"vertical\",\n    // vertical, horizontal\n    gestureOrientation = \"vertical\",\n    // vertical, horizontal, both\n    touchMultiplier = 1,\n    wheelMultiplier = 1,\n    autoResize = true,\n    prevent,\n    virtualScroll,\n    overscroll = true,\n    autoRaf = false,\n    anchors = false,\n    autoToggle = false,\n    // https://caniuse.com/?search=transition-behavior\n    allowNestedScroll = false,\n    __experimental__naiveDimensions = false\n  } = {}) {\n    __publicField(this, \"_isScrolling\", false);\n    // true when scroll is animating\n    __publicField(this, \"_isStopped\", false);\n    // true if user should not be able to scroll - enable/disable programmatically\n    __publicField(this, \"_isLocked\", false);\n    // same as isStopped but enabled/disabled when scroll reaches target\n    __publicField(this, \"_preventNextNativeScrollEvent\", false);\n    __publicField(this, \"_resetVelocityTimeout\", null);\n    __publicField(this, \"__rafID\", null);\n    /**\n     * Whether or not the user is touching the screen\n     */\n    __publicField(this, \"isTouching\");\n    /**\n     * The time in ms since the lenis instance was created\n     */\n    __publicField(this, \"time\", 0);\n    /**\n     * User data that will be forwarded through the scroll event\n     *\n     * @example\n     * lenis.scrollTo(100, {\n     *   userData: {\n     *     foo: 'bar'\n     *   }\n     * })\n     */\n    __publicField(this, \"userData\", {});\n    /**\n     * The last velocity of the scroll\n     */\n    __publicField(this, \"lastVelocity\", 0);\n    /**\n     * The current velocity of the scroll\n     */\n    __publicField(this, \"velocity\", 0);\n    /**\n     * The direction of the scroll\n     */\n    __publicField(this, \"direction\", 0);\n    /**\n     * The options passed to the lenis instance\n     */\n    __publicField(this, \"options\");\n    /**\n     * The target scroll value\n     */\n    __publicField(this, \"targetScroll\");\n    /**\n     * The animated scroll value\n     */\n    __publicField(this, \"animatedScroll\");\n    // These are instanciated here as they don't need information from the options\n    __publicField(this, \"animate\", new Animate());\n    __publicField(this, \"emitter\", new Emitter());\n    // These are instanciated in the constructor as they need information from the options\n    __publicField(this, \"dimensions\");\n    // This is not private because it's used in the Snap class\n    __publicField(this, \"virtualScroll\");\n    __publicField(this, \"onScrollEnd\", (e) => {\n      if (!(e instanceof CustomEvent)) {\n        if (this.isScrolling === \"smooth\" || this.isScrolling === false) {\n          e.stopPropagation();\n        }\n      }\n    });\n    __publicField(this, \"dispatchScrollendEvent\", () => {\n      this.options.wrapper.dispatchEvent(\n        new CustomEvent(\"scrollend\", {\n          bubbles: this.options.wrapper === window,\n          // cancelable: false,\n          detail: {\n            lenisScrollEnd: true\n          }\n        })\n      );\n    });\n    __publicField(this, \"onTransitionEnd\", (event) => {\n      if (event.propertyName.includes(\"overflow\")) {\n        const property = this.isHorizontal ? \"overflow-x\" : \"overflow-y\";\n        const overflow = getComputedStyle(this.rootElement)[property];\n        if ([\"hidden\", \"clip\"].includes(overflow)) {\n          this.stop();\n        } else {\n          this.start();\n        }\n      }\n    });\n    __publicField(this, \"onClick\", (event) => {\n      const path = event.composedPath();\n      const anchor = path.find(\n        (node) => {\n          var _a, _b, _c;\n          return node instanceof HTMLAnchorElement && (((_a = node.getAttribute(\"href\")) == null ? void 0 : _a.startsWith(\"#\")) || ((_b = node.getAttribute(\"href\")) == null ? void 0 : _b.startsWith(\"/#\")) || ((_c = node.getAttribute(\"href\")) == null ? void 0 : _c.startsWith(\"./#\")));\n        }\n      );\n      if (anchor) {\n        const id = anchor.getAttribute(\"href\");\n        if (id) {\n          const options = typeof this.options.anchors === \"object\" && this.options.anchors ? this.options.anchors : void 0;\n          let target = `#${id.split(\"#\")[1]}`;\n          if ([\"#\", \"/#\", \"./#\", \"#top\", \"/#top\", \"./#top\"].includes(id)) {\n            target = 0;\n          }\n          this.scrollTo(target, options);\n        }\n      }\n    });\n    __publicField(this, \"onPointerDown\", (event) => {\n      if (event.button === 1) {\n        this.reset();\n      }\n    });\n    __publicField(this, \"onVirtualScroll\", (data) => {\n      if (typeof this.options.virtualScroll === \"function\" && this.options.virtualScroll(data) === false)\n        return;\n      const { deltaX, deltaY, event } = data;\n      this.emitter.emit(\"virtual-scroll\", { deltaX, deltaY, event });\n      if (event.ctrlKey)\n        return;\n      if (event.lenisStopPropagation)\n        return;\n      const isTouch = event.type.includes(\"touch\");\n      const isWheel = event.type.includes(\"wheel\");\n      this.isTouching = event.type === \"touchstart\" || event.type === \"touchmove\";\n      const isClickOrTap = deltaX === 0 && deltaY === 0;\n      const isTapToStop = this.options.syncTouch && isTouch && event.type === \"touchstart\" && isClickOrTap && !this.isStopped && !this.isLocked;\n      if (isTapToStop) {\n        this.reset();\n        return;\n      }\n      const isUnknownGesture = this.options.gestureOrientation === \"vertical\" && deltaY === 0 || this.options.gestureOrientation === \"horizontal\" && deltaX === 0;\n      if (isClickOrTap || isUnknownGesture) {\n        return;\n      }\n      let composedPath = event.composedPath();\n      composedPath = composedPath.slice(0, composedPath.indexOf(this.rootElement));\n      const prevent = this.options.prevent;\n      if (!!composedPath.find(\n        (node) => {\n          var _a, _b, _c;\n          return node instanceof HTMLElement && (typeof prevent === \"function\" && (prevent == null ? void 0 : prevent(node)) || ((_a = node.hasAttribute) == null ? void 0 : _a.call(node, \"data-lenis-prevent\")) || isTouch && ((_b = node.hasAttribute) == null ? void 0 : _b.call(node, \"data-lenis-prevent-touch\")) || isWheel && ((_c = node.hasAttribute) == null ? void 0 : _c.call(node, \"data-lenis-prevent-wheel\")) || this.options.allowNestedScroll && this.checkNestedScroll(node, { deltaX, deltaY }));\n        }\n      ))\n        return;\n      if (this.isStopped || this.isLocked) {\n        event.preventDefault();\n        return;\n      }\n      const isSmooth = this.options.syncTouch && isTouch || this.options.smoothWheel && isWheel;\n      if (!isSmooth) {\n        this.isScrolling = \"native\";\n        this.animate.stop();\n        event.lenisStopPropagation = true;\n        return;\n      }\n      let delta = deltaY;\n      if (this.options.gestureOrientation === \"both\") {\n        delta = Math.abs(deltaY) > Math.abs(deltaX) ? deltaY : deltaX;\n      } else if (this.options.gestureOrientation === \"horizontal\") {\n        delta = deltaX;\n      }\n      if (!this.options.overscroll || this.options.infinite || this.options.wrapper !== window && (this.animatedScroll > 0 && this.animatedScroll < this.limit || this.animatedScroll === 0 && deltaY > 0 || this.animatedScroll === this.limit && deltaY < 0)) {\n        event.lenisStopPropagation = true;\n      }\n      event.preventDefault();\n      const isSyncTouch = isTouch && this.options.syncTouch;\n      const isTouchEnd = isTouch && event.type === \"touchend\";\n      const hasTouchInertia = isTouchEnd && Math.abs(delta) > 5;\n      if (hasTouchInertia) {\n        delta = this.velocity * this.options.touchInertiaMultiplier;\n      }\n      this.scrollTo(this.targetScroll + delta, {\n        programmatic: false,\n        ...isSyncTouch ? {\n          lerp: hasTouchInertia ? this.options.syncTouchLerp : 1\n          // immediate: !hasTouchInertia,\n        } : {\n          lerp: this.options.lerp,\n          duration: this.options.duration,\n          easing: this.options.easing\n        }\n      });\n    });\n    __publicField(this, \"onNativeScroll\", () => {\n      if (this._resetVelocityTimeout !== null) {\n        clearTimeout(this._resetVelocityTimeout);\n        this._resetVelocityTimeout = null;\n      }\n      if (this._preventNextNativeScrollEvent) {\n        this._preventNextNativeScrollEvent = false;\n        return;\n      }\n      if (this.isScrolling === false || this.isScrolling === \"native\") {\n        const lastScroll = this.animatedScroll;\n        this.animatedScroll = this.targetScroll = this.actualScroll;\n        this.lastVelocity = this.velocity;\n        this.velocity = this.animatedScroll - lastScroll;\n        this.direction = Math.sign(\n          this.animatedScroll - lastScroll\n        );\n        if (!this.isStopped) {\n          this.isScrolling = \"native\";\n        }\n        this.emit();\n        if (this.velocity !== 0) {\n          this._resetVelocityTimeout = setTimeout(() => {\n            this.lastVelocity = this.velocity;\n            this.velocity = 0;\n            this.isScrolling = false;\n            this.emit();\n          }, 400);\n        }\n      }\n    });\n    /**\n     * RequestAnimationFrame for lenis\n     *\n     * @param time The time in ms from an external clock like `requestAnimationFrame` or Tempus\n     */\n    __publicField(this, \"raf\", (time) => {\n      const deltaTime = time - (this.time || time);\n      this.time = time;\n      this.animate.advance(deltaTime * 1e-3);\n      if (this.options.autoRaf) {\n        this.__rafID = requestAnimationFrame(this.raf);\n      }\n    });\n    window.lenisVersion = version;\n    if (!wrapper || wrapper === document.documentElement) {\n      wrapper = window;\n    }\n    if (typeof duration === \"number\" && typeof easing !== \"function\") {\n      easing = defaultEasing;\n    } else if (typeof easing === \"function\" && typeof duration !== \"number\") {\n      duration = 1;\n    }\n    this.options = {\n      wrapper,\n      content,\n      eventsTarget,\n      smoothWheel,\n      syncTouch,\n      syncTouchLerp,\n      touchInertiaMultiplier,\n      duration,\n      easing,\n      lerp: lerp2,\n      infinite,\n      gestureOrientation,\n      orientation,\n      touchMultiplier,\n      wheelMultiplier,\n      autoResize,\n      prevent,\n      virtualScroll,\n      overscroll,\n      autoRaf,\n      anchors,\n      autoToggle,\n      allowNestedScroll,\n      __experimental__naiveDimensions\n    };\n    this.dimensions = new Dimensions(wrapper, content, { autoResize });\n    this.updateClassName();\n    this.targetScroll = this.animatedScroll = this.actualScroll;\n    this.options.wrapper.addEventListener(\"scroll\", this.onNativeScroll, false);\n    this.options.wrapper.addEventListener(\"scrollend\", this.onScrollEnd, {\n      capture: true\n    });\n    if (this.options.anchors && this.options.wrapper === window) {\n      this.options.wrapper.addEventListener(\n        \"click\",\n        this.onClick,\n        false\n      );\n    }\n    this.options.wrapper.addEventListener(\n      \"pointerdown\",\n      this.onPointerDown,\n      false\n    );\n    this.virtualScroll = new VirtualScroll(eventsTarget, {\n      touchMultiplier,\n      wheelMultiplier\n    });\n    this.virtualScroll.on(\"scroll\", this.onVirtualScroll);\n    if (this.options.autoToggle) {\n      this.rootElement.addEventListener(\"transitionend\", this.onTransitionEnd, {\n        passive: true\n      });\n    }\n    if (this.options.autoRaf) {\n      this.__rafID = requestAnimationFrame(this.raf);\n    }\n  }\n  /**\n   * Destroy the lenis instance, remove all event listeners and clean up the class name\n   */\n  destroy() {\n    this.emitter.destroy();\n    this.options.wrapper.removeEventListener(\n      \"scroll\",\n      this.onNativeScroll,\n      false\n    );\n    this.options.wrapper.removeEventListener(\"scrollend\", this.onScrollEnd, {\n      capture: true\n    });\n    this.options.wrapper.removeEventListener(\n      \"pointerdown\",\n      this.onPointerDown,\n      false\n    );\n    if (this.options.anchors && this.options.wrapper === window) {\n      this.options.wrapper.removeEventListener(\n        \"click\",\n        this.onClick,\n        false\n      );\n    }\n    this.virtualScroll.destroy();\n    this.dimensions.destroy();\n    this.cleanUpClassName();\n    if (this.__rafID) {\n      cancelAnimationFrame(this.__rafID);\n    }\n  }\n  on(event, callback) {\n    return this.emitter.on(event, callback);\n  }\n  off(event, callback) {\n    return this.emitter.off(event, callback);\n  }\n  setScroll(scroll) {\n    if (this.isHorizontal) {\n      this.options.wrapper.scrollTo({ left: scroll, behavior: \"instant\" });\n    } else {\n      this.options.wrapper.scrollTo({ top: scroll, behavior: \"instant\" });\n    }\n  }\n  /**\n   * Force lenis to recalculate the dimensions\n   */\n  resize() {\n    this.dimensions.resize();\n    this.animatedScroll = this.targetScroll = this.actualScroll;\n    this.emit();\n  }\n  emit() {\n    this.emitter.emit(\"scroll\", this);\n  }\n  reset() {\n    this.isLocked = false;\n    this.isScrolling = false;\n    this.animatedScroll = this.targetScroll = this.actualScroll;\n    this.lastVelocity = this.velocity = 0;\n    this.animate.stop();\n  }\n  /**\n   * Start lenis scroll after it has been stopped\n   */\n  start() {\n    if (!this.isStopped)\n      return;\n    this.reset();\n    this.isStopped = false;\n    this.emit();\n  }\n  /**\n   * Stop lenis scroll\n   */\n  stop() {\n    if (this.isStopped)\n      return;\n    this.reset();\n    this.isStopped = true;\n    this.emit();\n  }\n  /**\n   * Scroll to a target value\n   *\n   * @param target The target value to scroll to\n   * @param options The options for the scroll\n   *\n   * @example\n   * lenis.scrollTo(100, {\n   *   offset: 100,\n   *   duration: 1,\n   *   easing: (t) => 1 - Math.cos((t * Math.PI) / 2),\n   *   lerp: 0.1,\n   *   onStart: () => {\n   *     console.log('onStart')\n   *   },\n   *   onComplete: () => {\n   *     console.log('onComplete')\n   *   },\n   * })\n   */\n  scrollTo(target, {\n    offset = 0,\n    immediate = false,\n    lock = false,\n    duration = this.options.duration,\n    easing = this.options.easing,\n    lerp: lerp2 = this.options.lerp,\n    onStart,\n    onComplete,\n    force = false,\n    // scroll even if stopped\n    programmatic = true,\n    // called from outside of the class\n    userData\n  } = {}) {\n    if ((this.isStopped || this.isLocked) && !force)\n      return;\n    if (typeof target === \"string\" && [\"top\", \"left\", \"start\"].includes(target)) {\n      target = 0;\n    } else if (typeof target === \"string\" && [\"bottom\", \"right\", \"end\"].includes(target)) {\n      target = this.limit;\n    } else {\n      let node;\n      if (typeof target === \"string\") {\n        node = document.querySelector(target);\n      } else if (target instanceof HTMLElement && (target == null ? void 0 : target.nodeType)) {\n        node = target;\n      }\n      if (node) {\n        if (this.options.wrapper !== window) {\n          const wrapperRect = this.rootElement.getBoundingClientRect();\n          offset -= this.isHorizontal ? wrapperRect.left : wrapperRect.top;\n        }\n        const rect = node.getBoundingClientRect();\n        target = (this.isHorizontal ? rect.left : rect.top) + this.animatedScroll;\n      }\n    }\n    if (typeof target !== \"number\")\n      return;\n    target += offset;\n    target = Math.round(target);\n    if (this.options.infinite) {\n      if (programmatic) {\n        this.targetScroll = this.animatedScroll = this.scroll;\n        const distance = target - this.animatedScroll;\n        if (distance > this.limit / 2) {\n          target = target - this.limit;\n        } else if (distance < -this.limit / 2) {\n          target = target + this.limit;\n        }\n      }\n    } else {\n      target = clamp(0, target, this.limit);\n    }\n    if (target === this.targetScroll) {\n      onStart == null ? void 0 : onStart(this);\n      onComplete == null ? void 0 : onComplete(this);\n      return;\n    }\n    this.userData = userData ?? {};\n    if (immediate) {\n      this.animatedScroll = this.targetScroll = target;\n      this.setScroll(this.scroll);\n      this.reset();\n      this.preventNextNativeScrollEvent();\n      this.emit();\n      onComplete == null ? void 0 : onComplete(this);\n      this.userData = {};\n      requestAnimationFrame(() => {\n        this.dispatchScrollendEvent();\n      });\n      return;\n    }\n    if (!programmatic) {\n      this.targetScroll = target;\n    }\n    if (typeof duration === \"number\" && typeof easing !== \"function\") {\n      easing = defaultEasing;\n    } else if (typeof easing === \"function\" && typeof duration !== \"number\") {\n      duration = 1;\n    }\n    this.animate.fromTo(this.animatedScroll, target, {\n      duration,\n      easing,\n      lerp: lerp2,\n      onStart: () => {\n        if (lock)\n          this.isLocked = true;\n        this.isScrolling = \"smooth\";\n        onStart == null ? void 0 : onStart(this);\n      },\n      onUpdate: (value, completed) => {\n        this.isScrolling = \"smooth\";\n        this.lastVelocity = this.velocity;\n        this.velocity = value - this.animatedScroll;\n        this.direction = Math.sign(this.velocity);\n        this.animatedScroll = value;\n        this.setScroll(this.scroll);\n        if (programmatic) {\n          this.targetScroll = value;\n        }\n        if (!completed)\n          this.emit();\n        if (completed) {\n          this.reset();\n          this.emit();\n          onComplete == null ? void 0 : onComplete(this);\n          this.userData = {};\n          requestAnimationFrame(() => {\n            this.dispatchScrollendEvent();\n          });\n          this.preventNextNativeScrollEvent();\n        }\n      }\n    });\n  }\n  preventNextNativeScrollEvent() {\n    this._preventNextNativeScrollEvent = true;\n    requestAnimationFrame(() => {\n      this._preventNextNativeScrollEvent = false;\n    });\n  }\n  checkNestedScroll(node, { deltaX, deltaY }) {\n    const time = Date.now();\n    const cache = node._lenis ?? (node._lenis = {});\n    let hasOverflowX, hasOverflowY, isScrollableX, isScrollableY, scrollWidth, scrollHeight, clientWidth, clientHeight;\n    const gestureOrientation = this.options.gestureOrientation;\n    if (time - (cache.time ?? 0) > 2e3) {\n      cache.time = Date.now();\n      const computedStyle = window.getComputedStyle(node);\n      cache.computedStyle = computedStyle;\n      const overflowXString = computedStyle.overflowX;\n      const overflowYString = computedStyle.overflowY;\n      hasOverflowX = [\"auto\", \"overlay\", \"scroll\"].includes(overflowXString);\n      hasOverflowY = [\"auto\", \"overlay\", \"scroll\"].includes(overflowYString);\n      cache.hasOverflowX = hasOverflowX;\n      cache.hasOverflowY = hasOverflowY;\n      if (!hasOverflowX && !hasOverflowY)\n        return false;\n      if (gestureOrientation === \"vertical\" && !hasOverflowY)\n        return false;\n      if (gestureOrientation === \"horizontal\" && !hasOverflowX)\n        return false;\n      scrollWidth = node.scrollWidth;\n      scrollHeight = node.scrollHeight;\n      clientWidth = node.clientWidth;\n      clientHeight = node.clientHeight;\n      isScrollableX = scrollWidth > clientWidth;\n      isScrollableY = scrollHeight > clientHeight;\n      cache.isScrollableX = isScrollableX;\n      cache.isScrollableY = isScrollableY;\n      cache.scrollWidth = scrollWidth;\n      cache.scrollHeight = scrollHeight;\n      cache.clientWidth = clientWidth;\n      cache.clientHeight = clientHeight;\n    } else {\n      isScrollableX = cache.isScrollableX;\n      isScrollableY = cache.isScrollableY;\n      hasOverflowX = cache.hasOverflowX;\n      hasOverflowY = cache.hasOverflowY;\n      scrollWidth = cache.scrollWidth;\n      scrollHeight = cache.scrollHeight;\n      clientWidth = cache.clientWidth;\n      clientHeight = cache.clientHeight;\n    }\n    if (!hasOverflowX && !hasOverflowY || !isScrollableX && !isScrollableY) {\n      return false;\n    }\n    if (gestureOrientation === \"vertical\" && (!hasOverflowY || !isScrollableY))\n      return false;\n    if (gestureOrientation === \"horizontal\" && (!hasOverflowX || !isScrollableX))\n      return false;\n    let orientation;\n    if (gestureOrientation === \"horizontal\") {\n      orientation = \"x\";\n    } else if (gestureOrientation === \"vertical\") {\n      orientation = \"y\";\n    } else {\n      const isScrollingX = deltaX !== 0;\n      const isScrollingY = deltaY !== 0;\n      if (isScrollingX && hasOverflowX && isScrollableX) {\n        orientation = \"x\";\n      }\n      if (isScrollingY && hasOverflowY && isScrollableY) {\n        orientation = \"y\";\n      }\n    }\n    if (!orientation)\n      return false;\n    let scroll, maxScroll, delta, hasOverflow, isScrollable;\n    if (orientation === \"x\") {\n      scroll = node.scrollLeft;\n      maxScroll = scrollWidth - clientWidth;\n      delta = deltaX;\n      hasOverflow = hasOverflowX;\n      isScrollable = isScrollableX;\n    } else if (orientation === \"y\") {\n      scroll = node.scrollTop;\n      maxScroll = scrollHeight - clientHeight;\n      delta = deltaY;\n      hasOverflow = hasOverflowY;\n      isScrollable = isScrollableY;\n    } else {\n      return false;\n    }\n    const willScroll = delta > 0 ? scroll < maxScroll : scroll > 0;\n    return willScroll && hasOverflow && isScrollable;\n  }\n  /**\n   * The root element on which lenis is instanced\n   */\n  get rootElement() {\n    return this.options.wrapper === window ? document.documentElement : this.options.wrapper;\n  }\n  /**\n   * The limit which is the maximum scroll value\n   */\n  get limit() {\n    if (this.options.__experimental__naiveDimensions) {\n      if (this.isHorizontal) {\n        return this.rootElement.scrollWidth - this.rootElement.clientWidth;\n      } else {\n        return this.rootElement.scrollHeight - this.rootElement.clientHeight;\n      }\n    } else {\n      return this.dimensions.limit[this.isHorizontal ? \"x\" : \"y\"];\n    }\n  }\n  /**\n   * Whether or not the scroll is horizontal\n   */\n  get isHorizontal() {\n    return this.options.orientation === \"horizontal\";\n  }\n  /**\n   * The actual scroll value\n   */\n  get actualScroll() {\n    const wrapper = this.options.wrapper;\n    return this.isHorizontal ? wrapper.scrollX ?? wrapper.scrollLeft : wrapper.scrollY ?? wrapper.scrollTop;\n  }\n  /**\n   * The current scroll value\n   */\n  get scroll() {\n    return this.options.infinite ? modulo(this.animatedScroll, this.limit) : this.animatedScroll;\n  }\n  /**\n   * The progress of the scroll relative to the limit\n   */\n  get progress() {\n    return this.limit === 0 ? 1 : this.scroll / this.limit;\n  }\n  /**\n   * Current scroll state\n   */\n  get isScrolling() {\n    return this._isScrolling;\n  }\n  set isScrolling(value) {\n    if (this._isScrolling !== value) {\n      this._isScrolling = value;\n      this.updateClassName();\n    }\n  }\n  /**\n   * Check if lenis is stopped\n   */\n  get isStopped() {\n    return this._isStopped;\n  }\n  set isStopped(value) {\n    if (this._isStopped !== value) {\n      this._isStopped = value;\n      this.updateClassName();\n    }\n  }\n  /**\n   * Check if lenis is locked\n   */\n  get isLocked() {\n    return this._isLocked;\n  }\n  set isLocked(value) {\n    if (this._isLocked !== value) {\n      this._isLocked = value;\n      this.updateClassName();\n    }\n  }\n  /**\n   * Check if lenis is smooth scrolling\n   */\n  get isSmooth() {\n    return this.isScrolling === \"smooth\";\n  }\n  /**\n   * The class name applied to the wrapper element\n   */\n  get className() {\n    let className = \"lenis\";\n    if (this.options.autoToggle)\n      className += \" lenis-autoToggle\";\n    if (this.isStopped)\n      className += \" lenis-stopped\";\n    if (this.isLocked)\n      className += \" lenis-locked\";\n    if (this.isScrolling)\n      className += \" lenis-scrolling\";\n    if (this.isScrolling === \"smooth\")\n      className += \" lenis-smooth\";\n    return className;\n  }\n  updateClassName() {\n    this.cleanUpClassName();\n    this.rootElement.className = `${this.rootElement.className} ${this.className}`.trim();\n  }\n  cleanUpClassName() {\n    this.rootElement.className = this.rootElement.className.replace(/lenis(-\\w+)?/g, \"\").trim();\n  }\n};\nexport {\n  Lenis as default\n};\n//# sourceMappingURL=lenis.js.map\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 34285,
            "count": 1
          }
        ]
      },
      {
        "functionName": "clamp",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 200,
            "endOffset": 281,
            "count": 0
          }
        ]
      },
      {
        "functionName": "lerp",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 282,
            "endOffset": 338,
            "count": 0
          }
        ]
      },
      {
        "functionName": "damp",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 339,
            "endOffset": 437,
            "count": 0
          }
        ]
      },
      {
        "functionName": "modulo",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 438,
            "endOffset": 489,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Animate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 514,
            "endOffset": 921,
            "count": 0
          }
        ]
      },
      {
        "functionName": "advance",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1061,
            "endOffset": 1910,
            "count": 0
          }
        ]
      },
      {
        "functionName": "stop",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1941,
            "endOffset": 1981,
            "count": 0
          }
        ]
      },
      {
        "functionName": "fromTo",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2271,
            "endOffset": 2604,
            "count": 0
          }
        ]
      },
      {
        "functionName": "debounce",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2608,
            "endOffset": 2847,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Dimensions",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2875,
            "endOffset": 4701,
            "count": 0
          }
        ]
      },
      {
        "functionName": "destroy",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4704,
            "endOffset": 5021,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get limit",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 5024,
            "endOffset": 5142,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Emitter",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 5170,
            "endOffset": 5228,
            "count": 0
          }
        ]
      },
      {
        "functionName": "emit",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 5363,
            "endOffset": 5593,
            "count": 0
          }
        ]
      },
      {
        "functionName": "on",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 5738,
            "endOffset": 6007,
            "count": 0
          }
        ]
      },
      {
        "functionName": "off",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 6128,
            "endOffset": 6270,
            "count": 0
          }
        ]
      },
      {
        "functionName": "destroy",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 6330,
            "endOffset": 6367,
            "count": 0
          }
        ]
      },
      {
        "functionName": "VirtualScroll",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 6470,
            "endOffset": 9319,
            "count": 0
          }
        ]
      },
      {
        "functionName": "on",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 9467,
            "endOffset": 9537,
            "count": 0
          }
        ]
      },
      {
        "functionName": "destroy",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 9589,
            "endOffset": 10110,
            "count": 0
          }
        ]
      },
      {
        "functionName": "defaultEasing",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10134,
            "endOffset": 10182,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Lenis",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10206,
            "endOffset": 21769,
            "count": 0
          }
        ]
      },
      {
        "functionName": "destroy",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 21872,
            "endOffset": 22590,
            "count": 0
          }
        ]
      },
      {
        "functionName": "on",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 22593,
            "endOffset": 22663,
            "count": 0
          }
        ]
      },
      {
        "functionName": "off",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 22666,
            "endOffset": 22738,
            "count": 0
          }
        ]
      },
      {
        "functionName": "setScroll",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 22741,
            "endOffset": 22963,
            "count": 0
          }
        ]
      },
      {
        "functionName": "resize",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 23025,
            "endOffset": 23151,
            "count": 0
          }
        ]
      },
      {
        "functionName": "emit",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 23154,
            "endOffset": 23205,
            "count": 0
          }
        ]
      },
      {
        "functionName": "reset",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 23208,
            "endOffset": 23411,
            "count": 0
          }
        ]
      },
      {
        "functionName": "start",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 23476,
            "endOffset": 23591,
            "count": 0
          }
        ]
      },
      {
        "functionName": "stop",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 23629,
            "endOffset": 23741,
            "count": 0
          }
        ]
      },
      {
        "functionName": "scrollTo",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 24192,
            "endOffset": 27856,
            "count": 0
          }
        ]
      },
      {
        "functionName": "preventNextNativeScrollEvent",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 27859,
            "endOffset": 28034,
            "count": 0
          }
        ]
      },
      {
        "functionName": "checkNestedScroll",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 28037,
            "endOffset": 31395,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get rootElement",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 31460,
            "endOffset": 31577,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get limit",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 31641,
            "endOffset": 32008,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get isHorizontal",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 32068,
            "endOffset": 32146,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get actualScroll",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 32190,
            "endOffset": 32365,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get scroll",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 32410,
            "endOffset": 32526,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get progress",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 32595,
            "endOffset": 32675,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get isScrolling",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 32716,
            "endOffset": 32769,
            "count": 0
          }
        ]
      },
      {
        "functionName": "set isScrolling",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 32772,
            "endOffset": 32908,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get isStopped",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 32954,
            "endOffset": 33003,
            "count": 0
          }
        ]
      },
      {
        "functionName": "set isStopped",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 33006,
            "endOffset": 33136,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get isLocked",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 33181,
            "endOffset": 33228,
            "count": 0
          }
        ]
      },
      {
        "functionName": "set isLocked",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 33231,
            "endOffset": 33358,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get isSmooth",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 33413,
            "endOffset": 33475,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get className",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 33541,
            "endOffset": 33946,
            "count": 0
          }
        ]
      },
      {
        "functionName": "updateClassName",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 33949,
            "endOffset": 34092,
            "count": 0
          }
        ]
      },
      {
        "functionName": "cleanUpClassName",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 34095,
            "endOffset": 34216,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5173/src/components/KineticPhone/KineticPhone.tsx",
    "scriptId": "48",
    "source": "import { createHotContext as __vite__createHotContext } from \"/@vite/client\";import.meta.hot = __vite__createHotContext(\"/src/components/KineticPhone/KineticPhone.tsx\");import __vite__cjsImport0_react_jsxDevRuntime from \"/node_modules/.vite/deps/react_jsx-dev-runtime.js?v=a50bb159\"; const jsxDEV = __vite__cjsImport0_react_jsxDevRuntime[\"jsxDEV\"];\nimport RefreshRuntime from \"/@react-refresh\";\nconst inWebWorker = typeof WorkerGlobalScope !== \"undefined\" && self instanceof WorkerGlobalScope;\nlet prevRefreshReg;\nlet prevRefreshSig;\nif (import.meta.hot && !inWebWorker) {\n  if (!window.__vite_plugin_react_preamble_installed__) {\n    throw new Error(\"@vitejs/plugin-react can't detect preamble. Something is wrong. See https://github.com/vitejs/vite-plugin-react/pull/11#discussion_r430879201\");\n  }\n  prevRefreshReg = window.$RefreshReg$;\n  prevRefreshSig = window.$RefreshSig$;\n  window.$RefreshReg$ = (type, id) => {\n    RefreshRuntime.register(type, \"/home/will/local_dev/portfolio/apps/robin-noguier/src/components/KineticPhone/KineticPhone.tsx \" + id);\n  };\n  window.$RefreshSig$ = RefreshRuntime.createSignatureFunctionForTransform;\n}\nvar _s = $RefreshSig$();\nimport __vite__cjsImport3_react from \"/node_modules/.vite/deps/react.js?v=a50bb159\"; const useRef = __vite__cjsImport3_react[\"useRef\"]; const useState = __vite__cjsImport3_react[\"useState\"]; const useEffect = __vite__cjsImport3_react[\"useEffect\"];\nimport { gsap } from \"/node_modules/.vite/deps/gsap.js?v=a50bb159\";\nimport styles from \"/src/components/KineticPhone/KineticPhone.module.css\";\nexport const KineticPhone = ({ className }) => {\n  _s();\n  const containerRef = useRef(null);\n  const [currentStage, setCurrentStage] = useState(0);\n  const flipInterval = useRef();\n  const stages = [\"332 287-9533\", \"332 AT-RYLEE\", \"NYC @ RYLEE \"];\n  useEffect(() => {\n    flipInterval.current = setInterval(() => {\n      setCurrentStage((prev) => (prev + 1) % stages.length);\n    }, 3e3);\n    return () => {\n      if (flipInterval.current)\n        clearInterval(flipInterval.current);\n    };\n  }, []);\n  useEffect(() => {\n    if (!containerRef.current)\n      return;\n    const container = containerRef.current;\n    const flippers = container.querySelectorAll(`.${styles.flipper}`);\n    flippers.forEach((flipper, index) => {\n      const currentChar = stages[currentStage][index];\n      const prevChar = stages[(currentStage - 1 + stages.length) % stages.length][index];\n      if (currentChar !== prevChar) {\n        const delay = index * 0.03;\n        gsap.to(flipper, {\n          rotateX: -90,\n          duration: 0.3,\n          delay,\n          ease: \"power2.in\",\n          onComplete: () => {\n            flipper.textContent = currentChar || \" \";\n            gsap.to(flipper, {\n              rotateX: 0,\n              duration: 0.3,\n              ease: \"power2.out\"\n            });\n          }\n        });\n      }\n    });\n  }, [currentStage]);\n  return /* @__PURE__ */ jsxDEV(\n    \"div\",\n    {\n      ref: containerRef,\n      className: `${styles.container} ${className || \"\"}`,\n      children: /* @__PURE__ */ jsxDEV(\"a\", { href: \"tel:3322879533\", className: styles.phoneLink, children: stages[0].split(\"\").map(\n        (char, index) => /* @__PURE__ */ jsxDEV(\"span\", { className: styles.flipContainer, children: /* @__PURE__ */ jsxDEV(\"span\", { className: styles.flipper, children: char }, void 0, false, {\n          fileName: \"/home/will/local_dev/portfolio/apps/robin-noguier/src/components/KineticPhone/KineticPhone.tsx\",\n          lineNumber: 71,\n          columnNumber: 13\n        }, this) }, index, false, {\n          fileName: \"/home/will/local_dev/portfolio/apps/robin-noguier/src/components/KineticPhone/KineticPhone.tsx\",\n          lineNumber: 70,\n          columnNumber: 9\n        }, this)\n      ) }, void 0, false, {\n        fileName: \"/home/will/local_dev/portfolio/apps/robin-noguier/src/components/KineticPhone/KineticPhone.tsx\",\n        lineNumber: 68,\n        columnNumber: 7\n      }, this)\n    },\n    void 0,\n    false,\n    {\n      fileName: \"/home/will/local_dev/portfolio/apps/robin-noguier/src/components/KineticPhone/KineticPhone.tsx\",\n      lineNumber: 64,\n      columnNumber: 5\n    },\n    this\n  );\n};\n_s(KineticPhone, \"tZXI+tDNj3y1KA5JUeiGNVL52Zg=\");\n_c = KineticPhone;\nvar _c;\n$RefreshReg$(_c, \"KineticPhone\");\nif (import.meta.hot && !inWebWorker) {\n  window.$RefreshReg$ = prevRefreshReg;\n  window.$RefreshSig$ = prevRefreshSig;\n  RefreshRuntime.__hmr_import(import.meta.url).then((currentExports) => {\n    RefreshRuntime.registerExportsForReactRefresh(\"/home/will/local_dev/portfolio/apps/robin-noguier/src/components/KineticPhone/KineticPhone.tsx\", currentExports);\n    import.meta.hot.accept((nextExports) => {\n      if (!nextExports)\n        return;\n      const invalidateMessage = RefreshRuntime.validateRefreshBoundaryAndEnqueueUpdate(currentExports, nextExports);\n      if (invalidateMessage)\n        import.meta.hot.invalidate(invalidateMessage);\n    });\n  });\n}\n\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJtYXBwaW5ncyI6IkFBc0VZOzJCQXRFWjtBQUFpQkEsTUFBVUMsY0FBUyxPQUFRLHNCQUFPO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ25ELFNBQVNDLFlBQVk7QUFDckIsT0FBT0MsWUFBWTtBQU1aLGFBQU1DLGVBQWVBLENBQUMsRUFBRUMsVUFBNkIsTUFBTTtBQUFBQyxLQUFBO0FBQ2hFLFFBQU1DLGVBQWVDLE9BQXVCLElBQUk7QUFDaEQsUUFBTSxDQUFDQyxjQUFjQyxlQUFlLElBQUlWLFNBQVMsQ0FBQztBQUNsRCxRQUFNVyxlQUFlSCxPQUF1QjtBQUc1QyxRQUFNSSxTQUFTLENBQUMsZ0JBQWdCLGdCQUFnQixjQUFjO0FBRzlEWCxZQUFVLE1BQU07QUFDZFUsaUJBQWFFLFVBQVVDLFlBQVksTUFBTTtBQUN2Q0osc0JBQWdCLENBQUNLLFVBQVVBLE9BQU8sS0FBS0gsT0FBT0ksTUFBTTtBQUFBLElBQ3RELEdBQUcsR0FBSTtBQUVQLFdBQU8sTUFBTTtBQUNYLFVBQUlMLGFBQWFFO0FBQVNJLHNCQUFjTixhQUFhRSxPQUFPO0FBQUEsSUFDOUQ7QUFBQSxFQUNGLEdBQUcsRUFBRTtBQUdMWixZQUFVLE1BQU07QUFDZCxRQUFJLENBQUNNLGFBQWFNO0FBQVM7QUFFM0IsVUFBTUssWUFBWVgsYUFBYU07QUFDL0IsVUFBTU0sV0FBV0QsVUFBVUUsaUJBQWlCLElBQUlqQixPQUFPa0IsT0FBTyxFQUFFO0FBRWhFRixhQUFTRyxRQUFRLENBQUNELFNBQVNFLFVBQVU7QUFDbkMsWUFBTUMsY0FBY1osT0FBT0gsWUFBWSxFQUFFYyxLQUFLO0FBQzlDLFlBQU1FLFdBQ0piLFFBQVFILGVBQWUsSUFBSUcsT0FBT0ksVUFBVUosT0FBT0ksTUFBTSxFQUFFTyxLQUFLO0FBR2xFLFVBQUlDLGdCQUFnQkMsVUFBVTtBQUM1QixjQUFNQyxRQUFRSCxRQUFRO0FBRXRCckIsYUFBS3lCLEdBQUdOLFNBQVM7QUFBQSxVQUNmTyxTQUFTO0FBQUEsVUFDVEMsVUFBVTtBQUFBLFVBQ1ZIO0FBQUFBLFVBQ0FJLE1BQU07QUFBQSxVQUNOQyxZQUFZQSxNQUFNO0FBRWhCVixvQkFBUVcsY0FBY1IsZUFBZTtBQUNyQ3RCLGlCQUFLeUIsR0FBR04sU0FBUztBQUFBLGNBQ2ZPLFNBQVM7QUFBQSxjQUNUQyxVQUFVO0FBQUEsY0FDVkMsTUFBTTtBQUFBLFlBQ1IsQ0FBQztBQUFBLFVBQ0g7QUFBQSxRQUNGLENBQUM7QUFBQSxNQUNIO0FBQUEsSUFDRixDQUFDO0FBQUEsRUFDSCxHQUFHLENBQUNyQixZQUFZLENBQUM7QUFFakIsU0FDRTtBQUFBLElBQUM7QUFBQTtBQUFBLE1BQ0MsS0FBS0Y7QUFBQUEsTUFDTCxXQUFXLEdBQUdKLE9BQU9lLFNBQVMsSUFBSWIsYUFBYSxFQUFFO0FBQUEsTUFFakQsaUNBQUMsT0FBRSxNQUFLLGtCQUFpQixXQUFXRixPQUFPOEIsV0FDeENyQixpQkFBTyxDQUFDLEVBQUVzQixNQUFNLEVBQUUsRUFBRUM7QUFBQUEsUUFBSSxDQUFDQyxNQUFNYixVQUM5Qix1QkFBQyxVQUFpQixXQUFXcEIsT0FBT2tDLGVBQ2xDLGlDQUFDLFVBQUssV0FBV2xDLE9BQU9rQixTQUFVZSxrQkFBbEM7QUFBQTtBQUFBO0FBQUE7QUFBQSxlQUF1QyxLQUQ5QmIsT0FBWDtBQUFBO0FBQUE7QUFBQTtBQUFBLGVBRUE7QUFBQSxNQUNELEtBTEg7QUFBQTtBQUFBO0FBQUE7QUFBQSxhQU1BO0FBQUE7QUFBQSxJQVZGO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQVdBO0FBRUo7QUFBQ2pCLEdBcEVZRixjQUFZO0FBQUFrQyxLQUFabEM7QUFBWSxJQUFBa0M7QUFBQUMsYUFBQUQsSUFBQSIsIm5hbWVzIjpbInVzZVN0YXRlIiwidXNlRWZmZWN0IiwiZ3NhcCIsInN0eWxlcyIsIktpbmV0aWNQaG9uZSIsImNsYXNzTmFtZSIsIl9zIiwiY29udGFpbmVyUmVmIiwidXNlUmVmIiwiY3VycmVudFN0YWdlIiwic2V0Q3VycmVudFN0YWdlIiwiZmxpcEludGVydmFsIiwic3RhZ2VzIiwiY3VycmVudCIsInNldEludGVydmFsIiwicHJldiIsImxlbmd0aCIsImNsZWFySW50ZXJ2YWwiLCJjb250YWluZXIiLCJmbGlwcGVycyIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJmbGlwcGVyIiwiZm9yRWFjaCIsImluZGV4IiwiY3VycmVudENoYXIiLCJwcmV2Q2hhciIsImRlbGF5IiwidG8iLCJyb3RhdGVYIiwiZHVyYXRpb24iLCJlYXNlIiwib25Db21wbGV0ZSIsInRleHRDb250ZW50IiwicGhvbmVMaW5rIiwic3BsaXQiLCJtYXAiLCJjaGFyIiwiZmxpcENvbnRhaW5lciIsIl9jIiwiJFJlZnJlc2hSZWckIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VzIjpbIktpbmV0aWNQaG9uZS50c3giXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlUmVmLCB1c2VTdGF0ZSwgdXNlRWZmZWN0IH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgeyBnc2FwIH0gZnJvbSAnZ3NhcCdcbmltcG9ydCBzdHlsZXMgZnJvbSAnLi9LaW5ldGljUGhvbmUubW9kdWxlLmNzcydcblxuaW50ZXJmYWNlIEtpbmV0aWNQaG9uZVByb3BzIHtcbiAgY2xhc3NOYW1lPzogc3RyaW5nXG59XG5cbmV4cG9ydCBjb25zdCBLaW5ldGljUGhvbmUgPSAoeyBjbGFzc05hbWUgfTogS2luZXRpY1Bob25lUHJvcHMpID0+IHtcbiAgY29uc3QgY29udGFpbmVyUmVmID0gdXNlUmVmPEhUTUxEaXZFbGVtZW50PihudWxsKVxuICBjb25zdCBbY3VycmVudFN0YWdlLCBzZXRDdXJyZW50U3RhZ2VdID0gdXNlU3RhdGUoMClcbiAgY29uc3QgZmxpcEludGVydmFsID0gdXNlUmVmPE5vZGVKUy5UaW1lb3V0PigpXG5cbiAgLy8gRWFjaCBzdGFnZSBtdXN0IGhhdmUgZXhhY3Qgc2FtZSBjaGFyYWN0ZXIgcG9zaXRpb25zXG4gIGNvbnN0IHN0YWdlcyA9IFsnMzMyIDI4Ny05NTMzJywgJzMzMiBBVC1SWUxFRScsICdOWUMgQCBSWUxFRSAnXVxuXG4gIC8vIEF1dG8tZmxpcCBhbmltYXRpb25cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBmbGlwSW50ZXJ2YWwuY3VycmVudCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgIHNldEN1cnJlbnRTdGFnZSgocHJldikgPT4gKHByZXYgKyAxKSAlIHN0YWdlcy5sZW5ndGgpXG4gICAgfSwgMzAwMClcblxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpZiAoZmxpcEludGVydmFsLmN1cnJlbnQpIGNsZWFySW50ZXJ2YWwoZmxpcEludGVydmFsLmN1cnJlbnQpXG4gICAgfVxuICB9LCBbXSlcblxuICAvLyBGbGlwIGFuaW1hdGlvblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghY29udGFpbmVyUmVmLmN1cnJlbnQpIHJldHVyblxuXG4gICAgY29uc3QgY29udGFpbmVyID0gY29udGFpbmVyUmVmLmN1cnJlbnRcbiAgICBjb25zdCBmbGlwcGVycyA9IGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKGAuJHtzdHlsZXMuZmxpcHBlcn1gKVxuXG4gICAgZmxpcHBlcnMuZm9yRWFjaCgoZmxpcHBlciwgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IGN1cnJlbnRDaGFyID0gc3RhZ2VzW2N1cnJlbnRTdGFnZV1baW5kZXhdXG4gICAgICBjb25zdCBwcmV2Q2hhciA9XG4gICAgICAgIHN0YWdlc1soY3VycmVudFN0YWdlIC0gMSArIHN0YWdlcy5sZW5ndGgpICUgc3RhZ2VzLmxlbmd0aF1baW5kZXhdXG5cbiAgICAgIC8vIE9ubHkgZmxpcCBpZiBjaGFyYWN0ZXIgYWN0dWFsbHkgY2hhbmdlc1xuICAgICAgaWYgKGN1cnJlbnRDaGFyICE9PSBwcmV2Q2hhcikge1xuICAgICAgICBjb25zdCBkZWxheSA9IGluZGV4ICogMC4wM1xuXG4gICAgICAgIGdzYXAudG8oZmxpcHBlciwge1xuICAgICAgICAgIHJvdGF0ZVg6IC05MCxcbiAgICAgICAgICBkdXJhdGlvbjogMC4zLFxuICAgICAgICAgIGRlbGF5LFxuICAgICAgICAgIGVhc2U6ICdwb3dlcjIuaW4nLFxuICAgICAgICAgIG9uQ29tcGxldGU6ICgpID0+IHtcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBjb250ZW50IG1pZC1mbGlwXG4gICAgICAgICAgICBmbGlwcGVyLnRleHRDb250ZW50ID0gY3VycmVudENoYXIgfHwgJyAnXG4gICAgICAgICAgICBnc2FwLnRvKGZsaXBwZXIsIHtcbiAgICAgICAgICAgICAgcm90YXRlWDogMCxcbiAgICAgICAgICAgICAgZHVyYXRpb246IDAuMyxcbiAgICAgICAgICAgICAgZWFzZTogJ3Bvd2VyMi5vdXQnLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9LFxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH0pXG4gIH0sIFtjdXJyZW50U3RhZ2VdKVxuXG4gIHJldHVybiAoXG4gICAgPGRpdlxuICAgICAgcmVmPXtjb250YWluZXJSZWZ9XG4gICAgICBjbGFzc05hbWU9e2Ake3N0eWxlcy5jb250YWluZXJ9ICR7Y2xhc3NOYW1lIHx8ICcnfWB9XG4gICAgPlxuICAgICAgPGEgaHJlZj1cInRlbDozMzIyODc5NTMzXCIgY2xhc3NOYW1lPXtzdHlsZXMucGhvbmVMaW5rfT5cbiAgICAgICAge3N0YWdlc1swXS5zcGxpdCgnJykubWFwKChjaGFyLCBpbmRleCkgPT4gKFxuICAgICAgICAgIDxzcGFuIGtleT17aW5kZXh9IGNsYXNzTmFtZT17c3R5bGVzLmZsaXBDb250YWluZXJ9PlxuICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPXtzdHlsZXMuZmxpcHBlcn0+e2NoYXJ9PC9zcGFuPlxuICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgKSl9XG4gICAgICA8L2E+XG4gICAgPC9kaXY+XG4gIClcbn1cbiJdLCJmaWxlIjoiL2hvbWUvd2lsbC9sb2NhbF9kZXYvcG9ydGZvbGlvL2FwcHMvcm9iaW4tbm9ndWllci9zcmMvY29tcG9uZW50cy9LaW5ldGljUGhvbmUvS2luZXRpY1Bob25lLnRzeCJ9",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 11077,
            "count": 1
          },
          {
            "startOffset": 456,
            "endOffset": 492,
            "count": 0
          },
          {
            "startOffset": 629,
            "endOffset": 800,
            "count": 0
          }
        ]
      },
      {
        "functionName": "window.$RefreshReg$",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 905,
            "endOffset": 1063,
            "count": 1
          }
        ]
      },
      {
        "functionName": "KineticPhone",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1587,
            "endOffset": 4188,
            "count": 4
          },
          {
            "startOffset": 3032,
            "endOffset": 3037,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1820,
            "endOffset": 2055,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1867,
            "endOffset": 1941,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1897,
            "endOffset": 1933,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1960,
            "endOffset": 2050,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 2074,
            "endOffset": 2888,
            "count": 3
          },
          {
            "startOffset": 2119,
            "endOffset": 2126,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 2263,
            "endOffset": 2882,
            "count": 36
          },
          {
            "startOffset": 2466,
            "endOffset": 2876,
            "count": 30
          }
        ]
      },
      {
        "functionName": "onComplete",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 2648,
            "endOffset": 2856,
            "count": 30
          },
          {
            "startOffset": 2702,
            "endOffset": 2708,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 3183,
            "endOffset": 3764,
            "count": 48
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 4472,
            "endOffset": 4957,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4686,
            "endOffset": 4951,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5173/src/config/site-config.json?t=1750724128431&import",
    "scriptId": "49",
    "source": "export const metadata = {\n\ttitle: \"Research Portfolio | Finance Research | Rylee Brasseur\",\n\tdescription: \"Explore Rylee Brasseur's finance-rooted research portfolio. Michigan State University student showcasing developing research skills.\",\n\tcanonicalUrl: \"https://rysdesigns.com/\",\n\togImage: \"https://rysdesigns.com/og-image.jpg\",\n\togImageAlt: \"Homepage screenshot of Rylee Brasseur's research portfolio\",\n\tsiteName: \"Rylee Brasseur Portfolio\",\n\ttwitterHandle: \"@RyleeBrasseur\",\n\tlastUpdated: \"2025-06-23T14:00:00Z\"\n};\nexport const hero = {\n\tname: \"Rylee Brasseur\",\n\ttitle: \"Exploring Finance & Policy\",\n\tinstitution: \"Michigan State University | James Madison College\",\n\temail: \"hello@rysdesigns.com\",\n\tphoneNumber: \"517.449.9836\"\n};\nexport const header = {\n\tbrandName: \"rys designs \",\n\ttagline: \"Research in Progress\",\n\temail: \"hello@rysdesigns.com\"\n};\nexport const motionSystem = {\n\tsections: [\n\t\t\"hero\",\n\t\t\"header\"\n\t],\n\tanimationDuration: 1000,\n\teasing: \"expo.inOut\",\n\tstaggerDelay: 0.05\n};\nexport const structuredData = {\n\tpersonName: \"Rylee Brasseur\",\n\taffiliation: \"Michigan State University, James Madison College\",\n\turl: \"https://rysdesigns.com/\",\n\temail: \"mailto:hello@rysdesigns.com\",\n\tknowsAbout: [\n\t\t\"research\",\n\t\t\"finance\",\n\t\t\"international relations\"\n\t]\n};\nexport default {\n\tmetadata: metadata,\n\thero: hero,\n\theader: header,\n\tmotionSystem: motionSystem,\n\tstructuredData: structuredData\n};\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 1408,
            "count": 1
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5173/src/components/KineticPhone/KineticPhone.module.css",
    "scriptId": "50",
    "source": "import { createHotContext as __vite__createHotContext } from \"/@vite/client\";import.meta.hot = __vite__createHotContext(\"/src/components/KineticPhone/KineticPhone.module.css\");import { updateStyle as __vite__updateStyle, removeStyle as __vite__removeStyle } from \"/@vite/client\"\nconst __vite__id = \"/home/will/local_dev/portfolio/apps/robin-noguier/src/components/KineticPhone/KineticPhone.module.css\"\nconst __vite__css = \"._container_1cwo4_1 {\\n  position: relative;\\n  display: inline-block;\\n}\\n\\n._phoneLink_1cwo4_6 {\\n  display: inline-flex;\\n  align-items: center;\\n  text-decoration: none;\\n  color: inherit;\\n  font-family: var(--font-subtitle);\\n  font-size: clamp(0.875rem, 1.25vw, 1.125rem);\\n  font-weight: 400;\\n  letter-spacing: 0;\\n  color: var(--text-primary);\\n  opacity: 0.8;\\n  transition: opacity 0.3s ease;\\n}\\n\\n._phoneLink_1cwo4_6:hover {\\n  opacity: 1;\\n}\\n\\n/* Individual character container */\\n._flipContainer_1cwo4_25 {\\n  display: inline-block;\\n  position: relative;\\n  height: 1.2em;\\n  overflow: hidden;\\n  transform-style: preserve-3d;\\n  perspective: 300px;\\n}\\n\\n/* The flipping character */\\n._flipper_1cwo4_35 {\\n  display: inline-flex;\\n  align-items: center;\\n  justify-content: center;\\n  height: 100%;\\n  min-width: 0.5ch;\\n  transform-origin: center center;\\n  transform-style: preserve-3d;\\n  font-variant-numeric: tabular-nums;\\n}\\n\\n/* Mobile adjustments */\\n@media (max-width: 768px) {\\n  ._phoneLink_1cwo4_6 {\\n    font-size: clamp(0.9rem, 2.5vw, 1.125rem);\\n  }\\n}\\n\"\n__vite__updateStyle(__vite__id, __vite__css)\nexport const container = \"_container_1cwo4_1\";\nexport const phoneLink = \"_phoneLink_1cwo4_6\";\nexport const flipContainer = \"_flipContainer_1cwo4_25\";\nexport const flipper = \"_flipper_1cwo4_35\";\nexport default {\n\tcontainer: container,\n\tphoneLink: phoneLink,\n\tflipContainer: flipContainer,\n\tflipper: flipper\n};\n\nimport.meta.hot.prune(() => __vite__removeStyle(__vite__id))",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 1931,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1893,
            "endOffset": 1930,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5173/node_modules/.vite/deps/framer-motion.js?v=a50bb159",
    "scriptId": "47",
    "source": "import {\n  require_react\n} from \"/node_modules/.vite/deps/chunk-R7U5S34U.js?v=a50bb159\";\nimport {\n  __commonJS,\n  __toESM\n} from \"/node_modules/.vite/deps/chunk-LNEMQRCO.js?v=a50bb159\";\n\n// optional-peer-dep:__vite-optional-peer-dep:@emotion/is-prop-valid:framer-motion\nvar require_is_prop_valid_framer_motion = __commonJS({\n  \"optional-peer-dep:__vite-optional-peer-dep:@emotion/is-prop-valid:framer-motion\"() {\n    throw new Error(`Could not resolve \"@emotion/is-prop-valid\" imported by \"framer-motion\". Is it installed?`);\n  }\n});\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/motion/index.mjs\nvar React = __toESM(require_react(), 1);\nvar import_react11 = __toESM(require_react(), 1);\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/context/MotionConfigContext.mjs\nvar import_react = __toESM(require_react(), 1);\nvar MotionConfigContext = (0, import_react.createContext)({\n  transformPagePoint: (p) => p,\n  isStatic: false,\n  reducedMotion: \"never\"\n});\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/context/MotionContext/index.mjs\nvar import_react2 = __toESM(require_react(), 1);\nvar MotionContext = (0, import_react2.createContext)({});\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/motion/utils/use-visual-element.mjs\nvar import_react6 = __toESM(require_react(), 1);\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/context/PresenceContext.mjs\nvar import_react3 = __toESM(require_react(), 1);\nvar PresenceContext = (0, import_react3.createContext)(null);\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/utils/use-isomorphic-effect.mjs\nvar import_react4 = __toESM(require_react(), 1);\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/utils/is-browser.mjs\nvar isBrowser = typeof document !== \"undefined\";\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/utils/use-isomorphic-effect.mjs\nvar useIsomorphicLayoutEffect = isBrowser ? import_react4.useLayoutEffect : import_react4.useEffect;\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/context/LazyContext.mjs\nvar import_react5 = __toESM(require_react(), 1);\nvar LazyContext = (0, import_react5.createContext)({ strict: false });\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/dom/utils/camel-to-dash.mjs\nvar camelToDash = (str) => str.replace(/([a-z])([A-Z])/gu, \"$1-$2\").toLowerCase();\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/animation/optimized-appear/data-id.mjs\nvar optimizedAppearDataId = \"framerAppearId\";\nvar optimizedAppearDataAttribute = \"data-\" + camelToDash(optimizedAppearDataId);\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/utils/GlobalConfig.mjs\nvar MotionGlobalConfig = {\n  skipAnimations: false,\n  useManualTiming: false\n};\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/frameloop/render-step.mjs\nvar Queue = class {\n  constructor() {\n    this.order = [];\n    this.scheduled = /* @__PURE__ */ new Set();\n  }\n  add(process2) {\n    if (!this.scheduled.has(process2)) {\n      this.scheduled.add(process2);\n      this.order.push(process2);\n      return true;\n    }\n  }\n  remove(process2) {\n    const index = this.order.indexOf(process2);\n    if (index !== -1) {\n      this.order.splice(index, 1);\n      this.scheduled.delete(process2);\n    }\n  }\n  clear() {\n    this.order.length = 0;\n    this.scheduled.clear();\n  }\n};\nfunction createRenderStep(runNextFrame) {\n  let thisFrame = new Queue();\n  let nextFrame = new Queue();\n  let numToRun = 0;\n  let isProcessing = false;\n  let flushNextFrame = false;\n  const toKeepAlive = /* @__PURE__ */ new WeakSet();\n  const step = {\n    /**\n     * Schedule a process to run on the next frame.\n     */\n    schedule: (callback, keepAlive = false, immediate = false) => {\n      const addToCurrentFrame = immediate && isProcessing;\n      const queue = addToCurrentFrame ? thisFrame : nextFrame;\n      if (keepAlive)\n        toKeepAlive.add(callback);\n      if (queue.add(callback) && addToCurrentFrame && isProcessing) {\n        numToRun = thisFrame.order.length;\n      }\n      return callback;\n    },\n    /**\n     * Cancel the provided callback from running on the next frame.\n     */\n    cancel: (callback) => {\n      nextFrame.remove(callback);\n      toKeepAlive.delete(callback);\n    },\n    /**\n     * Execute all schedule callbacks.\n     */\n    process: (frameData2) => {\n      if (isProcessing) {\n        flushNextFrame = true;\n        return;\n      }\n      isProcessing = true;\n      [thisFrame, nextFrame] = [nextFrame, thisFrame];\n      nextFrame.clear();\n      numToRun = thisFrame.order.length;\n      if (numToRun) {\n        for (let i = 0; i < numToRun; i++) {\n          const callback = thisFrame.order[i];\n          if (toKeepAlive.has(callback)) {\n            step.schedule(callback);\n            runNextFrame();\n          }\n          callback(frameData2);\n        }\n      }\n      isProcessing = false;\n      if (flushNextFrame) {\n        flushNextFrame = false;\n        step.process(frameData2);\n      }\n    }\n  };\n  return step;\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/frameloop/batcher.mjs\nvar stepsOrder = [\n  \"read\",\n  \"resolveKeyframes\",\n  \"update\",\n  \"preRender\",\n  \"render\",\n  \"postRender\"\n  // Compute\n];\nvar maxElapsed = 40;\nfunction createRenderBatcher(scheduleNextBatch, allowKeepAlive) {\n  let runNextFrame = false;\n  let useDefaultElapsed = true;\n  const state = {\n    delta: 0,\n    timestamp: 0,\n    isProcessing: false\n  };\n  const steps2 = stepsOrder.reduce((acc, key) => {\n    acc[key] = createRenderStep(() => runNextFrame = true);\n    return acc;\n  }, {});\n  const processStep = (stepId) => {\n    steps2[stepId].process(state);\n  };\n  const processBatch = () => {\n    const timestamp = MotionGlobalConfig.useManualTiming ? state.timestamp : performance.now();\n    runNextFrame = false;\n    state.delta = useDefaultElapsed ? 1e3 / 60 : Math.max(Math.min(timestamp - state.timestamp, maxElapsed), 1);\n    state.timestamp = timestamp;\n    state.isProcessing = true;\n    stepsOrder.forEach(processStep);\n    state.isProcessing = false;\n    if (runNextFrame && allowKeepAlive) {\n      useDefaultElapsed = false;\n      scheduleNextBatch(processBatch);\n    }\n  };\n  const wake = () => {\n    runNextFrame = true;\n    useDefaultElapsed = true;\n    if (!state.isProcessing) {\n      scheduleNextBatch(processBatch);\n    }\n  };\n  const schedule = stepsOrder.reduce((acc, key) => {\n    const step = steps2[key];\n    acc[key] = (process2, keepAlive = false, immediate = false) => {\n      if (!runNextFrame)\n        wake();\n      return step.schedule(process2, keepAlive, immediate);\n    };\n    return acc;\n  }, {});\n  const cancel = (process2) => stepsOrder.forEach((key) => steps2[key].cancel(process2));\n  return { schedule, cancel, state, steps: steps2 };\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/frameloop/microtask.mjs\nvar { schedule: microtask, cancel: cancelMicrotask } = createRenderBatcher(queueMicrotask, false);\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/motion/utils/use-visual-element.mjs\nfunction useVisualElement(Component2, visualState, props, createVisualElement2) {\n  const { visualElement: parent } = (0, import_react6.useContext)(MotionContext);\n  const lazyContext = (0, import_react6.useContext)(LazyContext);\n  const presenceContext = (0, import_react6.useContext)(PresenceContext);\n  const reducedMotionConfig = (0, import_react6.useContext)(MotionConfigContext).reducedMotion;\n  const visualElementRef = (0, import_react6.useRef)();\n  createVisualElement2 = createVisualElement2 || lazyContext.renderer;\n  if (!visualElementRef.current && createVisualElement2) {\n    visualElementRef.current = createVisualElement2(Component2, {\n      visualState,\n      parent,\n      props,\n      presenceContext,\n      blockInitialAnimation: presenceContext ? presenceContext.initial === false : false,\n      reducedMotionConfig\n    });\n  }\n  const visualElement = visualElementRef.current;\n  (0, import_react6.useInsertionEffect)(() => {\n    visualElement && visualElement.update(props, presenceContext);\n  });\n  const wantsHandoff = (0, import_react6.useRef)(Boolean(props[optimizedAppearDataAttribute] && !window.HandoffComplete));\n  useIsomorphicLayoutEffect(() => {\n    if (!visualElement)\n      return;\n    microtask.postRender(visualElement.render);\n    if (wantsHandoff.current && visualElement.animationState) {\n      visualElement.animationState.animateChanges();\n    }\n  });\n  (0, import_react6.useEffect)(() => {\n    if (!visualElement)\n      return;\n    visualElement.updateFeatures();\n    if (!wantsHandoff.current && visualElement.animationState) {\n      visualElement.animationState.animateChanges();\n    }\n    if (wantsHandoff.current) {\n      wantsHandoff.current = false;\n      window.HandoffComplete = true;\n    }\n  });\n  return visualElement;\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/motion/utils/use-motion-ref.mjs\nvar import_react7 = __toESM(require_react(), 1);\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/utils/is-ref-object.mjs\nfunction isRefObject(ref) {\n  return ref && typeof ref === \"object\" && Object.prototype.hasOwnProperty.call(ref, \"current\");\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/motion/utils/use-motion-ref.mjs\nfunction useMotionRef(visualState, visualElement, externalRef) {\n  return (0, import_react7.useCallback)(\n    (instance) => {\n      instance && visualState.mount && visualState.mount(instance);\n      if (visualElement) {\n        instance ? visualElement.mount(instance) : visualElement.unmount();\n      }\n      if (externalRef) {\n        if (typeof externalRef === \"function\") {\n          externalRef(instance);\n        } else if (isRefObject(externalRef)) {\n          externalRef.current = instance;\n        }\n      }\n    },\n    /**\n     * Only pass a new ref callback to React if we've received a visual element\n     * factory. Otherwise we'll be mounting/remounting every time externalRef\n     * or other dependencies change.\n     */\n    [visualElement]\n  );\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/context/MotionContext/create.mjs\nvar import_react8 = __toESM(require_react(), 1);\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/utils/is-variant-label.mjs\nfunction isVariantLabel(v) {\n  return typeof v === \"string\" || Array.isArray(v);\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/animation/utils/is-animation-controls.mjs\nfunction isAnimationControls(v) {\n  return v !== null && typeof v === \"object\" && typeof v.start === \"function\";\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/utils/variant-props.mjs\nvar variantPriorityOrder = [\n  \"animate\",\n  \"whileInView\",\n  \"whileFocus\",\n  \"whileHover\",\n  \"whileTap\",\n  \"whileDrag\",\n  \"exit\"\n];\nvar variantProps = [\"initial\", ...variantPriorityOrder];\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/utils/is-controlling-variants.mjs\nfunction isControllingVariants(props) {\n  return isAnimationControls(props.animate) || variantProps.some((name) => isVariantLabel(props[name]));\n}\nfunction isVariantNode(props) {\n  return Boolean(isControllingVariants(props) || props.variants);\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/context/MotionContext/utils.mjs\nfunction getCurrentTreeVariants(props, context) {\n  if (isControllingVariants(props)) {\n    const { initial, animate: animate2 } = props;\n    return {\n      initial: initial === false || isVariantLabel(initial) ? initial : void 0,\n      animate: isVariantLabel(animate2) ? animate2 : void 0\n    };\n  }\n  return props.inherit !== false ? context : {};\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/context/MotionContext/create.mjs\nfunction useCreateMotionContext(props) {\n  const { initial, animate: animate2 } = getCurrentTreeVariants(props, (0, import_react8.useContext)(MotionContext));\n  return (0, import_react8.useMemo)(() => ({ initial, animate: animate2 }), [variantLabelsAsDependency(initial), variantLabelsAsDependency(animate2)]);\n}\nfunction variantLabelsAsDependency(prop) {\n  return Array.isArray(prop) ? prop.join(\" \") : prop;\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/motion/features/definitions.mjs\nvar featureProps = {\n  animation: [\n    \"animate\",\n    \"variants\",\n    \"whileHover\",\n    \"whileTap\",\n    \"exit\",\n    \"whileInView\",\n    \"whileFocus\",\n    \"whileDrag\"\n  ],\n  exit: [\"exit\"],\n  drag: [\"drag\", \"dragControls\"],\n  focus: [\"whileFocus\"],\n  hover: [\"whileHover\", \"onHoverStart\", \"onHoverEnd\"],\n  tap: [\"whileTap\", \"onTap\", \"onTapStart\", \"onTapCancel\"],\n  pan: [\"onPan\", \"onPanStart\", \"onPanSessionStart\", \"onPanEnd\"],\n  inView: [\"whileInView\", \"onViewportEnter\", \"onViewportLeave\"],\n  layout: [\"layout\", \"layoutId\"]\n};\nvar featureDefinitions = {};\nfor (const key in featureProps) {\n  featureDefinitions[key] = {\n    isEnabled: (props) => featureProps[key].some((name) => !!props[name])\n  };\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/motion/features/load-features.mjs\nfunction loadFeatures(features) {\n  for (const key in features) {\n    featureDefinitions[key] = {\n      ...featureDefinitions[key],\n      ...features[key]\n    };\n  }\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/context/LayoutGroupContext.mjs\nvar import_react9 = __toESM(require_react(), 1);\nvar LayoutGroupContext = (0, import_react9.createContext)({});\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/context/SwitchLayoutGroupContext.mjs\nvar import_react10 = __toESM(require_react(), 1);\nvar SwitchLayoutGroupContext = (0, import_react10.createContext)({});\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/motion/utils/symbol.mjs\nvar motionComponentSymbol = Symbol.for(\"motionComponentSymbol\");\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/motion/index.mjs\nfunction createMotionComponent({ preloadedFeatures: preloadedFeatures2, createVisualElement: createVisualElement2, useRender, useVisualState: useVisualState2, Component: Component2 }) {\n  preloadedFeatures2 && loadFeatures(preloadedFeatures2);\n  function MotionComponent(props, externalRef) {\n    let MeasureLayout2;\n    const configAndProps = {\n      ...(0, import_react11.useContext)(MotionConfigContext),\n      ...props,\n      layoutId: useLayoutId(props)\n    };\n    const { isStatic } = configAndProps;\n    const context = useCreateMotionContext(props);\n    const visualState = useVisualState2(props, isStatic);\n    if (!isStatic && isBrowser) {\n      context.visualElement = useVisualElement(Component2, visualState, configAndProps, createVisualElement2);\n      const initialLayoutGroupConfig = (0, import_react11.useContext)(SwitchLayoutGroupContext);\n      const isStrict = (0, import_react11.useContext)(LazyContext).strict;\n      if (context.visualElement) {\n        MeasureLayout2 = context.visualElement.loadFeatures(\n          // Note: Pass the full new combined props to correctly re-render dynamic feature components.\n          configAndProps,\n          isStrict,\n          preloadedFeatures2,\n          initialLayoutGroupConfig\n        );\n      }\n    }\n    return React.createElement(\n      MotionContext.Provider,\n      { value: context },\n      MeasureLayout2 && context.visualElement ? React.createElement(MeasureLayout2, { visualElement: context.visualElement, ...configAndProps }) : null,\n      useRender(Component2, props, useMotionRef(visualState, context.visualElement, externalRef), visualState, isStatic, context.visualElement)\n    );\n  }\n  const ForwardRefComponent = (0, import_react11.forwardRef)(MotionComponent);\n  ForwardRefComponent[motionComponentSymbol] = Component2;\n  return ForwardRefComponent;\n}\nfunction useLayoutId({ layoutId }) {\n  const layoutGroupId = (0, import_react11.useContext)(LayoutGroupContext).id;\n  return layoutGroupId && layoutId !== void 0 ? layoutGroupId + \"-\" + layoutId : layoutId;\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/dom/motion-proxy.mjs\nfunction createMotionProxy(createConfig) {\n  function custom(Component2, customMotionComponentConfig = {}) {\n    return createMotionComponent(createConfig(Component2, customMotionComponentConfig));\n  }\n  if (typeof Proxy === \"undefined\") {\n    return custom;\n  }\n  const componentCache = /* @__PURE__ */ new Map();\n  return new Proxy(custom, {\n    /**\n     * Called when `motion` is referenced with a prop: `motion.div`, `motion.input` etc.\n     * The prop name is passed through as `key` and we can use that to generate a `motion`\n     * DOM component with that name.\n     */\n    get: (_target, key) => {\n      if (!componentCache.has(key)) {\n        componentCache.set(key, custom(key));\n      }\n      return componentCache.get(key);\n    }\n  });\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/svg/lowercase-elements.mjs\nvar lowercaseSVGElements = [\n  \"animate\",\n  \"circle\",\n  \"defs\",\n  \"desc\",\n  \"ellipse\",\n  \"g\",\n  \"image\",\n  \"line\",\n  \"filter\",\n  \"marker\",\n  \"mask\",\n  \"metadata\",\n  \"path\",\n  \"pattern\",\n  \"polygon\",\n  \"polyline\",\n  \"rect\",\n  \"stop\",\n  \"switch\",\n  \"symbol\",\n  \"svg\",\n  \"text\",\n  \"tspan\",\n  \"use\",\n  \"view\"\n];\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/dom/utils/is-svg-component.mjs\nfunction isSVGComponent(Component2) {\n  if (\n    /**\n     * If it's not a string, it's a custom React component. Currently we only support\n     * HTML custom React components.\n     */\n    typeof Component2 !== \"string\" || /**\n     * If it contains a dash, the element is a custom HTML webcomponent.\n     */\n    Component2.includes(\"-\")\n  ) {\n    return false;\n  } else if (\n    /**\n     * If it's in our list of lowercase SVG tags, it's an SVG component\n     */\n    lowercaseSVGElements.indexOf(Component2) > -1 || /**\n     * If it contains a capital letter, it's an SVG component\n     */\n    /[A-Z]/u.test(Component2)\n  ) {\n    return true;\n  }\n  return false;\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/dom/use-render.mjs\nvar import_react14 = __toESM(require_react(), 1);\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/html/use-props.mjs\nvar import_react12 = __toESM(require_react(), 1);\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/projection/styles/scale-correction.mjs\nvar scaleCorrectors = {};\nfunction addScaleCorrector(correctors) {\n  Object.assign(scaleCorrectors, correctors);\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/html/utils/transform.mjs\nvar transformPropOrder = [\n  \"transformPerspective\",\n  \"x\",\n  \"y\",\n  \"z\",\n  \"translateX\",\n  \"translateY\",\n  \"translateZ\",\n  \"scale\",\n  \"scaleX\",\n  \"scaleY\",\n  \"rotate\",\n  \"rotateX\",\n  \"rotateY\",\n  \"rotateZ\",\n  \"skew\",\n  \"skewX\",\n  \"skewY\"\n];\nvar transformProps = new Set(transformPropOrder);\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/motion/utils/is-forced-motion-value.mjs\nfunction isForcedMotionValue(key, { layout: layout2, layoutId }) {\n  return transformProps.has(key) || key.startsWith(\"origin\") || (layout2 || layoutId !== void 0) && (!!scaleCorrectors[key] || key === \"opacity\");\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/value/utils/is-motion-value.mjs\nvar isMotionValue = (value) => Boolean(value && value.getVelocity);\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/html/utils/build-transform.mjs\nvar translateAlias = {\n  x: \"translateX\",\n  y: \"translateY\",\n  z: \"translateZ\",\n  transformPerspective: \"perspective\"\n};\nvar numTransforms = transformPropOrder.length;\nfunction buildTransform(transform2, { enableHardwareAcceleration = true, allowTransformNone = true }, transformIsDefault, transformTemplate) {\n  let transformString = \"\";\n  for (let i = 0; i < numTransforms; i++) {\n    const key = transformPropOrder[i];\n    if (transform2[key] !== void 0) {\n      const transformName = translateAlias[key] || key;\n      transformString += `${transformName}(${transform2[key]}) `;\n    }\n  }\n  if (enableHardwareAcceleration && !transform2.z) {\n    transformString += \"translateZ(0)\";\n  }\n  transformString = transformString.trim();\n  if (transformTemplate) {\n    transformString = transformTemplate(transform2, transformIsDefault ? \"\" : transformString);\n  } else if (allowTransformNone && transformIsDefault) {\n    transformString = \"none\";\n  }\n  return transformString;\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/dom/utils/is-css-variable.mjs\nvar checkStringStartsWith = (token) => (key) => typeof key === \"string\" && key.startsWith(token);\nvar isCSSVariableName = checkStringStartsWith(\"--\");\nvar startsAsVariableToken = checkStringStartsWith(\"var(--\");\nvar isCSSVariableToken = (value) => {\n  const startsWithToken = startsAsVariableToken(value);\n  if (!startsWithToken)\n    return false;\n  return singleCssVariableRegex.test(value.split(\"/*\")[0].trim());\n};\nvar singleCssVariableRegex = /var\\(--(?:[\\w-]+\\s*|[\\w-]+\\s*,(?:\\s*[^)(\\s]|\\s*\\((?:[^)(]|\\([^)(]*\\))*\\))+\\s*)\\)$/iu;\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/dom/value-types/get-as-type.mjs\nvar getValueAsType = (value, type) => {\n  return type && typeof value === \"number\" ? type.transform(value) : value;\n};\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/utils/clamp.mjs\nvar clamp = (min, max, v) => {\n  if (v > max)\n    return max;\n  if (v < min)\n    return min;\n  return v;\n};\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/value/types/numbers/index.mjs\nvar number = {\n  test: (v) => typeof v === \"number\",\n  parse: parseFloat,\n  transform: (v) => v\n};\nvar alpha = {\n  ...number,\n  transform: (v) => clamp(0, 1, v)\n};\nvar scale = {\n  ...number,\n  default: 1\n};\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/value/types/utils.mjs\nvar sanitize = (v) => Math.round(v * 1e5) / 1e5;\nvar floatRegex = /-?(?:\\d+(?:\\.\\d+)?|\\.\\d+)/gu;\nvar colorRegex = /(?:#[\\da-f]{3,8}|(?:rgb|hsl)a?\\((?:-?[\\d.]+%?[,\\s]+){2}-?[\\d.]+%?\\s*(?:[,/]\\s*)?(?:\\b\\d+(?:\\.\\d+)?|\\.\\d+)?%?\\))/giu;\nvar singleColorRegex = /^(?:#[\\da-f]{3,8}|(?:rgb|hsl)a?\\((?:-?[\\d.]+%?[,\\s]+){2}-?[\\d.]+%?\\s*(?:[,/]\\s*)?(?:\\b\\d+(?:\\.\\d+)?|\\.\\d+)?%?\\))$/iu;\nfunction isString(v) {\n  return typeof v === \"string\";\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/value/types/numbers/units.mjs\nvar createUnitType = (unit) => ({\n  test: (v) => isString(v) && v.endsWith(unit) && v.split(\" \").length === 1,\n  parse: parseFloat,\n  transform: (v) => `${v}${unit}`\n});\nvar degrees = createUnitType(\"deg\");\nvar percent = createUnitType(\"%\");\nvar px = createUnitType(\"px\");\nvar vh = createUnitType(\"vh\");\nvar vw = createUnitType(\"vw\");\nvar progressPercentage = {\n  ...percent,\n  parse: (v) => percent.parse(v) / 100,\n  transform: (v) => percent.transform(v * 100)\n};\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/dom/value-types/type-int.mjs\nvar int = {\n  ...number,\n  transform: Math.round\n};\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/dom/value-types/number.mjs\nvar numberValueTypes = {\n  // Border props\n  borderWidth: px,\n  borderTopWidth: px,\n  borderRightWidth: px,\n  borderBottomWidth: px,\n  borderLeftWidth: px,\n  borderRadius: px,\n  radius: px,\n  borderTopLeftRadius: px,\n  borderTopRightRadius: px,\n  borderBottomRightRadius: px,\n  borderBottomLeftRadius: px,\n  // Positioning props\n  width: px,\n  maxWidth: px,\n  height: px,\n  maxHeight: px,\n  size: px,\n  top: px,\n  right: px,\n  bottom: px,\n  left: px,\n  // Spacing props\n  padding: px,\n  paddingTop: px,\n  paddingRight: px,\n  paddingBottom: px,\n  paddingLeft: px,\n  margin: px,\n  marginTop: px,\n  marginRight: px,\n  marginBottom: px,\n  marginLeft: px,\n  // Transform props\n  rotate: degrees,\n  rotateX: degrees,\n  rotateY: degrees,\n  rotateZ: degrees,\n  scale,\n  scaleX: scale,\n  scaleY: scale,\n  scaleZ: scale,\n  skew: degrees,\n  skewX: degrees,\n  skewY: degrees,\n  distance: px,\n  translateX: px,\n  translateY: px,\n  translateZ: px,\n  x: px,\n  y: px,\n  z: px,\n  perspective: px,\n  transformPerspective: px,\n  opacity: alpha,\n  originX: progressPercentage,\n  originY: progressPercentage,\n  originZ: px,\n  // Misc\n  zIndex: int,\n  backgroundPositionX: px,\n  backgroundPositionY: px,\n  // SVG\n  fillOpacity: alpha,\n  strokeOpacity: alpha,\n  numOctaves: int\n};\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/html/utils/build-styles.mjs\nfunction buildHTMLStyles(state, latestValues, options, transformTemplate) {\n  const { style, vars, transform: transform2, transformOrigin } = state;\n  let hasTransform2 = false;\n  let hasTransformOrigin = false;\n  let transformIsNone = true;\n  for (const key in latestValues) {\n    const value = latestValues[key];\n    if (isCSSVariableName(key)) {\n      vars[key] = value;\n      continue;\n    }\n    const valueType = numberValueTypes[key];\n    const valueAsType = getValueAsType(value, valueType);\n    if (transformProps.has(key)) {\n      hasTransform2 = true;\n      transform2[key] = valueAsType;\n      if (!transformIsNone)\n        continue;\n      if (value !== (valueType.default || 0))\n        transformIsNone = false;\n    } else if (key.startsWith(\"origin\")) {\n      hasTransformOrigin = true;\n      transformOrigin[key] = valueAsType;\n    } else {\n      style[key] = valueAsType;\n    }\n  }\n  if (!latestValues.transform) {\n    if (hasTransform2 || transformTemplate) {\n      style.transform = buildTransform(state.transform, options, transformIsNone, transformTemplate);\n    } else if (style.transform) {\n      style.transform = \"none\";\n    }\n  }\n  if (hasTransformOrigin) {\n    const { originX = \"50%\", originY = \"50%\", originZ = 0 } = transformOrigin;\n    style.transformOrigin = `${originX} ${originY} ${originZ}`;\n  }\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/html/utils/create-render-state.mjs\nvar createHtmlRenderState = () => ({\n  style: {},\n  transform: {},\n  transformOrigin: {},\n  vars: {}\n});\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/html/use-props.mjs\nfunction copyRawValuesOnly(target, source, props) {\n  for (const key in source) {\n    if (!isMotionValue(source[key]) && !isForcedMotionValue(key, props)) {\n      target[key] = source[key];\n    }\n  }\n}\nfunction useInitialMotionValues({ transformTemplate }, visualState, isStatic) {\n  return (0, import_react12.useMemo)(() => {\n    const state = createHtmlRenderState();\n    buildHTMLStyles(state, visualState, { enableHardwareAcceleration: !isStatic }, transformTemplate);\n    return Object.assign({}, state.vars, state.style);\n  }, [visualState]);\n}\nfunction useStyle(props, visualState, isStatic) {\n  const styleProp = props.style || {};\n  const style = {};\n  copyRawValuesOnly(style, styleProp, props);\n  Object.assign(style, useInitialMotionValues(props, visualState, isStatic));\n  return style;\n}\nfunction useHTMLProps(props, visualState, isStatic) {\n  const htmlProps = {};\n  const style = useStyle(props, visualState, isStatic);\n  if (props.drag && props.dragListener !== false) {\n    htmlProps.draggable = false;\n    style.userSelect = style.WebkitUserSelect = style.WebkitTouchCallout = \"none\";\n    style.touchAction = props.drag === true ? \"none\" : `pan-${props.drag === \"x\" ? \"y\" : \"x\"}`;\n  }\n  if (props.tabIndex === void 0 && (props.onTap || props.onTapStart || props.whileTap)) {\n    htmlProps.tabIndex = 0;\n  }\n  htmlProps.style = style;\n  return htmlProps;\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/motion/utils/valid-prop.mjs\nvar validMotionProps = /* @__PURE__ */ new Set([\n  \"animate\",\n  \"exit\",\n  \"variants\",\n  \"initial\",\n  \"style\",\n  \"values\",\n  \"variants\",\n  \"transition\",\n  \"transformTemplate\",\n  \"custom\",\n  \"inherit\",\n  \"onBeforeLayoutMeasure\",\n  \"onAnimationStart\",\n  \"onAnimationComplete\",\n  \"onUpdate\",\n  \"onDragStart\",\n  \"onDrag\",\n  \"onDragEnd\",\n  \"onMeasureDragConstraints\",\n  \"onDirectionLock\",\n  \"onDragTransitionEnd\",\n  \"_dragX\",\n  \"_dragY\",\n  \"onHoverStart\",\n  \"onHoverEnd\",\n  \"onViewportEnter\",\n  \"onViewportLeave\",\n  \"globalTapTarget\",\n  \"ignoreStrict\",\n  \"viewport\"\n]);\nfunction isValidMotionProp(key) {\n  return key.startsWith(\"while\") || key.startsWith(\"drag\") && key !== \"draggable\" || key.startsWith(\"layout\") || key.startsWith(\"onTap\") || key.startsWith(\"onPan\") || key.startsWith(\"onLayout\") || validMotionProps.has(key);\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/dom/utils/filter-props.mjs\nvar shouldForward = (key) => !isValidMotionProp(key);\nfunction loadExternalIsValidProp(isValidProp) {\n  if (!isValidProp)\n    return;\n  shouldForward = (key) => key.startsWith(\"on\") ? !isValidMotionProp(key) : isValidProp(key);\n}\ntry {\n  loadExternalIsValidProp(require_is_prop_valid_framer_motion().default);\n} catch (_a) {\n}\nfunction filterProps(props, isDom, forwardMotionProps) {\n  const filteredProps = {};\n  for (const key in props) {\n    if (key === \"values\" && typeof props.values === \"object\")\n      continue;\n    if (shouldForward(key) || forwardMotionProps === true && isValidMotionProp(key) || !isDom && !isValidMotionProp(key) || // If trying to use native HTML drag events, forward drag listeners\n    props[\"draggable\"] && key.startsWith(\"onDrag\")) {\n      filteredProps[key] = props[key];\n    }\n  }\n  return filteredProps;\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/svg/use-props.mjs\nvar import_react13 = __toESM(require_react(), 1);\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/svg/utils/transform-origin.mjs\nfunction calcOrigin(origin, offset, size) {\n  return typeof origin === \"string\" ? origin : px.transform(offset + size * origin);\n}\nfunction calcSVGTransformOrigin(dimensions, originX, originY) {\n  const pxOriginX = calcOrigin(originX, dimensions.x, dimensions.width);\n  const pxOriginY = calcOrigin(originY, dimensions.y, dimensions.height);\n  return `${pxOriginX} ${pxOriginY}`;\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/svg/utils/path.mjs\nvar dashKeys = {\n  offset: \"stroke-dashoffset\",\n  array: \"stroke-dasharray\"\n};\nvar camelKeys = {\n  offset: \"strokeDashoffset\",\n  array: \"strokeDasharray\"\n};\nfunction buildSVGPath(attrs, length, spacing = 1, offset = 0, useDashCase = true) {\n  attrs.pathLength = 1;\n  const keys2 = useDashCase ? dashKeys : camelKeys;\n  attrs[keys2.offset] = px.transform(-offset);\n  const pathLength = px.transform(length);\n  const pathSpacing = px.transform(spacing);\n  attrs[keys2.array] = `${pathLength} ${pathSpacing}`;\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/svg/utils/build-attrs.mjs\nfunction buildSVGAttrs(state, {\n  attrX,\n  attrY,\n  attrScale,\n  originX,\n  originY,\n  pathLength,\n  pathSpacing = 1,\n  pathOffset = 0,\n  // This is object creation, which we try to avoid per-frame.\n  ...latest\n}, options, isSVGTag2, transformTemplate) {\n  buildHTMLStyles(state, latest, options, transformTemplate);\n  if (isSVGTag2) {\n    if (state.style.viewBox) {\n      state.attrs.viewBox = state.style.viewBox;\n    }\n    return;\n  }\n  state.attrs = state.style;\n  state.style = {};\n  const { attrs, style, dimensions } = state;\n  if (attrs.transform) {\n    if (dimensions)\n      style.transform = attrs.transform;\n    delete attrs.transform;\n  }\n  if (dimensions && (originX !== void 0 || originY !== void 0 || style.transform)) {\n    style.transformOrigin = calcSVGTransformOrigin(dimensions, originX !== void 0 ? originX : 0.5, originY !== void 0 ? originY : 0.5);\n  }\n  if (attrX !== void 0)\n    attrs.x = attrX;\n  if (attrY !== void 0)\n    attrs.y = attrY;\n  if (attrScale !== void 0)\n    attrs.scale = attrScale;\n  if (pathLength !== void 0) {\n    buildSVGPath(attrs, pathLength, pathSpacing, pathOffset, false);\n  }\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/svg/utils/create-render-state.mjs\nvar createSvgRenderState = () => ({\n  ...createHtmlRenderState(),\n  attrs: {}\n});\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/svg/utils/is-svg-tag.mjs\nvar isSVGTag = (tag) => typeof tag === \"string\" && tag.toLowerCase() === \"svg\";\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/svg/use-props.mjs\nfunction useSVGProps(props, visualState, _isStatic, Component2) {\n  const visualProps = (0, import_react13.useMemo)(() => {\n    const state = createSvgRenderState();\n    buildSVGAttrs(state, visualState, { enableHardwareAcceleration: false }, isSVGTag(Component2), props.transformTemplate);\n    return {\n      ...state.attrs,\n      style: { ...state.style }\n    };\n  }, [visualState]);\n  if (props.style) {\n    const rawStyles = {};\n    copyRawValuesOnly(rawStyles, props.style, props);\n    visualProps.style = { ...rawStyles, ...visualProps.style };\n  }\n  return visualProps;\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/dom/use-render.mjs\nfunction createUseRender(forwardMotionProps = false) {\n  const useRender = (Component2, props, ref, { latestValues }, isStatic) => {\n    const useVisualProps = isSVGComponent(Component2) ? useSVGProps : useHTMLProps;\n    const visualProps = useVisualProps(props, latestValues, isStatic, Component2);\n    const filteredProps = filterProps(props, typeof Component2 === \"string\", forwardMotionProps);\n    const elementProps = Component2 !== import_react14.Fragment ? { ...filteredProps, ...visualProps, ref } : {};\n    const { children } = props;\n    const renderedChildren = (0, import_react14.useMemo)(() => isMotionValue(children) ? children.get() : children, [children]);\n    return (0, import_react14.createElement)(Component2, {\n      ...elementProps,\n      children: renderedChildren\n    });\n  };\n  return useRender;\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/html/utils/render.mjs\nfunction renderHTML(element, { style, vars }, styleProp, projection) {\n  Object.assign(element.style, style, projection && projection.getProjectionStyles(styleProp));\n  for (const key in vars) {\n    element.style.setProperty(key, vars[key]);\n  }\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/svg/utils/camel-case-attrs.mjs\nvar camelCaseAttributes = /* @__PURE__ */ new Set([\n  \"baseFrequency\",\n  \"diffuseConstant\",\n  \"kernelMatrix\",\n  \"kernelUnitLength\",\n  \"keySplines\",\n  \"keyTimes\",\n  \"limitingConeAngle\",\n  \"markerHeight\",\n  \"markerWidth\",\n  \"numOctaves\",\n  \"targetX\",\n  \"targetY\",\n  \"surfaceScale\",\n  \"specularConstant\",\n  \"specularExponent\",\n  \"stdDeviation\",\n  \"tableValues\",\n  \"viewBox\",\n  \"gradientTransform\",\n  \"pathLength\",\n  \"startOffset\",\n  \"textLength\",\n  \"lengthAdjust\"\n]);\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/svg/utils/render.mjs\nfunction renderSVG(element, renderState, _styleProp, projection) {\n  renderHTML(element, renderState, void 0, projection);\n  for (const key in renderState.attrs) {\n    element.setAttribute(!camelCaseAttributes.has(key) ? camelToDash(key) : key, renderState.attrs[key]);\n  }\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/html/utils/scrape-motion-values.mjs\nfunction scrapeMotionValuesFromProps(props, prevProps, visualElement) {\n  var _a;\n  const { style } = props;\n  const newValues = {};\n  for (const key in style) {\n    if (isMotionValue(style[key]) || prevProps.style && isMotionValue(prevProps.style[key]) || isForcedMotionValue(key, props) || ((_a = visualElement === null || visualElement === void 0 ? void 0 : visualElement.getValue(key)) === null || _a === void 0 ? void 0 : _a.liveStyle) !== void 0) {\n      newValues[key] = style[key];\n    }\n  }\n  return newValues;\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/svg/utils/scrape-motion-values.mjs\nfunction scrapeMotionValuesFromProps2(props, prevProps, visualElement) {\n  const newValues = scrapeMotionValuesFromProps(props, prevProps, visualElement);\n  for (const key in props) {\n    if (isMotionValue(props[key]) || isMotionValue(prevProps[key])) {\n      const targetKey = transformPropOrder.indexOf(key) !== -1 ? \"attr\" + key.charAt(0).toUpperCase() + key.substring(1) : key;\n      newValues[targetKey] = props[key];\n    }\n  }\n  return newValues;\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/motion/utils/use-visual-state.mjs\nvar import_react16 = __toESM(require_react(), 1);\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/utils/resolve-variants.mjs\nfunction resolveVariantFromProps(props, definition, custom, currentValues = {}, currentVelocity = {}) {\n  if (typeof definition === \"function\") {\n    definition = definition(custom !== void 0 ? custom : props.custom, currentValues, currentVelocity);\n  }\n  if (typeof definition === \"string\") {\n    definition = props.variants && props.variants[definition];\n  }\n  if (typeof definition === \"function\") {\n    definition = definition(custom !== void 0 ? custom : props.custom, currentValues, currentVelocity);\n  }\n  return definition;\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/utils/use-constant.mjs\nvar import_react15 = __toESM(require_react(), 1);\nfunction useConstant(init) {\n  const ref = (0, import_react15.useRef)(null);\n  if (ref.current === null) {\n    ref.current = init();\n  }\n  return ref.current;\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/animation/utils/is-keyframes-target.mjs\nvar isKeyframesTarget = (v) => {\n  return Array.isArray(v);\n};\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/utils/resolve-value.mjs\nvar isCustomValue = (v) => {\n  return Boolean(v && typeof v === \"object\" && v.mix && v.toValue);\n};\nvar resolveFinalValueInKeyframes = (v) => {\n  return isKeyframesTarget(v) ? v[v.length - 1] || 0 : v;\n};\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/value/utils/resolve-motion-value.mjs\nfunction resolveMotionValue(value) {\n  const unwrappedValue = isMotionValue(value) ? value.get() : value;\n  return isCustomValue(unwrappedValue) ? unwrappedValue.toValue() : unwrappedValue;\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/motion/utils/use-visual-state.mjs\nfunction makeState({ scrapeMotionValuesFromProps: scrapeMotionValuesFromProps3, createRenderState, onMount }, props, context, presenceContext) {\n  const state = {\n    latestValues: makeLatestValues(props, context, presenceContext, scrapeMotionValuesFromProps3),\n    renderState: createRenderState()\n  };\n  if (onMount) {\n    state.mount = (instance) => onMount(props, instance, state);\n  }\n  return state;\n}\nvar makeUseVisualState = (config) => (props, isStatic) => {\n  const context = (0, import_react16.useContext)(MotionContext);\n  const presenceContext = (0, import_react16.useContext)(PresenceContext);\n  const make = () => makeState(config, props, context, presenceContext);\n  return isStatic ? make() : useConstant(make);\n};\nfunction makeLatestValues(props, context, presenceContext, scrapeMotionValues) {\n  const values = {};\n  const motionValues = scrapeMotionValues(props, {});\n  for (const key in motionValues) {\n    values[key] = resolveMotionValue(motionValues[key]);\n  }\n  let { initial, animate: animate2 } = props;\n  const isControllingVariants$1 = isControllingVariants(props);\n  const isVariantNode$1 = isVariantNode(props);\n  if (context && isVariantNode$1 && !isControllingVariants$1 && props.inherit !== false) {\n    if (initial === void 0)\n      initial = context.initial;\n    if (animate2 === void 0)\n      animate2 = context.animate;\n  }\n  let isInitialAnimationBlocked = presenceContext ? presenceContext.initial === false : false;\n  isInitialAnimationBlocked = isInitialAnimationBlocked || initial === false;\n  const variantToSet = isInitialAnimationBlocked ? animate2 : initial;\n  if (variantToSet && typeof variantToSet !== \"boolean\" && !isAnimationControls(variantToSet)) {\n    const list = Array.isArray(variantToSet) ? variantToSet : [variantToSet];\n    list.forEach((definition) => {\n      const resolved = resolveVariantFromProps(props, definition);\n      if (!resolved)\n        return;\n      const { transitionEnd, transition, ...target } = resolved;\n      for (const key in target) {\n        let valueTarget = target[key];\n        if (Array.isArray(valueTarget)) {\n          const index = isInitialAnimationBlocked ? valueTarget.length - 1 : 0;\n          valueTarget = valueTarget[index];\n        }\n        if (valueTarget !== null) {\n          values[key] = valueTarget;\n        }\n      }\n      for (const key in transitionEnd)\n        values[key] = transitionEnd[key];\n    });\n  }\n  return values;\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/utils/noop.mjs\nvar noop = (any) => any;\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/frameloop/frame.mjs\nvar { schedule: frame, cancel: cancelFrame, state: frameData, steps } = createRenderBatcher(typeof requestAnimationFrame !== \"undefined\" ? requestAnimationFrame : noop, true);\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/svg/config-motion.mjs\nvar svgMotionConfig = {\n  useVisualState: makeUseVisualState({\n    scrapeMotionValuesFromProps: scrapeMotionValuesFromProps2,\n    createRenderState: createSvgRenderState,\n    onMount: (props, instance, { renderState, latestValues }) => {\n      frame.read(() => {\n        try {\n          renderState.dimensions = typeof instance.getBBox === \"function\" ? instance.getBBox() : instance.getBoundingClientRect();\n        } catch (e) {\n          renderState.dimensions = {\n            x: 0,\n            y: 0,\n            width: 0,\n            height: 0\n          };\n        }\n      });\n      frame.render(() => {\n        buildSVGAttrs(renderState, latestValues, { enableHardwareAcceleration: false }, isSVGTag(instance.tagName), props.transformTemplate);\n        renderSVG(instance, renderState);\n      });\n    }\n  })\n};\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/html/config-motion.mjs\nvar htmlMotionConfig = {\n  useVisualState: makeUseVisualState({\n    scrapeMotionValuesFromProps,\n    createRenderState: createHtmlRenderState\n  })\n};\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/dom/utils/create-config.mjs\nfunction createDomMotionConfig(Component2, { forwardMotionProps = false }, preloadedFeatures2, createVisualElement2) {\n  const baseConfig = isSVGComponent(Component2) ? svgMotionConfig : htmlMotionConfig;\n  return {\n    ...baseConfig,\n    preloadedFeatures: preloadedFeatures2,\n    useRender: createUseRender(forwardMotionProps),\n    createVisualElement: createVisualElement2,\n    Component: Component2\n  };\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/events/add-dom-event.mjs\nfunction addDomEvent(target, eventName, handler, options = { passive: true }) {\n  target.addEventListener(eventName, handler, options);\n  return () => target.removeEventListener(eventName, handler);\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/events/utils/is-primary-pointer.mjs\nvar isPrimaryPointer = (event) => {\n  if (event.pointerType === \"mouse\") {\n    return typeof event.button !== \"number\" || event.button <= 0;\n  } else {\n    return event.isPrimary !== false;\n  }\n};\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/events/event-info.mjs\nfunction extractEventInfo(event, pointType = \"page\") {\n  return {\n    point: {\n      x: event[pointType + \"X\"],\n      y: event[pointType + \"Y\"]\n    }\n  };\n}\nvar addPointerInfo = (handler) => {\n  return (event) => isPrimaryPointer(event) && handler(event, extractEventInfo(event));\n};\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/events/add-pointer-event.mjs\nfunction addPointerEvent(target, eventName, handler, options) {\n  return addDomEvent(target, eventName, addPointerInfo(handler), options);\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/utils/pipe.mjs\nvar combineFunctions = (a, b) => (v) => b(a(v));\nvar pipe = (...transformers) => transformers.reduce(combineFunctions);\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/gestures/drag/utils/lock.mjs\nfunction createLock(name) {\n  let lock = null;\n  return () => {\n    const openLock = () => {\n      lock = null;\n    };\n    if (lock === null) {\n      lock = name;\n      return openLock;\n    }\n    return false;\n  };\n}\nvar globalHorizontalLock = createLock(\"dragHorizontal\");\nvar globalVerticalLock = createLock(\"dragVertical\");\nfunction getGlobalLock(drag2) {\n  let lock = false;\n  if (drag2 === \"y\") {\n    lock = globalVerticalLock();\n  } else if (drag2 === \"x\") {\n    lock = globalHorizontalLock();\n  } else {\n    const openHorizontal = globalHorizontalLock();\n    const openVertical = globalVerticalLock();\n    if (openHorizontal && openVertical) {\n      lock = () => {\n        openHorizontal();\n        openVertical();\n      };\n    } else {\n      if (openHorizontal)\n        openHorizontal();\n      if (openVertical)\n        openVertical();\n    }\n  }\n  return lock;\n}\nfunction isDragActive() {\n  const openGestureLock = getGlobalLock(true);\n  if (!openGestureLock)\n    return true;\n  openGestureLock();\n  return false;\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/motion/features/Feature.mjs\nvar Feature = class {\n  constructor(node) {\n    this.isMounted = false;\n    this.node = node;\n  }\n  update() {\n  }\n};\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/gestures/hover.mjs\nfunction addHoverEvent(node, isActive) {\n  const eventName = \"pointer\" + (isActive ? \"enter\" : \"leave\");\n  const callbackName = \"onHover\" + (isActive ? \"Start\" : \"End\");\n  const handleEvent = (event, info) => {\n    if (event.pointerType === \"touch\" || isDragActive())\n      return;\n    const props = node.getProps();\n    if (node.animationState && props.whileHover) {\n      node.animationState.setActive(\"whileHover\", isActive);\n    }\n    if (props[callbackName]) {\n      props[callbackName](event, info);\n    }\n  };\n  return addPointerEvent(node.current, eventName, handleEvent, {\n    passive: !node.getProps()[callbackName]\n  });\n}\nvar HoverGesture = class extends Feature {\n  mount() {\n    this.unmount = pipe(addHoverEvent(this.node, true), addHoverEvent(this.node, false));\n  }\n  unmount() {\n  }\n};\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/gestures/focus.mjs\nvar FocusGesture = class extends Feature {\n  constructor() {\n    super(...arguments);\n    this.isActive = false;\n  }\n  onFocus() {\n    let isFocusVisible = false;\n    try {\n      isFocusVisible = this.node.current.matches(\":focus-visible\");\n    } catch (e) {\n      isFocusVisible = true;\n    }\n    if (!isFocusVisible || !this.node.animationState)\n      return;\n    this.node.animationState.setActive(\"whileFocus\", true);\n    this.isActive = true;\n  }\n  onBlur() {\n    if (!this.isActive || !this.node.animationState)\n      return;\n    this.node.animationState.setActive(\"whileFocus\", false);\n    this.isActive = false;\n  }\n  mount() {\n    this.unmount = pipe(addDomEvent(this.node.current, \"focus\", () => this.onFocus()), addDomEvent(this.node.current, \"blur\", () => this.onBlur()));\n  }\n  unmount() {\n  }\n};\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/gestures/utils/is-node-or-child.mjs\nvar isNodeOrChild = (parent, child) => {\n  if (!child) {\n    return false;\n  } else if (parent === child) {\n    return true;\n  } else {\n    return isNodeOrChild(parent, child.parentElement);\n  }\n};\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/gestures/press.mjs\nfunction fireSyntheticPointerEvent(name, handler) {\n  if (!handler)\n    return;\n  const syntheticPointerEvent = new PointerEvent(\"pointer\" + name);\n  handler(syntheticPointerEvent, extractEventInfo(syntheticPointerEvent));\n}\nvar PressGesture = class extends Feature {\n  constructor() {\n    super(...arguments);\n    this.removeStartListeners = noop;\n    this.removeEndListeners = noop;\n    this.removeAccessibleListeners = noop;\n    this.startPointerPress = (startEvent, startInfo) => {\n      if (this.isPressing)\n        return;\n      this.removeEndListeners();\n      const props = this.node.getProps();\n      const endPointerPress = (endEvent, endInfo) => {\n        if (!this.checkPressEnd())\n          return;\n        const { onTap, onTapCancel, globalTapTarget } = this.node.getProps();\n        !globalTapTarget && !isNodeOrChild(this.node.current, endEvent.target) ? onTapCancel && onTapCancel(endEvent, endInfo) : onTap && onTap(endEvent, endInfo);\n      };\n      const removePointerUpListener = addPointerEvent(window, \"pointerup\", endPointerPress, { passive: !(props.onTap || props[\"onPointerUp\"]) });\n      const removePointerCancelListener = addPointerEvent(window, \"pointercancel\", (cancelEvent, cancelInfo) => this.cancelPress(cancelEvent, cancelInfo), { passive: !(props.onTapCancel || props[\"onPointerCancel\"]) });\n      this.removeEndListeners = pipe(removePointerUpListener, removePointerCancelListener);\n      this.startPress(startEvent, startInfo);\n    };\n    this.startAccessiblePress = () => {\n      const handleKeydown = (keydownEvent) => {\n        if (keydownEvent.key !== \"Enter\" || this.isPressing)\n          return;\n        const handleKeyup = (keyupEvent) => {\n          if (keyupEvent.key !== \"Enter\" || !this.checkPressEnd())\n            return;\n          fireSyntheticPointerEvent(\"up\", (event, info) => {\n            const { onTap } = this.node.getProps();\n            if (onTap)\n              onTap(event, info);\n          });\n        };\n        this.removeEndListeners();\n        this.removeEndListeners = addDomEvent(this.node.current, \"keyup\", handleKeyup);\n        fireSyntheticPointerEvent(\"down\", (event, info) => {\n          this.startPress(event, info);\n        });\n      };\n      const removeKeydownListener = addDomEvent(this.node.current, \"keydown\", handleKeydown);\n      const handleBlur = () => {\n        if (!this.isPressing)\n          return;\n        fireSyntheticPointerEvent(\"cancel\", (cancelEvent, cancelInfo) => this.cancelPress(cancelEvent, cancelInfo));\n      };\n      const removeBlurListener = addDomEvent(this.node.current, \"blur\", handleBlur);\n      this.removeAccessibleListeners = pipe(removeKeydownListener, removeBlurListener);\n    };\n  }\n  startPress(event, info) {\n    this.isPressing = true;\n    const { onTapStart, whileTap } = this.node.getProps();\n    if (whileTap && this.node.animationState) {\n      this.node.animationState.setActive(\"whileTap\", true);\n    }\n    if (onTapStart) {\n      onTapStart(event, info);\n    }\n  }\n  checkPressEnd() {\n    this.removeEndListeners();\n    this.isPressing = false;\n    const props = this.node.getProps();\n    if (props.whileTap && this.node.animationState) {\n      this.node.animationState.setActive(\"whileTap\", false);\n    }\n    return !isDragActive();\n  }\n  cancelPress(event, info) {\n    if (!this.checkPressEnd())\n      return;\n    const { onTapCancel } = this.node.getProps();\n    if (onTapCancel)\n      onTapCancel(event, info);\n  }\n  mount() {\n    const props = this.node.getProps();\n    const removePointerListener = addPointerEvent(props.globalTapTarget ? window : this.node.current, \"pointerdown\", this.startPointerPress, { passive: !(props.onTapStart || props[\"onPointerStart\"]) });\n    const removeFocusListener = addDomEvent(this.node.current, \"focus\", this.startAccessiblePress);\n    this.removeStartListeners = pipe(removePointerListener, removeFocusListener);\n  }\n  unmount() {\n    this.removeStartListeners();\n    this.removeEndListeners();\n    this.removeAccessibleListeners();\n  }\n};\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/motion/features/viewport/observers.mjs\nvar observerCallbacks = /* @__PURE__ */ new WeakMap();\nvar observers = /* @__PURE__ */ new WeakMap();\nvar fireObserverCallback = (entry) => {\n  const callback = observerCallbacks.get(entry.target);\n  callback && callback(entry);\n};\nvar fireAllObserverCallbacks = (entries) => {\n  entries.forEach(fireObserverCallback);\n};\nfunction initIntersectionObserver({ root, ...options }) {\n  const lookupRoot = root || document;\n  if (!observers.has(lookupRoot)) {\n    observers.set(lookupRoot, {});\n  }\n  const rootObservers = observers.get(lookupRoot);\n  const key = JSON.stringify(options);\n  if (!rootObservers[key]) {\n    rootObservers[key] = new IntersectionObserver(fireAllObserverCallbacks, { root, ...options });\n  }\n  return rootObservers[key];\n}\nfunction observeIntersection(element, options, callback) {\n  const rootInteresectionObserver = initIntersectionObserver(options);\n  observerCallbacks.set(element, callback);\n  rootInteresectionObserver.observe(element);\n  return () => {\n    observerCallbacks.delete(element);\n    rootInteresectionObserver.unobserve(element);\n  };\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/motion/features/viewport/index.mjs\nvar thresholdNames = {\n  some: 0,\n  all: 1\n};\nvar InViewFeature = class extends Feature {\n  constructor() {\n    super(...arguments);\n    this.hasEnteredView = false;\n    this.isInView = false;\n  }\n  startObserver() {\n    this.unmount();\n    const { viewport = {} } = this.node.getProps();\n    const { root, margin: rootMargin, amount = \"some\", once } = viewport;\n    const options = {\n      root: root ? root.current : void 0,\n      rootMargin,\n      threshold: typeof amount === \"number\" ? amount : thresholdNames[amount]\n    };\n    const onIntersectionUpdate = (entry) => {\n      const { isIntersecting } = entry;\n      if (this.isInView === isIntersecting)\n        return;\n      this.isInView = isIntersecting;\n      if (once && !isIntersecting && this.hasEnteredView) {\n        return;\n      } else if (isIntersecting) {\n        this.hasEnteredView = true;\n      }\n      if (this.node.animationState) {\n        this.node.animationState.setActive(\"whileInView\", isIntersecting);\n      }\n      const { onViewportEnter, onViewportLeave } = this.node.getProps();\n      const callback = isIntersecting ? onViewportEnter : onViewportLeave;\n      callback && callback(entry);\n    };\n    return observeIntersection(this.node.current, options, onIntersectionUpdate);\n  }\n  mount() {\n    this.startObserver();\n  }\n  update() {\n    if (typeof IntersectionObserver === \"undefined\")\n      return;\n    const { props, prevProps } = this.node;\n    const hasOptionsChanged = [\"amount\", \"margin\", \"root\"].some(hasViewportOptionChanged(props, prevProps));\n    if (hasOptionsChanged) {\n      this.startObserver();\n    }\n  }\n  unmount() {\n  }\n};\nfunction hasViewportOptionChanged({ viewport = {} }, { viewport: prevViewport = {} } = {}) {\n  return (name) => viewport[name] !== prevViewport[name];\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/motion/features/gestures.mjs\nvar gestureAnimations = {\n  inView: {\n    Feature: InViewFeature\n  },\n  tap: {\n    Feature: PressGesture\n  },\n  focus: {\n    Feature: FocusGesture\n  },\n  hover: {\n    Feature: HoverGesture\n  }\n};\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/utils/shallow-compare.mjs\nfunction shallowCompare(next, prev) {\n  if (!Array.isArray(prev))\n    return false;\n  const prevLength = prev.length;\n  if (prevLength !== next.length)\n    return false;\n  for (let i = 0; i < prevLength; i++) {\n    if (prev[i] !== next[i])\n      return false;\n  }\n  return true;\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/utils/resolve-dynamic-variants.mjs\nfunction getCurrent(visualElement) {\n  const current = {};\n  visualElement.values.forEach((value, key) => current[key] = value.get());\n  return current;\n}\nfunction getVelocity(visualElement) {\n  const velocity = {};\n  visualElement.values.forEach((value, key) => velocity[key] = value.getVelocity());\n  return velocity;\n}\nfunction resolveVariant(visualElement, definition, custom) {\n  const props = visualElement.getProps();\n  return resolveVariantFromProps(props, definition, custom !== void 0 ? custom : props.custom, getCurrent(visualElement), getVelocity(visualElement));\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/utils/time-conversion.mjs\nvar secondsToMilliseconds = (seconds) => seconds * 1e3;\nvar millisecondsToSeconds = (milliseconds) => milliseconds / 1e3;\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/animation/utils/default-transitions.mjs\nvar underDampedSpring = {\n  type: \"spring\",\n  stiffness: 500,\n  damping: 25,\n  restSpeed: 10\n};\nvar criticallyDampedSpring = (target) => ({\n  type: \"spring\",\n  stiffness: 550,\n  damping: target === 0 ? 2 * Math.sqrt(550) : 30,\n  restSpeed: 10\n});\nvar keyframesTransition = {\n  type: \"keyframes\",\n  duration: 0.8\n};\nvar ease = {\n  type: \"keyframes\",\n  ease: [0.25, 0.1, 0.35, 1],\n  duration: 0.3\n};\nvar getDefaultTransition = (valueKey, { keyframes: keyframes2 }) => {\n  if (keyframes2.length > 2) {\n    return keyframesTransition;\n  } else if (transformProps.has(valueKey)) {\n    return valueKey.startsWith(\"scale\") ? criticallyDampedSpring(keyframes2[1]) : underDampedSpring;\n  }\n  return ease;\n};\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/animation/utils/transitions.mjs\nfunction isTransitionDefined({ when, delay: _delay, delayChildren, staggerChildren, staggerDirection, repeat, repeatType, repeatDelay, from, elapsed, ...transition }) {\n  return !!Object.keys(transition).length;\n}\nfunction getValueTransition(transition, key) {\n  return transition[key] || transition[\"default\"] || transition;\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/utils/use-instant-transition-state.mjs\nvar instantAnimationState = {\n  current: false\n};\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/animation/animators/waapi/utils/get-final-keyframe.mjs\nvar isNotNull = (value) => value !== null;\nfunction getFinalKeyframe(keyframes2, { repeat, repeatType = \"loop\" }, finalKeyframe) {\n  const resolvedKeyframes = keyframes2.filter(isNotNull);\n  const index = repeat && repeatType !== \"loop\" && repeat % 2 === 1 ? 0 : resolvedKeyframes.length - 1;\n  return !index || finalKeyframe === void 0 ? resolvedKeyframes[index] : finalKeyframe;\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/frameloop/sync-time.mjs\nvar now;\nfunction clearTime() {\n  now = void 0;\n}\nvar time = {\n  now: () => {\n    if (now === void 0) {\n      time.set(frameData.isProcessing || MotionGlobalConfig.useManualTiming ? frameData.timestamp : performance.now());\n    }\n    return now;\n  },\n  set: (newTime) => {\n    now = newTime;\n    queueMicrotask(clearTime);\n  }\n};\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/utils/is-zero-value-string.mjs\nvar isZeroValueString = (v) => /^0[^.\\s]+$/u.test(v);\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/animation/utils/is-none.mjs\nfunction isNone(value) {\n  if (typeof value === \"number\") {\n    return value === 0;\n  } else if (value !== null) {\n    return value === \"none\" || value === \"0\" || isZeroValueString(value);\n  } else {\n    return true;\n  }\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/utils/errors.mjs\nvar warning = noop;\nvar invariant = noop;\nif (true) {\n  warning = (check, message) => {\n    if (!check && typeof console !== \"undefined\") {\n      console.warn(message);\n    }\n  };\n  invariant = (check, message) => {\n    if (!check) {\n      throw new Error(message);\n    }\n  };\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/utils/is-numerical-string.mjs\nvar isNumericalString = (v) => /^-?(?:\\d+(?:\\.\\d+)?|\\.\\d+)$/u.test(v);\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/dom/utils/css-variables-conversion.mjs\nvar splitCSSVariableRegex = (\n  // eslint-disable-next-line redos-detector/no-unsafe-regex -- false positive, as it can match a lot of words\n  /^var\\(--(?:([\\w-]+)|([\\w-]+), ?([a-zA-Z\\d ()%#.,-]+))\\)/u\n);\nfunction parseCSSVariable(current) {\n  const match = splitCSSVariableRegex.exec(current);\n  if (!match)\n    return [,];\n  const [, token1, token2, fallback] = match;\n  return [`--${token1 !== null && token1 !== void 0 ? token1 : token2}`, fallback];\n}\nvar maxDepth = 4;\nfunction getVariableValue(current, element, depth = 1) {\n  invariant(depth <= maxDepth, `Max CSS variable fallback depth detected in property \"${current}\". This may indicate a circular fallback dependency.`);\n  const [token, fallback] = parseCSSVariable(current);\n  if (!token)\n    return;\n  const resolved = window.getComputedStyle(element).getPropertyValue(token);\n  if (resolved) {\n    const trimmed = resolved.trim();\n    return isNumericalString(trimmed) ? parseFloat(trimmed) : trimmed;\n  }\n  return isCSSVariableToken(fallback) ? getVariableValue(fallback, element, depth + 1) : fallback;\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/dom/utils/unit-conversion.mjs\nvar positionalKeys = /* @__PURE__ */ new Set([\n  \"width\",\n  \"height\",\n  \"top\",\n  \"left\",\n  \"right\",\n  \"bottom\",\n  \"x\",\n  \"y\",\n  \"translateX\",\n  \"translateY\"\n]);\nvar isNumOrPxType = (v) => v === number || v === px;\nvar getPosFromMatrix = (matrix, pos) => parseFloat(matrix.split(\", \")[pos]);\nvar getTranslateFromMatrix = (pos2, pos3) => (_bbox, { transform: transform2 }) => {\n  if (transform2 === \"none\" || !transform2)\n    return 0;\n  const matrix3d = transform2.match(/^matrix3d\\((.+)\\)$/u);\n  if (matrix3d) {\n    return getPosFromMatrix(matrix3d[1], pos3);\n  } else {\n    const matrix = transform2.match(/^matrix\\((.+)\\)$/u);\n    if (matrix) {\n      return getPosFromMatrix(matrix[1], pos2);\n    } else {\n      return 0;\n    }\n  }\n};\nvar transformKeys = /* @__PURE__ */ new Set([\"x\", \"y\", \"z\"]);\nvar nonTranslationalTransformKeys = transformPropOrder.filter((key) => !transformKeys.has(key));\nfunction removeNonTranslationalTransform(visualElement) {\n  const removedTransforms = [];\n  nonTranslationalTransformKeys.forEach((key) => {\n    const value = visualElement.getValue(key);\n    if (value !== void 0) {\n      removedTransforms.push([key, value.get()]);\n      value.set(key.startsWith(\"scale\") ? 1 : 0);\n    }\n  });\n  return removedTransforms;\n}\nvar positionalValues = {\n  // Dimensions\n  width: ({ x }, { paddingLeft = \"0\", paddingRight = \"0\" }) => x.max - x.min - parseFloat(paddingLeft) - parseFloat(paddingRight),\n  height: ({ y }, { paddingTop = \"0\", paddingBottom = \"0\" }) => y.max - y.min - parseFloat(paddingTop) - parseFloat(paddingBottom),\n  top: (_bbox, { top }) => parseFloat(top),\n  left: (_bbox, { left }) => parseFloat(left),\n  bottom: ({ y }, { top }) => parseFloat(top) + (y.max - y.min),\n  right: ({ x }, { left }) => parseFloat(left) + (x.max - x.min),\n  // Transform\n  x: getTranslateFromMatrix(4, 13),\n  y: getTranslateFromMatrix(5, 14)\n};\npositionalValues.translateX = positionalValues.x;\npositionalValues.translateY = positionalValues.y;\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/dom/value-types/test.mjs\nvar testValueType = (v) => (type) => type.test(v);\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/dom/value-types/type-auto.mjs\nvar auto = {\n  test: (v) => v === \"auto\",\n  parse: (v) => v\n};\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/dom/value-types/dimensions.mjs\nvar dimensionValueTypes = [number, px, percent, degrees, vw, vh, auto];\nvar findDimensionValueType = (v) => dimensionValueTypes.find(testValueType(v));\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/utils/KeyframesResolver.mjs\nvar toResolve = /* @__PURE__ */ new Set();\nvar isScheduled = false;\nvar anyNeedsMeasurement = false;\nfunction measureAllKeyframes() {\n  if (anyNeedsMeasurement) {\n    const resolversToMeasure = Array.from(toResolve).filter((resolver) => resolver.needsMeasurement);\n    const elementsToMeasure = new Set(resolversToMeasure.map((resolver) => resolver.element));\n    const transformsToRestore = /* @__PURE__ */ new Map();\n    elementsToMeasure.forEach((element) => {\n      const removedTransforms = removeNonTranslationalTransform(element);\n      if (!removedTransforms.length)\n        return;\n      transformsToRestore.set(element, removeNonTranslationalTransform(element));\n      element.render();\n    });\n    resolversToMeasure.forEach((resolver) => resolver.measureInitialState());\n    elementsToMeasure.forEach((element) => {\n      element.render();\n    });\n    resolversToMeasure.forEach((resolver) => resolver.measureEndState());\n    resolversToMeasure.forEach((resolver) => {\n      if (resolver.suspendedScrollY !== void 0) {\n        window.scrollTo(0, resolver.suspendedScrollY);\n      }\n    });\n  }\n  anyNeedsMeasurement = false;\n  isScheduled = false;\n  toResolve.forEach((resolver) => resolver.complete());\n  toResolve.clear();\n}\nfunction readAllKeyframes() {\n  toResolve.forEach((resolver) => {\n    resolver.readKeyframes();\n    if (resolver.needsMeasurement) {\n      anyNeedsMeasurement = true;\n    }\n  });\n}\nfunction flushKeyframeResolvers() {\n  readAllKeyframes();\n  measureAllKeyframes();\n}\nvar KeyframeResolver = class {\n  constructor(unresolvedKeyframes, onComplete, name, motionValue2, element, isAsync = false) {\n    this.isComplete = false;\n    this.isAsync = false;\n    this.needsMeasurement = false;\n    this.isScheduled = false;\n    this.unresolvedKeyframes = [...unresolvedKeyframes];\n    this.onComplete = onComplete;\n    this.name = name;\n    this.motionValue = motionValue2;\n    this.element = element;\n    this.isAsync = isAsync;\n  }\n  scheduleResolve() {\n    this.isScheduled = true;\n    if (this.isAsync) {\n      toResolve.add(this);\n      if (!isScheduled) {\n        isScheduled = true;\n        frame.read(readAllKeyframes);\n        frame.resolveKeyframes(measureAllKeyframes);\n      }\n    } else {\n      this.readKeyframes();\n      this.complete();\n    }\n  }\n  readKeyframes() {\n    const { unresolvedKeyframes, name, element, motionValue: motionValue2 } = this;\n    for (let i = 0; i < unresolvedKeyframes.length; i++) {\n      if (unresolvedKeyframes[i] === null) {\n        if (i === 0) {\n          const currentValue = motionValue2 === null || motionValue2 === void 0 ? void 0 : motionValue2.get();\n          const finalKeyframe = unresolvedKeyframes[unresolvedKeyframes.length - 1];\n          if (currentValue !== void 0) {\n            unresolvedKeyframes[0] = currentValue;\n          } else if (element && name) {\n            const valueAsRead = element.readValue(name, finalKeyframe);\n            if (valueAsRead !== void 0 && valueAsRead !== null) {\n              unresolvedKeyframes[0] = valueAsRead;\n            }\n          }\n          if (unresolvedKeyframes[0] === void 0) {\n            unresolvedKeyframes[0] = finalKeyframe;\n          }\n          if (motionValue2 && currentValue === void 0) {\n            motionValue2.set(unresolvedKeyframes[0]);\n          }\n        } else {\n          unresolvedKeyframes[i] = unresolvedKeyframes[i - 1];\n        }\n      }\n    }\n  }\n  setFinalKeyframe() {\n  }\n  measureInitialState() {\n  }\n  renderEndStyles() {\n  }\n  measureEndState() {\n  }\n  complete() {\n    this.isComplete = true;\n    this.onComplete(this.unresolvedKeyframes, this.finalKeyframe);\n    toResolve.delete(this);\n  }\n  cancel() {\n    if (!this.isComplete) {\n      this.isScheduled = false;\n      toResolve.delete(this);\n    }\n  }\n  resume() {\n    if (!this.isComplete)\n      this.scheduleResolve();\n  }\n};\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/value/types/color/utils.mjs\nvar isColorString = (type, testProp) => (v) => {\n  return Boolean(isString(v) && singleColorRegex.test(v) && v.startsWith(type) || testProp && Object.prototype.hasOwnProperty.call(v, testProp));\n};\nvar splitColor = (aName, bName, cName) => (v) => {\n  if (!isString(v))\n    return v;\n  const [a, b, c, alpha2] = v.match(floatRegex);\n  return {\n    [aName]: parseFloat(a),\n    [bName]: parseFloat(b),\n    [cName]: parseFloat(c),\n    alpha: alpha2 !== void 0 ? parseFloat(alpha2) : 1\n  };\n};\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/value/types/color/rgba.mjs\nvar clampRgbUnit = (v) => clamp(0, 255, v);\nvar rgbUnit = {\n  ...number,\n  transform: (v) => Math.round(clampRgbUnit(v))\n};\nvar rgba = {\n  test: isColorString(\"rgb\", \"red\"),\n  parse: splitColor(\"red\", \"green\", \"blue\"),\n  transform: ({ red, green, blue, alpha: alpha$1 = 1 }) => \"rgba(\" + rgbUnit.transform(red) + \", \" + rgbUnit.transform(green) + \", \" + rgbUnit.transform(blue) + \", \" + sanitize(alpha.transform(alpha$1)) + \")\"\n};\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/value/types/color/hex.mjs\nfunction parseHex(v) {\n  let r = \"\";\n  let g = \"\";\n  let b = \"\";\n  let a = \"\";\n  if (v.length > 5) {\n    r = v.substring(1, 3);\n    g = v.substring(3, 5);\n    b = v.substring(5, 7);\n    a = v.substring(7, 9);\n  } else {\n    r = v.substring(1, 2);\n    g = v.substring(2, 3);\n    b = v.substring(3, 4);\n    a = v.substring(4, 5);\n    r += r;\n    g += g;\n    b += b;\n    a += a;\n  }\n  return {\n    red: parseInt(r, 16),\n    green: parseInt(g, 16),\n    blue: parseInt(b, 16),\n    alpha: a ? parseInt(a, 16) / 255 : 1\n  };\n}\nvar hex = {\n  test: isColorString(\"#\"),\n  parse: parseHex,\n  transform: rgba.transform\n};\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/value/types/color/hsla.mjs\nvar hsla = {\n  test: isColorString(\"hsl\", \"hue\"),\n  parse: splitColor(\"hue\", \"saturation\", \"lightness\"),\n  transform: ({ hue, saturation, lightness, alpha: alpha$1 = 1 }) => {\n    return \"hsla(\" + Math.round(hue) + \", \" + percent.transform(sanitize(saturation)) + \", \" + percent.transform(sanitize(lightness)) + \", \" + sanitize(alpha.transform(alpha$1)) + \")\";\n  }\n};\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/value/types/color/index.mjs\nvar color = {\n  test: (v) => rgba.test(v) || hex.test(v) || hsla.test(v),\n  parse: (v) => {\n    if (rgba.test(v)) {\n      return rgba.parse(v);\n    } else if (hsla.test(v)) {\n      return hsla.parse(v);\n    } else {\n      return hex.parse(v);\n    }\n  },\n  transform: (v) => {\n    return isString(v) ? v : v.hasOwnProperty(\"red\") ? rgba.transform(v) : hsla.transform(v);\n  }\n};\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/value/types/complex/index.mjs\nfunction test(v) {\n  var _a, _b;\n  return isNaN(v) && isString(v) && (((_a = v.match(floatRegex)) === null || _a === void 0 ? void 0 : _a.length) || 0) + (((_b = v.match(colorRegex)) === null || _b === void 0 ? void 0 : _b.length) || 0) > 0;\n}\nvar NUMBER_TOKEN = \"number\";\nvar COLOR_TOKEN = \"color\";\nvar VAR_TOKEN = \"var\";\nvar VAR_FUNCTION_TOKEN = \"var(\";\nvar SPLIT_TOKEN = \"${}\";\nvar complexRegex = /var\\s*\\(\\s*--(?:[\\w-]+\\s*|[\\w-]+\\s*,(?:\\s*[^)(\\s]|\\s*\\((?:[^)(]|\\([^)(]*\\))*\\))+\\s*)\\)|#[\\da-f]{3,8}|(?:rgb|hsl)a?\\((?:-?[\\d.]+%?[,\\s]+){2}-?[\\d.]+%?\\s*(?:[,/]\\s*)?(?:\\b\\d+(?:\\.\\d+)?|\\.\\d+)?%?\\)|-?(?:\\d+(?:\\.\\d+)?|\\.\\d+)/giu;\nfunction analyseComplexValue(value) {\n  const originalValue = value.toString();\n  const values = [];\n  const indexes = {\n    color: [],\n    number: [],\n    var: []\n  };\n  const types = [];\n  let i = 0;\n  const tokenised = originalValue.replace(complexRegex, (parsedValue) => {\n    if (color.test(parsedValue)) {\n      indexes.color.push(i);\n      types.push(COLOR_TOKEN);\n      values.push(color.parse(parsedValue));\n    } else if (parsedValue.startsWith(VAR_FUNCTION_TOKEN)) {\n      indexes.var.push(i);\n      types.push(VAR_TOKEN);\n      values.push(parsedValue);\n    } else {\n      indexes.number.push(i);\n      types.push(NUMBER_TOKEN);\n      values.push(parseFloat(parsedValue));\n    }\n    ++i;\n    return SPLIT_TOKEN;\n  });\n  const split = tokenised.split(SPLIT_TOKEN);\n  return { values, split, indexes, types };\n}\nfunction parseComplexValue(v) {\n  return analyseComplexValue(v).values;\n}\nfunction createTransformer(source) {\n  const { split, types } = analyseComplexValue(source);\n  const numSections = split.length;\n  return (v) => {\n    let output = \"\";\n    for (let i = 0; i < numSections; i++) {\n      output += split[i];\n      if (v[i] !== void 0) {\n        const type = types[i];\n        if (type === NUMBER_TOKEN) {\n          output += sanitize(v[i]);\n        } else if (type === COLOR_TOKEN) {\n          output += color.transform(v[i]);\n        } else {\n          output += v[i];\n        }\n      }\n    }\n    return output;\n  };\n}\nvar convertNumbersToZero = (v) => typeof v === \"number\" ? 0 : v;\nfunction getAnimatableNone(v) {\n  const parsed = parseComplexValue(v);\n  const transformer = createTransformer(v);\n  return transformer(parsed.map(convertNumbersToZero));\n}\nvar complex = {\n  test,\n  parse: parseComplexValue,\n  createTransformer,\n  getAnimatableNone\n};\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/value/types/complex/filter.mjs\nvar maxDefaults = /* @__PURE__ */ new Set([\"brightness\", \"contrast\", \"saturate\", \"opacity\"]);\nfunction applyDefaultFilter(v) {\n  const [name, value] = v.slice(0, -1).split(\"(\");\n  if (name === \"drop-shadow\")\n    return v;\n  const [number2] = value.match(floatRegex) || [];\n  if (!number2)\n    return v;\n  const unit = value.replace(number2, \"\");\n  let defaultValue = maxDefaults.has(name) ? 1 : 0;\n  if (number2 !== value)\n    defaultValue *= 100;\n  return name + \"(\" + defaultValue + unit + \")\";\n}\nvar functionRegex = /\\b([a-z-]*)\\(.*?\\)/gu;\nvar filter = {\n  ...complex,\n  getAnimatableNone: (v) => {\n    const functions = v.match(functionRegex);\n    return functions ? functions.map(applyDefaultFilter).join(\" \") : v;\n  }\n};\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/dom/value-types/defaults.mjs\nvar defaultValueTypes = {\n  ...numberValueTypes,\n  // Color props\n  color,\n  backgroundColor: color,\n  outlineColor: color,\n  fill: color,\n  stroke: color,\n  // Border props\n  borderColor: color,\n  borderTopColor: color,\n  borderRightColor: color,\n  borderBottomColor: color,\n  borderLeftColor: color,\n  filter,\n  WebkitFilter: filter\n};\nvar getDefaultValueType = (key) => defaultValueTypes[key];\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/dom/value-types/animatable-none.mjs\nfunction getAnimatableNone2(key, value) {\n  let defaultValueType = getDefaultValueType(key);\n  if (defaultValueType !== filter)\n    defaultValueType = complex;\n  return defaultValueType.getAnimatableNone ? defaultValueType.getAnimatableNone(value) : void 0;\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/html/utils/make-none-animatable.mjs\nfunction makeNoneKeyframesAnimatable(unresolvedKeyframes, noneKeyframeIndexes, name) {\n  let i = 0;\n  let animatableTemplate = void 0;\n  while (i < unresolvedKeyframes.length && !animatableTemplate) {\n    if (typeof unresolvedKeyframes[i] === \"string\" && unresolvedKeyframes[i] !== \"none\" && unresolvedKeyframes[i] !== \"0\") {\n      animatableTemplate = unresolvedKeyframes[i];\n    }\n    i++;\n  }\n  if (animatableTemplate && name) {\n    for (const noneIndex of noneKeyframeIndexes) {\n      unresolvedKeyframes[noneIndex] = getAnimatableNone2(name, animatableTemplate);\n    }\n  }\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/dom/DOMKeyframesResolver.mjs\nvar DOMKeyframesResolver = class extends KeyframeResolver {\n  constructor(unresolvedKeyframes, onComplete, name, motionValue2) {\n    super(unresolvedKeyframes, onComplete, name, motionValue2, motionValue2 === null || motionValue2 === void 0 ? void 0 : motionValue2.owner, true);\n  }\n  readKeyframes() {\n    const { unresolvedKeyframes, element, name } = this;\n    if (!element.current)\n      return;\n    super.readKeyframes();\n    for (let i = 0; i < unresolvedKeyframes.length; i++) {\n      const keyframe = unresolvedKeyframes[i];\n      if (typeof keyframe === \"string\" && isCSSVariableToken(keyframe)) {\n        const resolved = getVariableValue(keyframe, element.current);\n        if (resolved !== void 0) {\n          unresolvedKeyframes[i] = resolved;\n        }\n      }\n    }\n    if (!positionalKeys.has(name) || unresolvedKeyframes.length !== 2) {\n      return this.resolveNoneKeyframes();\n    }\n    const [origin, target] = unresolvedKeyframes;\n    const originType = findDimensionValueType(origin);\n    const targetType = findDimensionValueType(target);\n    if (originType === targetType)\n      return;\n    if (isNumOrPxType(originType) && isNumOrPxType(targetType)) {\n      for (let i = 0; i < unresolvedKeyframes.length; i++) {\n        const value = unresolvedKeyframes[i];\n        if (typeof value === \"string\") {\n          unresolvedKeyframes[i] = parseFloat(value);\n        }\n      }\n    } else {\n      this.needsMeasurement = true;\n    }\n  }\n  resolveNoneKeyframes() {\n    const { unresolvedKeyframes, name } = this;\n    const noneKeyframeIndexes = [];\n    for (let i = 0; i < unresolvedKeyframes.length; i++) {\n      if (isNone(unresolvedKeyframes[i])) {\n        noneKeyframeIndexes.push(i);\n      }\n    }\n    if (noneKeyframeIndexes.length) {\n      makeNoneKeyframesAnimatable(unresolvedKeyframes, noneKeyframeIndexes, name);\n    }\n  }\n  measureInitialState() {\n    const { element, unresolvedKeyframes, name } = this;\n    if (!element.current)\n      return;\n    if (name === \"height\") {\n      this.suspendedScrollY = window.pageYOffset;\n    }\n    this.measuredOrigin = positionalValues[name](element.measureViewportBox(), window.getComputedStyle(element.current));\n    unresolvedKeyframes[0] = this.measuredOrigin;\n    const measureKeyframe = unresolvedKeyframes[unresolvedKeyframes.length - 1];\n    if (measureKeyframe !== void 0) {\n      element.getValue(name, measureKeyframe).jump(measureKeyframe, false);\n    }\n  }\n  measureEndState() {\n    var _a;\n    const { element, name, unresolvedKeyframes } = this;\n    if (!element.current)\n      return;\n    const value = element.getValue(name);\n    value && value.jump(this.measuredOrigin, false);\n    const finalKeyframeIndex = unresolvedKeyframes.length - 1;\n    const finalKeyframe = unresolvedKeyframes[finalKeyframeIndex];\n    unresolvedKeyframes[finalKeyframeIndex] = positionalValues[name](element.measureViewportBox(), window.getComputedStyle(element.current));\n    if (finalKeyframe !== null) {\n      this.finalKeyframe = finalKeyframe;\n    }\n    if ((_a = this.removedTransforms) === null || _a === void 0 ? void 0 : _a.length) {\n      this.removedTransforms.forEach(([unsetTransformName, unsetTransformValue]) => {\n        element.getValue(unsetTransformName).set(unsetTransformValue);\n      });\n    }\n    this.resolveNoneKeyframes();\n  }\n};\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/utils/memo.mjs\nfunction memo(callback) {\n  let result;\n  return () => {\n    if (result === void 0)\n      result = callback();\n    return result;\n  };\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/animation/utils/is-animatable.mjs\nvar isAnimatable = (value, name) => {\n  if (name === \"zIndex\")\n    return false;\n  if (typeof value === \"number\" || Array.isArray(value))\n    return true;\n  if (typeof value === \"string\" && // It's animatable if we have a string\n  (complex.test(value) || value === \"0\") && // And it contains numbers and/or colors\n  !value.startsWith(\"url(\")) {\n    return true;\n  }\n  return false;\n};\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/animation/animators/utils/can-animate.mjs\nfunction hasKeyframesChanged(keyframes2) {\n  const current = keyframes2[0];\n  if (keyframes2.length === 1)\n    return true;\n  for (let i = 0; i < keyframes2.length; i++) {\n    if (keyframes2[i] !== current)\n      return true;\n  }\n}\nfunction canAnimate(keyframes2, name, type, velocity) {\n  const originKeyframe = keyframes2[0];\n  if (originKeyframe === null)\n    return false;\n  const targetKeyframe = keyframes2[keyframes2.length - 1];\n  const isOriginAnimatable = isAnimatable(originKeyframe, name);\n  const isTargetAnimatable = isAnimatable(targetKeyframe, name);\n  warning(isOriginAnimatable === isTargetAnimatable, `You are trying to animate ${name} from \"${originKeyframe}\" to \"${targetKeyframe}\". ${originKeyframe} is not an animatable value - to enable this animation set ${originKeyframe} to a value animatable to ${targetKeyframe} via the \\`style\\` property.`);\n  if (!isOriginAnimatable || !isTargetAnimatable) {\n    return false;\n  }\n  return hasKeyframesChanged(keyframes2) || type === \"spring\" && velocity;\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/animation/animators/BaseAnimation.mjs\nvar BaseAnimation = class {\n  constructor({ autoplay = true, delay: delay2 = 0, type = \"keyframes\", repeat = 0, repeatDelay = 0, repeatType = \"loop\", ...options }) {\n    this.isStopped = false;\n    this.hasAttemptedResolve = false;\n    this.options = {\n      autoplay,\n      delay: delay2,\n      type,\n      repeat,\n      repeatDelay,\n      repeatType,\n      ...options\n    };\n    this.updateFinishedPromise();\n  }\n  /**\n   * A getter for resolved data. If keyframes are not yet resolved, accessing\n   * this.resolved will synchronously flush all pending keyframe resolvers.\n   * This is a deoptimisation, but at its worst still batches read/writes.\n   */\n  get resolved() {\n    if (!this._resolved && !this.hasAttemptedResolve) {\n      flushKeyframeResolvers();\n    }\n    return this._resolved;\n  }\n  /**\n   * A method to be called when the keyframes resolver completes. This method\n   * will check if its possible to run the animation and, if not, skip it.\n   * Otherwise, it will call initPlayback on the implementing class.\n   */\n  onKeyframesResolved(keyframes2, finalKeyframe) {\n    this.hasAttemptedResolve = true;\n    const { name, type, velocity, delay: delay2, onComplete, onUpdate, isGenerator } = this.options;\n    if (!isGenerator && !canAnimate(keyframes2, name, type, velocity)) {\n      if (instantAnimationState.current || !delay2) {\n        onUpdate === null || onUpdate === void 0 ? void 0 : onUpdate(getFinalKeyframe(keyframes2, this.options, finalKeyframe));\n        onComplete === null || onComplete === void 0 ? void 0 : onComplete();\n        this.resolveFinishedPromise();\n        return;\n      } else {\n        this.options.duration = 0;\n      }\n    }\n    const resolvedAnimation = this.initPlayback(keyframes2, finalKeyframe);\n    if (resolvedAnimation === false)\n      return;\n    this._resolved = {\n      keyframes: keyframes2,\n      finalKeyframe,\n      ...resolvedAnimation\n    };\n    this.onPostResolved();\n  }\n  onPostResolved() {\n  }\n  /**\n   * Allows the returned animation to be awaited or promise-chained. Currently\n   * resolves when the animation finishes at all but in a future update could/should\n   * reject if its cancels.\n   */\n  then(resolve, reject) {\n    return this.currentFinishedPromise.then(resolve, reject);\n  }\n  updateFinishedPromise() {\n    this.currentFinishedPromise = new Promise((resolve) => {\n      this.resolveFinishedPromise = resolve;\n    });\n  }\n};\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/utils/velocity-per-second.mjs\nfunction velocityPerSecond(velocity, frameDuration) {\n  return frameDuration ? velocity * (1e3 / frameDuration) : 0;\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/animation/generators/utils/velocity.mjs\nvar velocitySampleDuration = 5;\nfunction calcGeneratorVelocity(resolveValue, t, current) {\n  const prevT = Math.max(t - velocitySampleDuration, 0);\n  return velocityPerSecond(current - resolveValue(prevT), t - prevT);\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/animation/generators/spring/find.mjs\nvar safeMin = 1e-3;\nvar minDuration = 0.01;\nvar maxDuration = 10;\nvar minDamping = 0.05;\nvar maxDamping = 1;\nfunction findSpring({ duration = 800, bounce = 0.25, velocity = 0, mass = 1 }) {\n  let envelope;\n  let derivative;\n  warning(duration <= secondsToMilliseconds(maxDuration), \"Spring duration must be 10 seconds or less\");\n  let dampingRatio = 1 - bounce;\n  dampingRatio = clamp(minDamping, maxDamping, dampingRatio);\n  duration = clamp(minDuration, maxDuration, millisecondsToSeconds(duration));\n  if (dampingRatio < 1) {\n    envelope = (undampedFreq2) => {\n      const exponentialDecay = undampedFreq2 * dampingRatio;\n      const delta = exponentialDecay * duration;\n      const a = exponentialDecay - velocity;\n      const b = calcAngularFreq(undampedFreq2, dampingRatio);\n      const c = Math.exp(-delta);\n      return safeMin - a / b * c;\n    };\n    derivative = (undampedFreq2) => {\n      const exponentialDecay = undampedFreq2 * dampingRatio;\n      const delta = exponentialDecay * duration;\n      const d = delta * velocity + velocity;\n      const e = Math.pow(dampingRatio, 2) * Math.pow(undampedFreq2, 2) * duration;\n      const f = Math.exp(-delta);\n      const g = calcAngularFreq(Math.pow(undampedFreq2, 2), dampingRatio);\n      const factor = -envelope(undampedFreq2) + safeMin > 0 ? -1 : 1;\n      return factor * ((d - e) * f) / g;\n    };\n  } else {\n    envelope = (undampedFreq2) => {\n      const a = Math.exp(-undampedFreq2 * duration);\n      const b = (undampedFreq2 - velocity) * duration + 1;\n      return -safeMin + a * b;\n    };\n    derivative = (undampedFreq2) => {\n      const a = Math.exp(-undampedFreq2 * duration);\n      const b = (velocity - undampedFreq2) * (duration * duration);\n      return a * b;\n    };\n  }\n  const initialGuess = 5 / duration;\n  const undampedFreq = approximateRoot(envelope, derivative, initialGuess);\n  duration = secondsToMilliseconds(duration);\n  if (isNaN(undampedFreq)) {\n    return {\n      stiffness: 100,\n      damping: 10,\n      duration\n    };\n  } else {\n    const stiffness = Math.pow(undampedFreq, 2) * mass;\n    return {\n      stiffness,\n      damping: dampingRatio * 2 * Math.sqrt(mass * stiffness),\n      duration\n    };\n  }\n}\nvar rootIterations = 12;\nfunction approximateRoot(envelope, derivative, initialGuess) {\n  let result = initialGuess;\n  for (let i = 1; i < rootIterations; i++) {\n    result = result - envelope(result) / derivative(result);\n  }\n  return result;\n}\nfunction calcAngularFreq(undampedFreq, dampingRatio) {\n  return undampedFreq * Math.sqrt(1 - dampingRatio * dampingRatio);\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/animation/generators/spring/index.mjs\nvar durationKeys = [\"duration\", \"bounce\"];\nvar physicsKeys = [\"stiffness\", \"damping\", \"mass\"];\nfunction isSpringType(options, keys2) {\n  return keys2.some((key) => options[key] !== void 0);\n}\nfunction getSpringOptions(options) {\n  let springOptions = {\n    velocity: 0,\n    stiffness: 100,\n    damping: 10,\n    mass: 1,\n    isResolvedFromDuration: false,\n    ...options\n  };\n  if (!isSpringType(options, physicsKeys) && isSpringType(options, durationKeys)) {\n    const derived = findSpring(options);\n    springOptions = {\n      ...springOptions,\n      ...derived,\n      mass: 1\n    };\n    springOptions.isResolvedFromDuration = true;\n  }\n  return springOptions;\n}\nfunction spring({ keyframes: keyframes2, restDelta, restSpeed, ...options }) {\n  const origin = keyframes2[0];\n  const target = keyframes2[keyframes2.length - 1];\n  const state = { done: false, value: origin };\n  const { stiffness, damping, mass, duration, velocity, isResolvedFromDuration } = getSpringOptions({\n    ...options,\n    velocity: -millisecondsToSeconds(options.velocity || 0)\n  });\n  const initialVelocity = velocity || 0;\n  const dampingRatio = damping / (2 * Math.sqrt(stiffness * mass));\n  const initialDelta = target - origin;\n  const undampedAngularFreq = millisecondsToSeconds(Math.sqrt(stiffness / mass));\n  const isGranularScale = Math.abs(initialDelta) < 5;\n  restSpeed || (restSpeed = isGranularScale ? 0.01 : 2);\n  restDelta || (restDelta = isGranularScale ? 5e-3 : 0.5);\n  let resolveSpring;\n  if (dampingRatio < 1) {\n    const angularFreq = calcAngularFreq(undampedAngularFreq, dampingRatio);\n    resolveSpring = (t) => {\n      const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\n      return target - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) / angularFreq * Math.sin(angularFreq * t) + initialDelta * Math.cos(angularFreq * t));\n    };\n  } else if (dampingRatio === 1) {\n    resolveSpring = (t) => target - Math.exp(-undampedAngularFreq * t) * (initialDelta + (initialVelocity + undampedAngularFreq * initialDelta) * t);\n  } else {\n    const dampedAngularFreq = undampedAngularFreq * Math.sqrt(dampingRatio * dampingRatio - 1);\n    resolveSpring = (t) => {\n      const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\n      const freqForT = Math.min(dampedAngularFreq * t, 300);\n      return target - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) * Math.sinh(freqForT) + dampedAngularFreq * initialDelta * Math.cosh(freqForT)) / dampedAngularFreq;\n    };\n  }\n  return {\n    calculatedDuration: isResolvedFromDuration ? duration || null : null,\n    next: (t) => {\n      const current = resolveSpring(t);\n      if (!isResolvedFromDuration) {\n        let currentVelocity = initialVelocity;\n        if (t !== 0) {\n          if (dampingRatio < 1) {\n            currentVelocity = calcGeneratorVelocity(resolveSpring, t, current);\n          } else {\n            currentVelocity = 0;\n          }\n        }\n        const isBelowVelocityThreshold = Math.abs(currentVelocity) <= restSpeed;\n        const isBelowDisplacementThreshold = Math.abs(target - current) <= restDelta;\n        state.done = isBelowVelocityThreshold && isBelowDisplacementThreshold;\n      } else {\n        state.done = t >= duration;\n      }\n      state.value = state.done ? target : current;\n      return state;\n    }\n  };\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/animation/generators/inertia.mjs\nfunction inertia({ keyframes: keyframes2, velocity = 0, power = 0.8, timeConstant = 325, bounceDamping = 10, bounceStiffness = 500, modifyTarget, min, max, restDelta = 0.5, restSpeed }) {\n  const origin = keyframes2[0];\n  const state = {\n    done: false,\n    value: origin\n  };\n  const isOutOfBounds = (v) => min !== void 0 && v < min || max !== void 0 && v > max;\n  const nearestBoundary = (v) => {\n    if (min === void 0)\n      return max;\n    if (max === void 0)\n      return min;\n    return Math.abs(min - v) < Math.abs(max - v) ? min : max;\n  };\n  let amplitude = power * velocity;\n  const ideal = origin + amplitude;\n  const target = modifyTarget === void 0 ? ideal : modifyTarget(ideal);\n  if (target !== ideal)\n    amplitude = target - origin;\n  const calcDelta = (t) => -amplitude * Math.exp(-t / timeConstant);\n  const calcLatest = (t) => target + calcDelta(t);\n  const applyFriction = (t) => {\n    const delta = calcDelta(t);\n    const latest = calcLatest(t);\n    state.done = Math.abs(delta) <= restDelta;\n    state.value = state.done ? target : latest;\n  };\n  let timeReachedBoundary;\n  let spring$1;\n  const checkCatchBoundary = (t) => {\n    if (!isOutOfBounds(state.value))\n      return;\n    timeReachedBoundary = t;\n    spring$1 = spring({\n      keyframes: [state.value, nearestBoundary(state.value)],\n      velocity: calcGeneratorVelocity(calcLatest, t, state.value),\n      damping: bounceDamping,\n      stiffness: bounceStiffness,\n      restDelta,\n      restSpeed\n    });\n  };\n  checkCatchBoundary(0);\n  return {\n    calculatedDuration: null,\n    next: (t) => {\n      let hasUpdatedFrame = false;\n      if (!spring$1 && timeReachedBoundary === void 0) {\n        hasUpdatedFrame = true;\n        applyFriction(t);\n        checkCatchBoundary(t);\n      }\n      if (timeReachedBoundary !== void 0 && t >= timeReachedBoundary) {\n        return spring$1.next(t - timeReachedBoundary);\n      } else {\n        !hasUpdatedFrame && applyFriction(t);\n        return state;\n      }\n    }\n  };\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/easing/cubic-bezier.mjs\nvar calcBezier = (t, a1, a2) => (((1 - 3 * a2 + 3 * a1) * t + (3 * a2 - 6 * a1)) * t + 3 * a1) * t;\nvar subdivisionPrecision = 1e-7;\nvar subdivisionMaxIterations = 12;\nfunction binarySubdivide(x, lowerBound, upperBound, mX1, mX2) {\n  let currentX;\n  let currentT;\n  let i = 0;\n  do {\n    currentT = lowerBound + (upperBound - lowerBound) / 2;\n    currentX = calcBezier(currentT, mX1, mX2) - x;\n    if (currentX > 0) {\n      upperBound = currentT;\n    } else {\n      lowerBound = currentT;\n    }\n  } while (Math.abs(currentX) > subdivisionPrecision && ++i < subdivisionMaxIterations);\n  return currentT;\n}\nfunction cubicBezier(mX1, mY1, mX2, mY2) {\n  if (mX1 === mY1 && mX2 === mY2)\n    return noop;\n  const getTForX = (aX) => binarySubdivide(aX, 0, 1, mX1, mX2);\n  return (t) => t === 0 || t === 1 ? t : calcBezier(getTForX(t), mY1, mY2);\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/easing/ease.mjs\nvar easeIn = cubicBezier(0.42, 0, 1, 1);\nvar easeOut = cubicBezier(0, 0, 0.58, 1);\nvar easeInOut = cubicBezier(0.42, 0, 0.58, 1);\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/easing/utils/is-easing-array.mjs\nvar isEasingArray = (ease2) => {\n  return Array.isArray(ease2) && typeof ease2[0] !== \"number\";\n};\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/easing/modifiers/mirror.mjs\nvar mirrorEasing = (easing) => (p) => p <= 0.5 ? easing(2 * p) / 2 : (2 - easing(2 * (1 - p))) / 2;\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/easing/modifiers/reverse.mjs\nvar reverseEasing = (easing) => (p) => 1 - easing(1 - p);\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/easing/circ.mjs\nvar circIn = (p) => 1 - Math.sin(Math.acos(p));\nvar circOut = reverseEasing(circIn);\nvar circInOut = mirrorEasing(circIn);\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/easing/back.mjs\nvar backOut = cubicBezier(0.33, 1.53, 0.69, 0.99);\nvar backIn = reverseEasing(backOut);\nvar backInOut = mirrorEasing(backIn);\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/easing/anticipate.mjs\nvar anticipate = (p) => (p *= 2) < 1 ? 0.5 * backIn(p) : 0.5 * (2 - Math.pow(2, -10 * (p - 1)));\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/easing/utils/map.mjs\nvar easingLookup = {\n  linear: noop,\n  easeIn,\n  easeInOut,\n  easeOut,\n  circIn,\n  circInOut,\n  circOut,\n  backIn,\n  backInOut,\n  backOut,\n  anticipate\n};\nvar easingDefinitionToFunction = (definition) => {\n  if (Array.isArray(definition)) {\n    invariant(definition.length === 4, `Cubic bezier arrays must contain four numerical values.`);\n    const [x1, y1, x2, y2] = definition;\n    return cubicBezier(x1, y1, x2, y2);\n  } else if (typeof definition === \"string\") {\n    invariant(easingLookup[definition] !== void 0, `Invalid easing type '${definition}'`);\n    return easingLookup[definition];\n  }\n  return definition;\n};\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/utils/progress.mjs\nvar progress = (from, to, value) => {\n  const toFromDifference = to - from;\n  return toFromDifference === 0 ? 1 : (value - from) / toFromDifference;\n};\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/utils/mix/number.mjs\nvar mixNumber = (from, to, progress2) => {\n  return from + (to - from) * progress2;\n};\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/utils/hsla-to-rgba.mjs\nfunction hueToRgb(p, q, t) {\n  if (t < 0)\n    t += 1;\n  if (t > 1)\n    t -= 1;\n  if (t < 1 / 6)\n    return p + (q - p) * 6 * t;\n  if (t < 1 / 2)\n    return q;\n  if (t < 2 / 3)\n    return p + (q - p) * (2 / 3 - t) * 6;\n  return p;\n}\nfunction hslaToRgba({ hue, saturation, lightness, alpha: alpha2 }) {\n  hue /= 360;\n  saturation /= 100;\n  lightness /= 100;\n  let red = 0;\n  let green = 0;\n  let blue = 0;\n  if (!saturation) {\n    red = green = blue = lightness;\n  } else {\n    const q = lightness < 0.5 ? lightness * (1 + saturation) : lightness + saturation - lightness * saturation;\n    const p = 2 * lightness - q;\n    red = hueToRgb(p, q, hue + 1 / 3);\n    green = hueToRgb(p, q, hue);\n    blue = hueToRgb(p, q, hue - 1 / 3);\n  }\n  return {\n    red: Math.round(red * 255),\n    green: Math.round(green * 255),\n    blue: Math.round(blue * 255),\n    alpha: alpha2\n  };\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/utils/mix/color.mjs\nvar mixLinearColor = (from, to, v) => {\n  const fromExpo = from * from;\n  const expo = v * (to * to - fromExpo) + fromExpo;\n  return expo < 0 ? 0 : Math.sqrt(expo);\n};\nvar colorTypes = [hex, rgba, hsla];\nvar getColorType = (v) => colorTypes.find((type) => type.test(v));\nfunction asRGBA(color2) {\n  const type = getColorType(color2);\n  invariant(Boolean(type), `'${color2}' is not an animatable color. Use the equivalent color code instead.`);\n  let model = type.parse(color2);\n  if (type === hsla) {\n    model = hslaToRgba(model);\n  }\n  return model;\n}\nvar mixColor = (from, to) => {\n  const fromRGBA = asRGBA(from);\n  const toRGBA = asRGBA(to);\n  const blended = { ...fromRGBA };\n  return (v) => {\n    blended.red = mixLinearColor(fromRGBA.red, toRGBA.red, v);\n    blended.green = mixLinearColor(fromRGBA.green, toRGBA.green, v);\n    blended.blue = mixLinearColor(fromRGBA.blue, toRGBA.blue, v);\n    blended.alpha = mixNumber(fromRGBA.alpha, toRGBA.alpha, v);\n    return rgba.transform(blended);\n  };\n};\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/utils/mix/complex.mjs\nfunction mixImmediate(a, b) {\n  return (p) => p > 0 ? b : a;\n}\nfunction mixNumber2(a, b) {\n  return (p) => mixNumber(a, b, p);\n}\nfunction getMixer(a) {\n  if (typeof a === \"number\") {\n    return mixNumber2;\n  } else if (typeof a === \"string\") {\n    return isCSSVariableToken(a) ? mixImmediate : color.test(a) ? mixColor : mixComplex;\n  } else if (Array.isArray(a)) {\n    return mixArray;\n  } else if (typeof a === \"object\") {\n    return color.test(a) ? mixColor : mixObject;\n  }\n  return mixImmediate;\n}\nfunction mixArray(a, b) {\n  const output = [...a];\n  const numValues = output.length;\n  const blendValue = a.map((v, i) => getMixer(v)(v, b[i]));\n  return (p) => {\n    for (let i = 0; i < numValues; i++) {\n      output[i] = blendValue[i](p);\n    }\n    return output;\n  };\n}\nfunction mixObject(a, b) {\n  const output = { ...a, ...b };\n  const blendValue = {};\n  for (const key in output) {\n    if (a[key] !== void 0 && b[key] !== void 0) {\n      blendValue[key] = getMixer(a[key])(a[key], b[key]);\n    }\n  }\n  return (v) => {\n    for (const key in blendValue) {\n      output[key] = blendValue[key](v);\n    }\n    return output;\n  };\n}\nfunction matchOrder(origin, target) {\n  var _a;\n  const orderedOrigin = [];\n  const pointers = { color: 0, var: 0, number: 0 };\n  for (let i = 0; i < target.values.length; i++) {\n    const type = target.types[i];\n    const originIndex = origin.indexes[type][pointers[type]];\n    const originValue = (_a = origin.values[originIndex]) !== null && _a !== void 0 ? _a : 0;\n    orderedOrigin[i] = originValue;\n    pointers[type]++;\n  }\n  return orderedOrigin;\n}\nvar mixComplex = (origin, target) => {\n  const template = complex.createTransformer(target);\n  const originStats = analyseComplexValue(origin);\n  const targetStats = analyseComplexValue(target);\n  const canInterpolate = originStats.indexes.var.length === targetStats.indexes.var.length && originStats.indexes.color.length === targetStats.indexes.color.length && originStats.indexes.number.length >= targetStats.indexes.number.length;\n  if (canInterpolate) {\n    return pipe(mixArray(matchOrder(originStats, targetStats), targetStats.values), template);\n  } else {\n    warning(true, `Complex values '${origin}' and '${target}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`);\n    return mixImmediate(origin, target);\n  }\n};\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/utils/mix/index.mjs\nfunction mix(from, to, p) {\n  if (typeof from === \"number\" && typeof to === \"number\" && typeof p === \"number\") {\n    return mixNumber(from, to, p);\n  }\n  const mixer = getMixer(from);\n  return mixer(from, to);\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/utils/interpolate.mjs\nfunction createMixers(output, ease2, customMixer) {\n  const mixers = [];\n  const mixerFactory = customMixer || mix;\n  const numMixers = output.length - 1;\n  for (let i = 0; i < numMixers; i++) {\n    let mixer = mixerFactory(output[i], output[i + 1]);\n    if (ease2) {\n      const easingFunction = Array.isArray(ease2) ? ease2[i] || noop : ease2;\n      mixer = pipe(easingFunction, mixer);\n    }\n    mixers.push(mixer);\n  }\n  return mixers;\n}\nfunction interpolate(input, output, { clamp: isClamp = true, ease: ease2, mixer } = {}) {\n  const inputLength = input.length;\n  invariant(inputLength === output.length, \"Both input and output ranges must be the same length\");\n  if (inputLength === 1)\n    return () => output[0];\n  if (inputLength === 2 && input[0] === input[1])\n    return () => output[1];\n  if (input[0] > input[inputLength - 1]) {\n    input = [...input].reverse();\n    output = [...output].reverse();\n  }\n  const mixers = createMixers(output, ease2, mixer);\n  const numMixers = mixers.length;\n  const interpolator = (v) => {\n    let i = 0;\n    if (numMixers > 1) {\n      for (; i < input.length - 2; i++) {\n        if (v < input[i + 1])\n          break;\n      }\n    }\n    const progressInRange = progress(input[i], input[i + 1], v);\n    return mixers[i](progressInRange);\n  };\n  return isClamp ? (v) => interpolator(clamp(input[0], input[inputLength - 1], v)) : interpolator;\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/utils/offsets/fill.mjs\nfunction fillOffset(offset, remaining) {\n  const min = offset[offset.length - 1];\n  for (let i = 1; i <= remaining; i++) {\n    const offsetProgress = progress(0, remaining, i);\n    offset.push(mixNumber(min, 1, offsetProgress));\n  }\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/utils/offsets/default.mjs\nfunction defaultOffset(arr) {\n  const offset = [0];\n  fillOffset(offset, arr.length - 1);\n  return offset;\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/utils/offsets/time.mjs\nfunction convertOffsetToTimes(offset, duration) {\n  return offset.map((o) => o * duration);\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/animation/generators/keyframes.mjs\nfunction defaultEasing(values, easing) {\n  return values.map(() => easing || easeInOut).splice(0, values.length - 1);\n}\nfunction keyframes({ duration = 300, keyframes: keyframeValues, times, ease: ease2 = \"easeInOut\" }) {\n  const easingFunctions = isEasingArray(ease2) ? ease2.map(easingDefinitionToFunction) : easingDefinitionToFunction(ease2);\n  const state = {\n    done: false,\n    value: keyframeValues[0]\n  };\n  const absoluteTimes = convertOffsetToTimes(\n    // Only use the provided offsets if they're the correct length\n    // TODO Maybe we should warn here if there's a length mismatch\n    times && times.length === keyframeValues.length ? times : defaultOffset(keyframeValues),\n    duration\n  );\n  const mapTimeToKeyframe = interpolate(absoluteTimes, keyframeValues, {\n    ease: Array.isArray(easingFunctions) ? easingFunctions : defaultEasing(keyframeValues, easingFunctions)\n  });\n  return {\n    calculatedDuration: duration,\n    next: (t) => {\n      state.value = mapTimeToKeyframe(t);\n      state.done = t >= duration;\n      return state;\n    }\n  };\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/animation/generators/utils/calc-duration.mjs\nvar maxGeneratorDuration = 2e4;\nfunction calcGeneratorDuration(generator) {\n  let duration = 0;\n  const timeStep = 50;\n  let state = generator.next(duration);\n  while (!state.done && duration < maxGeneratorDuration) {\n    duration += timeStep;\n    state = generator.next(duration);\n  }\n  return duration >= maxGeneratorDuration ? Infinity : duration;\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/animation/animators/drivers/driver-frameloop.mjs\nvar frameloopDriver = (update) => {\n  const passTimestamp = ({ timestamp }) => update(timestamp);\n  return {\n    start: () => frame.update(passTimestamp, true),\n    stop: () => cancelFrame(passTimestamp),\n    /**\n     * If we're processing this frame we can use the\n     * framelocked timestamp to keep things in sync.\n     */\n    now: () => frameData.isProcessing ? frameData.timestamp : time.now()\n  };\n};\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/animation/animators/MainThreadAnimation.mjs\nvar generators = {\n  decay: inertia,\n  inertia,\n  tween: keyframes,\n  keyframes,\n  spring\n};\nvar percentToProgress = (percent2) => percent2 / 100;\nvar MainThreadAnimation = class extends BaseAnimation {\n  constructor({ KeyframeResolver: KeyframeResolver$1 = KeyframeResolver, ...options }) {\n    super(options);\n    this.holdTime = null;\n    this.startTime = null;\n    this.cancelTime = null;\n    this.currentTime = 0;\n    this.playbackSpeed = 1;\n    this.pendingPlayState = \"running\";\n    this.state = \"idle\";\n    const { name, motionValue: motionValue2, keyframes: keyframes2 } = this.options;\n    const onResolved = (resolvedKeyframes, finalKeyframe) => this.onKeyframesResolved(resolvedKeyframes, finalKeyframe);\n    if (name && motionValue2 && motionValue2.owner) {\n      this.resolver = motionValue2.owner.resolveKeyframes(keyframes2, onResolved, name, motionValue2);\n    } else {\n      this.resolver = new KeyframeResolver$1(keyframes2, onResolved, name, motionValue2);\n    }\n    this.resolver.scheduleResolve();\n  }\n  initPlayback(keyframes$1) {\n    const { type = \"keyframes\", repeat = 0, repeatDelay = 0, repeatType, velocity = 0 } = this.options;\n    const generatorFactory = generators[type] || keyframes;\n    let mapPercentToKeyframes;\n    let mirroredGenerator;\n    if (generatorFactory !== keyframes && typeof keyframes$1[0] !== \"number\") {\n      if (true) {\n        invariant(keyframes$1.length === 2, `Only two keyframes currently supported with spring and inertia animations. Trying to animate ${keyframes$1}`);\n      }\n      mapPercentToKeyframes = pipe(percentToProgress, mix(keyframes$1[0], keyframes$1[1]));\n      keyframes$1 = [0, 100];\n    }\n    const generator = generatorFactory({ ...this.options, keyframes: keyframes$1 });\n    if (repeatType === \"mirror\") {\n      mirroredGenerator = generatorFactory({\n        ...this.options,\n        keyframes: [...keyframes$1].reverse(),\n        velocity: -velocity\n      });\n    }\n    if (generator.calculatedDuration === null) {\n      generator.calculatedDuration = calcGeneratorDuration(generator);\n    }\n    const { calculatedDuration } = generator;\n    const resolvedDuration = calculatedDuration + repeatDelay;\n    const totalDuration = resolvedDuration * (repeat + 1) - repeatDelay;\n    return {\n      generator,\n      mirroredGenerator,\n      mapPercentToKeyframes,\n      calculatedDuration,\n      resolvedDuration,\n      totalDuration\n    };\n  }\n  onPostResolved() {\n    const { autoplay = true } = this.options;\n    this.play();\n    if (this.pendingPlayState === \"paused\" || !autoplay) {\n      this.pause();\n    } else {\n      this.state = this.pendingPlayState;\n    }\n  }\n  tick(timestamp, sample = false) {\n    const { resolved } = this;\n    if (!resolved) {\n      const { keyframes: keyframes3 } = this.options;\n      return { done: true, value: keyframes3[keyframes3.length - 1] };\n    }\n    const { finalKeyframe, generator, mirroredGenerator, mapPercentToKeyframes, keyframes: keyframes2, calculatedDuration, totalDuration, resolvedDuration } = resolved;\n    if (this.startTime === null)\n      return generator.next(0);\n    const { delay: delay2, repeat, repeatType, repeatDelay, onUpdate } = this.options;\n    if (this.speed > 0) {\n      this.startTime = Math.min(this.startTime, timestamp);\n    } else if (this.speed < 0) {\n      this.startTime = Math.min(timestamp - totalDuration / this.speed, this.startTime);\n    }\n    if (sample) {\n      this.currentTime = timestamp;\n    } else if (this.holdTime !== null) {\n      this.currentTime = this.holdTime;\n    } else {\n      this.currentTime = Math.round(timestamp - this.startTime) * this.speed;\n    }\n    const timeWithoutDelay = this.currentTime - delay2 * (this.speed >= 0 ? 1 : -1);\n    const isInDelayPhase = this.speed >= 0 ? timeWithoutDelay < 0 : timeWithoutDelay > totalDuration;\n    this.currentTime = Math.max(timeWithoutDelay, 0);\n    if (this.state === \"finished\" && this.holdTime === null) {\n      this.currentTime = totalDuration;\n    }\n    let elapsed = this.currentTime;\n    let frameGenerator = generator;\n    if (repeat) {\n      const progress2 = Math.min(this.currentTime, totalDuration) / resolvedDuration;\n      let currentIteration = Math.floor(progress2);\n      let iterationProgress = progress2 % 1;\n      if (!iterationProgress && progress2 >= 1) {\n        iterationProgress = 1;\n      }\n      iterationProgress === 1 && currentIteration--;\n      currentIteration = Math.min(currentIteration, repeat + 1);\n      const isOddIteration = Boolean(currentIteration % 2);\n      if (isOddIteration) {\n        if (repeatType === \"reverse\") {\n          iterationProgress = 1 - iterationProgress;\n          if (repeatDelay) {\n            iterationProgress -= repeatDelay / resolvedDuration;\n          }\n        } else if (repeatType === \"mirror\") {\n          frameGenerator = mirroredGenerator;\n        }\n      }\n      elapsed = clamp(0, 1, iterationProgress) * resolvedDuration;\n    }\n    const state = isInDelayPhase ? { done: false, value: keyframes2[0] } : frameGenerator.next(elapsed);\n    if (mapPercentToKeyframes) {\n      state.value = mapPercentToKeyframes(state.value);\n    }\n    let { done } = state;\n    if (!isInDelayPhase && calculatedDuration !== null) {\n      done = this.speed >= 0 ? this.currentTime >= totalDuration : this.currentTime <= 0;\n    }\n    const isAnimationFinished = this.holdTime === null && (this.state === \"finished\" || this.state === \"running\" && done);\n    if (isAnimationFinished && finalKeyframe !== void 0) {\n      state.value = getFinalKeyframe(keyframes2, this.options, finalKeyframe);\n    }\n    if (onUpdate) {\n      onUpdate(state.value);\n    }\n    if (isAnimationFinished) {\n      this.finish();\n    }\n    return state;\n  }\n  get duration() {\n    const { resolved } = this;\n    return resolved ? millisecondsToSeconds(resolved.calculatedDuration) : 0;\n  }\n  get time() {\n    return millisecondsToSeconds(this.currentTime);\n  }\n  set time(newTime) {\n    newTime = secondsToMilliseconds(newTime);\n    this.currentTime = newTime;\n    if (this.holdTime !== null || this.speed === 0) {\n      this.holdTime = newTime;\n    } else if (this.driver) {\n      this.startTime = this.driver.now() - newTime / this.speed;\n    }\n  }\n  get speed() {\n    return this.playbackSpeed;\n  }\n  set speed(newSpeed) {\n    const hasChanged = this.playbackSpeed !== newSpeed;\n    this.playbackSpeed = newSpeed;\n    if (hasChanged) {\n      this.time = millisecondsToSeconds(this.currentTime);\n    }\n  }\n  play() {\n    if (!this.resolver.isScheduled) {\n      this.resolver.resume();\n    }\n    if (!this._resolved) {\n      this.pendingPlayState = \"running\";\n      return;\n    }\n    if (this.isStopped)\n      return;\n    const { driver = frameloopDriver, onPlay } = this.options;\n    if (!this.driver) {\n      this.driver = driver((timestamp) => this.tick(timestamp));\n    }\n    onPlay && onPlay();\n    const now2 = this.driver.now();\n    if (this.holdTime !== null) {\n      this.startTime = now2 - this.holdTime;\n    } else if (!this.startTime || this.state === \"finished\") {\n      this.startTime = now2;\n    }\n    if (this.state === \"finished\") {\n      this.updateFinishedPromise();\n    }\n    this.cancelTime = this.startTime;\n    this.holdTime = null;\n    this.state = \"running\";\n    this.driver.start();\n  }\n  pause() {\n    var _a;\n    if (!this._resolved) {\n      this.pendingPlayState = \"paused\";\n      return;\n    }\n    this.state = \"paused\";\n    this.holdTime = (_a = this.currentTime) !== null && _a !== void 0 ? _a : 0;\n  }\n  stop() {\n    this.resolver.cancel();\n    this.isStopped = true;\n    if (this.state === \"idle\")\n      return;\n    this.teardown();\n    const { onStop } = this.options;\n    onStop && onStop();\n  }\n  complete() {\n    if (this.state !== \"running\") {\n      this.play();\n    }\n    this.pendingPlayState = this.state = \"finished\";\n    this.holdTime = null;\n  }\n  finish() {\n    this.teardown();\n    this.state = \"finished\";\n    const { onComplete } = this.options;\n    onComplete && onComplete();\n  }\n  cancel() {\n    if (this.cancelTime !== null) {\n      this.tick(this.cancelTime);\n    }\n    this.teardown();\n    this.updateFinishedPromise();\n  }\n  teardown() {\n    this.state = \"idle\";\n    this.stopDriver();\n    this.resolveFinishedPromise();\n    this.updateFinishedPromise();\n    this.startTime = this.cancelTime = null;\n    this.resolver.cancel();\n  }\n  stopDriver() {\n    if (!this.driver)\n      return;\n    this.driver.stop();\n    this.driver = void 0;\n  }\n  sample(time2) {\n    this.startTime = 0;\n    return this.tick(time2, true);\n  }\n};\nfunction animateValue(options) {\n  return new MainThreadAnimation(options);\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/easing/utils/is-bezier-definition.mjs\nvar isBezierDefinition = (easing) => Array.isArray(easing) && typeof easing[0] === \"number\";\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/animation/animators/waapi/easing.mjs\nfunction isWaapiSupportedEasing(easing) {\n  return Boolean(!easing || typeof easing === \"string\" && supportedWaapiEasing[easing] || isBezierDefinition(easing) || Array.isArray(easing) && easing.every(isWaapiSupportedEasing));\n}\nvar cubicBezierAsString = ([a, b, c, d]) => `cubic-bezier(${a}, ${b}, ${c}, ${d})`;\nvar supportedWaapiEasing = {\n  linear: \"linear\",\n  ease: \"ease\",\n  easeIn: \"ease-in\",\n  easeOut: \"ease-out\",\n  easeInOut: \"ease-in-out\",\n  circIn: cubicBezierAsString([0, 0.65, 0.55, 1]),\n  circOut: cubicBezierAsString([0.55, 0, 1, 0.45]),\n  backIn: cubicBezierAsString([0.31, 0.01, 0.66, -0.59]),\n  backOut: cubicBezierAsString([0.33, 1.53, 0.69, 0.99])\n};\nfunction mapEasingToNativeEasing(easing) {\n  if (!easing)\n    return void 0;\n  return isBezierDefinition(easing) ? cubicBezierAsString(easing) : Array.isArray(easing) ? easing.map(mapEasingToNativeEasing) : supportedWaapiEasing[easing];\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/animation/animators/waapi/index.mjs\nfunction animateStyle(element, valueName, keyframes2, { delay: delay2 = 0, duration = 300, repeat = 0, repeatType = \"loop\", ease: ease2, times } = {}) {\n  const keyframeOptions = { [valueName]: keyframes2 };\n  if (times)\n    keyframeOptions.offset = times;\n  const easing = mapEasingToNativeEasing(ease2);\n  if (Array.isArray(easing))\n    keyframeOptions.easing = easing;\n  return element.animate(keyframeOptions, {\n    delay: delay2,\n    duration,\n    easing: !Array.isArray(easing) ? easing : \"linear\",\n    fill: \"both\",\n    iterations: repeat + 1,\n    direction: repeatType === \"reverse\" ? \"alternate\" : \"normal\"\n  });\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/animation/animators/AcceleratedAnimation.mjs\nvar supportsWaapi = memo(() => Object.hasOwnProperty.call(Element.prototype, \"animate\"));\nvar acceleratedValues = /* @__PURE__ */ new Set([\n  \"opacity\",\n  \"clipPath\",\n  \"filter\",\n  \"transform\"\n  // TODO: Can be accelerated but currently disabled until https://issues.chromium.org/issues/41491098 is resolved\n  // or until we implement support for linear() easing.\n  // \"background-color\"\n]);\nvar sampleDelta = 10;\nvar maxDuration2 = 2e4;\nfunction requiresPregeneratedKeyframes(options) {\n  return options.type === \"spring\" || options.name === \"backgroundColor\" || !isWaapiSupportedEasing(options.ease);\n}\nfunction pregenerateKeyframes(keyframes2, options) {\n  const sampleAnimation = new MainThreadAnimation({\n    ...options,\n    keyframes: keyframes2,\n    repeat: 0,\n    delay: 0,\n    isGenerator: true\n  });\n  let state = { done: false, value: keyframes2[0] };\n  const pregeneratedKeyframes = [];\n  let t = 0;\n  while (!state.done && t < maxDuration2) {\n    state = sampleAnimation.sample(t);\n    pregeneratedKeyframes.push(state.value);\n    t += sampleDelta;\n  }\n  return {\n    times: void 0,\n    keyframes: pregeneratedKeyframes,\n    duration: t - sampleDelta,\n    ease: \"linear\"\n  };\n}\nvar AcceleratedAnimation = class extends BaseAnimation {\n  constructor(options) {\n    super(options);\n    const { name, motionValue: motionValue2, keyframes: keyframes2 } = this.options;\n    this.resolver = new DOMKeyframesResolver(keyframes2, (resolvedKeyframes, finalKeyframe) => this.onKeyframesResolved(resolvedKeyframes, finalKeyframe), name, motionValue2);\n    this.resolver.scheduleResolve();\n  }\n  initPlayback(keyframes2, finalKeyframe) {\n    var _a;\n    let { duration = 300, times, ease: ease2, type, motionValue: motionValue2, name } = this.options;\n    if (!((_a = motionValue2.owner) === null || _a === void 0 ? void 0 : _a.current)) {\n      return false;\n    }\n    if (requiresPregeneratedKeyframes(this.options)) {\n      const { onComplete, onUpdate, motionValue: motionValue3, ...options } = this.options;\n      const pregeneratedAnimation = pregenerateKeyframes(keyframes2, options);\n      keyframes2 = pregeneratedAnimation.keyframes;\n      if (keyframes2.length === 1) {\n        keyframes2[1] = keyframes2[0];\n      }\n      duration = pregeneratedAnimation.duration;\n      times = pregeneratedAnimation.times;\n      ease2 = pregeneratedAnimation.ease;\n      type = \"keyframes\";\n    }\n    const animation = animateStyle(motionValue2.owner.current, name, keyframes2, { ...this.options, duration, times, ease: ease2 });\n    animation.startTime = time.now();\n    if (this.pendingTimeline) {\n      animation.timeline = this.pendingTimeline;\n      this.pendingTimeline = void 0;\n    } else {\n      animation.onfinish = () => {\n        const { onComplete } = this.options;\n        motionValue2.set(getFinalKeyframe(keyframes2, this.options, finalKeyframe));\n        onComplete && onComplete();\n        this.cancel();\n        this.resolveFinishedPromise();\n      };\n    }\n    return {\n      animation,\n      duration,\n      times,\n      type,\n      ease: ease2,\n      keyframes: keyframes2\n    };\n  }\n  get duration() {\n    const { resolved } = this;\n    if (!resolved)\n      return 0;\n    const { duration } = resolved;\n    return millisecondsToSeconds(duration);\n  }\n  get time() {\n    const { resolved } = this;\n    if (!resolved)\n      return 0;\n    const { animation } = resolved;\n    return millisecondsToSeconds(animation.currentTime || 0);\n  }\n  set time(newTime) {\n    const { resolved } = this;\n    if (!resolved)\n      return;\n    const { animation } = resolved;\n    animation.currentTime = secondsToMilliseconds(newTime);\n  }\n  get speed() {\n    const { resolved } = this;\n    if (!resolved)\n      return 1;\n    const { animation } = resolved;\n    return animation.playbackRate;\n  }\n  set speed(newSpeed) {\n    const { resolved } = this;\n    if (!resolved)\n      return;\n    const { animation } = resolved;\n    animation.playbackRate = newSpeed;\n  }\n  get state() {\n    const { resolved } = this;\n    if (!resolved)\n      return \"idle\";\n    const { animation } = resolved;\n    return animation.playState;\n  }\n  /**\n   * Replace the default DocumentTimeline with another AnimationTimeline.\n   * Currently used for scroll animations.\n   */\n  attachTimeline(timeline) {\n    if (!this._resolved) {\n      this.pendingTimeline = timeline;\n    } else {\n      const { resolved } = this;\n      if (!resolved)\n        return noop;\n      const { animation } = resolved;\n      animation.timeline = timeline;\n      animation.onfinish = null;\n    }\n    return noop;\n  }\n  play() {\n    if (this.isStopped)\n      return;\n    const { resolved } = this;\n    if (!resolved)\n      return;\n    const { animation } = resolved;\n    if (animation.playState === \"finished\") {\n      this.updateFinishedPromise();\n    }\n    animation.play();\n  }\n  pause() {\n    const { resolved } = this;\n    if (!resolved)\n      return;\n    const { animation } = resolved;\n    animation.pause();\n  }\n  stop() {\n    this.resolver.cancel();\n    this.isStopped = true;\n    if (this.state === \"idle\")\n      return;\n    const { resolved } = this;\n    if (!resolved)\n      return;\n    const { animation, keyframes: keyframes2, duration, type, ease: ease2, times } = resolved;\n    if (animation.playState === \"idle\" || animation.playState === \"finished\") {\n      return;\n    }\n    if (this.time) {\n      const { motionValue: motionValue2, onUpdate, onComplete, ...options } = this.options;\n      const sampleAnimation = new MainThreadAnimation({\n        ...options,\n        keyframes: keyframes2,\n        duration,\n        type,\n        ease: ease2,\n        times,\n        isGenerator: true\n      });\n      const sampleTime = secondsToMilliseconds(this.time);\n      motionValue2.setWithVelocity(sampleAnimation.sample(sampleTime - sampleDelta).value, sampleAnimation.sample(sampleTime).value, sampleDelta);\n    }\n    this.cancel();\n  }\n  complete() {\n    const { resolved } = this;\n    if (!resolved)\n      return;\n    resolved.animation.finish();\n  }\n  cancel() {\n    const { resolved } = this;\n    if (!resolved)\n      return;\n    resolved.animation.cancel();\n  }\n  static supports(options) {\n    const { motionValue: motionValue2, name, repeatDelay, repeatType, damping, type } = options;\n    return supportsWaapi() && name && acceleratedValues.has(name) && motionValue2 && motionValue2.owner && motionValue2.owner.current instanceof HTMLElement && /**\n     * If we're outputting values to onUpdate then we can't use WAAPI as there's\n     * no way to read the value from WAAPI every frame.\n     */\n    !motionValue2.owner.getProps().onUpdate && !repeatDelay && repeatType !== \"mirror\" && damping !== 0 && type !== \"inertia\";\n  }\n};\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/animation/interfaces/motion-value.mjs\nvar animateMotionValue = (name, value, target, transition = {}, element, isHandoff) => (onComplete) => {\n  const valueTransition = getValueTransition(transition, name) || {};\n  const delay2 = valueTransition.delay || transition.delay || 0;\n  let { elapsed = 0 } = transition;\n  elapsed = elapsed - secondsToMilliseconds(delay2);\n  let options = {\n    keyframes: Array.isArray(target) ? target : [null, target],\n    ease: \"easeOut\",\n    velocity: value.getVelocity(),\n    ...valueTransition,\n    delay: -elapsed,\n    onUpdate: (v) => {\n      value.set(v);\n      valueTransition.onUpdate && valueTransition.onUpdate(v);\n    },\n    onComplete: () => {\n      onComplete();\n      valueTransition.onComplete && valueTransition.onComplete();\n    },\n    name,\n    motionValue: value,\n    element: isHandoff ? void 0 : element\n  };\n  if (!isTransitionDefined(valueTransition)) {\n    options = {\n      ...options,\n      ...getDefaultTransition(name, options)\n    };\n  }\n  if (options.duration) {\n    options.duration = secondsToMilliseconds(options.duration);\n  }\n  if (options.repeatDelay) {\n    options.repeatDelay = secondsToMilliseconds(options.repeatDelay);\n  }\n  if (options.from !== void 0) {\n    options.keyframes[0] = options.from;\n  }\n  let shouldSkip = false;\n  if (options.type === false) {\n    options.duration = 0;\n    if (options.delay === 0) {\n      shouldSkip = true;\n    }\n  }\n  if (instantAnimationState.current || MotionGlobalConfig.skipAnimations) {\n    shouldSkip = true;\n    options.duration = 0;\n    options.delay = 0;\n  }\n  if (shouldSkip && !isHandoff && value.get() !== void 0) {\n    const finalKeyframe = getFinalKeyframe(options.keyframes, valueTransition);\n    if (finalKeyframe !== void 0) {\n      frame.update(() => {\n        options.onUpdate(finalKeyframe);\n        options.onComplete();\n      });\n      return;\n    }\n  }\n  if (!isHandoff && AcceleratedAnimation.supports(options)) {\n    return new AcceleratedAnimation(options);\n  } else {\n    return new MainThreadAnimation(options);\n  }\n};\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/value/use-will-change/is.mjs\nfunction isWillChangeMotionValue(value) {\n  return Boolean(isMotionValue(value) && value.add);\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/utils/array.mjs\nfunction addUniqueItem(arr, item) {\n  if (arr.indexOf(item) === -1)\n    arr.push(item);\n}\nfunction removeItem(arr, item) {\n  const index = arr.indexOf(item);\n  if (index > -1)\n    arr.splice(index, 1);\n}\nfunction moveItem([...arr], fromIndex, toIndex) {\n  const startIndex = fromIndex < 0 ? arr.length + fromIndex : fromIndex;\n  if (startIndex >= 0 && startIndex < arr.length) {\n    const endIndex = toIndex < 0 ? arr.length + toIndex : toIndex;\n    const [item] = arr.splice(fromIndex, 1);\n    arr.splice(endIndex, 0, item);\n  }\n  return arr;\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/utils/subscription-manager.mjs\nvar SubscriptionManager = class {\n  constructor() {\n    this.subscriptions = [];\n  }\n  add(handler) {\n    addUniqueItem(this.subscriptions, handler);\n    return () => removeItem(this.subscriptions, handler);\n  }\n  notify(a, b, c) {\n    const numSubscriptions = this.subscriptions.length;\n    if (!numSubscriptions)\n      return;\n    if (numSubscriptions === 1) {\n      this.subscriptions[0](a, b, c);\n    } else {\n      for (let i = 0; i < numSubscriptions; i++) {\n        const handler = this.subscriptions[i];\n        handler && handler(a, b, c);\n      }\n    }\n  }\n  getSize() {\n    return this.subscriptions.length;\n  }\n  clear() {\n    this.subscriptions.length = 0;\n  }\n};\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/utils/warn-once.mjs\nvar warned = /* @__PURE__ */ new Set();\nfunction warnOnce(condition, message, element) {\n  if (condition || warned.has(message))\n    return;\n  console.warn(message);\n  if (element)\n    console.warn(element);\n  warned.add(message);\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/value/index.mjs\nvar MAX_VELOCITY_DELTA = 30;\nvar isFloat = (value) => {\n  return !isNaN(parseFloat(value));\n};\nvar collectMotionValues = {\n  current: void 0\n};\nvar MotionValue = class {\n  /**\n   * @param init - The initiating value\n   * @param config - Optional configuration options\n   *\n   * -  `transformer`: A function to transform incoming values with.\n   *\n   * @internal\n   */\n  constructor(init, options = {}) {\n    this.version = \"11.0.24\";\n    this.canTrackVelocity = false;\n    this.events = {};\n    this.updateAndNotify = (v, render = true) => {\n      const currentTime = time.now();\n      if (this.updatedAt !== currentTime) {\n        this.setPrevFrameValue();\n      }\n      this.prev = this.current;\n      this.setCurrent(v);\n      if (this.current !== this.prev && this.events.change) {\n        this.events.change.notify(this.current);\n      }\n      if (render && this.events.renderRequest) {\n        this.events.renderRequest.notify(this.current);\n      }\n    };\n    this.hasAnimated = false;\n    this.setCurrent(init);\n    this.canTrackVelocity = isFloat(this.current);\n    this.owner = options.owner;\n  }\n  setCurrent(current) {\n    this.current = current;\n    this.updatedAt = time.now();\n  }\n  setPrevFrameValue(prevFrameValue = this.current) {\n    this.prevFrameValue = prevFrameValue;\n    this.prevUpdatedAt = this.updatedAt;\n  }\n  /**\n   * Adds a function that will be notified when the `MotionValue` is updated.\n   *\n   * It returns a function that, when called, will cancel the subscription.\n   *\n   * When calling `onChange` inside a React component, it should be wrapped with the\n   * `useEffect` hook. As it returns an unsubscribe function, this should be returned\n   * from the `useEffect` function to ensure you don't add duplicate subscribers..\n   *\n   * ```jsx\n   * export const MyComponent = () => {\n   *   const x = useMotionValue(0)\n   *   const y = useMotionValue(0)\n   *   const opacity = useMotionValue(1)\n   *\n   *   useEffect(() => {\n   *     function updateOpacity() {\n   *       const maxXY = Math.max(x.get(), y.get())\n   *       const newOpacity = transform(maxXY, [0, 100], [1, 0])\n   *       opacity.set(newOpacity)\n   *     }\n   *\n   *     const unsubscribeX = x.on(\"change\", updateOpacity)\n   *     const unsubscribeY = y.on(\"change\", updateOpacity)\n   *\n   *     return () => {\n   *       unsubscribeX()\n   *       unsubscribeY()\n   *     }\n   *   }, [])\n   *\n   *   return <motion.div style={{ x }} />\n   * }\n   * ```\n   *\n   * @param subscriber - A function that receives the latest value.\n   * @returns A function that, when called, will cancel this subscription.\n   *\n   * @deprecated\n   */\n  onChange(subscription) {\n    if (true) {\n      warnOnce(false, `value.onChange(callback) is deprecated. Switch to value.on(\"change\", callback).`);\n    }\n    return this.on(\"change\", subscription);\n  }\n  on(eventName, callback) {\n    if (!this.events[eventName]) {\n      this.events[eventName] = new SubscriptionManager();\n    }\n    const unsubscribe = this.events[eventName].add(callback);\n    if (eventName === \"change\") {\n      return () => {\n        unsubscribe();\n        frame.read(() => {\n          if (!this.events.change.getSize()) {\n            this.stop();\n          }\n        });\n      };\n    }\n    return unsubscribe;\n  }\n  clearListeners() {\n    for (const eventManagers in this.events) {\n      this.events[eventManagers].clear();\n    }\n  }\n  /**\n   * Attaches a passive effect to the `MotionValue`.\n   *\n   * @internal\n   */\n  attach(passiveEffect, stopPassiveEffect) {\n    this.passiveEffect = passiveEffect;\n    this.stopPassiveEffect = stopPassiveEffect;\n  }\n  /**\n   * Sets the state of the `MotionValue`.\n   *\n   * @remarks\n   *\n   * ```jsx\n   * const x = useMotionValue(0)\n   * x.set(10)\n   * ```\n   *\n   * @param latest - Latest value to set.\n   * @param render - Whether to notify render subscribers. Defaults to `true`\n   *\n   * @public\n   */\n  set(v, render = true) {\n    if (!render || !this.passiveEffect) {\n      this.updateAndNotify(v, render);\n    } else {\n      this.passiveEffect(v, this.updateAndNotify);\n    }\n  }\n  setWithVelocity(prev, current, delta) {\n    this.set(current);\n    this.prev = void 0;\n    this.prevFrameValue = prev;\n    this.prevUpdatedAt = this.updatedAt - delta;\n  }\n  /**\n   * Set the state of the `MotionValue`, stopping any active animations,\n   * effects, and resets velocity to `0`.\n   */\n  jump(v, endAnimation = true) {\n    this.updateAndNotify(v);\n    this.prev = v;\n    this.prevUpdatedAt = this.prevFrameValue = void 0;\n    endAnimation && this.stop();\n    if (this.stopPassiveEffect)\n      this.stopPassiveEffect();\n  }\n  /**\n   * Returns the latest state of `MotionValue`\n   *\n   * @returns - The latest state of `MotionValue`\n   *\n   * @public\n   */\n  get() {\n    if (collectMotionValues.current) {\n      collectMotionValues.current.push(this);\n    }\n    return this.current;\n  }\n  /**\n   * @public\n   */\n  getPrevious() {\n    return this.prev;\n  }\n  /**\n   * Returns the latest velocity of `MotionValue`\n   *\n   * @returns - The latest velocity of `MotionValue`. Returns `0` if the state is non-numerical.\n   *\n   * @public\n   */\n  getVelocity() {\n    const currentTime = time.now();\n    if (!this.canTrackVelocity || this.prevFrameValue === void 0 || currentTime - this.updatedAt > MAX_VELOCITY_DELTA) {\n      return 0;\n    }\n    const delta = Math.min(this.updatedAt - this.prevUpdatedAt, MAX_VELOCITY_DELTA);\n    return velocityPerSecond(parseFloat(this.current) - parseFloat(this.prevFrameValue), delta);\n  }\n  /**\n   * Registers a new animation to control this `MotionValue`. Only one\n   * animation can drive a `MotionValue` at one time.\n   *\n   * ```jsx\n   * value.start()\n   * ```\n   *\n   * @param animation - A function that starts the provided animation\n   *\n   * @internal\n   */\n  start(startAnimation) {\n    this.stop();\n    return new Promise((resolve) => {\n      this.hasAnimated = true;\n      this.animation = startAnimation(resolve);\n      if (this.events.animationStart) {\n        this.events.animationStart.notify();\n      }\n    }).then(() => {\n      if (this.events.animationComplete) {\n        this.events.animationComplete.notify();\n      }\n      this.clearAnimation();\n    });\n  }\n  /**\n   * Stop the currently active animation.\n   *\n   * @public\n   */\n  stop() {\n    if (this.animation) {\n      this.animation.stop();\n      if (this.events.animationCancel) {\n        this.events.animationCancel.notify();\n      }\n    }\n    this.clearAnimation();\n  }\n  /**\n   * Returns `true` if this value is currently animating.\n   *\n   * @public\n   */\n  isAnimating() {\n    return !!this.animation;\n  }\n  clearAnimation() {\n    delete this.animation;\n  }\n  /**\n   * Destroy and clean up subscribers to this `MotionValue`.\n   *\n   * The `MotionValue` hooks like `useMotionValue` and `useTransform` automatically\n   * handle the lifecycle of the returned `MotionValue`, so this method is only necessary if you've manually\n   * created a `MotionValue` via the `motionValue` function.\n   *\n   * @public\n   */\n  destroy() {\n    this.clearListeners();\n    this.stop();\n    if (this.stopPassiveEffect) {\n      this.stopPassiveEffect();\n    }\n  }\n};\nfunction motionValue(init, options) {\n  return new MotionValue(init, options);\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/utils/setters.mjs\nfunction setMotionValue(visualElement, key, value) {\n  if (visualElement.hasValue(key)) {\n    visualElement.getValue(key).set(value);\n  } else {\n    visualElement.addValue(key, motionValue(value));\n  }\n}\nfunction setTarget(visualElement, definition) {\n  const resolved = resolveVariant(visualElement, definition);\n  let { transitionEnd = {}, transition = {}, ...target } = resolved || {};\n  target = { ...target, ...transitionEnd };\n  for (const key in target) {\n    const value = resolveFinalValueInKeyframes(target[key]);\n    setMotionValue(visualElement, key, value);\n  }\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/animation/interfaces/visual-element-target.mjs\nfunction shouldBlockAnimation({ protectedKeys, needsAnimating }, key) {\n  const shouldBlock = protectedKeys.hasOwnProperty(key) && needsAnimating[key] !== true;\n  needsAnimating[key] = false;\n  return shouldBlock;\n}\nfunction animateTarget(visualElement, targetAndTransition, { delay: delay2 = 0, transitionOverride, type } = {}) {\n  var _a;\n  let { transition = visualElement.getDefaultTransition(), transitionEnd, ...target } = targetAndTransition;\n  const willChange = visualElement.getValue(\"willChange\");\n  if (transitionOverride)\n    transition = transitionOverride;\n  const animations2 = [];\n  const animationTypeState = type && visualElement.animationState && visualElement.animationState.getState()[type];\n  for (const key in target) {\n    const value = visualElement.getValue(key, (_a = visualElement.latestValues[key]) !== null && _a !== void 0 ? _a : null);\n    const valueTarget = target[key];\n    if (valueTarget === void 0 || animationTypeState && shouldBlockAnimation(animationTypeState, key)) {\n      continue;\n    }\n    const valueTransition = {\n      delay: delay2,\n      elapsed: 0,\n      ...getValueTransition(transition || {}, key)\n    };\n    let isHandoff = false;\n    if (window.HandoffAppearAnimations) {\n      const appearId = visualElement.getProps()[optimizedAppearDataAttribute];\n      if (appearId) {\n        const elapsed = window.HandoffAppearAnimations(appearId, key);\n        if (elapsed !== null) {\n          valueTransition.elapsed = elapsed;\n          isHandoff = true;\n        }\n      }\n    }\n    value.start(animateMotionValue(key, value, valueTarget, visualElement.shouldReduceMotion && transformProps.has(key) ? { type: false } : valueTransition, visualElement, isHandoff));\n    const animation = value.animation;\n    if (animation) {\n      if (isWillChangeMotionValue(willChange)) {\n        willChange.add(key);\n        animation.then(() => willChange.remove(key));\n      }\n      animations2.push(animation);\n    }\n  }\n  if (transitionEnd) {\n    Promise.all(animations2).then(() => {\n      frame.update(() => {\n        transitionEnd && setTarget(visualElement, transitionEnd);\n      });\n    });\n  }\n  return animations2;\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/animation/interfaces/visual-element-variant.mjs\nfunction animateVariant(visualElement, variant, options = {}) {\n  var _a;\n  const resolved = resolveVariant(visualElement, variant, options.type === \"exit\" ? (_a = visualElement.presenceContext) === null || _a === void 0 ? void 0 : _a.custom : void 0);\n  let { transition = visualElement.getDefaultTransition() || {} } = resolved || {};\n  if (options.transitionOverride) {\n    transition = options.transitionOverride;\n  }\n  const getAnimation = resolved ? () => Promise.all(animateTarget(visualElement, resolved, options)) : () => Promise.resolve();\n  const getChildAnimations = visualElement.variantChildren && visualElement.variantChildren.size ? (forwardDelay = 0) => {\n    const { delayChildren = 0, staggerChildren, staggerDirection } = transition;\n    return animateChildren(visualElement, variant, delayChildren + forwardDelay, staggerChildren, staggerDirection, options);\n  } : () => Promise.resolve();\n  const { when } = transition;\n  if (when) {\n    const [first, last] = when === \"beforeChildren\" ? [getAnimation, getChildAnimations] : [getChildAnimations, getAnimation];\n    return first().then(() => last());\n  } else {\n    return Promise.all([getAnimation(), getChildAnimations(options.delay)]);\n  }\n}\nfunction animateChildren(visualElement, variant, delayChildren = 0, staggerChildren = 0, staggerDirection = 1, options) {\n  const animations2 = [];\n  const maxStaggerDuration = (visualElement.variantChildren.size - 1) * staggerChildren;\n  const generateStaggerDuration = staggerDirection === 1 ? (i = 0) => i * staggerChildren : (i = 0) => maxStaggerDuration - i * staggerChildren;\n  Array.from(visualElement.variantChildren).sort(sortByTreeOrder).forEach((child, i) => {\n    child.notify(\"AnimationStart\", variant);\n    animations2.push(animateVariant(child, variant, {\n      ...options,\n      delay: delayChildren + generateStaggerDuration(i)\n    }).then(() => child.notify(\"AnimationComplete\", variant)));\n  });\n  return Promise.all(animations2);\n}\nfunction sortByTreeOrder(a, b) {\n  return a.sortNodePosition(b);\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/animation/interfaces/visual-element.mjs\nfunction animateVisualElement(visualElement, definition, options = {}) {\n  visualElement.notify(\"AnimationStart\", definition);\n  let animation;\n  if (Array.isArray(definition)) {\n    const animations2 = definition.map((variant) => animateVariant(visualElement, variant, options));\n    animation = Promise.all(animations2);\n  } else if (typeof definition === \"string\") {\n    animation = animateVariant(visualElement, definition, options);\n  } else {\n    const resolvedDefinition = typeof definition === \"function\" ? resolveVariant(visualElement, definition, options.custom) : definition;\n    animation = Promise.all(animateTarget(visualElement, resolvedDefinition, options));\n  }\n  return animation.then(() => {\n    frame.postRender(() => {\n      visualElement.notify(\"AnimationComplete\", definition);\n    });\n  });\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/utils/animation-state.mjs\nvar reversePriorityOrder = [...variantPriorityOrder].reverse();\nvar numAnimationTypes = variantPriorityOrder.length;\nfunction animateList(visualElement) {\n  return (animations2) => Promise.all(animations2.map(({ animation, options }) => animateVisualElement(visualElement, animation, options)));\n}\nfunction createAnimationState(visualElement) {\n  let animate2 = animateList(visualElement);\n  const state = createState();\n  let isInitialRender = true;\n  const buildResolvedTypeValues = (type) => (acc, definition) => {\n    var _a;\n    const resolved = resolveVariant(visualElement, definition, type === \"exit\" ? (_a = visualElement.presenceContext) === null || _a === void 0 ? void 0 : _a.custom : void 0);\n    if (resolved) {\n      const { transition, transitionEnd, ...target } = resolved;\n      acc = { ...acc, ...target, ...transitionEnd };\n    }\n    return acc;\n  };\n  function setAnimateFunction(makeAnimator) {\n    animate2 = makeAnimator(visualElement);\n  }\n  function animateChanges(changedActiveType) {\n    const props = visualElement.getProps();\n    const context = visualElement.getVariantContext(true) || {};\n    const animations2 = [];\n    const removedKeys = /* @__PURE__ */ new Set();\n    let encounteredKeys = {};\n    let removedVariantIndex = Infinity;\n    for (let i = 0; i < numAnimationTypes; i++) {\n      const type = reversePriorityOrder[i];\n      const typeState = state[type];\n      const prop = props[type] !== void 0 ? props[type] : context[type];\n      const propIsVariant = isVariantLabel(prop);\n      const activeDelta = type === changedActiveType ? typeState.isActive : null;\n      if (activeDelta === false)\n        removedVariantIndex = i;\n      let isInherited = prop === context[type] && prop !== props[type] && propIsVariant;\n      if (isInherited && isInitialRender && visualElement.manuallyAnimateOnMount) {\n        isInherited = false;\n      }\n      typeState.protectedKeys = { ...encounteredKeys };\n      if (\n        // If it isn't active and hasn't *just* been set as inactive\n        !typeState.isActive && activeDelta === null || // If we didn't and don't have any defined prop for this animation type\n        !prop && !typeState.prevProp || // Or if the prop doesn't define an animation\n        isAnimationControls(prop) || typeof prop === \"boolean\"\n      ) {\n        continue;\n      }\n      const variantDidChange = checkVariantsDidChange(typeState.prevProp, prop);\n      let shouldAnimateType = variantDidChange || // If we're making this variant active, we want to always make it active\n      type === changedActiveType && typeState.isActive && !isInherited && propIsVariant || // If we removed a higher-priority variant (i is in reverse order)\n      i > removedVariantIndex && propIsVariant;\n      let handledRemovedValues = false;\n      const definitionList = Array.isArray(prop) ? prop : [prop];\n      let resolvedValues = definitionList.reduce(buildResolvedTypeValues(type), {});\n      if (activeDelta === false)\n        resolvedValues = {};\n      const { prevResolvedValues = {} } = typeState;\n      const allKeys = {\n        ...prevResolvedValues,\n        ...resolvedValues\n      };\n      const markToAnimate = (key) => {\n        shouldAnimateType = true;\n        if (removedKeys.has(key)) {\n          handledRemovedValues = true;\n          removedKeys.delete(key);\n        }\n        typeState.needsAnimating[key] = true;\n        const motionValue2 = visualElement.getValue(key);\n        if (motionValue2)\n          motionValue2.liveStyle = false;\n      };\n      for (const key in allKeys) {\n        const next = resolvedValues[key];\n        const prev = prevResolvedValues[key];\n        if (encounteredKeys.hasOwnProperty(key))\n          continue;\n        let valueHasChanged = false;\n        if (isKeyframesTarget(next) && isKeyframesTarget(prev)) {\n          valueHasChanged = !shallowCompare(next, prev);\n        } else {\n          valueHasChanged = next !== prev;\n        }\n        if (valueHasChanged) {\n          if (next !== void 0 && next !== null) {\n            markToAnimate(key);\n          } else {\n            removedKeys.add(key);\n          }\n        } else if (next !== void 0 && removedKeys.has(key)) {\n          markToAnimate(key);\n        } else {\n          typeState.protectedKeys[key] = true;\n        }\n      }\n      typeState.prevProp = prop;\n      typeState.prevResolvedValues = resolvedValues;\n      if (typeState.isActive) {\n        encounteredKeys = { ...encounteredKeys, ...resolvedValues };\n      }\n      if (isInitialRender && visualElement.blockInitialAnimation) {\n        shouldAnimateType = false;\n      }\n      if (shouldAnimateType && (!isInherited || handledRemovedValues)) {\n        animations2.push(...definitionList.map((animation) => ({\n          animation,\n          options: { type }\n        })));\n      }\n    }\n    if (removedKeys.size) {\n      const fallbackAnimation = {};\n      removedKeys.forEach((key) => {\n        const fallbackTarget = visualElement.getBaseTarget(key);\n        const motionValue2 = visualElement.getValue(key);\n        if (motionValue2)\n          motionValue2.liveStyle = true;\n        fallbackAnimation[key] = fallbackTarget === void 0 ? null : fallbackTarget;\n      });\n      animations2.push({ animation: fallbackAnimation });\n    }\n    let shouldAnimate = Boolean(animations2.length);\n    if (isInitialRender && (props.initial === false || props.initial === props.animate) && !visualElement.manuallyAnimateOnMount) {\n      shouldAnimate = false;\n    }\n    isInitialRender = false;\n    return shouldAnimate ? animate2(animations2) : Promise.resolve();\n  }\n  function setActive(type, isActive) {\n    var _a;\n    if (state[type].isActive === isActive)\n      return Promise.resolve();\n    (_a = visualElement.variantChildren) === null || _a === void 0 ? void 0 : _a.forEach((child) => {\n      var _a2;\n      return (_a2 = child.animationState) === null || _a2 === void 0 ? void 0 : _a2.setActive(type, isActive);\n    });\n    state[type].isActive = isActive;\n    const animations2 = animateChanges(type);\n    for (const key in state) {\n      state[key].protectedKeys = {};\n    }\n    return animations2;\n  }\n  return {\n    animateChanges,\n    setActive,\n    setAnimateFunction,\n    getState: () => state\n  };\n}\nfunction checkVariantsDidChange(prev, next) {\n  if (typeof next === \"string\") {\n    return next !== prev;\n  } else if (Array.isArray(next)) {\n    return !shallowCompare(next, prev);\n  }\n  return false;\n}\nfunction createTypeState(isActive = false) {\n  return {\n    isActive,\n    protectedKeys: {},\n    needsAnimating: {},\n    prevResolvedValues: {}\n  };\n}\nfunction createState() {\n  return {\n    animate: createTypeState(true),\n    whileInView: createTypeState(),\n    whileHover: createTypeState(),\n    whileTap: createTypeState(),\n    whileDrag: createTypeState(),\n    whileFocus: createTypeState(),\n    exit: createTypeState()\n  };\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/motion/features/animation/index.mjs\nvar AnimationFeature = class extends Feature {\n  /**\n   * We dynamically generate the AnimationState manager as it contains a reference\n   * to the underlying animation library. We only want to load that if we load this,\n   * so people can optionally code split it out using the `m` component.\n   */\n  constructor(node) {\n    super(node);\n    node.animationState || (node.animationState = createAnimationState(node));\n  }\n  updateAnimationControlsSubscription() {\n    const { animate: animate2 } = this.node.getProps();\n    this.unmount();\n    if (isAnimationControls(animate2)) {\n      this.unmount = animate2.subscribe(this.node);\n    }\n  }\n  /**\n   * Subscribe any provided AnimationControls to the component's VisualElement\n   */\n  mount() {\n    this.updateAnimationControlsSubscription();\n  }\n  update() {\n    const { animate: animate2 } = this.node.getProps();\n    const { animate: prevAnimate } = this.node.prevProps || {};\n    if (animate2 !== prevAnimate) {\n      this.updateAnimationControlsSubscription();\n    }\n  }\n  unmount() {\n  }\n};\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/motion/features/animation/exit.mjs\nvar id = 0;\nvar ExitAnimationFeature = class extends Feature {\n  constructor() {\n    super(...arguments);\n    this.id = id++;\n  }\n  update() {\n    if (!this.node.presenceContext)\n      return;\n    const { isPresent: isPresent2, onExitComplete } = this.node.presenceContext;\n    const { isPresent: prevIsPresent } = this.node.prevPresenceContext || {};\n    if (!this.node.animationState || isPresent2 === prevIsPresent) {\n      return;\n    }\n    const exitAnimation = this.node.animationState.setActive(\"exit\", !isPresent2);\n    if (onExitComplete && !isPresent2) {\n      exitAnimation.then(() => onExitComplete(this.id));\n    }\n  }\n  mount() {\n    const { register } = this.node.presenceContext || {};\n    if (register) {\n      this.unmount = register(this.id);\n    }\n  }\n  unmount() {\n  }\n};\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/motion/features/animations.mjs\nvar animations = {\n  animation: {\n    Feature: AnimationFeature\n  },\n  exit: {\n    Feature: ExitAnimationFeature\n  }\n};\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/utils/distance.mjs\nvar distance = (a, b) => Math.abs(a - b);\nfunction distance2D(a, b) {\n  const xDelta = distance(a.x, b.x);\n  const yDelta = distance(a.y, b.y);\n  return Math.sqrt(xDelta ** 2 + yDelta ** 2);\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/gestures/pan/PanSession.mjs\nvar PanSession = class {\n  constructor(event, handlers, { transformPagePoint, contextWindow, dragSnapToOrigin = false } = {}) {\n    this.startEvent = null;\n    this.lastMoveEvent = null;\n    this.lastMoveEventInfo = null;\n    this.handlers = {};\n    this.contextWindow = window;\n    this.updatePoint = () => {\n      if (!(this.lastMoveEvent && this.lastMoveEventInfo))\n        return;\n      const info2 = getPanInfo(this.lastMoveEventInfo, this.history);\n      const isPanStarted = this.startEvent !== null;\n      const isDistancePastThreshold = distance2D(info2.offset, { x: 0, y: 0 }) >= 3;\n      if (!isPanStarted && !isDistancePastThreshold)\n        return;\n      const { point: point3 } = info2;\n      const { timestamp: timestamp2 } = frameData;\n      this.history.push({ ...point3, timestamp: timestamp2 });\n      const { onStart, onMove } = this.handlers;\n      if (!isPanStarted) {\n        onStart && onStart(this.lastMoveEvent, info2);\n        this.startEvent = this.lastMoveEvent;\n      }\n      onMove && onMove(this.lastMoveEvent, info2);\n    };\n    this.handlePointerMove = (event2, info2) => {\n      this.lastMoveEvent = event2;\n      this.lastMoveEventInfo = transformPoint(info2, this.transformPagePoint);\n      frame.update(this.updatePoint, true);\n    };\n    this.handlePointerUp = (event2, info2) => {\n      this.end();\n      const { onEnd, onSessionEnd, resumeAnimation } = this.handlers;\n      if (this.dragSnapToOrigin)\n        resumeAnimation && resumeAnimation();\n      if (!(this.lastMoveEvent && this.lastMoveEventInfo))\n        return;\n      const panInfo = getPanInfo(event2.type === \"pointercancel\" ? this.lastMoveEventInfo : transformPoint(info2, this.transformPagePoint), this.history);\n      if (this.startEvent && onEnd) {\n        onEnd(event2, panInfo);\n      }\n      onSessionEnd && onSessionEnd(event2, panInfo);\n    };\n    if (!isPrimaryPointer(event))\n      return;\n    this.dragSnapToOrigin = dragSnapToOrigin;\n    this.handlers = handlers;\n    this.transformPagePoint = transformPagePoint;\n    this.contextWindow = contextWindow || window;\n    const info = extractEventInfo(event);\n    const initialInfo = transformPoint(info, this.transformPagePoint);\n    const { point: point2 } = initialInfo;\n    const { timestamp } = frameData;\n    this.history = [{ ...point2, timestamp }];\n    const { onSessionStart } = handlers;\n    onSessionStart && onSessionStart(event, getPanInfo(initialInfo, this.history));\n    this.removeListeners = pipe(addPointerEvent(this.contextWindow, \"pointermove\", this.handlePointerMove), addPointerEvent(this.contextWindow, \"pointerup\", this.handlePointerUp), addPointerEvent(this.contextWindow, \"pointercancel\", this.handlePointerUp));\n  }\n  updateHandlers(handlers) {\n    this.handlers = handlers;\n  }\n  end() {\n    this.removeListeners && this.removeListeners();\n    cancelFrame(this.updatePoint);\n  }\n};\nfunction transformPoint(info, transformPagePoint) {\n  return transformPagePoint ? { point: transformPagePoint(info.point) } : info;\n}\nfunction subtractPoint(a, b) {\n  return { x: a.x - b.x, y: a.y - b.y };\n}\nfunction getPanInfo({ point: point2 }, history) {\n  return {\n    point: point2,\n    delta: subtractPoint(point2, lastDevicePoint(history)),\n    offset: subtractPoint(point2, startDevicePoint(history)),\n    velocity: getVelocity2(history, 0.1)\n  };\n}\nfunction startDevicePoint(history) {\n  return history[0];\n}\nfunction lastDevicePoint(history) {\n  return history[history.length - 1];\n}\nfunction getVelocity2(history, timeDelta) {\n  if (history.length < 2) {\n    return { x: 0, y: 0 };\n  }\n  let i = history.length - 1;\n  let timestampedPoint = null;\n  const lastPoint = lastDevicePoint(history);\n  while (i >= 0) {\n    timestampedPoint = history[i];\n    if (lastPoint.timestamp - timestampedPoint.timestamp > secondsToMilliseconds(timeDelta)) {\n      break;\n    }\n    i--;\n  }\n  if (!timestampedPoint) {\n    return { x: 0, y: 0 };\n  }\n  const time2 = millisecondsToSeconds(lastPoint.timestamp - timestampedPoint.timestamp);\n  if (time2 === 0) {\n    return { x: 0, y: 0 };\n  }\n  const currentVelocity = {\n    x: (lastPoint.x - timestampedPoint.x) / time2,\n    y: (lastPoint.y - timestampedPoint.y) / time2\n  };\n  if (currentVelocity.x === Infinity) {\n    currentVelocity.x = 0;\n  }\n  if (currentVelocity.y === Infinity) {\n    currentVelocity.y = 0;\n  }\n  return currentVelocity;\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/projection/geometry/delta-calc.mjs\nfunction calcLength(axis) {\n  return axis.max - axis.min;\n}\nfunction isNear(value, target = 0, maxDistance = 0.01) {\n  return Math.abs(value - target) <= maxDistance;\n}\nfunction calcAxisDelta(delta, source, target, origin = 0.5) {\n  delta.origin = origin;\n  delta.originPoint = mixNumber(source.min, source.max, delta.origin);\n  delta.scale = calcLength(target) / calcLength(source);\n  if (isNear(delta.scale, 1, 1e-4) || isNaN(delta.scale))\n    delta.scale = 1;\n  delta.translate = mixNumber(target.min, target.max, delta.origin) - delta.originPoint;\n  if (isNear(delta.translate) || isNaN(delta.translate))\n    delta.translate = 0;\n}\nfunction calcBoxDelta(delta, source, target, origin) {\n  calcAxisDelta(delta.x, source.x, target.x, origin ? origin.originX : void 0);\n  calcAxisDelta(delta.y, source.y, target.y, origin ? origin.originY : void 0);\n}\nfunction calcRelativeAxis(target, relative, parent) {\n  target.min = parent.min + relative.min;\n  target.max = target.min + calcLength(relative);\n}\nfunction calcRelativeBox(target, relative, parent) {\n  calcRelativeAxis(target.x, relative.x, parent.x);\n  calcRelativeAxis(target.y, relative.y, parent.y);\n}\nfunction calcRelativeAxisPosition(target, layout2, parent) {\n  target.min = layout2.min - parent.min;\n  target.max = target.min + calcLength(layout2);\n}\nfunction calcRelativePosition(target, layout2, parent) {\n  calcRelativeAxisPosition(target.x, layout2.x, parent.x);\n  calcRelativeAxisPosition(target.y, layout2.y, parent.y);\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/gestures/drag/utils/constraints.mjs\nfunction applyConstraints(point2, { min, max }, elastic) {\n  if (min !== void 0 && point2 < min) {\n    point2 = elastic ? mixNumber(min, point2, elastic.min) : Math.max(point2, min);\n  } else if (max !== void 0 && point2 > max) {\n    point2 = elastic ? mixNumber(max, point2, elastic.max) : Math.min(point2, max);\n  }\n  return point2;\n}\nfunction calcRelativeAxisConstraints(axis, min, max) {\n  return {\n    min: min !== void 0 ? axis.min + min : void 0,\n    max: max !== void 0 ? axis.max + max - (axis.max - axis.min) : void 0\n  };\n}\nfunction calcRelativeConstraints(layoutBox, { top, left, bottom, right }) {\n  return {\n    x: calcRelativeAxisConstraints(layoutBox.x, left, right),\n    y: calcRelativeAxisConstraints(layoutBox.y, top, bottom)\n  };\n}\nfunction calcViewportAxisConstraints(layoutAxis, constraintsAxis) {\n  let min = constraintsAxis.min - layoutAxis.min;\n  let max = constraintsAxis.max - layoutAxis.max;\n  if (constraintsAxis.max - constraintsAxis.min < layoutAxis.max - layoutAxis.min) {\n    [min, max] = [max, min];\n  }\n  return { min, max };\n}\nfunction calcViewportConstraints(layoutBox, constraintsBox) {\n  return {\n    x: calcViewportAxisConstraints(layoutBox.x, constraintsBox.x),\n    y: calcViewportAxisConstraints(layoutBox.y, constraintsBox.y)\n  };\n}\nfunction calcOrigin2(source, target) {\n  let origin = 0.5;\n  const sourceLength = calcLength(source);\n  const targetLength = calcLength(target);\n  if (targetLength > sourceLength) {\n    origin = progress(target.min, target.max - sourceLength, source.min);\n  } else if (sourceLength > targetLength) {\n    origin = progress(source.min, source.max - targetLength, target.min);\n  }\n  return clamp(0, 1, origin);\n}\nfunction rebaseAxisConstraints(layout2, constraints) {\n  const relativeConstraints = {};\n  if (constraints.min !== void 0) {\n    relativeConstraints.min = constraints.min - layout2.min;\n  }\n  if (constraints.max !== void 0) {\n    relativeConstraints.max = constraints.max - layout2.min;\n  }\n  return relativeConstraints;\n}\nvar defaultElastic = 0.35;\nfunction resolveDragElastic(dragElastic = defaultElastic) {\n  if (dragElastic === false) {\n    dragElastic = 0;\n  } else if (dragElastic === true) {\n    dragElastic = defaultElastic;\n  }\n  return {\n    x: resolveAxisElastic(dragElastic, \"left\", \"right\"),\n    y: resolveAxisElastic(dragElastic, \"top\", \"bottom\")\n  };\n}\nfunction resolveAxisElastic(dragElastic, minLabel, maxLabel) {\n  return {\n    min: resolvePointElastic(dragElastic, minLabel),\n    max: resolvePointElastic(dragElastic, maxLabel)\n  };\n}\nfunction resolvePointElastic(dragElastic, label) {\n  return typeof dragElastic === \"number\" ? dragElastic : dragElastic[label] || 0;\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/projection/geometry/models.mjs\nvar createAxisDelta = () => ({\n  translate: 0,\n  scale: 1,\n  origin: 0,\n  originPoint: 0\n});\nvar createDelta = () => ({\n  x: createAxisDelta(),\n  y: createAxisDelta()\n});\nvar createAxis = () => ({ min: 0, max: 0 });\nvar createBox = () => ({\n  x: createAxis(),\n  y: createAxis()\n});\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/projection/utils/each-axis.mjs\nfunction eachAxis(callback) {\n  return [callback(\"x\"), callback(\"y\")];\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/projection/geometry/conversion.mjs\nfunction convertBoundingBoxToBox({ top, left, right, bottom }) {\n  return {\n    x: { min: left, max: right },\n    y: { min: top, max: bottom }\n  };\n}\nfunction convertBoxToBoundingBox({ x, y }) {\n  return { top: y.min, right: x.max, bottom: y.max, left: x.min };\n}\nfunction transformBoxPoints(point2, transformPoint2) {\n  if (!transformPoint2)\n    return point2;\n  const topLeft = transformPoint2({ x: point2.left, y: point2.top });\n  const bottomRight = transformPoint2({ x: point2.right, y: point2.bottom });\n  return {\n    top: topLeft.y,\n    left: topLeft.x,\n    bottom: bottomRight.y,\n    right: bottomRight.x\n  };\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/projection/utils/has-transform.mjs\nfunction isIdentityScale(scale2) {\n  return scale2 === void 0 || scale2 === 1;\n}\nfunction hasScale({ scale: scale2, scaleX, scaleY }) {\n  return !isIdentityScale(scale2) || !isIdentityScale(scaleX) || !isIdentityScale(scaleY);\n}\nfunction hasTransform(values) {\n  return hasScale(values) || has2DTranslate(values) || values.z || values.rotate || values.rotateX || values.rotateY || values.skewX || values.skewY;\n}\nfunction has2DTranslate(values) {\n  return is2DTranslate(values.x) || is2DTranslate(values.y);\n}\nfunction is2DTranslate(value) {\n  return value && value !== \"0%\";\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/projection/geometry/delta-apply.mjs\nfunction scalePoint(point2, scale2, originPoint) {\n  const distanceFromOrigin = point2 - originPoint;\n  const scaled = scale2 * distanceFromOrigin;\n  return originPoint + scaled;\n}\nfunction applyPointDelta(point2, translate, scale2, originPoint, boxScale) {\n  if (boxScale !== void 0) {\n    point2 = scalePoint(point2, boxScale, originPoint);\n  }\n  return scalePoint(point2, scale2, originPoint) + translate;\n}\nfunction applyAxisDelta(axis, translate = 0, scale2 = 1, originPoint, boxScale) {\n  axis.min = applyPointDelta(axis.min, translate, scale2, originPoint, boxScale);\n  axis.max = applyPointDelta(axis.max, translate, scale2, originPoint, boxScale);\n}\nfunction applyBoxDelta(box, { x, y }) {\n  applyAxisDelta(box.x, x.translate, x.scale, x.originPoint);\n  applyAxisDelta(box.y, y.translate, y.scale, y.originPoint);\n}\nfunction applyTreeDeltas(box, treeScale, treePath, isSharedTransition = false) {\n  const treeLength = treePath.length;\n  if (!treeLength)\n    return;\n  treeScale.x = treeScale.y = 1;\n  let node;\n  let delta;\n  for (let i = 0; i < treeLength; i++) {\n    node = treePath[i];\n    delta = node.projectionDelta;\n    const instance = node.instance;\n    if (instance && instance.style && instance.style.display === \"contents\") {\n      continue;\n    }\n    if (isSharedTransition && node.options.layoutScroll && node.scroll && node !== node.root) {\n      transformBox(box, {\n        x: -node.scroll.offset.x,\n        y: -node.scroll.offset.y\n      });\n    }\n    if (delta) {\n      treeScale.x *= delta.x.scale;\n      treeScale.y *= delta.y.scale;\n      applyBoxDelta(box, delta);\n    }\n    if (isSharedTransition && hasTransform(node.latestValues)) {\n      transformBox(box, node.latestValues);\n    }\n  }\n  treeScale.x = snapToDefault(treeScale.x);\n  treeScale.y = snapToDefault(treeScale.y);\n}\nfunction snapToDefault(scale2) {\n  if (Number.isInteger(scale2))\n    return scale2;\n  return scale2 > 1.0000000000001 || scale2 < 0.999999999999 ? scale2 : 1;\n}\nfunction translateAxis(axis, distance2) {\n  axis.min = axis.min + distance2;\n  axis.max = axis.max + distance2;\n}\nfunction transformAxis(axis, transforms, [key, scaleKey, originKey]) {\n  const axisOrigin = transforms[originKey] !== void 0 ? transforms[originKey] : 0.5;\n  const originPoint = mixNumber(axis.min, axis.max, axisOrigin);\n  applyAxisDelta(axis, transforms[key], transforms[scaleKey], originPoint, transforms.scale);\n}\nvar xKeys = [\"x\", \"scaleX\", \"originX\"];\nvar yKeys = [\"y\", \"scaleY\", \"originY\"];\nfunction transformBox(box, transform2) {\n  transformAxis(box.x, transform2, xKeys);\n  transformAxis(box.y, transform2, yKeys);\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/projection/utils/measure.mjs\nfunction measureViewportBox(instance, transformPoint2) {\n  return convertBoundingBoxToBox(transformBoxPoints(instance.getBoundingClientRect(), transformPoint2));\n}\nfunction measurePageBox(element, rootProjectionNode2, transformPagePoint) {\n  const viewportBox = measureViewportBox(element, transformPagePoint);\n  const { scroll: scroll2 } = rootProjectionNode2;\n  if (scroll2) {\n    translateAxis(viewportBox.x, scroll2.offset.x);\n    translateAxis(viewportBox.y, scroll2.offset.y);\n  }\n  return viewportBox;\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/utils/get-context-window.mjs\nvar getContextWindow = ({ current }) => {\n  return current ? current.ownerDocument.defaultView : null;\n};\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/gestures/drag/VisualElementDragControls.mjs\nvar elementDragControls = /* @__PURE__ */ new WeakMap();\nvar VisualElementDragControls = class {\n  constructor(visualElement) {\n    this.openGlobalLock = null;\n    this.isDragging = false;\n    this.currentDirection = null;\n    this.originPoint = { x: 0, y: 0 };\n    this.constraints = false;\n    this.hasMutatedConstraints = false;\n    this.elastic = createBox();\n    this.visualElement = visualElement;\n  }\n  start(originEvent, { snapToCursor = false } = {}) {\n    const { presenceContext } = this.visualElement;\n    if (presenceContext && presenceContext.isPresent === false)\n      return;\n    const onSessionStart = (event) => {\n      const { dragSnapToOrigin: dragSnapToOrigin2 } = this.getProps();\n      dragSnapToOrigin2 ? this.pauseAnimation() : this.stopAnimation();\n      if (snapToCursor) {\n        this.snapToCursor(extractEventInfo(event, \"page\").point);\n      }\n    };\n    const onStart = (event, info) => {\n      const { drag: drag2, dragPropagation, onDragStart } = this.getProps();\n      if (drag2 && !dragPropagation) {\n        if (this.openGlobalLock)\n          this.openGlobalLock();\n        this.openGlobalLock = getGlobalLock(drag2);\n        if (!this.openGlobalLock)\n          return;\n      }\n      this.isDragging = true;\n      this.currentDirection = null;\n      this.resolveConstraints();\n      if (this.visualElement.projection) {\n        this.visualElement.projection.isAnimationBlocked = true;\n        this.visualElement.projection.target = void 0;\n      }\n      eachAxis((axis) => {\n        let current = this.getAxisMotionValue(axis).get() || 0;\n        if (percent.test(current)) {\n          const { projection } = this.visualElement;\n          if (projection && projection.layout) {\n            const measuredAxis = projection.layout.layoutBox[axis];\n            if (measuredAxis) {\n              const length = calcLength(measuredAxis);\n              current = length * (parseFloat(current) / 100);\n            }\n          }\n        }\n        this.originPoint[axis] = current;\n      });\n      if (onDragStart)\n        onDragStart(event, info);\n      const { animationState } = this.visualElement;\n      animationState && animationState.setActive(\"whileDrag\", true);\n    };\n    const onMove = (event, info) => {\n      const { dragPropagation, dragDirectionLock, onDirectionLock, onDrag } = this.getProps();\n      if (!dragPropagation && !this.openGlobalLock)\n        return;\n      const { offset } = info;\n      if (dragDirectionLock && this.currentDirection === null) {\n        this.currentDirection = getCurrentDirection(offset);\n        if (this.currentDirection !== null) {\n          onDirectionLock && onDirectionLock(this.currentDirection);\n        }\n        return;\n      }\n      this.updateAxis(\"x\", info.point, offset);\n      this.updateAxis(\"y\", info.point, offset);\n      this.visualElement.render();\n      onDrag && onDrag(event, info);\n    };\n    const onSessionEnd = (event, info) => this.stop(event, info);\n    const resumeAnimation = () => eachAxis((axis) => {\n      var _a;\n      return this.getAnimationState(axis) === \"paused\" && ((_a = this.getAxisMotionValue(axis).animation) === null || _a === void 0 ? void 0 : _a.play());\n    });\n    const { dragSnapToOrigin } = this.getProps();\n    this.panSession = new PanSession(originEvent, {\n      onSessionStart,\n      onStart,\n      onMove,\n      onSessionEnd,\n      resumeAnimation\n    }, {\n      transformPagePoint: this.visualElement.getTransformPagePoint(),\n      dragSnapToOrigin,\n      contextWindow: getContextWindow(this.visualElement)\n    });\n  }\n  stop(event, info) {\n    const isDragging = this.isDragging;\n    this.cancel();\n    if (!isDragging)\n      return;\n    const { velocity } = info;\n    this.startAnimation(velocity);\n    const { onDragEnd } = this.getProps();\n    if (onDragEnd)\n      onDragEnd(event, info);\n  }\n  cancel() {\n    this.isDragging = false;\n    const { projection, animationState } = this.visualElement;\n    if (projection) {\n      projection.isAnimationBlocked = false;\n    }\n    this.panSession && this.panSession.end();\n    this.panSession = void 0;\n    const { dragPropagation } = this.getProps();\n    if (!dragPropagation && this.openGlobalLock) {\n      this.openGlobalLock();\n      this.openGlobalLock = null;\n    }\n    animationState && animationState.setActive(\"whileDrag\", false);\n  }\n  updateAxis(axis, _point, offset) {\n    const { drag: drag2 } = this.getProps();\n    if (!offset || !shouldDrag(axis, drag2, this.currentDirection))\n      return;\n    const axisValue = this.getAxisMotionValue(axis);\n    let next = this.originPoint[axis] + offset[axis];\n    if (this.constraints && this.constraints[axis]) {\n      next = applyConstraints(next, this.constraints[axis], this.elastic[axis]);\n    }\n    axisValue.set(next);\n  }\n  resolveConstraints() {\n    var _a;\n    const { dragConstraints, dragElastic } = this.getProps();\n    const layout2 = this.visualElement.projection && !this.visualElement.projection.layout ? this.visualElement.projection.measure(false) : (_a = this.visualElement.projection) === null || _a === void 0 ? void 0 : _a.layout;\n    const prevConstraints = this.constraints;\n    if (dragConstraints && isRefObject(dragConstraints)) {\n      if (!this.constraints) {\n        this.constraints = this.resolveRefConstraints();\n      }\n    } else {\n      if (dragConstraints && layout2) {\n        this.constraints = calcRelativeConstraints(layout2.layoutBox, dragConstraints);\n      } else {\n        this.constraints = false;\n      }\n    }\n    this.elastic = resolveDragElastic(dragElastic);\n    if (prevConstraints !== this.constraints && layout2 && this.constraints && !this.hasMutatedConstraints) {\n      eachAxis((axis) => {\n        if (this.getAxisMotionValue(axis)) {\n          this.constraints[axis] = rebaseAxisConstraints(layout2.layoutBox[axis], this.constraints[axis]);\n        }\n      });\n    }\n  }\n  resolveRefConstraints() {\n    const { dragConstraints: constraints, onMeasureDragConstraints } = this.getProps();\n    if (!constraints || !isRefObject(constraints))\n      return false;\n    const constraintsElement = constraints.current;\n    invariant(constraintsElement !== null, \"If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop.\");\n    const { projection } = this.visualElement;\n    if (!projection || !projection.layout)\n      return false;\n    const constraintsBox = measurePageBox(constraintsElement, projection.root, this.visualElement.getTransformPagePoint());\n    let measuredConstraints = calcViewportConstraints(projection.layout.layoutBox, constraintsBox);\n    if (onMeasureDragConstraints) {\n      const userConstraints = onMeasureDragConstraints(convertBoxToBoundingBox(measuredConstraints));\n      this.hasMutatedConstraints = !!userConstraints;\n      if (userConstraints) {\n        measuredConstraints = convertBoundingBoxToBox(userConstraints);\n      }\n    }\n    return measuredConstraints;\n  }\n  startAnimation(velocity) {\n    const { drag: drag2, dragMomentum, dragElastic, dragTransition, dragSnapToOrigin, onDragTransitionEnd } = this.getProps();\n    const constraints = this.constraints || {};\n    const momentumAnimations = eachAxis((axis) => {\n      if (!shouldDrag(axis, drag2, this.currentDirection)) {\n        return;\n      }\n      let transition = constraints && constraints[axis] || {};\n      if (dragSnapToOrigin)\n        transition = { min: 0, max: 0 };\n      const bounceStiffness = dragElastic ? 200 : 1e6;\n      const bounceDamping = dragElastic ? 40 : 1e7;\n      const inertia2 = {\n        type: \"inertia\",\n        velocity: dragMomentum ? velocity[axis] : 0,\n        bounceStiffness,\n        bounceDamping,\n        timeConstant: 750,\n        restDelta: 1,\n        restSpeed: 10,\n        ...dragTransition,\n        ...transition\n      };\n      return this.startAxisValueAnimation(axis, inertia2);\n    });\n    return Promise.all(momentumAnimations).then(onDragTransitionEnd);\n  }\n  startAxisValueAnimation(axis, transition) {\n    const axisValue = this.getAxisMotionValue(axis);\n    return axisValue.start(animateMotionValue(axis, axisValue, 0, transition, this.visualElement));\n  }\n  stopAnimation() {\n    eachAxis((axis) => this.getAxisMotionValue(axis).stop());\n  }\n  pauseAnimation() {\n    eachAxis((axis) => {\n      var _a;\n      return (_a = this.getAxisMotionValue(axis).animation) === null || _a === void 0 ? void 0 : _a.pause();\n    });\n  }\n  getAnimationState(axis) {\n    var _a;\n    return (_a = this.getAxisMotionValue(axis).animation) === null || _a === void 0 ? void 0 : _a.state;\n  }\n  /**\n   * Drag works differently depending on which props are provided.\n   *\n   * - If _dragX and _dragY are provided, we output the gesture delta directly to those motion values.\n   * - Otherwise, we apply the delta to the x/y motion values.\n   */\n  getAxisMotionValue(axis) {\n    const dragKey = \"_drag\" + axis.toUpperCase();\n    const props = this.visualElement.getProps();\n    const externalMotionValue = props[dragKey];\n    return externalMotionValue ? externalMotionValue : this.visualElement.getValue(axis, (props.initial ? props.initial[axis] : void 0) || 0);\n  }\n  snapToCursor(point2) {\n    eachAxis((axis) => {\n      const { drag: drag2 } = this.getProps();\n      if (!shouldDrag(axis, drag2, this.currentDirection))\n        return;\n      const { projection } = this.visualElement;\n      const axisValue = this.getAxisMotionValue(axis);\n      if (projection && projection.layout) {\n        const { min, max } = projection.layout.layoutBox[axis];\n        axisValue.set(point2[axis] - mixNumber(min, max, 0.5));\n      }\n    });\n  }\n  /**\n   * When the viewport resizes we want to check if the measured constraints\n   * have changed and, if so, reposition the element within those new constraints\n   * relative to where it was before the resize.\n   */\n  scalePositionWithinConstraints() {\n    if (!this.visualElement.current)\n      return;\n    const { drag: drag2, dragConstraints } = this.getProps();\n    const { projection } = this.visualElement;\n    if (!isRefObject(dragConstraints) || !projection || !this.constraints)\n      return;\n    this.stopAnimation();\n    const boxProgress = { x: 0, y: 0 };\n    eachAxis((axis) => {\n      const axisValue = this.getAxisMotionValue(axis);\n      if (axisValue) {\n        const latest = axisValue.get();\n        boxProgress[axis] = calcOrigin2({ min: latest, max: latest }, this.constraints[axis]);\n      }\n    });\n    const { transformTemplate } = this.visualElement.getProps();\n    this.visualElement.current.style.transform = transformTemplate ? transformTemplate({}, \"\") : \"none\";\n    projection.root && projection.root.updateScroll();\n    projection.updateLayout();\n    this.resolveConstraints();\n    eachAxis((axis) => {\n      if (!shouldDrag(axis, drag2, null))\n        return;\n      const axisValue = this.getAxisMotionValue(axis);\n      const { min, max } = this.constraints[axis];\n      axisValue.set(mixNumber(min, max, boxProgress[axis]));\n    });\n  }\n  addListeners() {\n    if (!this.visualElement.current)\n      return;\n    elementDragControls.set(this.visualElement, this);\n    const element = this.visualElement.current;\n    const stopPointerListener = addPointerEvent(element, \"pointerdown\", (event) => {\n      const { drag: drag2, dragListener = true } = this.getProps();\n      drag2 && dragListener && this.start(event);\n    });\n    const measureDragConstraints = () => {\n      const { dragConstraints } = this.getProps();\n      if (isRefObject(dragConstraints)) {\n        this.constraints = this.resolveRefConstraints();\n      }\n    };\n    const { projection } = this.visualElement;\n    const stopMeasureLayoutListener = projection.addEventListener(\"measure\", measureDragConstraints);\n    if (projection && !projection.layout) {\n      projection.root && projection.root.updateScroll();\n      projection.updateLayout();\n    }\n    measureDragConstraints();\n    const stopResizeListener = addDomEvent(window, \"resize\", () => this.scalePositionWithinConstraints());\n    const stopLayoutUpdateListener = projection.addEventListener(\"didUpdate\", ({ delta, hasLayoutChanged }) => {\n      if (this.isDragging && hasLayoutChanged) {\n        eachAxis((axis) => {\n          const motionValue2 = this.getAxisMotionValue(axis);\n          if (!motionValue2)\n            return;\n          this.originPoint[axis] += delta[axis].translate;\n          motionValue2.set(motionValue2.get() + delta[axis].translate);\n        });\n        this.visualElement.render();\n      }\n    });\n    return () => {\n      stopResizeListener();\n      stopPointerListener();\n      stopMeasureLayoutListener();\n      stopLayoutUpdateListener && stopLayoutUpdateListener();\n    };\n  }\n  getProps() {\n    const props = this.visualElement.getProps();\n    const { drag: drag2 = false, dragDirectionLock = false, dragPropagation = false, dragConstraints = false, dragElastic = defaultElastic, dragMomentum = true } = props;\n    return {\n      ...props,\n      drag: drag2,\n      dragDirectionLock,\n      dragPropagation,\n      dragConstraints,\n      dragElastic,\n      dragMomentum\n    };\n  }\n};\nfunction shouldDrag(direction, drag2, currentDirection) {\n  return (drag2 === true || drag2 === direction) && (currentDirection === null || currentDirection === direction);\n}\nfunction getCurrentDirection(offset, lockThreshold = 10) {\n  let direction = null;\n  if (Math.abs(offset.y) > lockThreshold) {\n    direction = \"y\";\n  } else if (Math.abs(offset.x) > lockThreshold) {\n    direction = \"x\";\n  }\n  return direction;\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/gestures/drag/index.mjs\nvar DragGesture = class extends Feature {\n  constructor(node) {\n    super(node);\n    this.removeGroupControls = noop;\n    this.removeListeners = noop;\n    this.controls = new VisualElementDragControls(node);\n  }\n  mount() {\n    const { dragControls } = this.node.getProps();\n    if (dragControls) {\n      this.removeGroupControls = dragControls.subscribe(this.controls);\n    }\n    this.removeListeners = this.controls.addListeners() || noop;\n  }\n  unmount() {\n    this.removeGroupControls();\n    this.removeListeners();\n  }\n};\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/gestures/pan/index.mjs\nvar asyncHandler = (handler) => (event, info) => {\n  if (handler) {\n    handler(event, info);\n  }\n};\nvar PanGesture = class extends Feature {\n  constructor() {\n    super(...arguments);\n    this.removePointerDownListener = noop;\n  }\n  onPointerDown(pointerDownEvent) {\n    this.session = new PanSession(pointerDownEvent, this.createPanHandlers(), {\n      transformPagePoint: this.node.getTransformPagePoint(),\n      contextWindow: getContextWindow(this.node)\n    });\n  }\n  createPanHandlers() {\n    const { onPanSessionStart, onPanStart, onPan, onPanEnd } = this.node.getProps();\n    return {\n      onSessionStart: asyncHandler(onPanSessionStart),\n      onStart: asyncHandler(onPanStart),\n      onMove: onPan,\n      onEnd: (event, info) => {\n        delete this.session;\n        if (onPanEnd)\n          onPanEnd(event, info);\n      }\n    };\n  }\n  mount() {\n    this.removePointerDownListener = addPointerEvent(this.node.current, \"pointerdown\", (event) => this.onPointerDown(event));\n  }\n  update() {\n    this.session && this.session.updateHandlers(this.createPanHandlers());\n  }\n  unmount() {\n    this.removePointerDownListener();\n    this.session && this.session.end();\n  }\n};\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/motion/features/layout/MeasureLayout.mjs\nvar import_react18 = __toESM(require_react(), 1);\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/components/AnimatePresence/use-presence.mjs\nvar import_react17 = __toESM(require_react(), 1);\nfunction usePresence() {\n  const context = (0, import_react17.useContext)(PresenceContext);\n  if (context === null)\n    return [true, null];\n  const { isPresent: isPresent2, onExitComplete, register } = context;\n  const id4 = (0, import_react17.useId)();\n  (0, import_react17.useEffect)(() => register(id4), []);\n  const safeToRemove = () => onExitComplete && onExitComplete(id4);\n  return !isPresent2 && onExitComplete ? [false, safeToRemove] : [true];\n}\nfunction useIsPresent() {\n  return isPresent((0, import_react17.useContext)(PresenceContext));\n}\nfunction isPresent(context) {\n  return context === null ? true : context.isPresent;\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/projection/node/state.mjs\nvar globalProjectionState = {\n  /**\n   * Global flag as to whether the tree has animated since the last time\n   * we resized the window\n   */\n  hasAnimatedSinceResize: true,\n  /**\n   * We set this to true once, on the first update. Any nodes added to the tree beyond that\n   * update will be given a `data-projection-id` attribute.\n   */\n  hasEverUpdated: false\n};\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/projection/styles/scale-border-radius.mjs\nfunction pixelsToPercent(pixels, axis) {\n  if (axis.max === axis.min)\n    return 0;\n  return pixels / (axis.max - axis.min) * 100;\n}\nvar correctBorderRadius = {\n  correct: (latest, node) => {\n    if (!node.target)\n      return latest;\n    if (typeof latest === \"string\") {\n      if (px.test(latest)) {\n        latest = parseFloat(latest);\n      } else {\n        return latest;\n      }\n    }\n    const x = pixelsToPercent(latest, node.target.x);\n    const y = pixelsToPercent(latest, node.target.y);\n    return `${x}% ${y}%`;\n  }\n};\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/projection/styles/scale-box-shadow.mjs\nvar correctBoxShadow = {\n  correct: (latest, { treeScale, projectionDelta }) => {\n    const original = latest;\n    const shadow = complex.parse(latest);\n    if (shadow.length > 5)\n      return original;\n    const template = complex.createTransformer(latest);\n    const offset = typeof shadow[0] !== \"number\" ? 1 : 0;\n    const xScale = projectionDelta.x.scale * treeScale.x;\n    const yScale = projectionDelta.y.scale * treeScale.y;\n    shadow[0 + offset] /= xScale;\n    shadow[1 + offset] /= yScale;\n    const averageScale = mixNumber(xScale, yScale, 0.5);\n    if (typeof shadow[2 + offset] === \"number\")\n      shadow[2 + offset] /= averageScale;\n    if (typeof shadow[3 + offset] === \"number\")\n      shadow[3 + offset] /= averageScale;\n    return template(shadow);\n  }\n};\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/motion/features/layout/MeasureLayout.mjs\nvar MeasureLayoutWithContext = class extends import_react18.default.Component {\n  /**\n   * This only mounts projection nodes for components that\n   * need measuring, we might want to do it for all components\n   * in order to incorporate transforms\n   */\n  componentDidMount() {\n    const { visualElement, layoutGroup, switchLayoutGroup, layoutId } = this.props;\n    const { projection } = visualElement;\n    addScaleCorrector(defaultScaleCorrectors);\n    if (projection) {\n      if (layoutGroup.group)\n        layoutGroup.group.add(projection);\n      if (switchLayoutGroup && switchLayoutGroup.register && layoutId) {\n        switchLayoutGroup.register(projection);\n      }\n      projection.root.didUpdate();\n      projection.addEventListener(\"animationComplete\", () => {\n        this.safeToRemove();\n      });\n      projection.setOptions({\n        ...projection.options,\n        onExitComplete: () => this.safeToRemove()\n      });\n    }\n    globalProjectionState.hasEverUpdated = true;\n  }\n  getSnapshotBeforeUpdate(prevProps) {\n    const { layoutDependency, visualElement, drag: drag2, isPresent: isPresent2 } = this.props;\n    const projection = visualElement.projection;\n    if (!projection)\n      return null;\n    projection.isPresent = isPresent2;\n    if (drag2 || prevProps.layoutDependency !== layoutDependency || layoutDependency === void 0) {\n      projection.willUpdate();\n    } else {\n      this.safeToRemove();\n    }\n    if (prevProps.isPresent !== isPresent2) {\n      if (isPresent2) {\n        projection.promote();\n      } else if (!projection.relegate()) {\n        frame.postRender(() => {\n          const stack = projection.getStack();\n          if (!stack || !stack.members.length) {\n            this.safeToRemove();\n          }\n        });\n      }\n    }\n    return null;\n  }\n  componentDidUpdate() {\n    const { projection } = this.props.visualElement;\n    if (projection) {\n      projection.root.didUpdate();\n      microtask.postRender(() => {\n        if (!projection.currentAnimation && projection.isLead()) {\n          this.safeToRemove();\n        }\n      });\n    }\n  }\n  componentWillUnmount() {\n    const { visualElement, layoutGroup, switchLayoutGroup: promoteContext } = this.props;\n    const { projection } = visualElement;\n    if (projection) {\n      projection.scheduleCheckAfterUnmount();\n      if (layoutGroup && layoutGroup.group)\n        layoutGroup.group.remove(projection);\n      if (promoteContext && promoteContext.deregister)\n        promoteContext.deregister(projection);\n    }\n  }\n  safeToRemove() {\n    const { safeToRemove } = this.props;\n    safeToRemove && safeToRemove();\n  }\n  render() {\n    return null;\n  }\n};\nfunction MeasureLayout(props) {\n  const [isPresent2, safeToRemove] = usePresence();\n  const layoutGroup = (0, import_react18.useContext)(LayoutGroupContext);\n  return import_react18.default.createElement(MeasureLayoutWithContext, { ...props, layoutGroup, switchLayoutGroup: (0, import_react18.useContext)(SwitchLayoutGroupContext), isPresent: isPresent2, safeToRemove });\n}\nvar defaultScaleCorrectors = {\n  borderRadius: {\n    ...correctBorderRadius,\n    applyTo: [\n      \"borderTopLeftRadius\",\n      \"borderTopRightRadius\",\n      \"borderBottomLeftRadius\",\n      \"borderBottomRightRadius\"\n    ]\n  },\n  borderTopLeftRadius: correctBorderRadius,\n  borderTopRightRadius: correctBorderRadius,\n  borderBottomLeftRadius: correctBorderRadius,\n  borderBottomRightRadius: correctBorderRadius,\n  boxShadow: correctBoxShadow\n};\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/projection/animation/mix-values.mjs\nvar borders = [\"TopLeft\", \"TopRight\", \"BottomLeft\", \"BottomRight\"];\nvar numBorders = borders.length;\nvar asNumber = (value) => typeof value === \"string\" ? parseFloat(value) : value;\nvar isPx = (value) => typeof value === \"number\" || px.test(value);\nfunction mixValues(target, follow, lead, progress2, shouldCrossfadeOpacity, isOnlyMember) {\n  if (shouldCrossfadeOpacity) {\n    target.opacity = mixNumber(\n      0,\n      // TODO Reinstate this if only child\n      lead.opacity !== void 0 ? lead.opacity : 1,\n      easeCrossfadeIn(progress2)\n    );\n    target.opacityExit = mixNumber(follow.opacity !== void 0 ? follow.opacity : 1, 0, easeCrossfadeOut(progress2));\n  } else if (isOnlyMember) {\n    target.opacity = mixNumber(follow.opacity !== void 0 ? follow.opacity : 1, lead.opacity !== void 0 ? lead.opacity : 1, progress2);\n  }\n  for (let i = 0; i < numBorders; i++) {\n    const borderLabel = `border${borders[i]}Radius`;\n    let followRadius = getRadius(follow, borderLabel);\n    let leadRadius = getRadius(lead, borderLabel);\n    if (followRadius === void 0 && leadRadius === void 0)\n      continue;\n    followRadius || (followRadius = 0);\n    leadRadius || (leadRadius = 0);\n    const canMix = followRadius === 0 || leadRadius === 0 || isPx(followRadius) === isPx(leadRadius);\n    if (canMix) {\n      target[borderLabel] = Math.max(mixNumber(asNumber(followRadius), asNumber(leadRadius), progress2), 0);\n      if (percent.test(leadRadius) || percent.test(followRadius)) {\n        target[borderLabel] += \"%\";\n      }\n    } else {\n      target[borderLabel] = leadRadius;\n    }\n  }\n  if (follow.rotate || lead.rotate) {\n    target.rotate = mixNumber(follow.rotate || 0, lead.rotate || 0, progress2);\n  }\n}\nfunction getRadius(values, radiusName) {\n  return values[radiusName] !== void 0 ? values[radiusName] : values.borderRadius;\n}\nvar easeCrossfadeIn = compress(0, 0.5, circOut);\nvar easeCrossfadeOut = compress(0.5, 0.95, noop);\nfunction compress(min, max, easing) {\n  return (p) => {\n    if (p < min)\n      return 0;\n    if (p > max)\n      return 1;\n    return easing(progress(min, max, p));\n  };\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/projection/geometry/copy.mjs\nfunction copyAxisInto(axis, originAxis) {\n  axis.min = originAxis.min;\n  axis.max = originAxis.max;\n}\nfunction copyBoxInto(box, originBox) {\n  copyAxisInto(box.x, originBox.x);\n  copyAxisInto(box.y, originBox.y);\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/projection/geometry/delta-remove.mjs\nfunction removePointDelta(point2, translate, scale2, originPoint, boxScale) {\n  point2 -= translate;\n  point2 = scalePoint(point2, 1 / scale2, originPoint);\n  if (boxScale !== void 0) {\n    point2 = scalePoint(point2, 1 / boxScale, originPoint);\n  }\n  return point2;\n}\nfunction removeAxisDelta(axis, translate = 0, scale2 = 1, origin = 0.5, boxScale, originAxis = axis, sourceAxis = axis) {\n  if (percent.test(translate)) {\n    translate = parseFloat(translate);\n    const relativeProgress = mixNumber(sourceAxis.min, sourceAxis.max, translate / 100);\n    translate = relativeProgress - sourceAxis.min;\n  }\n  if (typeof translate !== \"number\")\n    return;\n  let originPoint = mixNumber(originAxis.min, originAxis.max, origin);\n  if (axis === originAxis)\n    originPoint -= translate;\n  axis.min = removePointDelta(axis.min, translate, scale2, originPoint, boxScale);\n  axis.max = removePointDelta(axis.max, translate, scale2, originPoint, boxScale);\n}\nfunction removeAxisTransforms(axis, transforms, [key, scaleKey, originKey], origin, sourceAxis) {\n  removeAxisDelta(axis, transforms[key], transforms[scaleKey], transforms[originKey], transforms.scale, origin, sourceAxis);\n}\nvar xKeys2 = [\"x\", \"scaleX\", \"originX\"];\nvar yKeys2 = [\"y\", \"scaleY\", \"originY\"];\nfunction removeBoxTransforms(box, transforms, originBox, sourceBox) {\n  removeAxisTransforms(box.x, transforms, xKeys2, originBox ? originBox.x : void 0, sourceBox ? sourceBox.x : void 0);\n  removeAxisTransforms(box.y, transforms, yKeys2, originBox ? originBox.y : void 0, sourceBox ? sourceBox.y : void 0);\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/projection/geometry/utils.mjs\nfunction isAxisDeltaZero(delta) {\n  return delta.translate === 0 && delta.scale === 1;\n}\nfunction isDeltaZero(delta) {\n  return isAxisDeltaZero(delta.x) && isAxisDeltaZero(delta.y);\n}\nfunction boxEquals(a, b) {\n  return a.x.min === b.x.min && a.x.max === b.x.max && a.y.min === b.y.min && a.y.max === b.y.max;\n}\nfunction boxEqualsRounded(a, b) {\n  return Math.round(a.x.min) === Math.round(b.x.min) && Math.round(a.x.max) === Math.round(b.x.max) && Math.round(a.y.min) === Math.round(b.y.min) && Math.round(a.y.max) === Math.round(b.y.max);\n}\nfunction aspectRatio(box) {\n  return calcLength(box.x) / calcLength(box.y);\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/projection/shared/stack.mjs\nvar NodeStack = class {\n  constructor() {\n    this.members = [];\n  }\n  add(node) {\n    addUniqueItem(this.members, node);\n    node.scheduleRender();\n  }\n  remove(node) {\n    removeItem(this.members, node);\n    if (node === this.prevLead) {\n      this.prevLead = void 0;\n    }\n    if (node === this.lead) {\n      const prevLead = this.members[this.members.length - 1];\n      if (prevLead) {\n        this.promote(prevLead);\n      }\n    }\n  }\n  relegate(node) {\n    const indexOfNode = this.members.findIndex((member) => node === member);\n    if (indexOfNode === 0)\n      return false;\n    let prevLead;\n    for (let i = indexOfNode; i >= 0; i--) {\n      const member = this.members[i];\n      if (member.isPresent !== false) {\n        prevLead = member;\n        break;\n      }\n    }\n    if (prevLead) {\n      this.promote(prevLead);\n      return true;\n    } else {\n      return false;\n    }\n  }\n  promote(node, preserveFollowOpacity) {\n    const prevLead = this.lead;\n    if (node === prevLead)\n      return;\n    this.prevLead = prevLead;\n    this.lead = node;\n    node.show();\n    if (prevLead) {\n      prevLead.instance && prevLead.scheduleRender();\n      node.scheduleRender();\n      node.resumeFrom = prevLead;\n      if (preserveFollowOpacity) {\n        node.resumeFrom.preserveOpacity = true;\n      }\n      if (prevLead.snapshot) {\n        node.snapshot = prevLead.snapshot;\n        node.snapshot.latestValues = prevLead.animationValues || prevLead.latestValues;\n      }\n      if (node.root && node.root.isUpdating) {\n        node.isLayoutDirty = true;\n      }\n      const { crossfade } = node.options;\n      if (crossfade === false) {\n        prevLead.hide();\n      }\n    }\n  }\n  exitAnimationComplete() {\n    this.members.forEach((node) => {\n      const { options, resumingFrom } = node;\n      options.onExitComplete && options.onExitComplete();\n      if (resumingFrom) {\n        resumingFrom.options.onExitComplete && resumingFrom.options.onExitComplete();\n      }\n    });\n  }\n  scheduleRender() {\n    this.members.forEach((node) => {\n      node.instance && node.scheduleRender(false);\n    });\n  }\n  /**\n   * Clear any leads that have been removed this render to prevent them from being\n   * used in future animations and to prevent memory leaks\n   */\n  removeLeadSnapshot() {\n    if (this.lead && this.lead.snapshot) {\n      this.lead.snapshot = void 0;\n    }\n  }\n};\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/projection/styles/transform.mjs\nfunction buildProjectionTransform(delta, treeScale, latestTransform) {\n  let transform2 = \"\";\n  const xTranslate = delta.x.translate / treeScale.x;\n  const yTranslate = delta.y.translate / treeScale.y;\n  const zTranslate = (latestTransform === null || latestTransform === void 0 ? void 0 : latestTransform.z) || 0;\n  if (xTranslate || yTranslate || zTranslate) {\n    transform2 = `translate3d(${xTranslate}px, ${yTranslate}px, ${zTranslate}px) `;\n  }\n  if (treeScale.x !== 1 || treeScale.y !== 1) {\n    transform2 += `scale(${1 / treeScale.x}, ${1 / treeScale.y}) `;\n  }\n  if (latestTransform) {\n    const { rotate, rotateX, rotateY, skewX, skewY } = latestTransform;\n    if (rotate)\n      transform2 += `rotate(${rotate}deg) `;\n    if (rotateX)\n      transform2 += `rotateX(${rotateX}deg) `;\n    if (rotateY)\n      transform2 += `rotateY(${rotateY}deg) `;\n    if (skewX)\n      transform2 += `skewX(${skewX}deg) `;\n    if (skewY)\n      transform2 += `skewY(${skewY}deg) `;\n  }\n  const elementScaleX = delta.x.scale * treeScale.x;\n  const elementScaleY = delta.y.scale * treeScale.y;\n  if (elementScaleX !== 1 || elementScaleY !== 1) {\n    transform2 += `scale(${elementScaleX}, ${elementScaleY})`;\n  }\n  return transform2 || \"none\";\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/utils/compare-by-depth.mjs\nvar compareByDepth = (a, b) => a.depth - b.depth;\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/utils/flat-tree.mjs\nvar FlatTree = class {\n  constructor() {\n    this.children = [];\n    this.isDirty = false;\n  }\n  add(child) {\n    addUniqueItem(this.children, child);\n    this.isDirty = true;\n  }\n  remove(child) {\n    removeItem(this.children, child);\n    this.isDirty = true;\n  }\n  forEach(callback) {\n    this.isDirty && this.children.sort(compareByDepth);\n    this.isDirty = false;\n    this.children.forEach(callback);\n  }\n};\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/utils/delay.mjs\nfunction delay(callback, timeout) {\n  const start = time.now();\n  const checkElapsed = ({ timestamp }) => {\n    const elapsed = timestamp - start;\n    if (elapsed >= timeout) {\n      cancelFrame(checkElapsed);\n      callback(elapsed - timeout);\n    }\n  };\n  frame.read(checkElapsed, true);\n  return () => cancelFrame(checkElapsed);\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/debug/record.mjs\nfunction record(data) {\n  if (window.MotionDebug) {\n    window.MotionDebug.record(data);\n  }\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/dom/utils/is-svg-element.mjs\nfunction isSVGElement(element) {\n  return element instanceof SVGElement && element.tagName !== \"svg\";\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/animation/interfaces/single-value.mjs\nfunction animateSingleValue(value, keyframes2, options) {\n  const motionValue$1 = isMotionValue(value) ? value : motionValue(value);\n  motionValue$1.start(animateMotionValue(\"\", motionValue$1, keyframes2, options));\n  return motionValue$1.animation;\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/projection/node/create-projection-node.mjs\nvar transformAxes = [\"\", \"X\", \"Y\", \"Z\"];\nvar hiddenVisibility = { visibility: \"hidden\" };\nvar animationTarget = 1e3;\nvar id2 = 0;\nvar projectionFrameData = {\n  type: \"projectionFrame\",\n  totalNodes: 0,\n  resolvedTargetDeltas: 0,\n  recalculatedProjection: 0\n};\nfunction resetDistortingTransform(key, visualElement, values, sharedAnimationValues) {\n  const { latestValues } = visualElement;\n  if (latestValues[key]) {\n    values[key] = latestValues[key];\n    visualElement.setStaticValue(key, 0);\n    if (sharedAnimationValues) {\n      sharedAnimationValues[key] = 0;\n    }\n  }\n}\nfunction createProjectionNode({ attachResizeListener, defaultParent, measureScroll, checkIsScrollRoot, resetTransform }) {\n  return class ProjectionNode {\n    constructor(latestValues = {}, parent = defaultParent === null || defaultParent === void 0 ? void 0 : defaultParent()) {\n      this.id = id2++;\n      this.animationId = 0;\n      this.children = /* @__PURE__ */ new Set();\n      this.options = {};\n      this.isTreeAnimating = false;\n      this.isAnimationBlocked = false;\n      this.isLayoutDirty = false;\n      this.isProjectionDirty = false;\n      this.isSharedProjectionDirty = false;\n      this.isTransformDirty = false;\n      this.updateManuallyBlocked = false;\n      this.updateBlockedByResize = false;\n      this.isUpdating = false;\n      this.isSVG = false;\n      this.needsReset = false;\n      this.shouldResetTransform = false;\n      this.treeScale = { x: 1, y: 1 };\n      this.eventHandlers = /* @__PURE__ */ new Map();\n      this.hasTreeAnimated = false;\n      this.updateScheduled = false;\n      this.projectionUpdateScheduled = false;\n      this.checkUpdateFailed = () => {\n        if (this.isUpdating) {\n          this.isUpdating = false;\n          this.clearAllSnapshots();\n        }\n      };\n      this.updateProjection = () => {\n        this.projectionUpdateScheduled = false;\n        projectionFrameData.totalNodes = projectionFrameData.resolvedTargetDeltas = projectionFrameData.recalculatedProjection = 0;\n        this.nodes.forEach(propagateDirtyNodes);\n        this.nodes.forEach(resolveTargetDelta);\n        this.nodes.forEach(calcProjection);\n        this.nodes.forEach(cleanDirtyNodes);\n        record(projectionFrameData);\n      };\n      this.hasProjected = false;\n      this.isVisible = true;\n      this.animationProgress = 0;\n      this.sharedNodes = /* @__PURE__ */ new Map();\n      this.latestValues = latestValues;\n      this.root = parent ? parent.root || parent : this;\n      this.path = parent ? [...parent.path, parent] : [];\n      this.parent = parent;\n      this.depth = parent ? parent.depth + 1 : 0;\n      for (let i = 0; i < this.path.length; i++) {\n        this.path[i].shouldResetTransform = true;\n      }\n      if (this.root === this)\n        this.nodes = new FlatTree();\n    }\n    addEventListener(name, handler) {\n      if (!this.eventHandlers.has(name)) {\n        this.eventHandlers.set(name, new SubscriptionManager());\n      }\n      return this.eventHandlers.get(name).add(handler);\n    }\n    notifyListeners(name, ...args) {\n      const subscriptionManager = this.eventHandlers.get(name);\n      subscriptionManager && subscriptionManager.notify(...args);\n    }\n    hasListeners(name) {\n      return this.eventHandlers.has(name);\n    }\n    /**\n     * Lifecycles\n     */\n    mount(instance, isLayoutDirty = this.root.hasTreeAnimated) {\n      if (this.instance)\n        return;\n      this.isSVG = isSVGElement(instance);\n      this.instance = instance;\n      const { layoutId, layout: layout2, visualElement } = this.options;\n      if (visualElement && !visualElement.current) {\n        visualElement.mount(instance);\n      }\n      this.root.nodes.add(this);\n      this.parent && this.parent.children.add(this);\n      if (isLayoutDirty && (layout2 || layoutId)) {\n        this.isLayoutDirty = true;\n      }\n      if (attachResizeListener) {\n        let cancelDelay;\n        const resizeUnblockUpdate = () => this.root.updateBlockedByResize = false;\n        attachResizeListener(instance, () => {\n          this.root.updateBlockedByResize = true;\n          cancelDelay && cancelDelay();\n          cancelDelay = delay(resizeUnblockUpdate, 250);\n          if (globalProjectionState.hasAnimatedSinceResize) {\n            globalProjectionState.hasAnimatedSinceResize = false;\n            this.nodes.forEach(finishAnimation);\n          }\n        });\n      }\n      if (layoutId) {\n        this.root.registerSharedNode(layoutId, this);\n      }\n      if (this.options.animate !== false && visualElement && (layoutId || layout2)) {\n        this.addEventListener(\"didUpdate\", ({ delta, hasLayoutChanged, hasRelativeTargetChanged, layout: newLayout }) => {\n          if (this.isTreeAnimationBlocked()) {\n            this.target = void 0;\n            this.relativeTarget = void 0;\n            return;\n          }\n          const layoutTransition = this.options.transition || visualElement.getDefaultTransition() || defaultLayoutTransition;\n          const { onLayoutAnimationStart, onLayoutAnimationComplete } = visualElement.getProps();\n          const targetChanged = !this.targetLayout || !boxEqualsRounded(this.targetLayout, newLayout) || hasRelativeTargetChanged;\n          const hasOnlyRelativeTargetChanged = !hasLayoutChanged && hasRelativeTargetChanged;\n          if (this.options.layoutRoot || this.resumeFrom && this.resumeFrom.instance || hasOnlyRelativeTargetChanged || hasLayoutChanged && (targetChanged || !this.currentAnimation)) {\n            if (this.resumeFrom) {\n              this.resumingFrom = this.resumeFrom;\n              this.resumingFrom.resumingFrom = void 0;\n            }\n            this.setAnimationOrigin(delta, hasOnlyRelativeTargetChanged);\n            const animationOptions = {\n              ...getValueTransition(layoutTransition, \"layout\"),\n              onPlay: onLayoutAnimationStart,\n              onComplete: onLayoutAnimationComplete\n            };\n            if (visualElement.shouldReduceMotion || this.options.layoutRoot) {\n              animationOptions.delay = 0;\n              animationOptions.type = false;\n            }\n            this.startAnimation(animationOptions);\n          } else {\n            if (!hasLayoutChanged) {\n              finishAnimation(this);\n            }\n            if (this.isLead() && this.options.onExitComplete) {\n              this.options.onExitComplete();\n            }\n          }\n          this.targetLayout = newLayout;\n        });\n      }\n    }\n    unmount() {\n      this.options.layoutId && this.willUpdate();\n      this.root.nodes.remove(this);\n      const stack = this.getStack();\n      stack && stack.remove(this);\n      this.parent && this.parent.children.delete(this);\n      this.instance = void 0;\n      cancelFrame(this.updateProjection);\n    }\n    // only on the root\n    blockUpdate() {\n      this.updateManuallyBlocked = true;\n    }\n    unblockUpdate() {\n      this.updateManuallyBlocked = false;\n    }\n    isUpdateBlocked() {\n      return this.updateManuallyBlocked || this.updateBlockedByResize;\n    }\n    isTreeAnimationBlocked() {\n      return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || false;\n    }\n    // Note: currently only running on root node\n    startUpdate() {\n      if (this.isUpdateBlocked())\n        return;\n      this.isUpdating = true;\n      this.nodes && this.nodes.forEach(resetSkewAndRotation);\n      this.animationId++;\n    }\n    getTransformTemplate() {\n      const { visualElement } = this.options;\n      return visualElement && visualElement.getProps().transformTemplate;\n    }\n    willUpdate(shouldNotifyListeners = true) {\n      this.root.hasTreeAnimated = true;\n      if (this.root.isUpdateBlocked()) {\n        this.options.onExitComplete && this.options.onExitComplete();\n        return;\n      }\n      !this.root.isUpdating && this.root.startUpdate();\n      if (this.isLayoutDirty)\n        return;\n      this.isLayoutDirty = true;\n      for (let i = 0; i < this.path.length; i++) {\n        const node = this.path[i];\n        node.shouldResetTransform = true;\n        node.updateScroll(\"snapshot\");\n        if (node.options.layoutRoot) {\n          node.willUpdate(false);\n        }\n      }\n      const { layoutId, layout: layout2 } = this.options;\n      if (layoutId === void 0 && !layout2)\n        return;\n      const transformTemplate = this.getTransformTemplate();\n      this.prevTransformTemplateValue = transformTemplate ? transformTemplate(this.latestValues, \"\") : void 0;\n      this.updateSnapshot();\n      shouldNotifyListeners && this.notifyListeners(\"willUpdate\");\n    }\n    update() {\n      this.updateScheduled = false;\n      const updateWasBlocked = this.isUpdateBlocked();\n      if (updateWasBlocked) {\n        this.unblockUpdate();\n        this.clearAllSnapshots();\n        this.nodes.forEach(clearMeasurements);\n        return;\n      }\n      if (!this.isUpdating) {\n        this.nodes.forEach(clearIsLayoutDirty);\n      }\n      this.isUpdating = false;\n      if (window.HandoffCancelAllAnimations) {\n        window.HandoffCancelAllAnimations();\n      }\n      this.nodes.forEach(resetTransformStyle);\n      this.nodes.forEach(updateLayout);\n      this.nodes.forEach(notifyLayoutUpdate);\n      this.clearAllSnapshots();\n      const now2 = time.now();\n      frameData.delta = clamp(0, 1e3 / 60, now2 - frameData.timestamp);\n      frameData.timestamp = now2;\n      frameData.isProcessing = true;\n      steps.update.process(frameData);\n      steps.preRender.process(frameData);\n      steps.render.process(frameData);\n      frameData.isProcessing = false;\n    }\n    didUpdate() {\n      if (!this.updateScheduled) {\n        this.updateScheduled = true;\n        microtask.read(() => this.update());\n      }\n    }\n    clearAllSnapshots() {\n      this.nodes.forEach(clearSnapshot);\n      this.sharedNodes.forEach(removeLeadSnapshots);\n    }\n    scheduleUpdateProjection() {\n      if (!this.projectionUpdateScheduled) {\n        this.projectionUpdateScheduled = true;\n        frame.preRender(this.updateProjection, false, true);\n      }\n    }\n    scheduleCheckAfterUnmount() {\n      frame.postRender(() => {\n        if (this.isLayoutDirty) {\n          this.root.didUpdate();\n        } else {\n          this.root.checkUpdateFailed();\n        }\n      });\n    }\n    /**\n     * Update measurements\n     */\n    updateSnapshot() {\n      if (this.snapshot || !this.instance)\n        return;\n      this.snapshot = this.measure();\n    }\n    updateLayout() {\n      if (!this.instance)\n        return;\n      this.updateScroll();\n      if (!(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty) {\n        return;\n      }\n      if (this.resumeFrom && !this.resumeFrom.instance) {\n        for (let i = 0; i < this.path.length; i++) {\n          const node = this.path[i];\n          node.updateScroll();\n        }\n      }\n      const prevLayout = this.layout;\n      this.layout = this.measure(false);\n      this.layoutCorrected = createBox();\n      this.isLayoutDirty = false;\n      this.projectionDelta = void 0;\n      this.notifyListeners(\"measure\", this.layout.layoutBox);\n      const { visualElement } = this.options;\n      visualElement && visualElement.notify(\"LayoutMeasure\", this.layout.layoutBox, prevLayout ? prevLayout.layoutBox : void 0);\n    }\n    updateScroll(phase = \"measure\") {\n      let needsMeasurement = Boolean(this.options.layoutScroll && this.instance);\n      if (this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === phase) {\n        needsMeasurement = false;\n      }\n      if (needsMeasurement) {\n        this.scroll = {\n          animationId: this.root.animationId,\n          phase,\n          isRoot: checkIsScrollRoot(this.instance),\n          offset: measureScroll(this.instance)\n        };\n      }\n    }\n    resetTransform() {\n      if (!resetTransform)\n        return;\n      const isResetRequested = this.isLayoutDirty || this.shouldResetTransform;\n      const hasProjection = this.projectionDelta && !isDeltaZero(this.projectionDelta);\n      const transformTemplate = this.getTransformTemplate();\n      const transformTemplateValue = transformTemplate ? transformTemplate(this.latestValues, \"\") : void 0;\n      const transformTemplateHasChanged = transformTemplateValue !== this.prevTransformTemplateValue;\n      if (isResetRequested && (hasProjection || hasTransform(this.latestValues) || transformTemplateHasChanged)) {\n        resetTransform(this.instance, transformTemplateValue);\n        this.shouldResetTransform = false;\n        this.scheduleRender();\n      }\n    }\n    measure(removeTransform = true) {\n      const pageBox = this.measurePageBox();\n      let layoutBox = this.removeElementScroll(pageBox);\n      if (removeTransform) {\n        layoutBox = this.removeTransform(layoutBox);\n      }\n      roundBox(layoutBox);\n      return {\n        animationId: this.root.animationId,\n        measuredBox: pageBox,\n        layoutBox,\n        latestValues: {},\n        source: this.id\n      };\n    }\n    measurePageBox() {\n      const { visualElement } = this.options;\n      if (!visualElement)\n        return createBox();\n      const box = visualElement.measureViewportBox();\n      const { scroll: scroll2 } = this.root;\n      if (scroll2) {\n        translateAxis(box.x, scroll2.offset.x);\n        translateAxis(box.y, scroll2.offset.y);\n      }\n      return box;\n    }\n    removeElementScroll(box) {\n      const boxWithoutScroll = createBox();\n      copyBoxInto(boxWithoutScroll, box);\n      for (let i = 0; i < this.path.length; i++) {\n        const node = this.path[i];\n        const { scroll: scroll2, options } = node;\n        if (node !== this.root && scroll2 && options.layoutScroll) {\n          if (scroll2.isRoot) {\n            copyBoxInto(boxWithoutScroll, box);\n            const { scroll: rootScroll } = this.root;\n            if (rootScroll) {\n              translateAxis(boxWithoutScroll.x, -rootScroll.offset.x);\n              translateAxis(boxWithoutScroll.y, -rootScroll.offset.y);\n            }\n          }\n          translateAxis(boxWithoutScroll.x, scroll2.offset.x);\n          translateAxis(boxWithoutScroll.y, scroll2.offset.y);\n        }\n      }\n      return boxWithoutScroll;\n    }\n    applyTransform(box, transformOnly = false) {\n      const withTransforms = createBox();\n      copyBoxInto(withTransforms, box);\n      for (let i = 0; i < this.path.length; i++) {\n        const node = this.path[i];\n        if (!transformOnly && node.options.layoutScroll && node.scroll && node !== node.root) {\n          transformBox(withTransforms, {\n            x: -node.scroll.offset.x,\n            y: -node.scroll.offset.y\n          });\n        }\n        if (!hasTransform(node.latestValues))\n          continue;\n        transformBox(withTransforms, node.latestValues);\n      }\n      if (hasTransform(this.latestValues)) {\n        transformBox(withTransforms, this.latestValues);\n      }\n      return withTransforms;\n    }\n    removeTransform(box) {\n      const boxWithoutTransform = createBox();\n      copyBoxInto(boxWithoutTransform, box);\n      for (let i = 0; i < this.path.length; i++) {\n        const node = this.path[i];\n        if (!node.instance)\n          continue;\n        if (!hasTransform(node.latestValues))\n          continue;\n        hasScale(node.latestValues) && node.updateSnapshot();\n        const sourceBox = createBox();\n        const nodeBox = node.measurePageBox();\n        copyBoxInto(sourceBox, nodeBox);\n        removeBoxTransforms(boxWithoutTransform, node.latestValues, node.snapshot ? node.snapshot.layoutBox : void 0, sourceBox);\n      }\n      if (hasTransform(this.latestValues)) {\n        removeBoxTransforms(boxWithoutTransform, this.latestValues);\n      }\n      return boxWithoutTransform;\n    }\n    setTargetDelta(delta) {\n      this.targetDelta = delta;\n      this.root.scheduleUpdateProjection();\n      this.isProjectionDirty = true;\n    }\n    setOptions(options) {\n      this.options = {\n        ...this.options,\n        ...options,\n        crossfade: options.crossfade !== void 0 ? options.crossfade : true\n      };\n    }\n    clearMeasurements() {\n      this.scroll = void 0;\n      this.layout = void 0;\n      this.snapshot = void 0;\n      this.prevTransformTemplateValue = void 0;\n      this.targetDelta = void 0;\n      this.target = void 0;\n      this.isLayoutDirty = false;\n    }\n    forceRelativeParentToResolveTarget() {\n      if (!this.relativeParent)\n        return;\n      if (this.relativeParent.resolvedRelativeTargetAt !== frameData.timestamp) {\n        this.relativeParent.resolveTargetDelta(true);\n      }\n    }\n    resolveTargetDelta(forceRecalculation = false) {\n      var _a;\n      const lead = this.getLead();\n      this.isProjectionDirty || (this.isProjectionDirty = lead.isProjectionDirty);\n      this.isTransformDirty || (this.isTransformDirty = lead.isTransformDirty);\n      this.isSharedProjectionDirty || (this.isSharedProjectionDirty = lead.isSharedProjectionDirty);\n      const isShared = Boolean(this.resumingFrom) || this !== lead;\n      const canSkip = !(forceRecalculation || isShared && this.isSharedProjectionDirty || this.isProjectionDirty || ((_a = this.parent) === null || _a === void 0 ? void 0 : _a.isProjectionDirty) || this.attemptToResolveRelativeTarget);\n      if (canSkip)\n        return;\n      const { layout: layout2, layoutId } = this.options;\n      if (!this.layout || !(layout2 || layoutId))\n        return;\n      this.resolvedRelativeTargetAt = frameData.timestamp;\n      if (!this.targetDelta && !this.relativeTarget) {\n        const relativeParent = this.getClosestProjectingParent();\n        if (relativeParent && relativeParent.layout && this.animationProgress !== 1) {\n          this.relativeParent = relativeParent;\n          this.forceRelativeParentToResolveTarget();\n          this.relativeTarget = createBox();\n          this.relativeTargetOrigin = createBox();\n          calcRelativePosition(this.relativeTargetOrigin, this.layout.layoutBox, relativeParent.layout.layoutBox);\n          copyBoxInto(this.relativeTarget, this.relativeTargetOrigin);\n        } else {\n          this.relativeParent = this.relativeTarget = void 0;\n        }\n      }\n      if (!this.relativeTarget && !this.targetDelta)\n        return;\n      if (!this.target) {\n        this.target = createBox();\n        this.targetWithTransforms = createBox();\n      }\n      if (this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target) {\n        this.forceRelativeParentToResolveTarget();\n        calcRelativeBox(this.target, this.relativeTarget, this.relativeParent.target);\n      } else if (this.targetDelta) {\n        if (Boolean(this.resumingFrom)) {\n          this.target = this.applyTransform(this.layout.layoutBox);\n        } else {\n          copyBoxInto(this.target, this.layout.layoutBox);\n        }\n        applyBoxDelta(this.target, this.targetDelta);\n      } else {\n        copyBoxInto(this.target, this.layout.layoutBox);\n      }\n      if (this.attemptToResolveRelativeTarget) {\n        this.attemptToResolveRelativeTarget = false;\n        const relativeParent = this.getClosestProjectingParent();\n        if (relativeParent && Boolean(relativeParent.resumingFrom) === Boolean(this.resumingFrom) && !relativeParent.options.layoutScroll && relativeParent.target && this.animationProgress !== 1) {\n          this.relativeParent = relativeParent;\n          this.forceRelativeParentToResolveTarget();\n          this.relativeTarget = createBox();\n          this.relativeTargetOrigin = createBox();\n          calcRelativePosition(this.relativeTargetOrigin, this.target, relativeParent.target);\n          copyBoxInto(this.relativeTarget, this.relativeTargetOrigin);\n        } else {\n          this.relativeParent = this.relativeTarget = void 0;\n        }\n      }\n      projectionFrameData.resolvedTargetDeltas++;\n    }\n    getClosestProjectingParent() {\n      if (!this.parent || hasScale(this.parent.latestValues) || has2DTranslate(this.parent.latestValues)) {\n        return void 0;\n      }\n      if (this.parent.isProjecting()) {\n        return this.parent;\n      } else {\n        return this.parent.getClosestProjectingParent();\n      }\n    }\n    isProjecting() {\n      return Boolean((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout);\n    }\n    calcProjection() {\n      var _a;\n      const lead = this.getLead();\n      const isShared = Boolean(this.resumingFrom) || this !== lead;\n      let canSkip = true;\n      if (this.isProjectionDirty || ((_a = this.parent) === null || _a === void 0 ? void 0 : _a.isProjectionDirty)) {\n        canSkip = false;\n      }\n      if (isShared && (this.isSharedProjectionDirty || this.isTransformDirty)) {\n        canSkip = false;\n      }\n      if (this.resolvedRelativeTargetAt === frameData.timestamp) {\n        canSkip = false;\n      }\n      if (canSkip)\n        return;\n      const { layout: layout2, layoutId } = this.options;\n      this.isTreeAnimating = Boolean(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation);\n      if (!this.isTreeAnimating) {\n        this.targetDelta = this.relativeTarget = void 0;\n      }\n      if (!this.layout || !(layout2 || layoutId))\n        return;\n      copyBoxInto(this.layoutCorrected, this.layout.layoutBox);\n      const prevTreeScaleX = this.treeScale.x;\n      const prevTreeScaleY = this.treeScale.y;\n      applyTreeDeltas(this.layoutCorrected, this.treeScale, this.path, isShared);\n      if (lead.layout && !lead.target && (this.treeScale.x !== 1 || this.treeScale.y !== 1)) {\n        lead.target = lead.layout.layoutBox;\n        lead.targetWithTransforms = createBox();\n      }\n      const { target } = lead;\n      if (!target) {\n        if (this.projectionTransform) {\n          this.projectionDelta = createDelta();\n          this.projectionTransform = \"none\";\n          this.scheduleRender();\n        }\n        return;\n      }\n      if (!this.projectionDelta) {\n        this.projectionDelta = createDelta();\n        this.projectionDeltaWithTransform = createDelta();\n      }\n      const prevProjectionTransform = this.projectionTransform;\n      calcBoxDelta(this.projectionDelta, this.layoutCorrected, target, this.latestValues);\n      this.projectionTransform = buildProjectionTransform(this.projectionDelta, this.treeScale);\n      if (this.projectionTransform !== prevProjectionTransform || this.treeScale.x !== prevTreeScaleX || this.treeScale.y !== prevTreeScaleY) {\n        this.hasProjected = true;\n        this.scheduleRender();\n        this.notifyListeners(\"projectionUpdate\", target);\n      }\n      projectionFrameData.recalculatedProjection++;\n    }\n    hide() {\n      this.isVisible = false;\n    }\n    show() {\n      this.isVisible = true;\n    }\n    scheduleRender(notifyAll2 = true) {\n      this.options.scheduleRender && this.options.scheduleRender();\n      if (notifyAll2) {\n        const stack = this.getStack();\n        stack && stack.scheduleRender();\n      }\n      if (this.resumingFrom && !this.resumingFrom.instance) {\n        this.resumingFrom = void 0;\n      }\n    }\n    setAnimationOrigin(delta, hasOnlyRelativeTargetChanged = false) {\n      const snapshot = this.snapshot;\n      const snapshotLatestValues = snapshot ? snapshot.latestValues : {};\n      const mixedValues = { ...this.latestValues };\n      const targetDelta = createDelta();\n      if (!this.relativeParent || !this.relativeParent.options.layoutRoot) {\n        this.relativeTarget = this.relativeTargetOrigin = void 0;\n      }\n      this.attemptToResolveRelativeTarget = !hasOnlyRelativeTargetChanged;\n      const relativeLayout = createBox();\n      const snapshotSource = snapshot ? snapshot.source : void 0;\n      const layoutSource = this.layout ? this.layout.source : void 0;\n      const isSharedLayoutAnimation = snapshotSource !== layoutSource;\n      const stack = this.getStack();\n      const isOnlyMember = !stack || stack.members.length <= 1;\n      const shouldCrossfadeOpacity = Boolean(isSharedLayoutAnimation && !isOnlyMember && this.options.crossfade === true && !this.path.some(hasOpacityCrossfade));\n      this.animationProgress = 0;\n      let prevRelativeTarget;\n      this.mixTargetDelta = (latest) => {\n        const progress2 = latest / 1e3;\n        mixAxisDelta(targetDelta.x, delta.x, progress2);\n        mixAxisDelta(targetDelta.y, delta.y, progress2);\n        this.setTargetDelta(targetDelta);\n        if (this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout) {\n          calcRelativePosition(relativeLayout, this.layout.layoutBox, this.relativeParent.layout.layoutBox);\n          mixBox(this.relativeTarget, this.relativeTargetOrigin, relativeLayout, progress2);\n          if (prevRelativeTarget && boxEquals(this.relativeTarget, prevRelativeTarget)) {\n            this.isProjectionDirty = false;\n          }\n          if (!prevRelativeTarget)\n            prevRelativeTarget = createBox();\n          copyBoxInto(prevRelativeTarget, this.relativeTarget);\n        }\n        if (isSharedLayoutAnimation) {\n          this.animationValues = mixedValues;\n          mixValues(mixedValues, snapshotLatestValues, this.latestValues, progress2, shouldCrossfadeOpacity, isOnlyMember);\n        }\n        this.root.scheduleUpdateProjection();\n        this.scheduleRender();\n        this.animationProgress = progress2;\n      };\n      this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0);\n    }\n    startAnimation(options) {\n      this.notifyListeners(\"animationStart\");\n      this.currentAnimation && this.currentAnimation.stop();\n      if (this.resumingFrom && this.resumingFrom.currentAnimation) {\n        this.resumingFrom.currentAnimation.stop();\n      }\n      if (this.pendingAnimation) {\n        cancelFrame(this.pendingAnimation);\n        this.pendingAnimation = void 0;\n      }\n      this.pendingAnimation = frame.update(() => {\n        globalProjectionState.hasAnimatedSinceResize = true;\n        this.currentAnimation = animateSingleValue(0, animationTarget, {\n          ...options,\n          onUpdate: (latest) => {\n            this.mixTargetDelta(latest);\n            options.onUpdate && options.onUpdate(latest);\n          },\n          onComplete: () => {\n            options.onComplete && options.onComplete();\n            this.completeAnimation();\n          }\n        });\n        if (this.resumingFrom) {\n          this.resumingFrom.currentAnimation = this.currentAnimation;\n        }\n        this.pendingAnimation = void 0;\n      });\n    }\n    completeAnimation() {\n      if (this.resumingFrom) {\n        this.resumingFrom.currentAnimation = void 0;\n        this.resumingFrom.preserveOpacity = void 0;\n      }\n      const stack = this.getStack();\n      stack && stack.exitAnimationComplete();\n      this.resumingFrom = this.currentAnimation = this.animationValues = void 0;\n      this.notifyListeners(\"animationComplete\");\n    }\n    finishAnimation() {\n      if (this.currentAnimation) {\n        this.mixTargetDelta && this.mixTargetDelta(animationTarget);\n        this.currentAnimation.stop();\n      }\n      this.completeAnimation();\n    }\n    applyTransformsToTarget() {\n      const lead = this.getLead();\n      let { targetWithTransforms, target, layout: layout2, latestValues } = lead;\n      if (!targetWithTransforms || !target || !layout2)\n        return;\n      if (this !== lead && this.layout && layout2 && shouldAnimatePositionOnly(this.options.animationType, this.layout.layoutBox, layout2.layoutBox)) {\n        target = this.target || createBox();\n        const xLength = calcLength(this.layout.layoutBox.x);\n        target.x.min = lead.target.x.min;\n        target.x.max = target.x.min + xLength;\n        const yLength = calcLength(this.layout.layoutBox.y);\n        target.y.min = lead.target.y.min;\n        target.y.max = target.y.min + yLength;\n      }\n      copyBoxInto(targetWithTransforms, target);\n      transformBox(targetWithTransforms, latestValues);\n      calcBoxDelta(this.projectionDeltaWithTransform, this.layoutCorrected, targetWithTransforms, latestValues);\n    }\n    registerSharedNode(layoutId, node) {\n      if (!this.sharedNodes.has(layoutId)) {\n        this.sharedNodes.set(layoutId, new NodeStack());\n      }\n      const stack = this.sharedNodes.get(layoutId);\n      stack.add(node);\n      const config = node.options.initialPromotionConfig;\n      node.promote({\n        transition: config ? config.transition : void 0,\n        preserveFollowOpacity: config && config.shouldPreserveFollowOpacity ? config.shouldPreserveFollowOpacity(node) : void 0\n      });\n    }\n    isLead() {\n      const stack = this.getStack();\n      return stack ? stack.lead === this : true;\n    }\n    getLead() {\n      var _a;\n      const { layoutId } = this.options;\n      return layoutId ? ((_a = this.getStack()) === null || _a === void 0 ? void 0 : _a.lead) || this : this;\n    }\n    getPrevLead() {\n      var _a;\n      const { layoutId } = this.options;\n      return layoutId ? (_a = this.getStack()) === null || _a === void 0 ? void 0 : _a.prevLead : void 0;\n    }\n    getStack() {\n      const { layoutId } = this.options;\n      if (layoutId)\n        return this.root.sharedNodes.get(layoutId);\n    }\n    promote({ needsReset, transition, preserveFollowOpacity } = {}) {\n      const stack = this.getStack();\n      if (stack)\n        stack.promote(this, preserveFollowOpacity);\n      if (needsReset) {\n        this.projectionDelta = void 0;\n        this.needsReset = true;\n      }\n      if (transition)\n        this.setOptions({ transition });\n    }\n    relegate() {\n      const stack = this.getStack();\n      if (stack) {\n        return stack.relegate(this);\n      } else {\n        return false;\n      }\n    }\n    resetSkewAndRotation() {\n      const { visualElement } = this.options;\n      if (!visualElement)\n        return;\n      let hasDistortingTransform = false;\n      const { latestValues } = visualElement;\n      if (latestValues.z || latestValues.rotate || latestValues.rotateX || latestValues.rotateY || latestValues.rotateZ || latestValues.skewX || latestValues.skewY) {\n        hasDistortingTransform = true;\n      }\n      if (!hasDistortingTransform)\n        return;\n      const resetValues = {};\n      if (latestValues.z) {\n        resetDistortingTransform(\"z\", visualElement, resetValues, this.animationValues);\n      }\n      for (let i = 0; i < transformAxes.length; i++) {\n        resetDistortingTransform(`rotate${transformAxes[i]}`, visualElement, resetValues, this.animationValues);\n        resetDistortingTransform(`skew${transformAxes[i]}`, visualElement, resetValues, this.animationValues);\n      }\n      visualElement.render();\n      for (const key in resetValues) {\n        visualElement.setStaticValue(key, resetValues[key]);\n        if (this.animationValues) {\n          this.animationValues[key] = resetValues[key];\n        }\n      }\n      visualElement.scheduleRender();\n    }\n    getProjectionStyles(styleProp) {\n      var _a, _b;\n      if (!this.instance || this.isSVG)\n        return void 0;\n      if (!this.isVisible) {\n        return hiddenVisibility;\n      }\n      const styles = {\n        visibility: \"\"\n      };\n      const transformTemplate = this.getTransformTemplate();\n      if (this.needsReset) {\n        this.needsReset = false;\n        styles.opacity = \"\";\n        styles.pointerEvents = resolveMotionValue(styleProp === null || styleProp === void 0 ? void 0 : styleProp.pointerEvents) || \"\";\n        styles.transform = transformTemplate ? transformTemplate(this.latestValues, \"\") : \"none\";\n        return styles;\n      }\n      const lead = this.getLead();\n      if (!this.projectionDelta || !this.layout || !lead.target) {\n        const emptyStyles = {};\n        if (this.options.layoutId) {\n          emptyStyles.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1;\n          emptyStyles.pointerEvents = resolveMotionValue(styleProp === null || styleProp === void 0 ? void 0 : styleProp.pointerEvents) || \"\";\n        }\n        if (this.hasProjected && !hasTransform(this.latestValues)) {\n          emptyStyles.transform = transformTemplate ? transformTemplate({}, \"\") : \"none\";\n          this.hasProjected = false;\n        }\n        return emptyStyles;\n      }\n      const valuesToRender = lead.animationValues || lead.latestValues;\n      this.applyTransformsToTarget();\n      styles.transform = buildProjectionTransform(this.projectionDeltaWithTransform, this.treeScale, valuesToRender);\n      if (transformTemplate) {\n        styles.transform = transformTemplate(valuesToRender, styles.transform);\n      }\n      const { x, y } = this.projectionDelta;\n      styles.transformOrigin = `${x.origin * 100}% ${y.origin * 100}% 0`;\n      if (lead.animationValues) {\n        styles.opacity = lead === this ? (_b = (_a = valuesToRender.opacity) !== null && _a !== void 0 ? _a : this.latestValues.opacity) !== null && _b !== void 0 ? _b : 1 : this.preserveOpacity ? this.latestValues.opacity : valuesToRender.opacityExit;\n      } else {\n        styles.opacity = lead === this ? valuesToRender.opacity !== void 0 ? valuesToRender.opacity : \"\" : valuesToRender.opacityExit !== void 0 ? valuesToRender.opacityExit : 0;\n      }\n      for (const key in scaleCorrectors) {\n        if (valuesToRender[key] === void 0)\n          continue;\n        const { correct, applyTo } = scaleCorrectors[key];\n        const corrected = styles.transform === \"none\" ? valuesToRender[key] : correct(valuesToRender[key], lead);\n        if (applyTo) {\n          const num = applyTo.length;\n          for (let i = 0; i < num; i++) {\n            styles[applyTo[i]] = corrected;\n          }\n        } else {\n          styles[key] = corrected;\n        }\n      }\n      if (this.options.layoutId) {\n        styles.pointerEvents = lead === this ? resolveMotionValue(styleProp === null || styleProp === void 0 ? void 0 : styleProp.pointerEvents) || \"\" : \"none\";\n      }\n      return styles;\n    }\n    clearSnapshot() {\n      this.resumeFrom = this.snapshot = void 0;\n    }\n    // Only run on root\n    resetTree() {\n      this.root.nodes.forEach((node) => {\n        var _a;\n        return (_a = node.currentAnimation) === null || _a === void 0 ? void 0 : _a.stop();\n      });\n      this.root.nodes.forEach(clearMeasurements);\n      this.root.sharedNodes.clear();\n    }\n  };\n}\nfunction updateLayout(node) {\n  node.updateLayout();\n}\nfunction notifyLayoutUpdate(node) {\n  var _a;\n  const snapshot = ((_a = node.resumeFrom) === null || _a === void 0 ? void 0 : _a.snapshot) || node.snapshot;\n  if (node.isLead() && node.layout && snapshot && node.hasListeners(\"didUpdate\")) {\n    const { layoutBox: layout2, measuredBox: measuredLayout } = node.layout;\n    const { animationType } = node.options;\n    const isShared = snapshot.source !== node.layout.source;\n    if (animationType === \"size\") {\n      eachAxis((axis) => {\n        const axisSnapshot = isShared ? snapshot.measuredBox[axis] : snapshot.layoutBox[axis];\n        const length = calcLength(axisSnapshot);\n        axisSnapshot.min = layout2[axis].min;\n        axisSnapshot.max = axisSnapshot.min + length;\n      });\n    } else if (shouldAnimatePositionOnly(animationType, snapshot.layoutBox, layout2)) {\n      eachAxis((axis) => {\n        const axisSnapshot = isShared ? snapshot.measuredBox[axis] : snapshot.layoutBox[axis];\n        const length = calcLength(layout2[axis]);\n        axisSnapshot.max = axisSnapshot.min + length;\n        if (node.relativeTarget && !node.currentAnimation) {\n          node.isProjectionDirty = true;\n          node.relativeTarget[axis].max = node.relativeTarget[axis].min + length;\n        }\n      });\n    }\n    const layoutDelta = createDelta();\n    calcBoxDelta(layoutDelta, layout2, snapshot.layoutBox);\n    const visualDelta = createDelta();\n    if (isShared) {\n      calcBoxDelta(visualDelta, node.applyTransform(measuredLayout, true), snapshot.measuredBox);\n    } else {\n      calcBoxDelta(visualDelta, layout2, snapshot.layoutBox);\n    }\n    const hasLayoutChanged = !isDeltaZero(layoutDelta);\n    let hasRelativeTargetChanged = false;\n    if (!node.resumeFrom) {\n      const relativeParent = node.getClosestProjectingParent();\n      if (relativeParent && !relativeParent.resumeFrom) {\n        const { snapshot: parentSnapshot, layout: parentLayout } = relativeParent;\n        if (parentSnapshot && parentLayout) {\n          const relativeSnapshot = createBox();\n          calcRelativePosition(relativeSnapshot, snapshot.layoutBox, parentSnapshot.layoutBox);\n          const relativeLayout = createBox();\n          calcRelativePosition(relativeLayout, layout2, parentLayout.layoutBox);\n          if (!boxEqualsRounded(relativeSnapshot, relativeLayout)) {\n            hasRelativeTargetChanged = true;\n          }\n          if (relativeParent.options.layoutRoot) {\n            node.relativeTarget = relativeLayout;\n            node.relativeTargetOrigin = relativeSnapshot;\n            node.relativeParent = relativeParent;\n          }\n        }\n      }\n    }\n    node.notifyListeners(\"didUpdate\", {\n      layout: layout2,\n      snapshot,\n      delta: visualDelta,\n      layoutDelta,\n      hasLayoutChanged,\n      hasRelativeTargetChanged\n    });\n  } else if (node.isLead()) {\n    const { onExitComplete } = node.options;\n    onExitComplete && onExitComplete();\n  }\n  node.options.transition = void 0;\n}\nfunction propagateDirtyNodes(node) {\n  projectionFrameData.totalNodes++;\n  if (!node.parent)\n    return;\n  if (!node.isProjecting()) {\n    node.isProjectionDirty = node.parent.isProjectionDirty;\n  }\n  node.isSharedProjectionDirty || (node.isSharedProjectionDirty = Boolean(node.isProjectionDirty || node.parent.isProjectionDirty || node.parent.isSharedProjectionDirty));\n  node.isTransformDirty || (node.isTransformDirty = node.parent.isTransformDirty);\n}\nfunction cleanDirtyNodes(node) {\n  node.isProjectionDirty = node.isSharedProjectionDirty = node.isTransformDirty = false;\n}\nfunction clearSnapshot(node) {\n  node.clearSnapshot();\n}\nfunction clearMeasurements(node) {\n  node.clearMeasurements();\n}\nfunction clearIsLayoutDirty(node) {\n  node.isLayoutDirty = false;\n}\nfunction resetTransformStyle(node) {\n  const { visualElement } = node.options;\n  if (visualElement && visualElement.getProps().onBeforeLayoutMeasure) {\n    visualElement.notify(\"BeforeLayoutMeasure\");\n  }\n  node.resetTransform();\n}\nfunction finishAnimation(node) {\n  node.finishAnimation();\n  node.targetDelta = node.relativeTarget = node.target = void 0;\n  node.isProjectionDirty = true;\n}\nfunction resolveTargetDelta(node) {\n  node.resolveTargetDelta();\n}\nfunction calcProjection(node) {\n  node.calcProjection();\n}\nfunction resetSkewAndRotation(node) {\n  node.resetSkewAndRotation();\n}\nfunction removeLeadSnapshots(stack) {\n  stack.removeLeadSnapshot();\n}\nfunction mixAxisDelta(output, delta, p) {\n  output.translate = mixNumber(delta.translate, 0, p);\n  output.scale = mixNumber(delta.scale, 1, p);\n  output.origin = delta.origin;\n  output.originPoint = delta.originPoint;\n}\nfunction mixAxis(output, from, to, p) {\n  output.min = mixNumber(from.min, to.min, p);\n  output.max = mixNumber(from.max, to.max, p);\n}\nfunction mixBox(output, from, to, p) {\n  mixAxis(output.x, from.x, to.x, p);\n  mixAxis(output.y, from.y, to.y, p);\n}\nfunction hasOpacityCrossfade(node) {\n  return node.animationValues && node.animationValues.opacityExit !== void 0;\n}\nvar defaultLayoutTransition = {\n  duration: 0.45,\n  ease: [0.4, 0, 0.1, 1]\n};\nvar userAgentContains = (string) => typeof navigator !== \"undefined\" && navigator.userAgent && navigator.userAgent.toLowerCase().includes(string);\nvar roundPoint = userAgentContains(\"applewebkit/\") && !userAgentContains(\"chrome/\") ? Math.round : noop;\nfunction roundAxis(axis) {\n  axis.min = roundPoint(axis.min);\n  axis.max = roundPoint(axis.max);\n}\nfunction roundBox(box) {\n  roundAxis(box.x);\n  roundAxis(box.y);\n}\nfunction shouldAnimatePositionOnly(animationType, snapshot, layout2) {\n  return animationType === \"position\" || animationType === \"preserve-aspect\" && !isNear(aspectRatio(snapshot), aspectRatio(layout2), 0.2);\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/projection/node/DocumentProjectionNode.mjs\nvar DocumentProjectionNode = createProjectionNode({\n  attachResizeListener: (ref, notify2) => addDomEvent(ref, \"resize\", notify2),\n  measureScroll: () => ({\n    x: document.documentElement.scrollLeft || document.body.scrollLeft,\n    y: document.documentElement.scrollTop || document.body.scrollTop\n  }),\n  checkIsScrollRoot: () => true\n});\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/projection/node/HTMLProjectionNode.mjs\nvar rootProjectionNode = {\n  current: void 0\n};\nvar HTMLProjectionNode = createProjectionNode({\n  measureScroll: (instance) => ({\n    x: instance.scrollLeft,\n    y: instance.scrollTop\n  }),\n  defaultParent: () => {\n    if (!rootProjectionNode.current) {\n      const documentNode = new DocumentProjectionNode({});\n      documentNode.mount(window);\n      documentNode.setOptions({ layoutScroll: true });\n      rootProjectionNode.current = documentNode;\n    }\n    return rootProjectionNode.current;\n  },\n  resetTransform: (instance, value) => {\n    instance.style.transform = value !== void 0 ? value : \"none\";\n  },\n  checkIsScrollRoot: (instance) => Boolean(window.getComputedStyle(instance).position === \"fixed\")\n});\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/motion/features/drag.mjs\nvar drag = {\n  pan: {\n    Feature: PanGesture\n  },\n  drag: {\n    Feature: DragGesture,\n    ProjectionNode: HTMLProjectionNode,\n    MeasureLayout\n  }\n};\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/utils/reduced-motion/state.mjs\nvar prefersReducedMotion = { current: null };\nvar hasReducedMotionListener = { current: false };\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/utils/reduced-motion/index.mjs\nfunction initPrefersReducedMotion() {\n  hasReducedMotionListener.current = true;\n  if (!isBrowser)\n    return;\n  if (window.matchMedia) {\n    const motionMediaQuery = window.matchMedia(\"(prefers-reduced-motion)\");\n    const setReducedMotionPreferences = () => prefersReducedMotion.current = motionMediaQuery.matches;\n    motionMediaQuery.addListener(setReducedMotionPreferences);\n    setReducedMotionPreferences();\n  } else {\n    prefersReducedMotion.current = false;\n  }\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/utils/motion-values.mjs\nfunction updateMotionValuesFromProps(element, next, prev) {\n  const { willChange } = next;\n  for (const key in next) {\n    const nextValue = next[key];\n    const prevValue = prev[key];\n    if (isMotionValue(nextValue)) {\n      element.addValue(key, nextValue);\n      if (isWillChangeMotionValue(willChange)) {\n        willChange.add(key);\n      }\n      if (true) {\n        warnOnce(nextValue.version === \"11.0.24\", `Attempting to mix Framer Motion versions ${nextValue.version} with 11.0.24 may not work as expected.`);\n      }\n    } else if (isMotionValue(prevValue)) {\n      element.addValue(key, motionValue(nextValue, { owner: element }));\n      if (isWillChangeMotionValue(willChange)) {\n        willChange.remove(key);\n      }\n    } else if (prevValue !== nextValue) {\n      if (element.hasValue(key)) {\n        const existingValue = element.getValue(key);\n        if (existingValue.liveStyle === true) {\n          existingValue.jump(nextValue);\n        } else if (!existingValue.hasAnimated) {\n          existingValue.set(nextValue);\n        }\n      } else {\n        const latestValue = element.getStaticValue(key);\n        element.addValue(key, motionValue(latestValue !== void 0 ? latestValue : nextValue, { owner: element }));\n      }\n    }\n  }\n  for (const key in prev) {\n    if (next[key] === void 0)\n      element.removeValue(key);\n  }\n  return next;\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/store.mjs\nvar visualElementStore = /* @__PURE__ */ new WeakMap();\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/dom/value-types/find.mjs\nvar valueTypes = [...dimensionValueTypes, color, complex];\nvar findValueType = (v) => valueTypes.find(testValueType(v));\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/VisualElement.mjs\nvar featureNames = Object.keys(featureDefinitions);\nvar numFeatures = featureNames.length;\nvar propEventHandlers = [\n  \"AnimationStart\",\n  \"AnimationComplete\",\n  \"Update\",\n  \"BeforeLayoutMeasure\",\n  \"LayoutMeasure\",\n  \"LayoutAnimationStart\",\n  \"LayoutAnimationComplete\"\n];\nvar numVariantProps = variantProps.length;\nvar VisualElement = class {\n  constructor({ parent, props, presenceContext, reducedMotionConfig, blockInitialAnimation, visualState }, options = {}) {\n    this.resolveKeyframes = (keyframes2, onComplete, name, value) => {\n      return new this.KeyframeResolver(keyframes2, onComplete, name, value, this);\n    };\n    this.current = null;\n    this.children = /* @__PURE__ */ new Set();\n    this.isVariantNode = false;\n    this.isControllingVariants = false;\n    this.shouldReduceMotion = null;\n    this.values = /* @__PURE__ */ new Map();\n    this.KeyframeResolver = KeyframeResolver;\n    this.features = {};\n    this.valueSubscriptions = /* @__PURE__ */ new Map();\n    this.prevMotionValues = {};\n    this.events = {};\n    this.propEventSubscriptions = {};\n    this.notifyUpdate = () => this.notify(\"Update\", this.latestValues);\n    this.render = () => {\n      if (!this.current)\n        return;\n      this.triggerBuild();\n      this.renderInstance(this.current, this.renderState, this.props.style, this.projection);\n    };\n    this.scheduleRender = () => frame.render(this.render, false, true);\n    const { latestValues, renderState } = visualState;\n    this.latestValues = latestValues;\n    this.baseTarget = { ...latestValues };\n    this.initialValues = props.initial ? { ...latestValues } : {};\n    this.renderState = renderState;\n    this.parent = parent;\n    this.props = props;\n    this.presenceContext = presenceContext;\n    this.depth = parent ? parent.depth + 1 : 0;\n    this.reducedMotionConfig = reducedMotionConfig;\n    this.options = options;\n    this.blockInitialAnimation = Boolean(blockInitialAnimation);\n    this.isControllingVariants = isControllingVariants(props);\n    this.isVariantNode = isVariantNode(props);\n    if (this.isVariantNode) {\n      this.variantChildren = /* @__PURE__ */ new Set();\n    }\n    this.manuallyAnimateOnMount = Boolean(parent && parent.current);\n    const { willChange, ...initialMotionValues } = this.scrapeMotionValuesFromProps(props, {}, this);\n    for (const key in initialMotionValues) {\n      const value = initialMotionValues[key];\n      if (latestValues[key] !== void 0 && isMotionValue(value)) {\n        value.set(latestValues[key], false);\n        if (isWillChangeMotionValue(willChange)) {\n          willChange.add(key);\n        }\n      }\n    }\n  }\n  /**\n   * This method takes React props and returns found MotionValues. For example, HTML\n   * MotionValues will be found within the style prop, whereas for Three.js within attribute arrays.\n   *\n   * This isn't an abstract method as it needs calling in the constructor, but it is\n   * intended to be one.\n   */\n  scrapeMotionValuesFromProps(_props, _prevProps, _visualElement) {\n    return {};\n  }\n  mount(instance) {\n    this.current = instance;\n    visualElementStore.set(instance, this);\n    if (this.projection && !this.projection.instance) {\n      this.projection.mount(instance);\n    }\n    if (this.parent && this.isVariantNode && !this.isControllingVariants) {\n      this.removeFromVariantTree = this.parent.addVariantChild(this);\n    }\n    this.values.forEach((value, key) => this.bindToMotionValue(key, value));\n    if (!hasReducedMotionListener.current) {\n      initPrefersReducedMotion();\n    }\n    this.shouldReduceMotion = this.reducedMotionConfig === \"never\" ? false : this.reducedMotionConfig === \"always\" ? true : prefersReducedMotion.current;\n    if (true) {\n      warnOnce(this.shouldReduceMotion !== true, \"You have Reduced Motion enabled on your device. Animations may not appear as expected.\");\n    }\n    if (this.parent)\n      this.parent.children.add(this);\n    this.update(this.props, this.presenceContext);\n  }\n  unmount() {\n    visualElementStore.delete(this.current);\n    this.projection && this.projection.unmount();\n    cancelFrame(this.notifyUpdate);\n    cancelFrame(this.render);\n    this.valueSubscriptions.forEach((remove) => remove());\n    this.removeFromVariantTree && this.removeFromVariantTree();\n    this.parent && this.parent.children.delete(this);\n    for (const key in this.events) {\n      this.events[key].clear();\n    }\n    for (const key in this.features) {\n      this.features[key].unmount();\n    }\n    this.current = null;\n  }\n  bindToMotionValue(key, value) {\n    const valueIsTransform = transformProps.has(key);\n    const removeOnChange = value.on(\"change\", (latestValue) => {\n      this.latestValues[key] = latestValue;\n      this.props.onUpdate && frame.preRender(this.notifyUpdate);\n      if (valueIsTransform && this.projection) {\n        this.projection.isTransformDirty = true;\n      }\n    });\n    const removeOnRenderRequest = value.on(\"renderRequest\", this.scheduleRender);\n    this.valueSubscriptions.set(key, () => {\n      removeOnChange();\n      removeOnRenderRequest();\n      if (value.owner)\n        value.stop();\n    });\n  }\n  sortNodePosition(other) {\n    if (!this.current || !this.sortInstanceNodePosition || this.type !== other.type) {\n      return 0;\n    }\n    return this.sortInstanceNodePosition(this.current, other.current);\n  }\n  loadFeatures({ children, ...renderedProps }, isStrict, preloadedFeatures2, initialLayoutGroupConfig) {\n    let ProjectionNodeConstructor;\n    let MeasureLayout2;\n    if (preloadedFeatures2 && isStrict) {\n      const strictMessage = \"You have rendered a `motion` component within a `LazyMotion` component. This will break tree shaking. Import and render a `m` component instead.\";\n      renderedProps.ignoreStrict ? warning(false, strictMessage) : invariant(false, strictMessage);\n    }\n    for (let i = 0; i < numFeatures; i++) {\n      const name = featureNames[i];\n      const { isEnabled, Feature: FeatureConstructor, ProjectionNode, MeasureLayout: MeasureLayoutComponent } = featureDefinitions[name];\n      if (ProjectionNode)\n        ProjectionNodeConstructor = ProjectionNode;\n      if (isEnabled(renderedProps)) {\n        if (!this.features[name] && FeatureConstructor) {\n          this.features[name] = new FeatureConstructor(this);\n        }\n        if (MeasureLayoutComponent) {\n          MeasureLayout2 = MeasureLayoutComponent;\n        }\n      }\n    }\n    if ((this.type === \"html\" || this.type === \"svg\") && !this.projection && ProjectionNodeConstructor) {\n      this.projection = new ProjectionNodeConstructor(this.latestValues, this.parent && this.parent.projection);\n      const { layoutId, layout: layout2, drag: drag2, dragConstraints, layoutScroll, layoutRoot } = renderedProps;\n      this.projection.setOptions({\n        layoutId,\n        layout: layout2,\n        alwaysMeasureLayout: Boolean(drag2) || dragConstraints && isRefObject(dragConstraints),\n        visualElement: this,\n        scheduleRender: () => this.scheduleRender(),\n        /**\n         * TODO: Update options in an effect. This could be tricky as it'll be too late\n         * to update by the time layout animations run.\n         * We also need to fix this safeToRemove by linking it up to the one returned by usePresence,\n         * ensuring it gets called if there's no potential layout animations.\n         *\n         */\n        animationType: typeof layout2 === \"string\" ? layout2 : \"both\",\n        initialPromotionConfig: initialLayoutGroupConfig,\n        layoutScroll,\n        layoutRoot\n      });\n    }\n    return MeasureLayout2;\n  }\n  updateFeatures() {\n    for (const key in this.features) {\n      const feature = this.features[key];\n      if (feature.isMounted) {\n        feature.update();\n      } else {\n        feature.mount();\n        feature.isMounted = true;\n      }\n    }\n  }\n  triggerBuild() {\n    this.build(this.renderState, this.latestValues, this.options, this.props);\n  }\n  /**\n   * Measure the current viewport box with or without transforms.\n   * Only measures axis-aligned boxes, rotate and skew must be manually\n   * removed with a re-render to work.\n   */\n  measureViewportBox() {\n    return this.current ? this.measureInstanceViewportBox(this.current, this.props) : createBox();\n  }\n  getStaticValue(key) {\n    return this.latestValues[key];\n  }\n  setStaticValue(key, value) {\n    this.latestValues[key] = value;\n  }\n  /**\n   * Update the provided props. Ensure any newly-added motion values are\n   * added to our map, old ones removed, and listeners updated.\n   */\n  update(props, presenceContext) {\n    if (props.transformTemplate || this.props.transformTemplate) {\n      this.scheduleRender();\n    }\n    this.prevProps = this.props;\n    this.props = props;\n    this.prevPresenceContext = this.presenceContext;\n    this.presenceContext = presenceContext;\n    for (let i = 0; i < propEventHandlers.length; i++) {\n      const key = propEventHandlers[i];\n      if (this.propEventSubscriptions[key]) {\n        this.propEventSubscriptions[key]();\n        delete this.propEventSubscriptions[key];\n      }\n      const listener = props[\"on\" + key];\n      if (listener) {\n        this.propEventSubscriptions[key] = this.on(key, listener);\n      }\n    }\n    this.prevMotionValues = updateMotionValuesFromProps(this, this.scrapeMotionValuesFromProps(props, this.prevProps, this), this.prevMotionValues);\n    if (this.handleChildMotionValue) {\n      this.handleChildMotionValue();\n    }\n  }\n  getProps() {\n    return this.props;\n  }\n  /**\n   * Returns the variant definition with a given name.\n   */\n  getVariant(name) {\n    return this.props.variants ? this.props.variants[name] : void 0;\n  }\n  /**\n   * Returns the defined default transition on this component.\n   */\n  getDefaultTransition() {\n    return this.props.transition;\n  }\n  getTransformPagePoint() {\n    return this.props.transformPagePoint;\n  }\n  getClosestVariantNode() {\n    return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0;\n  }\n  getVariantContext(startAtParent = false) {\n    if (startAtParent) {\n      return this.parent ? this.parent.getVariantContext() : void 0;\n    }\n    if (!this.isControllingVariants) {\n      const context2 = this.parent ? this.parent.getVariantContext() || {} : {};\n      if (this.props.initial !== void 0) {\n        context2.initial = this.props.initial;\n      }\n      return context2;\n    }\n    const context = {};\n    for (let i = 0; i < numVariantProps; i++) {\n      const name = variantProps[i];\n      const prop = this.props[name];\n      if (isVariantLabel(prop) || prop === false) {\n        context[name] = prop;\n      }\n    }\n    return context;\n  }\n  /**\n   * Add a child visual element to our set of children.\n   */\n  addVariantChild(child) {\n    const closestVariantNode = this.getClosestVariantNode();\n    if (closestVariantNode) {\n      closestVariantNode.variantChildren && closestVariantNode.variantChildren.add(child);\n      return () => closestVariantNode.variantChildren.delete(child);\n    }\n  }\n  /**\n   * Add a motion value and bind it to this visual element.\n   */\n  addValue(key, value) {\n    if (value !== this.values.get(key)) {\n      this.removeValue(key);\n      this.bindToMotionValue(key, value);\n    }\n    this.values.set(key, value);\n    this.latestValues[key] = value.get();\n  }\n  /**\n   * Remove a motion value and unbind any active subscriptions.\n   */\n  removeValue(key) {\n    this.values.delete(key);\n    const unsubscribe = this.valueSubscriptions.get(key);\n    if (unsubscribe) {\n      unsubscribe();\n      this.valueSubscriptions.delete(key);\n    }\n    delete this.latestValues[key];\n    this.removeValueFromRenderState(key, this.renderState);\n  }\n  /**\n   * Check whether we have a motion value for this key\n   */\n  hasValue(key) {\n    return this.values.has(key);\n  }\n  getValue(key, defaultValue) {\n    if (this.props.values && this.props.values[key]) {\n      return this.props.values[key];\n    }\n    let value = this.values.get(key);\n    if (value === void 0 && defaultValue !== void 0) {\n      value = motionValue(defaultValue === null ? void 0 : defaultValue, { owner: this });\n      this.addValue(key, value);\n    }\n    return value;\n  }\n  /**\n   * If we're trying to animate to a previously unencountered value,\n   * we need to check for it in our state and as a last resort read it\n   * directly from the instance (which might have performance implications).\n   */\n  readValue(key, target) {\n    var _a;\n    let value = this.latestValues[key] !== void 0 || !this.current ? this.latestValues[key] : (_a = this.getBaseTargetFromProps(this.props, key)) !== null && _a !== void 0 ? _a : this.readValueFromInstance(this.current, key, this.options);\n    if (value !== void 0 && value !== null) {\n      if (typeof value === \"string\" && (isNumericalString(value) || isZeroValueString(value))) {\n        value = parseFloat(value);\n      } else if (!findValueType(value) && complex.test(target)) {\n        value = getAnimatableNone2(key, target);\n      }\n      this.setBaseTarget(key, isMotionValue(value) ? value.get() : value);\n    }\n    return isMotionValue(value) ? value.get() : value;\n  }\n  /**\n   * Set the base target to later animate back to. This is currently\n   * only hydrated on creation and when we first read a value.\n   */\n  setBaseTarget(key, value) {\n    this.baseTarget[key] = value;\n  }\n  /**\n   * Find the base target for a value thats been removed from all animation\n   * props.\n   */\n  getBaseTarget(key) {\n    var _a, _b;\n    const { initial } = this.props;\n    const valueFromInitial = typeof initial === \"string\" || typeof initial === \"object\" ? (_b = resolveVariantFromProps(this.props, initial, (_a = this.presenceContext) === null || _a === void 0 ? void 0 : _a.custom)) === null || _b === void 0 ? void 0 : _b[key] : void 0;\n    if (initial && valueFromInitial !== void 0) {\n      return valueFromInitial;\n    }\n    const target = this.getBaseTargetFromProps(this.props, key);\n    if (target !== void 0 && !isMotionValue(target))\n      return target;\n    return this.initialValues[key] !== void 0 && valueFromInitial === void 0 ? void 0 : this.baseTarget[key];\n  }\n  on(eventName, callback) {\n    if (!this.events[eventName]) {\n      this.events[eventName] = new SubscriptionManager();\n    }\n    return this.events[eventName].add(callback);\n  }\n  notify(eventName, ...args) {\n    if (this.events[eventName]) {\n      this.events[eventName].notify(...args);\n    }\n  }\n};\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/dom/DOMVisualElement.mjs\nvar DOMVisualElement = class extends VisualElement {\n  constructor() {\n    super(...arguments);\n    this.KeyframeResolver = DOMKeyframesResolver;\n  }\n  sortInstanceNodePosition(a, b) {\n    return a.compareDocumentPosition(b) & 2 ? 1 : -1;\n  }\n  getBaseTargetFromProps(props, key) {\n    return props.style ? props.style[key] : void 0;\n  }\n  removeValueFromRenderState(key, { vars, style }) {\n    delete vars[key];\n    delete style[key];\n  }\n};\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/html/HTMLVisualElement.mjs\nfunction getComputedStyle2(element) {\n  return window.getComputedStyle(element);\n}\nvar HTMLVisualElement = class extends DOMVisualElement {\n  constructor() {\n    super(...arguments);\n    this.type = \"html\";\n  }\n  readValueFromInstance(instance, key) {\n    if (transformProps.has(key)) {\n      const defaultType = getDefaultValueType(key);\n      return defaultType ? defaultType.default || 0 : 0;\n    } else {\n      const computedStyle = getComputedStyle2(instance);\n      const value = (isCSSVariableName(key) ? computedStyle.getPropertyValue(key) : computedStyle[key]) || 0;\n      return typeof value === \"string\" ? value.trim() : value;\n    }\n  }\n  measureInstanceViewportBox(instance, { transformPagePoint }) {\n    return measureViewportBox(instance, transformPagePoint);\n  }\n  build(renderState, latestValues, options, props) {\n    buildHTMLStyles(renderState, latestValues, options, props.transformTemplate);\n  }\n  scrapeMotionValuesFromProps(props, prevProps, visualElement) {\n    return scrapeMotionValuesFromProps(props, prevProps, visualElement);\n  }\n  handleChildMotionValue() {\n    if (this.childSubscription) {\n      this.childSubscription();\n      delete this.childSubscription;\n    }\n    const { children } = this.props;\n    if (isMotionValue(children)) {\n      this.childSubscription = children.on(\"change\", (latest) => {\n        if (this.current)\n          this.current.textContent = `${latest}`;\n      });\n    }\n  }\n  renderInstance(instance, renderState, styleProp, projection) {\n    renderHTML(instance, renderState, styleProp, projection);\n  }\n};\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/svg/SVGVisualElement.mjs\nvar SVGVisualElement = class extends DOMVisualElement {\n  constructor() {\n    super(...arguments);\n    this.type = \"svg\";\n    this.isSVGTag = false;\n  }\n  getBaseTargetFromProps(props, key) {\n    return props[key];\n  }\n  readValueFromInstance(instance, key) {\n    if (transformProps.has(key)) {\n      const defaultType = getDefaultValueType(key);\n      return defaultType ? defaultType.default || 0 : 0;\n    }\n    key = !camelCaseAttributes.has(key) ? camelToDash(key) : key;\n    return instance.getAttribute(key);\n  }\n  measureInstanceViewportBox() {\n    return createBox();\n  }\n  scrapeMotionValuesFromProps(props, prevProps) {\n    return scrapeMotionValuesFromProps2(props, prevProps, this);\n  }\n  build(renderState, latestValues, options, props) {\n    buildSVGAttrs(renderState, latestValues, options, this.isSVGTag, props.transformTemplate);\n  }\n  renderInstance(instance, renderState, styleProp, projection) {\n    renderSVG(instance, renderState, styleProp, projection);\n  }\n  mount(instance) {\n    this.isSVGTag = isSVGTag(instance.tagName);\n    super.mount(instance);\n  }\n};\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/dom/create-visual-element.mjs\nvar createDomVisualElement = (Component2, options) => {\n  return isSVGComponent(Component2) ? new SVGVisualElement(options, { enableHardwareAcceleration: false }) : new HTMLVisualElement(options, { enableHardwareAcceleration: true });\n};\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/motion/features/layout.mjs\nvar layout = {\n  layout: {\n    ProjectionNode: HTMLProjectionNode,\n    MeasureLayout\n  }\n};\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/dom/motion.mjs\nvar preloadedFeatures = {\n  ...animations,\n  ...gestureAnimations,\n  ...drag,\n  ...layout\n};\nvar motion = createMotionProxy((Component2, config) => createDomMotionConfig(Component2, config, preloadedFeatures, createDomVisualElement));\nfunction createDomMotionComponent(key) {\n  return createMotionComponent(createDomMotionConfig(key, { forwardMotionProps: false }, preloadedFeatures, createDomVisualElement));\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/dom/motion-minimal.mjs\nvar m = createMotionProxy(createDomMotionConfig);\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/components/AnimatePresence/index.mjs\nvar React4 = __toESM(require_react(), 1);\nvar import_react24 = __toESM(require_react(), 1);\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/utils/use-force-update.mjs\nvar import_react20 = __toESM(require_react(), 1);\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/utils/use-is-mounted.mjs\nvar import_react19 = __toESM(require_react(), 1);\nfunction useIsMounted() {\n  const isMounted = (0, import_react19.useRef)(false);\n  useIsomorphicLayoutEffect(() => {\n    isMounted.current = true;\n    return () => {\n      isMounted.current = false;\n    };\n  }, []);\n  return isMounted;\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/utils/use-force-update.mjs\nfunction useForceUpdate() {\n  const isMounted = useIsMounted();\n  const [forcedRenderCount, setForcedRenderCount] = (0, import_react20.useState)(0);\n  const forceRender = (0, import_react20.useCallback)(() => {\n    isMounted.current && setForcedRenderCount(forcedRenderCount + 1);\n  }, [forcedRenderCount]);\n  const deferredForceRender = (0, import_react20.useCallback)(() => frame.postRender(forceRender), [forceRender]);\n  return [deferredForceRender, forcedRenderCount];\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/components/AnimatePresence/PresenceChild.mjs\nvar React3 = __toESM(require_react(), 1);\nvar import_react22 = __toESM(require_react(), 1);\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/components/AnimatePresence/PopChild.mjs\nvar React2 = __toESM(require_react(), 1);\nvar import_react21 = __toESM(require_react(), 1);\nvar PopChildMeasure = class extends React2.Component {\n  getSnapshotBeforeUpdate(prevProps) {\n    const element = this.props.childRef.current;\n    if (element && prevProps.isPresent && !this.props.isPresent) {\n      const size = this.props.sizeRef.current;\n      size.height = element.offsetHeight || 0;\n      size.width = element.offsetWidth || 0;\n      size.top = element.offsetTop;\n      size.left = element.offsetLeft;\n    }\n    return null;\n  }\n  /**\n   * Required with getSnapshotBeforeUpdate to stop React complaining.\n   */\n  componentDidUpdate() {\n  }\n  render() {\n    return this.props.children;\n  }\n};\nfunction PopChild({ children, isPresent: isPresent2 }) {\n  const id4 = (0, import_react21.useId)();\n  const ref = (0, import_react21.useRef)(null);\n  const size = (0, import_react21.useRef)({\n    width: 0,\n    height: 0,\n    top: 0,\n    left: 0\n  });\n  const { nonce } = (0, import_react21.useContext)(MotionConfigContext);\n  (0, import_react21.useInsertionEffect)(() => {\n    const { width, height, top, left } = size.current;\n    if (isPresent2 || !ref.current || !width || !height)\n      return;\n    ref.current.dataset.motionPopId = id4;\n    const style = document.createElement(\"style\");\n    if (nonce)\n      style.nonce = nonce;\n    document.head.appendChild(style);\n    if (style.sheet) {\n      style.sheet.insertRule(`\n          [data-motion-pop-id=\"${id4}\"] {\n            position: absolute !important;\n            width: ${width}px !important;\n            height: ${height}px !important;\n            top: ${top}px !important;\n            left: ${left}px !important;\n          }\n        `);\n    }\n    return () => {\n      document.head.removeChild(style);\n    };\n  }, [isPresent2]);\n  return React2.createElement(PopChildMeasure, { isPresent: isPresent2, childRef: ref, sizeRef: size }, React2.cloneElement(children, { ref }));\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/components/AnimatePresence/PresenceChild.mjs\nvar PresenceChild = ({ children, initial, isPresent: isPresent2, onExitComplete, custom, presenceAffectsLayout, mode }) => {\n  const presenceChildren = useConstant(newChildrenMap);\n  const id4 = (0, import_react22.useId)();\n  const context = (0, import_react22.useMemo)(\n    () => ({\n      id: id4,\n      initial,\n      isPresent: isPresent2,\n      custom,\n      onExitComplete: (childId) => {\n        presenceChildren.set(childId, true);\n        for (const isComplete of presenceChildren.values()) {\n          if (!isComplete)\n            return;\n        }\n        onExitComplete && onExitComplete();\n      },\n      register: (childId) => {\n        presenceChildren.set(childId, false);\n        return () => presenceChildren.delete(childId);\n      }\n    }),\n    /**\n     * If the presence of a child affects the layout of the components around it,\n     * we want to make a new context value to ensure they get re-rendered\n     * so they can detect that layout change.\n     */\n    presenceAffectsLayout ? void 0 : [isPresent2]\n  );\n  (0, import_react22.useMemo)(() => {\n    presenceChildren.forEach((_, key) => presenceChildren.set(key, false));\n  }, [isPresent2]);\n  React3.useEffect(() => {\n    !isPresent2 && !presenceChildren.size && onExitComplete && onExitComplete();\n  }, [isPresent2]);\n  if (mode === \"popLayout\") {\n    children = React3.createElement(PopChild, { isPresent: isPresent2 }, children);\n  }\n  return React3.createElement(PresenceContext.Provider, { value: context }, children);\n};\nfunction newChildrenMap() {\n  return /* @__PURE__ */ new Map();\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/utils/use-unmount-effect.mjs\nvar import_react23 = __toESM(require_react(), 1);\nfunction useUnmountEffect(callback) {\n  return (0, import_react23.useEffect)(() => () => callback(), []);\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/components/AnimatePresence/index.mjs\nvar getChildKey = (child) => child.key || \"\";\nfunction updateChildLookup(children, allChildren) {\n  children.forEach((child) => {\n    const key = getChildKey(child);\n    allChildren.set(key, child);\n  });\n}\nfunction onlyElements(children) {\n  const filtered = [];\n  import_react24.Children.forEach(children, (child) => {\n    if ((0, import_react24.isValidElement)(child))\n      filtered.push(child);\n  });\n  return filtered;\n}\nvar AnimatePresence = ({ children, custom, initial = true, onExitComplete, exitBeforeEnter, presenceAffectsLayout = true, mode = \"sync\" }) => {\n  invariant(!exitBeforeEnter, \"Replace exitBeforeEnter with mode='wait'\");\n  const forceRender = (0, import_react24.useContext)(LayoutGroupContext).forceRender || useForceUpdate()[0];\n  const isMounted = useIsMounted();\n  const filteredChildren = onlyElements(children);\n  let childrenToRender = filteredChildren;\n  const exitingChildren = (0, import_react24.useRef)(/* @__PURE__ */ new Map()).current;\n  const presentChildren = (0, import_react24.useRef)(childrenToRender);\n  const allChildren = (0, import_react24.useRef)(/* @__PURE__ */ new Map()).current;\n  const isInitialRender = (0, import_react24.useRef)(true);\n  useIsomorphicLayoutEffect(() => {\n    isInitialRender.current = false;\n    updateChildLookup(filteredChildren, allChildren);\n    presentChildren.current = childrenToRender;\n  });\n  useUnmountEffect(() => {\n    isInitialRender.current = true;\n    allChildren.clear();\n    exitingChildren.clear();\n  });\n  if (isInitialRender.current) {\n    return React4.createElement(React4.Fragment, null, childrenToRender.map((child) => React4.createElement(PresenceChild, { key: getChildKey(child), isPresent: true, initial: initial ? void 0 : false, presenceAffectsLayout, mode }, child)));\n  }\n  childrenToRender = [...childrenToRender];\n  const presentKeys = presentChildren.current.map(getChildKey);\n  const targetKeys = filteredChildren.map(getChildKey);\n  const numPresent = presentKeys.length;\n  for (let i = 0; i < numPresent; i++) {\n    const key = presentKeys[i];\n    if (targetKeys.indexOf(key) === -1 && !exitingChildren.has(key)) {\n      exitingChildren.set(key, void 0);\n    }\n  }\n  if (mode === \"wait\" && exitingChildren.size) {\n    childrenToRender = [];\n  }\n  exitingChildren.forEach((component, key) => {\n    if (targetKeys.indexOf(key) !== -1)\n      return;\n    const child = allChildren.get(key);\n    if (!child)\n      return;\n    const insertionIndex = presentKeys.indexOf(key);\n    let exitingComponent = component;\n    if (!exitingComponent) {\n      const onExit = () => {\n        exitingChildren.delete(key);\n        const leftOverKeys = Array.from(allChildren.keys()).filter((childKey) => !targetKeys.includes(childKey));\n        leftOverKeys.forEach((leftOverKey) => allChildren.delete(leftOverKey));\n        presentChildren.current = filteredChildren.filter((presentChild) => {\n          const presentChildKey = getChildKey(presentChild);\n          return (\n            // filter out the node exiting\n            presentChildKey === key || // filter out the leftover children\n            leftOverKeys.includes(presentChildKey)\n          );\n        });\n        if (!exitingChildren.size) {\n          if (isMounted.current === false)\n            return;\n          forceRender();\n          onExitComplete && onExitComplete();\n        }\n      };\n      exitingComponent = React4.createElement(PresenceChild, { key: getChildKey(child), isPresent: false, onExitComplete: onExit, custom, presenceAffectsLayout, mode }, child);\n      exitingChildren.set(key, exitingComponent);\n    }\n    childrenToRender.splice(insertionIndex, 0, exitingComponent);\n  });\n  childrenToRender = childrenToRender.map((child) => {\n    const key = child.key;\n    return exitingChildren.has(key) ? child : React4.createElement(PresenceChild, { key: getChildKey(child), isPresent: true, presenceAffectsLayout, mode }, child);\n  });\n  if (mode === \"wait\" && childrenToRender.length > 1) {\n    console.warn(`You're attempting to animate multiple children within AnimatePresence, but its mode is set to \"wait\". This will lead to odd visual behaviour.`);\n  }\n  return React4.createElement(React4.Fragment, null, exitingChildren.size ? childrenToRender : childrenToRender.map((child) => (0, import_react24.cloneElement)(child)));\n};\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/components/MotionConfig/index.mjs\nvar React5 = __toESM(require_react(), 1);\nvar import_react25 = __toESM(require_react(), 1);\nfunction MotionConfig({ children, isValidProp, ...config }) {\n  isValidProp && loadExternalIsValidProp(isValidProp);\n  config = { ...(0, import_react25.useContext)(MotionConfigContext), ...config };\n  config.isStatic = useConstant(() => config.isStatic);\n  const context = (0, import_react25.useMemo)(() => config, [JSON.stringify(config.transition), config.transformPagePoint, config.reducedMotion]);\n  return React5.createElement(MotionConfigContext.Provider, { value: context }, children);\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/components/LazyMotion/index.mjs\nvar React6 = __toESM(require_react(), 1);\nvar import_react26 = __toESM(require_react(), 1);\nfunction LazyMotion({ children, features, strict = false }) {\n  const [, setIsLoaded] = (0, import_react26.useState)(!isLazyBundle(features));\n  const loadedRenderer = (0, import_react26.useRef)(void 0);\n  if (!isLazyBundle(features)) {\n    const { renderer, ...loadedFeatures } = features;\n    loadedRenderer.current = renderer;\n    loadFeatures(loadedFeatures);\n  }\n  (0, import_react26.useEffect)(() => {\n    if (isLazyBundle(features)) {\n      features().then(({ renderer, ...loadedFeatures }) => {\n        loadFeatures(loadedFeatures);\n        loadedRenderer.current = renderer;\n        setIsLoaded(true);\n      });\n    }\n  }, []);\n  return React6.createElement(LazyContext.Provider, { value: { renderer: loadedRenderer.current, strict } }, children);\n}\nfunction isLazyBundle(features) {\n  return typeof features === \"function\";\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/components/LayoutGroup/index.mjs\nvar React7 = __toESM(require_react(), 1);\nvar import_react28 = __toESM(require_react(), 1);\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/context/DeprecatedLayoutGroupContext.mjs\nvar import_react27 = __toESM(require_react(), 1);\nvar DeprecatedLayoutGroupContext = (0, import_react27.createContext)(null);\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/projection/node/group.mjs\nvar notify = (node) => !node.isLayoutDirty && node.willUpdate(false);\nfunction nodeGroup() {\n  const nodes = /* @__PURE__ */ new Set();\n  const subscriptions = /* @__PURE__ */ new WeakMap();\n  const dirtyAll = () => nodes.forEach(notify);\n  return {\n    add: (node) => {\n      nodes.add(node);\n      subscriptions.set(node, node.addEventListener(\"willUpdate\", dirtyAll));\n    },\n    remove: (node) => {\n      nodes.delete(node);\n      const unsubscribe = subscriptions.get(node);\n      if (unsubscribe) {\n        unsubscribe();\n        subscriptions.delete(node);\n      }\n      dirtyAll();\n    },\n    dirty: dirtyAll\n  };\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/components/LayoutGroup/index.mjs\nvar shouldInheritGroup = (inherit) => inherit === true;\nvar shouldInheritId = (inherit) => shouldInheritGroup(inherit === true) || inherit === \"id\";\nvar LayoutGroup = ({ children, id: id4, inherit = true }) => {\n  const layoutGroupContext = (0, import_react28.useContext)(LayoutGroupContext);\n  const deprecatedLayoutGroupContext = (0, import_react28.useContext)(DeprecatedLayoutGroupContext);\n  const [forceRender, key] = useForceUpdate();\n  const context = (0, import_react28.useRef)(null);\n  const upstreamId = layoutGroupContext.id || deprecatedLayoutGroupContext;\n  if (context.current === null) {\n    if (shouldInheritId(inherit) && upstreamId) {\n      id4 = id4 ? upstreamId + \"-\" + id4 : upstreamId;\n    }\n    context.current = {\n      id: id4,\n      group: shouldInheritGroup(inherit) ? layoutGroupContext.group || nodeGroup() : nodeGroup()\n    };\n  }\n  const memoizedContext = (0, import_react28.useMemo)(() => ({ ...context.current, forceRender }), [key]);\n  return React7.createElement(LayoutGroupContext.Provider, { value: memoizedContext }, children);\n};\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/components/Reorder/Group.mjs\nvar React8 = __toESM(require_react(), 1);\nvar import_react30 = __toESM(require_react(), 1);\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/context/ReorderContext.mjs\nvar import_react29 = __toESM(require_react(), 1);\nvar ReorderContext = (0, import_react29.createContext)(null);\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/components/Reorder/utils/check-reorder.mjs\nfunction checkReorder(order, value, offset, velocity) {\n  if (!velocity)\n    return order;\n  const index = order.findIndex((item2) => item2.value === value);\n  if (index === -1)\n    return order;\n  const nextOffset = velocity > 0 ? 1 : -1;\n  const nextItem = order[index + nextOffset];\n  if (!nextItem)\n    return order;\n  const item = order[index];\n  const nextLayout = nextItem.layout;\n  const nextItemCenter = mixNumber(nextLayout.min, nextLayout.max, 0.5);\n  if (nextOffset === 1 && item.layout.max + offset > nextItemCenter || nextOffset === -1 && item.layout.min + offset < nextItemCenter) {\n    return moveItem(order, index, index + nextOffset);\n  }\n  return order;\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/components/Reorder/Group.mjs\nfunction ReorderGroup({ children, as = \"ul\", axis = \"y\", onReorder, values, ...props }, externalRef) {\n  const Component2 = useConstant(() => motion(as));\n  const order = [];\n  const isReordering = (0, import_react30.useRef)(false);\n  invariant(Boolean(values), \"Reorder.Group must be provided a values prop\");\n  const context = {\n    axis,\n    registerItem: (value, layout2) => {\n      const idx = order.findIndex((entry) => value === entry.value);\n      if (idx !== -1) {\n        order[idx].layout = layout2[axis];\n      } else {\n        order.push({ value, layout: layout2[axis] });\n      }\n      order.sort(compareMin);\n    },\n    updateOrder: (item, offset, velocity) => {\n      if (isReordering.current)\n        return;\n      const newOrder = checkReorder(order, item, offset, velocity);\n      if (order !== newOrder) {\n        isReordering.current = true;\n        onReorder(newOrder.map(getValue).filter((value) => values.indexOf(value) !== -1));\n      }\n    }\n  };\n  (0, import_react30.useEffect)(() => {\n    isReordering.current = false;\n  });\n  return React8.createElement(\n    Component2,\n    { ...props, ref: externalRef, ignoreStrict: true },\n    React8.createElement(ReorderContext.Provider, { value: context }, children)\n  );\n}\nvar Group = (0, import_react30.forwardRef)(ReorderGroup);\nfunction getValue(item) {\n  return item.value;\n}\nfunction compareMin(a, b) {\n  return a.layout.min - b.layout.min;\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/components/Reorder/Item.mjs\nvar React9 = __toESM(require_react(), 1);\nvar import_react32 = __toESM(require_react(), 1);\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/value/use-motion-value.mjs\nvar import_react31 = __toESM(require_react(), 1);\nfunction useMotionValue(initial) {\n  const value = useConstant(() => motionValue(initial));\n  const { isStatic } = (0, import_react31.useContext)(MotionConfigContext);\n  if (isStatic) {\n    const [, setLatest] = (0, import_react31.useState)(initial);\n    (0, import_react31.useEffect)(() => value.on(\"change\", setLatest), []);\n  }\n  return value;\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/utils/transform.mjs\nvar isCustomValueType = (v) => {\n  return v && typeof v === \"object\" && v.mix;\n};\nvar getMixer2 = (v) => isCustomValueType(v) ? v.mix : void 0;\nfunction transform(...args) {\n  const useImmediate = !Array.isArray(args[0]);\n  const argOffset = useImmediate ? 0 : -1;\n  const inputValue = args[0 + argOffset];\n  const inputRange = args[1 + argOffset];\n  const outputRange = args[2 + argOffset];\n  const options = args[3 + argOffset];\n  const interpolator = interpolate(inputRange, outputRange, {\n    mixer: getMixer2(outputRange[0]),\n    ...options\n  });\n  return useImmediate ? interpolator(inputValue) : interpolator;\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/value/use-combine-values.mjs\nfunction useCombineMotionValues(values, combineValues) {\n  const value = useMotionValue(combineValues());\n  const updateValue = () => value.set(combineValues());\n  updateValue();\n  useIsomorphicLayoutEffect(() => {\n    const scheduleUpdate = () => frame.update(updateValue, false, true);\n    const subscriptions = values.map((v) => v.on(\"change\", scheduleUpdate));\n    return () => {\n      subscriptions.forEach((unsubscribe) => unsubscribe());\n      cancelFrame(updateValue);\n    };\n  });\n  return value;\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/value/use-computed.mjs\nfunction useComputed(compute) {\n  collectMotionValues.current = [];\n  compute();\n  const value = useCombineMotionValues(collectMotionValues.current, compute);\n  collectMotionValues.current = void 0;\n  return value;\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/value/use-transform.mjs\nfunction useTransform(input, inputRangeOrTransformer, outputRange, options) {\n  if (typeof input === \"function\") {\n    return useComputed(input);\n  }\n  const transformer = typeof inputRangeOrTransformer === \"function\" ? inputRangeOrTransformer : transform(inputRangeOrTransformer, outputRange, options);\n  return Array.isArray(input) ? useListTransform(input, transformer) : useListTransform([input], ([latest]) => transformer(latest));\n}\nfunction useListTransform(values, transformer) {\n  const latest = useConstant(() => []);\n  return useCombineMotionValues(values, () => {\n    latest.length = 0;\n    const numValues = values.length;\n    for (let i = 0; i < numValues; i++) {\n      latest[i] = values[i].get();\n    }\n    return transformer(latest);\n  });\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/components/Reorder/Item.mjs\nfunction useDefaultMotionValue(value, defaultValue = 0) {\n  return isMotionValue(value) ? value : useMotionValue(defaultValue);\n}\nfunction ReorderItem({ children, style = {}, value, as = \"li\", onDrag, layout: layout2 = true, ...props }, externalRef) {\n  const Component2 = useConstant(() => motion(as));\n  const context = (0, import_react32.useContext)(ReorderContext);\n  const point2 = {\n    x: useDefaultMotionValue(style.x),\n    y: useDefaultMotionValue(style.y)\n  };\n  const zIndex = useTransform([point2.x, point2.y], ([latestX, latestY]) => latestX || latestY ? 1 : \"unset\");\n  invariant(Boolean(context), \"Reorder.Item must be a child of Reorder.Group\");\n  const { axis, registerItem, updateOrder } = context;\n  return React9.createElement(Component2, { drag: axis, ...props, dragSnapToOrigin: true, style: { ...style, x: point2.x, y: point2.y, zIndex }, layout: layout2, onDrag: (event, gesturePoint) => {\n    const { velocity } = gesturePoint;\n    velocity[axis] && updateOrder(value, point2[axis].get(), velocity[axis]);\n    onDrag && onDrag(event, gesturePoint);\n  }, onLayoutMeasure: (measured) => registerItem(value, measured), ref: externalRef, ignoreStrict: true }, children);\n}\nvar Item = (0, import_react32.forwardRef)(ReorderItem);\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/components/Reorder/index.mjs\nvar Reorder = {\n  Group,\n  Item\n};\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/dom/features-animation.mjs\nvar domAnimation = {\n  renderer: createDomVisualElement,\n  ...animations,\n  ...gestureAnimations\n};\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/dom/features-max.mjs\nvar domMax = {\n  ...domAnimation,\n  ...drag,\n  ...layout\n};\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/value/use-motion-template.mjs\nfunction useMotionTemplate(fragments, ...values) {\n  const numFragments = fragments.length;\n  function buildValue() {\n    let output = ``;\n    for (let i = 0; i < numFragments; i++) {\n      output += fragments[i];\n      const value = values[i];\n      if (value) {\n        output += isMotionValue(value) ? value.get() : value;\n      }\n    }\n    return output;\n  }\n  return useCombineMotionValues(values.filter(isMotionValue), buildValue);\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/value/use-spring.mjs\nvar import_react33 = __toESM(require_react(), 1);\nfunction useSpring(source, config = {}) {\n  const { isStatic } = (0, import_react33.useContext)(MotionConfigContext);\n  const activeSpringAnimation = (0, import_react33.useRef)(null);\n  const value = useMotionValue(isMotionValue(source) ? source.get() : source);\n  const stopAnimation2 = () => {\n    if (activeSpringAnimation.current) {\n      activeSpringAnimation.current.stop();\n    }\n  };\n  (0, import_react33.useInsertionEffect)(() => {\n    return value.attach((v, set) => {\n      if (isStatic)\n        return set(v);\n      const animation = activeSpringAnimation.current;\n      if (animation && animation.time === 0) {\n        animation.sample(frameData.delta);\n      }\n      stopAnimation2();\n      activeSpringAnimation.current = animateValue({\n        keyframes: [value.get(), v],\n        velocity: value.getVelocity(),\n        type: \"spring\",\n        restDelta: 1e-3,\n        restSpeed: 0.01,\n        ...config,\n        onUpdate: set\n      });\n      return value.get();\n    }, stopAnimation2);\n  }, [JSON.stringify(config)]);\n  useIsomorphicLayoutEffect(() => {\n    if (isMotionValue(source)) {\n      return source.on(\"change\", (v) => value.set(parseFloat(v)));\n    }\n  }, [value]);\n  return value;\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/utils/use-motion-value-event.mjs\nvar import_react34 = __toESM(require_react(), 1);\nfunction useMotionValueEvent(value, event, callback) {\n  (0, import_react34.useInsertionEffect)(() => value.on(event, callback), [value, event, callback]);\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/value/use-velocity.mjs\nfunction useVelocity(value) {\n  const velocity = useMotionValue(value.getVelocity());\n  const updateVelocity = () => {\n    const latest = value.getVelocity();\n    velocity.set(latest);\n    if (latest)\n      frame.update(updateVelocity);\n  };\n  useMotionValueEvent(value, \"change\", () => {\n    frame.update(updateVelocity, false, true);\n  });\n  return velocity;\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/value/use-scroll.mjs\nvar import_react35 = __toESM(require_react(), 1);\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/dom/utils/resolve-element.mjs\nfunction resolveElements(elements, scope, selectorCache) {\n  var _a;\n  if (typeof elements === \"string\") {\n    let root = document;\n    if (scope) {\n      invariant(Boolean(scope.current), \"Scope provided, but no element detected.\");\n      root = scope.current;\n    }\n    if (selectorCache) {\n      (_a = selectorCache[elements]) !== null && _a !== void 0 ? _a : selectorCache[elements] = root.querySelectorAll(elements);\n      elements = selectorCache[elements];\n    } else {\n      elements = root.querySelectorAll(elements);\n    }\n  } else if (elements instanceof Element) {\n    elements = [elements];\n  }\n  return Array.from(elements || []);\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/dom/resize/handle-element.mjs\nvar resizeHandlers = /* @__PURE__ */ new WeakMap();\nvar observer;\nfunction getElementSize(target, borderBoxSize) {\n  if (borderBoxSize) {\n    const { inlineSize, blockSize } = borderBoxSize[0];\n    return { width: inlineSize, height: blockSize };\n  } else if (target instanceof SVGElement && \"getBBox\" in target) {\n    return target.getBBox();\n  } else {\n    return {\n      width: target.offsetWidth,\n      height: target.offsetHeight\n    };\n  }\n}\nfunction notifyTarget({ target, contentRect, borderBoxSize }) {\n  var _a;\n  (_a = resizeHandlers.get(target)) === null || _a === void 0 ? void 0 : _a.forEach((handler) => {\n    handler({\n      target,\n      contentSize: contentRect,\n      get size() {\n        return getElementSize(target, borderBoxSize);\n      }\n    });\n  });\n}\nfunction notifyAll(entries) {\n  entries.forEach(notifyTarget);\n}\nfunction createResizeObserver() {\n  if (typeof ResizeObserver === \"undefined\")\n    return;\n  observer = new ResizeObserver(notifyAll);\n}\nfunction resizeElement(target, handler) {\n  if (!observer)\n    createResizeObserver();\n  const elements = resolveElements(target);\n  elements.forEach((element) => {\n    let elementHandlers = resizeHandlers.get(element);\n    if (!elementHandlers) {\n      elementHandlers = /* @__PURE__ */ new Set();\n      resizeHandlers.set(element, elementHandlers);\n    }\n    elementHandlers.add(handler);\n    observer === null || observer === void 0 ? void 0 : observer.observe(element);\n  });\n  return () => {\n    elements.forEach((element) => {\n      const elementHandlers = resizeHandlers.get(element);\n      elementHandlers === null || elementHandlers === void 0 ? void 0 : elementHandlers.delete(handler);\n      if (!(elementHandlers === null || elementHandlers === void 0 ? void 0 : elementHandlers.size)) {\n        observer === null || observer === void 0 ? void 0 : observer.unobserve(element);\n      }\n    });\n  };\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/dom/resize/handle-window.mjs\nvar windowCallbacks = /* @__PURE__ */ new Set();\nvar windowResizeHandler;\nfunction createWindowResizeHandler() {\n  windowResizeHandler = () => {\n    const size = {\n      width: window.innerWidth,\n      height: window.innerHeight\n    };\n    const info = {\n      target: window,\n      size,\n      contentSize: size\n    };\n    windowCallbacks.forEach((callback) => callback(info));\n  };\n  window.addEventListener(\"resize\", windowResizeHandler);\n}\nfunction resizeWindow(callback) {\n  windowCallbacks.add(callback);\n  if (!windowResizeHandler)\n    createWindowResizeHandler();\n  return () => {\n    windowCallbacks.delete(callback);\n    if (!windowCallbacks.size && windowResizeHandler) {\n      windowResizeHandler = void 0;\n    }\n  };\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/dom/resize/index.mjs\nfunction resize(a, b) {\n  return typeof a === \"function\" ? resizeWindow(a) : resizeElement(a, b);\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/dom/scroll/info.mjs\nvar maxElapsed2 = 50;\nvar createAxisInfo = () => ({\n  current: 0,\n  offset: [],\n  progress: 0,\n  scrollLength: 0,\n  targetOffset: 0,\n  targetLength: 0,\n  containerLength: 0,\n  velocity: 0\n});\nvar createScrollInfo = () => ({\n  time: 0,\n  x: createAxisInfo(),\n  y: createAxisInfo()\n});\nvar keys = {\n  x: {\n    length: \"Width\",\n    position: \"Left\"\n  },\n  y: {\n    length: \"Height\",\n    position: \"Top\"\n  }\n};\nfunction updateAxisInfo(element, axisName, info, time2) {\n  const axis = info[axisName];\n  const { length, position } = keys[axisName];\n  const prev = axis.current;\n  const prevTime = info.time;\n  axis.current = element[\"scroll\" + position];\n  axis.scrollLength = element[\"scroll\" + length] - element[\"client\" + length];\n  axis.offset.length = 0;\n  axis.offset[0] = 0;\n  axis.offset[1] = axis.scrollLength;\n  axis.progress = progress(0, axis.scrollLength, axis.current);\n  const elapsed = time2 - prevTime;\n  axis.velocity = elapsed > maxElapsed2 ? 0 : velocityPerSecond(axis.current - prev, elapsed);\n}\nfunction updateScrollInfo(element, info, time2) {\n  updateAxisInfo(element, \"x\", info, time2);\n  updateAxisInfo(element, \"y\", info, time2);\n  info.time = time2;\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/dom/scroll/offsets/inset.mjs\nfunction calcInset(element, container) {\n  const inset = { x: 0, y: 0 };\n  let current = element;\n  while (current && current !== container) {\n    if (current instanceof HTMLElement) {\n      inset.x += current.offsetLeft;\n      inset.y += current.offsetTop;\n      current = current.offsetParent;\n    } else if (current.tagName === \"svg\") {\n      const svgBoundingBox = current.getBoundingClientRect();\n      current = current.parentElement;\n      const parentBoundingBox = current.getBoundingClientRect();\n      inset.x += svgBoundingBox.left - parentBoundingBox.left;\n      inset.y += svgBoundingBox.top - parentBoundingBox.top;\n    } else if (current instanceof SVGGraphicsElement) {\n      const { x, y } = current.getBBox();\n      inset.x += x;\n      inset.y += y;\n      let svg = null;\n      let parent = current.parentNode;\n      while (!svg) {\n        if (parent.tagName === \"svg\") {\n          svg = parent;\n        }\n        parent = current.parentNode;\n      }\n      current = svg;\n    } else {\n      break;\n    }\n  }\n  return inset;\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/dom/scroll/offsets/presets.mjs\nvar ScrollOffset = {\n  Enter: [\n    [0, 1],\n    [1, 1]\n  ],\n  Exit: [\n    [0, 0],\n    [1, 0]\n  ],\n  Any: [\n    [1, 0],\n    [0, 1]\n  ],\n  All: [\n    [0, 0],\n    [1, 1]\n  ]\n};\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/dom/scroll/offsets/edge.mjs\nvar namedEdges = {\n  start: 0,\n  center: 0.5,\n  end: 1\n};\nfunction resolveEdge(edge, length, inset = 0) {\n  let delta = 0;\n  if (namedEdges[edge] !== void 0) {\n    edge = namedEdges[edge];\n  }\n  if (typeof edge === \"string\") {\n    const asNumber2 = parseFloat(edge);\n    if (edge.endsWith(\"px\")) {\n      delta = asNumber2;\n    } else if (edge.endsWith(\"%\")) {\n      edge = asNumber2 / 100;\n    } else if (edge.endsWith(\"vw\")) {\n      delta = asNumber2 / 100 * document.documentElement.clientWidth;\n    } else if (edge.endsWith(\"vh\")) {\n      delta = asNumber2 / 100 * document.documentElement.clientHeight;\n    } else {\n      edge = asNumber2;\n    }\n  }\n  if (typeof edge === \"number\") {\n    delta = length * edge;\n  }\n  return inset + delta;\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/dom/scroll/offsets/offset.mjs\nvar defaultOffset2 = [0, 0];\nfunction resolveOffset(offset, containerLength, targetLength, targetInset) {\n  let offsetDefinition = Array.isArray(offset) ? offset : defaultOffset2;\n  let targetPoint = 0;\n  let containerPoint = 0;\n  if (typeof offset === \"number\") {\n    offsetDefinition = [offset, offset];\n  } else if (typeof offset === \"string\") {\n    offset = offset.trim();\n    if (offset.includes(\" \")) {\n      offsetDefinition = offset.split(\" \");\n    } else {\n      offsetDefinition = [offset, namedEdges[offset] ? offset : `0`];\n    }\n  }\n  targetPoint = resolveEdge(offsetDefinition[0], targetLength, targetInset);\n  containerPoint = resolveEdge(offsetDefinition[1], containerLength);\n  return targetPoint - containerPoint;\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/dom/scroll/offsets/index.mjs\nvar point = { x: 0, y: 0 };\nfunction getTargetSize(target) {\n  return \"getBBox\" in target && target.tagName !== \"svg\" ? target.getBBox() : { width: target.clientWidth, height: target.clientHeight };\n}\nfunction resolveOffsets(container, info, options) {\n  const { offset: offsetDefinition = ScrollOffset.All } = options;\n  const { target = container, axis = \"y\" } = options;\n  const lengthLabel = axis === \"y\" ? \"height\" : \"width\";\n  const inset = target !== container ? calcInset(target, container) : point;\n  const targetSize = target === container ? { width: container.scrollWidth, height: container.scrollHeight } : getTargetSize(target);\n  const containerSize = {\n    width: container.clientWidth,\n    height: container.clientHeight\n  };\n  info[axis].offset.length = 0;\n  let hasChanged = !info[axis].interpolate;\n  const numOffsets = offsetDefinition.length;\n  for (let i = 0; i < numOffsets; i++) {\n    const offset = resolveOffset(offsetDefinition[i], containerSize[lengthLabel], targetSize[lengthLabel], inset[axis]);\n    if (!hasChanged && offset !== info[axis].interpolatorOffsets[i]) {\n      hasChanged = true;\n    }\n    info[axis].offset[i] = offset;\n  }\n  if (hasChanged) {\n    info[axis].interpolate = interpolate(info[axis].offset, defaultOffset(offsetDefinition));\n    info[axis].interpolatorOffsets = [...info[axis].offset];\n  }\n  info[axis].progress = info[axis].interpolate(info[axis].current);\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/dom/scroll/on-scroll-handler.mjs\nfunction measure(container, target = container, info) {\n  info.x.targetOffset = 0;\n  info.y.targetOffset = 0;\n  if (target !== container) {\n    let node = target;\n    while (node && node !== container) {\n      info.x.targetOffset += node.offsetLeft;\n      info.y.targetOffset += node.offsetTop;\n      node = node.offsetParent;\n    }\n  }\n  info.x.targetLength = target === container ? target.scrollWidth : target.clientWidth;\n  info.y.targetLength = target === container ? target.scrollHeight : target.clientHeight;\n  info.x.containerLength = container.clientWidth;\n  info.y.containerLength = container.clientHeight;\n  if (true) {\n    if (container && target && target !== container) {\n      warnOnce(getComputedStyle(container).position !== \"static\", \"Please ensure that the container has a non-static position, like 'relative', 'fixed', or 'absolute' to ensure scroll offset is calculated correctly.\");\n    }\n  }\n}\nfunction createOnScrollHandler(element, onScroll, info, options = {}) {\n  return {\n    measure: () => measure(element, options.target, info),\n    update: (time2) => {\n      updateScrollInfo(element, info, time2);\n      if (options.offset || options.target) {\n        resolveOffsets(element, info, options);\n      }\n    },\n    notify: () => onScroll(info)\n  };\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/dom/scroll/track.mjs\nvar scrollListeners = /* @__PURE__ */ new WeakMap();\nvar resizeListeners = /* @__PURE__ */ new WeakMap();\nvar onScrollHandlers = /* @__PURE__ */ new WeakMap();\nvar getEventTarget = (element) => element === document.documentElement ? window : element;\nfunction scrollInfo(onScroll, { container = document.documentElement, ...options } = {}) {\n  let containerHandlers = onScrollHandlers.get(container);\n  if (!containerHandlers) {\n    containerHandlers = /* @__PURE__ */ new Set();\n    onScrollHandlers.set(container, containerHandlers);\n  }\n  const info = createScrollInfo();\n  const containerHandler = createOnScrollHandler(container, onScroll, info, options);\n  containerHandlers.add(containerHandler);\n  if (!scrollListeners.has(container)) {\n    const measureAll = () => {\n      for (const handler of containerHandlers)\n        handler.measure();\n    };\n    const updateAll = () => {\n      for (const handler of containerHandlers) {\n        handler.update(frameData.timestamp);\n      }\n    };\n    const notifyAll2 = () => {\n      for (const handler of containerHandlers)\n        handler.notify();\n    };\n    const listener2 = () => {\n      frame.read(measureAll, false, true);\n      frame.read(updateAll, false, true);\n      frame.update(notifyAll2, false, true);\n    };\n    scrollListeners.set(container, listener2);\n    const target = getEventTarget(container);\n    window.addEventListener(\"resize\", listener2, { passive: true });\n    if (container !== document.documentElement) {\n      resizeListeners.set(container, resize(container, listener2));\n    }\n    target.addEventListener(\"scroll\", listener2, { passive: true });\n  }\n  const listener = scrollListeners.get(container);\n  frame.read(listener, false, true);\n  return () => {\n    var _a;\n    cancelFrame(listener);\n    const currentHandlers = onScrollHandlers.get(container);\n    if (!currentHandlers)\n      return;\n    currentHandlers.delete(containerHandler);\n    if (currentHandlers.size)\n      return;\n    const scrollListener = scrollListeners.get(container);\n    scrollListeners.delete(container);\n    if (scrollListener) {\n      getEventTarget(container).removeEventListener(\"scroll\", scrollListener);\n      (_a = resizeListeners.get(container)) === null || _a === void 0 ? void 0 : _a();\n      window.removeEventListener(\"resize\", scrollListener);\n    }\n  };\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/value/use-scroll.mjs\nfunction refWarning(name, ref) {\n  warning(Boolean(!ref || ref.current), `You have defined a ${name} options but the provided ref is not yet hydrated, probably because it's defined higher up the tree. Try calling useScroll() in the same component as the ref, or setting its \\`layoutEffect: false\\` option.`);\n}\nvar createScrollMotionValues = () => ({\n  scrollX: motionValue(0),\n  scrollY: motionValue(0),\n  scrollXProgress: motionValue(0),\n  scrollYProgress: motionValue(0)\n});\nfunction useScroll({ container, target, layoutEffect = true, ...options } = {}) {\n  const values = useConstant(createScrollMotionValues);\n  const useLifecycleEffect = layoutEffect ? useIsomorphicLayoutEffect : import_react35.useEffect;\n  useLifecycleEffect(() => {\n    refWarning(\"target\", target);\n    refWarning(\"container\", container);\n    return scrollInfo(({ x, y }) => {\n      values.scrollX.set(x.current);\n      values.scrollXProgress.set(x.progress);\n      values.scrollY.set(y.current);\n      values.scrollYProgress.set(y.progress);\n    }, {\n      ...options,\n      container: (container === null || container === void 0 ? void 0 : container.current) || void 0,\n      target: (target === null || target === void 0 ? void 0 : target.current) || void 0\n    });\n  }, [container, target, JSON.stringify(options.offset)]);\n  return values;\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/value/scroll/use-element-scroll.mjs\nfunction useElementScroll(ref) {\n  if (true) {\n    warnOnce(false, \"useElementScroll is deprecated. Convert to useScroll({ container: ref }).\");\n  }\n  return useScroll({ container: ref });\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/value/scroll/use-viewport-scroll.mjs\nfunction useViewportScroll() {\n  if (true) {\n    warnOnce(false, \"useViewportScroll is deprecated. Convert to useScroll().\");\n  }\n  return useScroll();\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/utils/use-animation-frame.mjs\nvar import_react36 = __toESM(require_react(), 1);\nfunction useAnimationFrame(callback) {\n  const initialTimestamp = (0, import_react36.useRef)(0);\n  const { isStatic } = (0, import_react36.useContext)(MotionConfigContext);\n  (0, import_react36.useEffect)(() => {\n    if (isStatic)\n      return;\n    const provideTimeSinceStart = ({ timestamp, delta }) => {\n      if (!initialTimestamp.current)\n        initialTimestamp.current = timestamp;\n      callback(timestamp - initialTimestamp.current, delta);\n    };\n    frame.update(provideTimeSinceStart, true);\n    return () => cancelFrame(provideTimeSinceStart);\n  }, [callback]);\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/value/use-time.mjs\nfunction useTime() {\n  const time2 = useMotionValue(0);\n  useAnimationFrame((t) => time2.set(t));\n  return time2;\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/value/use-will-change/index.mjs\nvar WillChangeMotionValue = class extends MotionValue {\n  constructor() {\n    super(...arguments);\n    this.members = [];\n    this.transforms = /* @__PURE__ */ new Set();\n  }\n  add(name) {\n    let memberName;\n    if (transformProps.has(name)) {\n      this.transforms.add(name);\n      memberName = \"transform\";\n    } else if (!name.startsWith(\"origin\") && !isCSSVariableName(name) && name !== \"willChange\") {\n      memberName = camelToDash(name);\n    }\n    if (memberName) {\n      addUniqueItem(this.members, memberName);\n      this.update();\n    }\n  }\n  remove(name) {\n    if (transformProps.has(name)) {\n      this.transforms.delete(name);\n      if (!this.transforms.size) {\n        removeItem(this.members, \"transform\");\n      }\n    } else {\n      removeItem(this.members, camelToDash(name));\n    }\n    this.update();\n  }\n  update() {\n    this.set(this.members.length ? this.members.join(\", \") : \"auto\");\n  }\n};\nfunction useWillChange() {\n  return useConstant(() => new WillChangeMotionValue(\"auto\"));\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/utils/reduced-motion/use-reduced-motion.mjs\nvar import_react37 = __toESM(require_react(), 1);\nfunction useReducedMotion() {\n  !hasReducedMotionListener.current && initPrefersReducedMotion();\n  const [shouldReduceMotion] = (0, import_react37.useState)(prefersReducedMotion.current);\n  if (true) {\n    warnOnce(shouldReduceMotion !== true, \"You have Reduced Motion enabled on your device. Animations may not appear as expected.\");\n  }\n  return shouldReduceMotion;\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/utils/reduced-motion/use-reduced-motion-config.mjs\nvar import_react38 = __toESM(require_react(), 1);\nfunction useReducedMotionConfig() {\n  const reducedMotionPreference = useReducedMotion();\n  const { reducedMotion } = (0, import_react38.useContext)(MotionConfigContext);\n  if (reducedMotion === \"never\") {\n    return false;\n  } else if (reducedMotion === \"always\") {\n    return true;\n  } else {\n    return reducedMotionPreference;\n  }\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/animation/hooks/animation-controls.mjs\nfunction stopAnimation(visualElement) {\n  visualElement.values.forEach((value) => value.stop());\n}\nfunction setVariants(visualElement, variantLabels) {\n  const reversedLabels = [...variantLabels].reverse();\n  reversedLabels.forEach((key) => {\n    const variant = visualElement.getVariant(key);\n    variant && setTarget(visualElement, variant);\n    if (visualElement.variantChildren) {\n      visualElement.variantChildren.forEach((child) => {\n        setVariants(child, variantLabels);\n      });\n    }\n  });\n}\nfunction setValues(visualElement, definition) {\n  if (Array.isArray(definition)) {\n    return setVariants(visualElement, definition);\n  } else if (typeof definition === \"string\") {\n    return setVariants(visualElement, [definition]);\n  } else {\n    setTarget(visualElement, definition);\n  }\n}\nfunction animationControls() {\n  let hasMounted = false;\n  const subscribers = /* @__PURE__ */ new Set();\n  const controls = {\n    subscribe(visualElement) {\n      subscribers.add(visualElement);\n      return () => void subscribers.delete(visualElement);\n    },\n    start(definition, transitionOverride) {\n      invariant(hasMounted, \"controls.start() should only be called after a component has mounted. Consider calling within a useEffect hook.\");\n      const animations2 = [];\n      subscribers.forEach((visualElement) => {\n        animations2.push(animateVisualElement(visualElement, definition, {\n          transitionOverride\n        }));\n      });\n      return Promise.all(animations2);\n    },\n    set(definition) {\n      invariant(hasMounted, \"controls.set() should only be called after a component has mounted. Consider calling within a useEffect hook.\");\n      return subscribers.forEach((visualElement) => {\n        setValues(visualElement, definition);\n      });\n    },\n    stop() {\n      subscribers.forEach((visualElement) => {\n        stopAnimation(visualElement);\n      });\n    },\n    mount() {\n      hasMounted = true;\n      return () => {\n        hasMounted = false;\n        controls.stop();\n      };\n    }\n  };\n  return controls;\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/dom/scroll/observe.mjs\nfunction observeTimeline(update, timeline) {\n  let prevProgress;\n  const onFrame = () => {\n    const { currentTime } = timeline;\n    const percentage = currentTime === null ? 0 : currentTime.value;\n    const progress2 = percentage / 100;\n    if (prevProgress !== progress2) {\n      update(progress2);\n    }\n    prevProgress = progress2;\n  };\n  frame.update(onFrame, true);\n  return () => cancelFrame(onFrame);\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/dom/scroll/supports.mjs\nvar supportsScrollTimeline = memo(() => window.ScrollTimeline !== void 0);\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/animation/GroupPlaybackControls.mjs\nvar GroupPlaybackControls = class {\n  constructor(animations2) {\n    this.animations = animations2.filter(Boolean);\n  }\n  then(onResolve, onReject) {\n    return Promise.all(this.animations).then(onResolve).catch(onReject);\n  }\n  /**\n   * TODO: Filter out cancelled or stopped animations before returning\n   */\n  getAll(propName) {\n    return this.animations[0][propName];\n  }\n  setAll(propName, newValue) {\n    for (let i = 0; i < this.animations.length; i++) {\n      this.animations[i][propName] = newValue;\n    }\n  }\n  attachTimeline(timeline) {\n    const cancelAll = this.animations.map((animation) => {\n      if (supportsScrollTimeline() && animation.attachTimeline) {\n        animation.attachTimeline(timeline);\n      } else {\n        animation.pause();\n        return observeTimeline((progress2) => {\n          animation.time = animation.duration * progress2;\n        }, timeline);\n      }\n    });\n    return () => {\n      cancelAll.forEach((cancelTimeline, i) => {\n        if (cancelTimeline)\n          cancelTimeline();\n        this.animations[i].stop();\n      });\n    };\n  }\n  get time() {\n    return this.getAll(\"time\");\n  }\n  set time(time2) {\n    this.setAll(\"time\", time2);\n  }\n  get speed() {\n    return this.getAll(\"speed\");\n  }\n  set speed(speed) {\n    this.setAll(\"speed\", speed);\n  }\n  get duration() {\n    let max = 0;\n    for (let i = 0; i < this.animations.length; i++) {\n      max = Math.max(max, this.animations[i].duration);\n    }\n    return max;\n  }\n  runAll(methodName) {\n    this.animations.forEach((controls) => controls[methodName]());\n  }\n  play() {\n    this.runAll(\"play\");\n  }\n  pause() {\n    this.runAll(\"pause\");\n  }\n  stop() {\n    this.runAll(\"stop\");\n  }\n  cancel() {\n    this.runAll(\"cancel\");\n  }\n  complete() {\n    this.runAll(\"complete\");\n  }\n};\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/animation/utils/is-dom-keyframes.mjs\nfunction isDOMKeyframes(keyframes2) {\n  return typeof keyframes2 === \"object\" && !Array.isArray(keyframes2);\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/animation/utils/create-visual-element.mjs\nfunction createVisualElement(element) {\n  const options = {\n    presenceContext: null,\n    props: {},\n    visualState: {\n      renderState: {\n        transform: {},\n        transformOrigin: {},\n        style: {},\n        vars: {},\n        attrs: {}\n      },\n      latestValues: {}\n    }\n  };\n  const node = isSVGElement(element) ? new SVGVisualElement(options, {\n    enableHardwareAcceleration: false\n  }) : new HTMLVisualElement(options, {\n    enableHardwareAcceleration: true\n  });\n  node.mount(element);\n  visualElementStore.set(element, node);\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/easing/utils/create-generator-easing.mjs\nfunction createGeneratorEasing(options, scale2 = 100) {\n  const generator = spring({ keyframes: [0, scale2], ...options });\n  const duration = Math.min(calcGeneratorDuration(generator), maxGeneratorDuration);\n  return {\n    type: \"keyframes\",\n    ease: (progress2) => generator.next(duration * progress2).value / scale2,\n    duration: millisecondsToSeconds(duration)\n  };\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/animation/sequence/utils/calc-time.mjs\nfunction calcNextTime(current, next, prev, labels) {\n  var _a;\n  if (typeof next === \"number\") {\n    return next;\n  } else if (next.startsWith(\"-\") || next.startsWith(\"+\")) {\n    return Math.max(0, current + parseFloat(next));\n  } else if (next === \"<\") {\n    return prev;\n  } else {\n    return (_a = labels.get(next)) !== null && _a !== void 0 ? _a : current;\n  }\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/utils/wrap.mjs\nvar wrap = (min, max, v) => {\n  const rangeSize = max - min;\n  return ((v - min) % rangeSize + rangeSize) % rangeSize + min;\n};\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/easing/utils/get-easing-for-segment.mjs\nfunction getEasingForSegment(easing, i) {\n  return isEasingArray(easing) ? easing[wrap(0, easing.length, i)] : easing;\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/animation/sequence/utils/edit.mjs\nfunction eraseKeyframes(sequence, startTime, endTime) {\n  for (let i = 0; i < sequence.length; i++) {\n    const keyframe = sequence[i];\n    if (keyframe.at > startTime && keyframe.at < endTime) {\n      removeItem(sequence, keyframe);\n      i--;\n    }\n  }\n}\nfunction addKeyframes(sequence, keyframes2, easing, offset, startTime, endTime) {\n  eraseKeyframes(sequence, startTime, endTime);\n  for (let i = 0; i < keyframes2.length; i++) {\n    sequence.push({\n      value: keyframes2[i],\n      at: mixNumber(startTime, endTime, offset[i]),\n      easing: getEasingForSegment(easing, i)\n    });\n  }\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/animation/sequence/utils/sort.mjs\nfunction compareByTime(a, b) {\n  if (a.at === b.at) {\n    if (a.value === null)\n      return 1;\n    if (b.value === null)\n      return -1;\n    return 0;\n  } else {\n    return a.at - b.at;\n  }\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/animation/sequence/create.mjs\nvar defaultSegmentEasing = \"easeInOut\";\nfunction createAnimationsFromSequence(sequence, { defaultTransition = {}, ...sequenceTransition } = {}, scope) {\n  const defaultDuration = defaultTransition.duration || 0.3;\n  const animationDefinitions = /* @__PURE__ */ new Map();\n  const sequences = /* @__PURE__ */ new Map();\n  const elementCache = {};\n  const timeLabels = /* @__PURE__ */ new Map();\n  let prevTime = 0;\n  let currentTime = 0;\n  let totalDuration = 0;\n  for (let i = 0; i < sequence.length; i++) {\n    const segment = sequence[i];\n    if (typeof segment === \"string\") {\n      timeLabels.set(segment, currentTime);\n      continue;\n    } else if (!Array.isArray(segment)) {\n      timeLabels.set(segment.name, calcNextTime(currentTime, segment.at, prevTime, timeLabels));\n      continue;\n    }\n    let [subject, keyframes2, transition = {}] = segment;\n    if (transition.at !== void 0) {\n      currentTime = calcNextTime(currentTime, transition.at, prevTime, timeLabels);\n    }\n    let maxDuration3 = 0;\n    const resolveValueSequence = (valueKeyframes, valueTransition, valueSequence, elementIndex = 0, numElements = 0) => {\n      const valueKeyframesAsList = keyframesAsList(valueKeyframes);\n      const { delay: delay2 = 0, times = defaultOffset(valueKeyframesAsList), type = \"keyframes\", ...remainingTransition } = valueTransition;\n      let { ease: ease2 = defaultTransition.ease || \"easeOut\", duration } = valueTransition;\n      const calculatedDelay = typeof delay2 === \"function\" ? delay2(elementIndex, numElements) : delay2;\n      const numKeyframes = valueKeyframesAsList.length;\n      if (numKeyframes <= 2 && type === \"spring\") {\n        let absoluteDelta = 100;\n        if (numKeyframes === 2 && isNumberKeyframesArray(valueKeyframesAsList)) {\n          const delta = valueKeyframesAsList[1] - valueKeyframesAsList[0];\n          absoluteDelta = Math.abs(delta);\n        }\n        const springTransition = { ...remainingTransition };\n        if (duration !== void 0) {\n          springTransition.duration = secondsToMilliseconds(duration);\n        }\n        const springEasing = createGeneratorEasing(springTransition, absoluteDelta);\n        ease2 = springEasing.ease;\n        duration = springEasing.duration;\n      }\n      duration !== null && duration !== void 0 ? duration : duration = defaultDuration;\n      const startTime = currentTime + calculatedDelay;\n      const targetTime = startTime + duration;\n      if (times.length === 1 && times[0] === 0) {\n        times[1] = 1;\n      }\n      const remainder = times.length - valueKeyframesAsList.length;\n      remainder > 0 && fillOffset(times, remainder);\n      valueKeyframesAsList.length === 1 && valueKeyframesAsList.unshift(null);\n      addKeyframes(valueSequence, valueKeyframesAsList, ease2, times, startTime, targetTime);\n      maxDuration3 = Math.max(calculatedDelay + duration, maxDuration3);\n      totalDuration = Math.max(targetTime, totalDuration);\n    };\n    if (isMotionValue(subject)) {\n      const subjectSequence = getSubjectSequence(subject, sequences);\n      resolveValueSequence(keyframes2, transition, getValueSequence(\"default\", subjectSequence));\n    } else {\n      const elements = resolveElements(subject, scope, elementCache);\n      const numElements = elements.length;\n      for (let elementIndex = 0; elementIndex < numElements; elementIndex++) {\n        keyframes2 = keyframes2;\n        transition = transition;\n        const element = elements[elementIndex];\n        const subjectSequence = getSubjectSequence(element, sequences);\n        for (const key in keyframes2) {\n          resolveValueSequence(keyframes2[key], getValueTransition2(transition, key), getValueSequence(key, subjectSequence), elementIndex, numElements);\n        }\n      }\n    }\n    prevTime = currentTime;\n    currentTime += maxDuration3;\n  }\n  sequences.forEach((valueSequences, element) => {\n    for (const key in valueSequences) {\n      const valueSequence = valueSequences[key];\n      valueSequence.sort(compareByTime);\n      const keyframes2 = [];\n      const valueOffset = [];\n      const valueEasing = [];\n      for (let i = 0; i < valueSequence.length; i++) {\n        const { at, value, easing } = valueSequence[i];\n        keyframes2.push(value);\n        valueOffset.push(progress(0, totalDuration, at));\n        valueEasing.push(easing || \"easeOut\");\n      }\n      if (valueOffset[0] !== 0) {\n        valueOffset.unshift(0);\n        keyframes2.unshift(keyframes2[0]);\n        valueEasing.unshift(defaultSegmentEasing);\n      }\n      if (valueOffset[valueOffset.length - 1] !== 1) {\n        valueOffset.push(1);\n        keyframes2.push(null);\n      }\n      if (!animationDefinitions.has(element)) {\n        animationDefinitions.set(element, {\n          keyframes: {},\n          transition: {}\n        });\n      }\n      const definition = animationDefinitions.get(element);\n      definition.keyframes[key] = keyframes2;\n      definition.transition[key] = {\n        ...defaultTransition,\n        duration: totalDuration,\n        ease: valueEasing,\n        times: valueOffset,\n        ...sequenceTransition\n      };\n    }\n  });\n  return animationDefinitions;\n}\nfunction getSubjectSequence(subject, sequences) {\n  !sequences.has(subject) && sequences.set(subject, {});\n  return sequences.get(subject);\n}\nfunction getValueSequence(name, sequences) {\n  if (!sequences[name])\n    sequences[name] = [];\n  return sequences[name];\n}\nfunction keyframesAsList(keyframes2) {\n  return Array.isArray(keyframes2) ? keyframes2 : [keyframes2];\n}\nfunction getValueTransition2(transition, key) {\n  return transition[key] ? { ...transition, ...transition[key] } : { ...transition };\n}\nvar isNumber = (keyframe) => typeof keyframe === \"number\";\nvar isNumberKeyframesArray = (keyframes2) => keyframes2.every(isNumber);\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/animation/animate.mjs\nfunction animateElements(elementOrSelector, keyframes2, options, scope) {\n  const elements = resolveElements(elementOrSelector, scope);\n  const numElements = elements.length;\n  invariant(Boolean(numElements), \"No valid element provided.\");\n  const animations2 = [];\n  for (let i = 0; i < numElements; i++) {\n    const element = elements[i];\n    if (!visualElementStore.has(element)) {\n      createVisualElement(element);\n    }\n    const visualElement = visualElementStore.get(element);\n    const transition = { ...options };\n    if (typeof transition.delay === \"function\") {\n      transition.delay = transition.delay(i, numElements);\n    }\n    animations2.push(...animateTarget(visualElement, { ...keyframes2, transition }, {}));\n  }\n  return new GroupPlaybackControls(animations2);\n}\nvar isSequence = (value) => Array.isArray(value) && Array.isArray(value[0]);\nfunction animateSequence(sequence, options, scope) {\n  const animations2 = [];\n  const animationDefinitions = createAnimationsFromSequence(sequence, options, scope);\n  animationDefinitions.forEach(({ keyframes: keyframes2, transition }, subject) => {\n    let animation;\n    if (isMotionValue(subject)) {\n      animation = animateSingleValue(subject, keyframes2.default, transition.default);\n    } else {\n      animation = animateElements(subject, keyframes2, transition);\n    }\n    animations2.push(animation);\n  });\n  return new GroupPlaybackControls(animations2);\n}\nvar createScopedAnimate = (scope) => {\n  function scopedAnimate(valueOrElementOrSequence, keyframes2, options) {\n    let animation;\n    if (isSequence(valueOrElementOrSequence)) {\n      animation = animateSequence(valueOrElementOrSequence, keyframes2, scope);\n    } else if (isDOMKeyframes(keyframes2)) {\n      animation = animateElements(valueOrElementOrSequence, keyframes2, options, scope);\n    } else {\n      animation = animateSingleValue(valueOrElementOrSequence, keyframes2, options);\n    }\n    if (scope) {\n      scope.animations.push(animation);\n    }\n    return animation;\n  }\n  return scopedAnimate;\n};\nvar animate = createScopedAnimate();\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/animation/hooks/use-animate.mjs\nfunction useAnimate() {\n  const scope = useConstant(() => ({\n    current: null,\n    animations: []\n  }));\n  const animate2 = useConstant(() => createScopedAnimate(scope));\n  useUnmountEffect(() => {\n    scope.animations.forEach((animation) => animation.stop());\n  });\n  return [scope, animate2];\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/animation/hooks/use-animation.mjs\nfunction useAnimationControls() {\n  const controls = useConstant(animationControls);\n  useIsomorphicLayoutEffect(controls.mount, []);\n  return controls;\n}\nvar useAnimation = useAnimationControls;\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/utils/use-cycle.mjs\nvar import_react39 = __toESM(require_react(), 1);\nfunction useCycle(...items) {\n  const index = (0, import_react39.useRef)(0);\n  const [item, setItem] = (0, import_react39.useState)(items[index.current]);\n  const runCycle = (0, import_react39.useCallback)(\n    (next) => {\n      index.current = typeof next !== \"number\" ? wrap(0, items.length, index.current + 1) : next;\n      setItem(items[index.current]);\n    },\n    // The array will change on each call, but by putting items.length at\n    // the front of this array, we guarantee the dependency comparison will match up\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [items.length, ...items]\n  );\n  return [item, runCycle];\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/utils/use-in-view.mjs\nvar import_react40 = __toESM(require_react(), 1);\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/dom/viewport/index.mjs\nvar thresholds = {\n  some: 0,\n  all: 1\n};\nfunction inView(elementOrSelector, onStart, { root, margin: rootMargin, amount = \"some\" } = {}) {\n  const elements = resolveElements(elementOrSelector);\n  const activeIntersections = /* @__PURE__ */ new WeakMap();\n  const onIntersectionChange = (entries) => {\n    entries.forEach((entry) => {\n      const onEnd = activeIntersections.get(entry.target);\n      if (entry.isIntersecting === Boolean(onEnd))\n        return;\n      if (entry.isIntersecting) {\n        const newOnEnd = onStart(entry);\n        if (typeof newOnEnd === \"function\") {\n          activeIntersections.set(entry.target, newOnEnd);\n        } else {\n          observer2.unobserve(entry.target);\n        }\n      } else if (onEnd) {\n        onEnd(entry);\n        activeIntersections.delete(entry.target);\n      }\n    });\n  };\n  const observer2 = new IntersectionObserver(onIntersectionChange, {\n    root,\n    rootMargin,\n    threshold: typeof amount === \"number\" ? amount : thresholds[amount]\n  });\n  elements.forEach((element) => observer2.observe(element));\n  return () => observer2.disconnect();\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/utils/use-in-view.mjs\nfunction useInView(ref, { root, margin, amount, once = false } = {}) {\n  const [isInView, setInView] = (0, import_react40.useState)(false);\n  (0, import_react40.useEffect)(() => {\n    if (!ref.current || once && isInView)\n      return;\n    const onEnter = () => {\n      setInView(true);\n      return once ? void 0 : () => setInView(false);\n    };\n    const options = {\n      root: root && root.current || void 0,\n      margin,\n      amount\n    };\n    return inView(ref.current, onEnter, options);\n  }, [root, ref, margin, once, amount]);\n  return isInView;\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/gestures/drag/use-drag-controls.mjs\nvar DragControls = class {\n  constructor() {\n    this.componentControls = /* @__PURE__ */ new Set();\n  }\n  /**\n   * Subscribe a component's internal `VisualElementDragControls` to the user-facing API.\n   *\n   * @internal\n   */\n  subscribe(controls) {\n    this.componentControls.add(controls);\n    return () => this.componentControls.delete(controls);\n  }\n  /**\n   * Start a drag gesture on every `motion` component that has this set of drag controls\n   * passed into it via the `dragControls` prop.\n   *\n   * ```jsx\n   * dragControls.start(e, {\n   *   snapToCursor: true\n   * })\n   * ```\n   *\n   * @param event - PointerEvent\n   * @param options - Options\n   *\n   * @public\n   */\n  start(event, options) {\n    this.componentControls.forEach((controls) => {\n      controls.start(event.nativeEvent || event, options);\n    });\n  }\n};\nvar createDragControls = () => new DragControls();\nfunction useDragControls() {\n  return useConstant(createDragControls);\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/events/use-dom-event.mjs\nvar import_react41 = __toESM(require_react(), 1);\nfunction useDomEvent(ref, eventName, handler, options) {\n  (0, import_react41.useEffect)(() => {\n    const element = ref.current;\n    if (handler && element) {\n      return addDomEvent(element, eventName, handler, options);\n    }\n  }, [ref, eventName, handler, options]);\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/motion/utils/is-motion-component.mjs\nfunction isMotionComponent(component) {\n  return component !== null && typeof component === \"object\" && motionComponentSymbol in component;\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/motion/utils/unwrap-motion-component.mjs\nfunction unwrapMotionComponent(component) {\n  if (isMotionComponent(component)) {\n    return component[motionComponentSymbol];\n  }\n  return void 0;\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/utils/use-instant-transition.mjs\nvar import_react42 = __toESM(require_react(), 1);\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/projection/use-instant-layout-transition.mjs\nfunction useInstantLayoutTransition() {\n  return startTransition;\n}\nfunction startTransition(callback) {\n  if (!rootProjectionNode.current)\n    return;\n  rootProjectionNode.current.isUpdating = false;\n  rootProjectionNode.current.blockUpdate();\n  callback && callback();\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/utils/use-instant-transition.mjs\nfunction useInstantTransition() {\n  const [forceUpdate, forcedRenderCount] = useForceUpdate();\n  const startInstantLayoutTransition = useInstantLayoutTransition();\n  const unlockOnFrameRef = (0, import_react42.useRef)();\n  (0, import_react42.useEffect)(() => {\n    frame.postRender(() => frame.postRender(() => {\n      if (forcedRenderCount !== unlockOnFrameRef.current)\n        return;\n      instantAnimationState.current = false;\n    }));\n  }, [forcedRenderCount]);\n  return (callback) => {\n    startInstantLayoutTransition(() => {\n      instantAnimationState.current = true;\n      forceUpdate();\n      callback();\n      unlockOnFrameRef.current = forcedRenderCount + 1;\n    });\n  };\n}\nfunction disableInstantTransitions() {\n  instantAnimationState.current = false;\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/projection/use-reset-projection.mjs\nvar React10 = __toESM(require_react(), 1);\nfunction useResetProjection() {\n  const reset = React10.useCallback(() => {\n    const root = rootProjectionNode.current;\n    if (!root)\n      return;\n    root.resetTree();\n  }, []);\n  return reset;\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/animation/optimized-appear/store-id.mjs\nvar appearStoreId = (id4, value) => `${id4}: ${value}`;\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/animation/optimized-appear/store.mjs\nvar appearAnimationStore = /* @__PURE__ */ new Map();\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/animation/optimized-appear/handoff.mjs\nvar handoffFrameTime;\nfunction handoffOptimizedAppearAnimation(elementId, valueName, _value, _frame) {\n  const optimisedValueName = transformProps.has(valueName) ? \"transform\" : valueName;\n  const storeId = appearStoreId(elementId, optimisedValueName);\n  const optimisedAnimation = appearAnimationStore.get(storeId);\n  if (!optimisedAnimation) {\n    return null;\n  }\n  const { animation, startTime } = optimisedAnimation;\n  const cancelAnimation = () => {\n    appearAnimationStore.delete(storeId);\n    try {\n      animation.cancel();\n    } catch (error) {\n    }\n  };\n  if (startTime === null || window.HandoffComplete) {\n    cancelAnimation();\n    return null;\n  } else {\n    if (handoffFrameTime === void 0) {\n      handoffFrameTime = performance.now();\n    }\n    return handoffFrameTime - startTime || 0;\n  }\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/animation/optimized-appear/start.mjs\nvar startFrameTime;\nvar readyAnimation;\nfunction startOptimizedAppearAnimation(element, name, keyframes2, options, onReady) {\n  if (window.HandoffComplete) {\n    window.HandoffAppearAnimations = void 0;\n    return;\n  }\n  const id4 = element.dataset[optimizedAppearDataId];\n  if (!id4)\n    return;\n  window.HandoffAppearAnimations = handoffOptimizedAppearAnimation;\n  const storeId = appearStoreId(id4, name);\n  if (!readyAnimation) {\n    readyAnimation = animateStyle(\n      element,\n      name,\n      [keyframes2[0], keyframes2[0]],\n      /**\n       * 10 secs is basically just a super-safe duration to give Chrome\n       * long enough to get the animation ready.\n       */\n      { duration: 1e4, ease: \"linear\" }\n    );\n    appearAnimationStore.set(storeId, {\n      animation: readyAnimation,\n      startTime: null\n    });\n    if (!window.HandoffCancelAllAnimations) {\n      window.HandoffCancelAllAnimations = () => {\n        appearAnimationStore.forEach(({ animation }) => {\n          animation.cancel();\n        });\n        appearAnimationStore.clear();\n        window.HandoffCancelAllAnimations = void 0;\n      };\n    }\n  }\n  const startAnimation = () => {\n    readyAnimation.cancel();\n    const appearAnimation = animateStyle(element, name, keyframes2, options);\n    if (startFrameTime === void 0) {\n      startFrameTime = performance.now();\n    }\n    appearAnimation.startTime = startFrameTime;\n    appearAnimationStore.set(storeId, {\n      animation: appearAnimation,\n      startTime: startFrameTime\n    });\n    if (onReady)\n      onReady(appearAnimation);\n  };\n  if (readyAnimation.ready) {\n    readyAnimation.ready.then(startAnimation).catch(noop);\n  } else {\n    startAnimation();\n  }\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/animation/hooks/use-animated-state.mjs\nvar import_react43 = __toESM(require_react(), 1);\nvar createObject = () => ({});\nvar StateVisualElement = class extends VisualElement {\n  build() {\n  }\n  measureInstanceViewportBox() {\n    return createBox();\n  }\n  resetTransform() {\n  }\n  restoreTransform() {\n  }\n  removeValueFromRenderState() {\n  }\n  renderInstance() {\n  }\n  scrapeMotionValuesFromProps() {\n    return createObject();\n  }\n  getBaseTargetFromProps() {\n    return void 0;\n  }\n  readValueFromInstance(_state, key, options) {\n    return options.initialState[key] || 0;\n  }\n  sortInstanceNodePosition() {\n    return 0;\n  }\n};\nvar useVisualState = makeUseVisualState({\n  scrapeMotionValuesFromProps: createObject,\n  createRenderState: createObject\n});\nfunction useAnimatedState(initialState) {\n  const [animationState, setAnimationState] = (0, import_react43.useState)(initialState);\n  const visualState = useVisualState({}, false);\n  const element = useConstant(() => {\n    return new StateVisualElement({ props: {}, visualState, presenceContext: null }, { initialState });\n  });\n  (0, import_react43.useEffect)(() => {\n    element.mount({});\n    return () => element.unmount();\n  }, [element]);\n  (0, import_react43.useEffect)(() => {\n    element.update({\n      onUpdate: (v) => {\n        setAnimationState({ ...v });\n      }\n    }, null);\n  }, [setAnimationState, element]);\n  const startAnimation = useConstant(() => (animationDefinition) => {\n    return animateVisualElement(element, animationDefinition);\n  });\n  return [animationState, startAnimation];\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/value/use-inverted-scale.mjs\nvar import_react44 = __toESM(require_react(), 1);\nvar maxScale = 1e5;\nvar invertScale = (scale2) => scale2 > 1e-3 ? 1 / scale2 : maxScale;\nvar hasWarned = false;\nfunction useInvertedScale(scale2) {\n  let parentScaleX = useMotionValue(1);\n  let parentScaleY = useMotionValue(1);\n  const { visualElement } = (0, import_react44.useContext)(MotionContext);\n  invariant(!!(scale2 || visualElement), \"If no scale values are provided, useInvertedScale must be used within a child of another motion component.\");\n  warning(hasWarned, \"useInvertedScale is deprecated and will be removed in 3.0. Use the layout prop instead.\");\n  hasWarned = true;\n  if (scale2) {\n    parentScaleX = scale2.scaleX || parentScaleX;\n    parentScaleY = scale2.scaleY || parentScaleY;\n  } else if (visualElement) {\n    parentScaleX = visualElement.getValue(\"scaleX\", 1);\n    parentScaleY = visualElement.getValue(\"scaleY\", 1);\n  }\n  const scaleX = useTransform(parentScaleX, invertScale);\n  const scaleY = useTransform(parentScaleY, invertScale);\n  return { scaleX, scaleY };\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/components/AnimateSharedLayout.mjs\nvar React11 = __toESM(require_react(), 1);\nvar id3 = 0;\nvar AnimateSharedLayout = ({ children }) => {\n  React11.useEffect(() => {\n    invariant(false, \"AnimateSharedLayout is deprecated: https://www.framer.com/docs/guide-upgrade/##shared-layout-animations\");\n  }, []);\n  return React11.createElement(LayoutGroup, { id: useConstant(() => `asl-${id3++}`) }, children);\n};\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/render/dom/scroll/index.mjs\nfunction scrollTimelineFallback({ source, axis = \"y\" }) {\n  const currentTime = { value: 0 };\n  const cancel = scrollInfo((info) => {\n    currentTime.value = info[axis].progress * 100;\n  }, { container: source, axis });\n  return { currentTime, cancel };\n}\nvar timelineCache = /* @__PURE__ */ new Map();\nfunction getTimeline({ source = document.documentElement, axis = \"y\" } = {}) {\n  if (!timelineCache.has(source)) {\n    timelineCache.set(source, {});\n  }\n  const elementCache = timelineCache.get(source);\n  if (!elementCache[axis]) {\n    elementCache[axis] = supportsScrollTimeline() ? new ScrollTimeline({ source, axis }) : scrollTimelineFallback({ source, axis });\n  }\n  return elementCache[axis];\n}\nfunction scroll(onScroll, options) {\n  const timeline = getTimeline(options);\n  if (typeof onScroll === \"function\") {\n    return observeTimeline(onScroll, timeline);\n  } else {\n    return onScroll.attachTimeline(timeline);\n  }\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/animation/utils/stagger.mjs\nfunction getOriginIndex(from, total) {\n  if (from === \"first\") {\n    return 0;\n  } else {\n    const lastIndex = total - 1;\n    return from === \"last\" ? lastIndex : lastIndex / 2;\n  }\n}\nfunction stagger(duration = 0.1, { startDelay = 0, from = 0, ease: ease2 } = {}) {\n  return (i, total) => {\n    const fromIndex = typeof from === \"number\" ? from : getOriginIndex(from, total);\n    const distance2 = Math.abs(fromIndex - i);\n    let delay2 = duration * distance2;\n    if (ease2) {\n      const maxDelay = total * duration;\n      const easingFunction = easingDefinitionToFunction(ease2);\n      delay2 = easingFunction(delay2 / maxDelay) * maxDelay;\n    }\n    return startDelay + delay2;\n  };\n}\n\n// ../../node_modules/.pnpm/framer-motion@11.0.24_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/framer-motion/dist/es/frameloop/index-legacy.mjs\nvar sync = frame;\nvar cancelSync = stepsOrder.reduce((acc, key) => {\n  acc[key] = (process2) => cancelFrame(process2);\n  return acc;\n}, {});\nexport {\n  AcceleratedAnimation,\n  AnimatePresence,\n  AnimateSharedLayout,\n  DeprecatedLayoutGroupContext,\n  DragControls,\n  FlatTree,\n  LayoutGroup,\n  LayoutGroupContext,\n  LazyMotion,\n  MotionConfig,\n  MotionConfigContext,\n  MotionContext,\n  MotionGlobalConfig,\n  MotionValue,\n  PresenceContext,\n  Reorder,\n  SwitchLayoutGroupContext,\n  VisualElement,\n  addPointerEvent,\n  addPointerInfo,\n  addScaleCorrector,\n  animate,\n  animateValue,\n  animateVisualElement,\n  animationControls,\n  animations,\n  anticipate,\n  backIn,\n  backInOut,\n  backOut,\n  buildTransform,\n  calcLength,\n  cancelFrame,\n  cancelSync,\n  circIn,\n  circInOut,\n  circOut,\n  clamp,\n  color,\n  complex,\n  createBox,\n  createDomMotionComponent,\n  createMotionComponent,\n  createScopedAnimate,\n  cubicBezier,\n  delay,\n  disableInstantTransitions,\n  distance,\n  distance2D,\n  domAnimation,\n  domMax,\n  easeIn,\n  easeInOut,\n  easeOut,\n  filterProps,\n  frame,\n  frameData,\n  inView,\n  interpolate,\n  invariant,\n  isBrowser,\n  isDragActive,\n  isMotionComponent,\n  isMotionValue,\n  isValidMotionProp,\n  m,\n  makeUseVisualState,\n  mirrorEasing,\n  mix,\n  motion,\n  motionValue,\n  optimizedAppearDataAttribute,\n  pipe,\n  progress,\n  px,\n  resolveMotionValue,\n  reverseEasing,\n  scroll,\n  scrollInfo,\n  spring,\n  stagger,\n  startOptimizedAppearAnimation,\n  steps,\n  sync,\n  transform,\n  unwrapMotionComponent,\n  useAnimate,\n  useAnimation,\n  useAnimationControls,\n  useAnimationFrame,\n  useCycle,\n  useAnimatedState as useDeprecatedAnimatedState,\n  useInvertedScale as useDeprecatedInvertedScale,\n  useDomEvent,\n  useDragControls,\n  useElementScroll,\n  useForceUpdate,\n  useInView,\n  useInstantLayoutTransition,\n  useInstantTransition,\n  useIsPresent,\n  useIsomorphicLayoutEffect,\n  useMotionTemplate,\n  useMotionValue,\n  useMotionValueEvent,\n  usePresence,\n  useReducedMotion,\n  useReducedMotionConfig,\n  useResetProjection,\n  useScroll,\n  useSpring,\n  useTime,\n  useTransform,\n  useUnmountEffect,\n  useVelocity,\n  useViewportScroll,\n  useWillChange,\n  visualElementStore,\n  warning,\n  wrap\n};\n//# sourceMappingURL=framer-motion.js.map\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 355207,
            "count": 1
          },
          {
            "startOffset": 2522,
            "endOffset": 2547,
            "count": 0
          },
          {
            "startOffset": 14730,
            "endOffset": 14842,
            "count": 9
          },
          {
            "startOffset": 46039,
            "endOffset": 46045,
            "count": 0
          },
          {
            "startOffset": 248281,
            "endOffset": 248293,
            "count": 0
          }
        ]
      },
      {
        "functionName": "optional-peer-dep:__vite-optional-peer-dep:@emotion/is-prop-valid:framer-motion",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 327,
            "endOffset": 529,
            "count": 1
          }
        ]
      },
      {
        "functionName": "transformPagePoint",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1064,
            "endOffset": 1072,
            "count": 0
          }
        ]
      },
      {
        "functionName": "camelToDash",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 3006,
            "endOffset": 3069,
            "count": 1
          }
        ]
      },
      {
        "functionName": "Queue",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 3778,
            "endOffset": 3866,
            "count": 24
          }
        ]
      },
      {
        "functionName": "add",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 3869,
            "endOffset": 4023,
            "count": 0
          }
        ]
      },
      {
        "functionName": "remove",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4026,
            "endOffset": 4200,
            "count": 0
          }
        ]
      },
      {
        "functionName": "clear",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4203,
            "endOffset": 4271,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createRenderStep",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 4275,
            "endOffset": 5937,
            "count": 12
          }
        ]
      },
      {
        "functionName": "schedule",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4609,
            "endOffset": 4990,
            "count": 0
          }
        ]
      },
      {
        "functionName": "cancel",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 5088,
            "endOffset": 5179,
            "count": 0
          }
        ]
      },
      {
        "functionName": "process",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 5249,
            "endOffset": 5915,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createRenderBatcher",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 6232,
            "endOffset": 7763,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 6472,
            "endOffset": 6567,
            "count": 12
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 6520,
            "endOffset": 6545,
            "count": 0
          }
        ]
      },
      {
        "functionName": "processStep",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 6596,
            "endOffset": 6648,
            "count": 0
          }
        ]
      },
      {
        "functionName": "processBatch",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 6673,
            "endOffset": 7172,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wake",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 7189,
            "endOffset": 7331,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7370,
            "endOffset": 7612,
            "count": 12
          }
        ]
      },
      {
        "functionName": "acc.<computed>",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 7431,
            "endOffset": 7591,
            "count": 0
          }
        ]
      },
      {
        "functionName": "cancel",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 7636,
            "endOffset": 7707,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useVisualElement",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 8183,
            "endOffset": 9956,
            "count": 0
          }
        ]
      },
      {
        "functionName": "isRefObject",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10322,
            "endOffset": 10448,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useMotionRef",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10611,
            "endOffset": 11374,
            "count": 0
          }
        ]
      },
      {
        "functionName": "isVariantLabel",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11751,
            "endOffset": 11833,
            "count": 0
          }
        ]
      },
      {
        "functionName": "isAnimationControls",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12006,
            "endOffset": 12120,
            "count": 0
          }
        ]
      },
      {
        "functionName": "isControllingVariants",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12642,
            "endOffset": 12788,
            "count": 0
          }
        ]
      },
      {
        "functionName": "isVariantNode",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12789,
            "endOffset": 12888,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getCurrentTreeVariants",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13051,
            "endOffset": 13403,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useCreateMotionContext",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13567,
            "endOffset": 13879,
            "count": 0
          }
        ]
      },
      {
        "functionName": "variantLabelsAsDependency",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13880,
            "endOffset": 13978,
            "count": 0
          }
        ]
      },
      {
        "functionName": "isEnabled",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14777,
            "endOffset": 14835,
            "count": 0
          }
        ]
      },
      {
        "functionName": "loadFeatures",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15007,
            "endOffset": 15174,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createMotionComponent",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 16101,
            "endOffset": 17934,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useLayoutId",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 17935,
            "endOffset": 18143,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createMotionProxy",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 18302,
            "endOffset": 19051,
            "count": 2
          },
          {
            "startOffset": 18540,
            "endOffset": 18564,
            "count": 0
          }
        ]
      },
      {
        "functionName": "custom",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 18347,
            "endOffset": 18503,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 18888,
            "endOffset": 19043,
            "count": 0
          }
        ]
      },
      {
        "functionName": "isSVGComponent",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 19692,
            "endOffset": 20355,
            "count": 0
          }
        ]
      },
      {
        "functionName": "addScaleCorrector",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 20963,
            "endOffset": 21051,
            "count": 0
          }
        ]
      },
      {
        "functionName": "isForcedMotionValue",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 21676,
            "endOffset": 21891,
            "count": 0
          }
        ]
      },
      {
        "functionName": "isMotionValue",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 22074,
            "endOffset": 22120,
            "count": 0
          }
        ]
      },
      {
        "functionName": "buildTransform",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 22458,
            "endOffset": 23264,
            "count": 0
          }
        ]
      },
      {
        "functionName": "checkStringStartsWith",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 23460,
            "endOffset": 23528,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 23471,
            "endOffset": 23528,
            "count": 0
          }
        ]
      },
      {
        "functionName": "isCSSVariableToken",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 23669,
            "endOffset": 23848,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getValueAsType",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 24156,
            "endOffset": 24252,
            "count": 0
          }
        ]
      },
      {
        "functionName": "clamp",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 24412,
            "endOffset": 24506,
            "count": 0
          }
        ]
      },
      {
        "functionName": "test",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 24691,
            "endOffset": 24719,
            "count": 0
          }
        ]
      },
      {
        "functionName": "transform",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 24755,
            "endOffset": 24763,
            "count": 0
          }
        ]
      },
      {
        "functionName": "transform",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 24807,
            "endOffset": 24828,
            "count": 0
          }
        ]
      },
      {
        "functionName": "sanitize",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 25042,
            "endOffset": 25074,
            "count": 0
          }
        ]
      },
      {
        "functionName": "isString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 25401,
            "endOffset": 25457,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createUnitType",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 25639,
            "endOffset": 25786,
            "count": 5
          }
        ]
      },
      {
        "functionName": "test",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 25660,
            "endOffset": 25727,
            "count": 0
          }
        ]
      },
      {
        "functionName": "transform",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 25763,
            "endOffset": 25783,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parse",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 26003,
            "endOffset": 26032,
            "count": 0
          }
        ]
      },
      {
        "functionName": "transform",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 26047,
            "endOffset": 26080,
            "count": 0
          }
        ]
      },
      {
        "functionName": "buildHTMLStyles",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 27889,
            "endOffset": 29219,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createHtmlRenderState",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 29420,
            "endOffset": 29495,
            "count": 0
          }
        ]
      },
      {
        "functionName": "copyRawValuesOnly",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 29653,
            "endOffset": 29854,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useInitialMotionValues",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 29855,
            "endOffset": 30203,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useStyle",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 30204,
            "endOffset": 30454,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useHTMLProps",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 30455,
            "endOffset": 31027,
            "count": 0
          }
        ]
      },
      {
        "functionName": "isValidMotionProp",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 31750,
            "endOffset": 32009,
            "count": 0
          }
        ]
      },
      {
        "functionName": "shouldForward",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 32194,
            "endOffset": 32226,
            "count": 0
          }
        ]
      },
      {
        "functionName": "loadExternalIsValidProp",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 32228,
            "endOffset": 32403,
            "count": 0
          }
        ]
      },
      {
        "functionName": "filterProps",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 32501,
            "endOffset": 33013,
            "count": 0
          }
        ]
      },
      {
        "functionName": "calcOrigin",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 33387,
            "endOffset": 33517,
            "count": 0
          }
        ]
      },
      {
        "functionName": "calcSVGTransformOrigin",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 33518,
            "endOffset": 33768,
            "count": 0
          }
        ]
      },
      {
        "functionName": "buildSVGPath",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 34082,
            "endOffset": 34433,
            "count": 0
          }
        ]
      },
      {
        "functionName": "buildSVGAttrs",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 34597,
            "endOffset": 35725,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createSvgRenderState",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 35924,
            "endOffset": 35977,
            "count": 0
          }
        ]
      },
      {
        "functionName": "isSVGTag",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 36156,
            "endOffset": 36219,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useSVGProps",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 36376,
            "endOffset": 36954,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createUseRender",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 37111,
            "endOffset": 37933,
            "count": 0
          }
        ]
      },
      {
        "functionName": "renderHTML",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 38093,
            "endOffset": 38340,
            "count": 0
          }
        ]
      },
      {
        "functionName": "renderSVG",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 39132,
            "endOffset": 39407,
            "count": 0
          }
        ]
      },
      {
        "functionName": "scrapeMotionValuesFromProps",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 39581,
            "endOffset": 40102,
            "count": 0
          }
        ]
      },
      {
        "functionName": "scrapeMotionValuesFromProps2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 40275,
            "endOffset": 40729,
            "count": 0
          }
        ]
      },
      {
        "functionName": "resolveVariantFromProps",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 41108,
            "endOffset": 41641,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useConstant",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 41845,
            "endOffset": 42005,
            "count": 0
          }
        ]
      },
      {
        "functionName": "isKeyframesTarget",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 42200,
            "endOffset": 42237,
            "count": 0
          }
        ]
      },
      {
        "functionName": "isCustomValue",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 42413,
            "endOffset": 42491,
            "count": 0
          }
        ]
      },
      {
        "functionName": "resolveFinalValueInKeyframes",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 42528,
            "endOffset": 42596,
            "count": 0
          }
        ]
      },
      {
        "functionName": "resolveMotionValue",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 42765,
            "endOffset": 42956,
            "count": 0
          }
        ]
      },
      {
        "functionName": "makeState",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 43121,
            "endOffset": 43528,
            "count": 0
          }
        ]
      },
      {
        "functionName": "makeUseVisualState",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 43554,
            "endOffset": 43851,
            "count": 3
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 43566,
            "endOffset": 43851,
            "count": 0
          }
        ]
      },
      {
        "functionName": "makeLatestValues",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 43853,
            "endOffset": 45557,
            "count": 0
          }
        ]
      },
      {
        "functionName": "noop",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 45714,
            "endOffset": 45726,
            "count": 0
          }
        ]
      },
      {
        "functionName": "onMount",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 46397,
            "endOffset": 47019,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createDomMotionConfig",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 47503,
            "endOffset": 47912,
            "count": 0
          }
        ]
      },
      {
        "functionName": "addDomEvent",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 48068,
            "endOffset": 48268,
            "count": 0
          }
        ]
      },
      {
        "functionName": "isPrimaryPointer",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 48458,
            "endOffset": 48630,
            "count": 0
          }
        ]
      },
      {
        "functionName": "extractEventInfo",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 48784,
            "endOffset": 48940,
            "count": 0
          }
        ]
      },
      {
        "functionName": "addPointerInfo",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 48962,
            "endOffset": 49066,
            "count": 0
          }
        ]
      },
      {
        "functionName": "addPointerEvent",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 49227,
            "endOffset": 49367,
            "count": 0
          }
        ]
      },
      {
        "functionName": "combineFunctions",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 49536,
            "endOffset": 49560,
            "count": 0
          }
        ]
      },
      {
        "functionName": "pipe",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 49573,
            "endOffset": 49631,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createLock",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 49792,
            "endOffset": 50008,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 49848,
            "endOffset": 50005,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getGlobalLock",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 50119,
            "endOffset": 50662,
            "count": 0
          }
        ]
      },
      {
        "functionName": "isDragActive",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 50663,
            "endOffset": 50815,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Feature",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 50998,
            "endOffset": 51071,
            "count": 0
          }
        ]
      },
      {
        "functionName": "update",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 51074,
            "endOffset": 51088,
            "count": 0
          }
        ]
      },
      {
        "functionName": "addHoverEvent",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 51241,
            "endOffset": 51874,
            "count": 0
          }
        ]
      },
      {
        "functionName": "mount",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 51920,
            "endOffset": 52023,
            "count": 0
          }
        ]
      },
      {
        "functionName": "unmount",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 52026,
            "endOffset": 52041,
            "count": 0
          }
        ]
      },
      {
        "functionName": "FocusGesture",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 52239,
            "endOffset": 52310,
            "count": 0
          }
        ]
      },
      {
        "functionName": "onFocus",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 52313,
            "endOffset": 52645,
            "count": 0
          }
        ]
      },
      {
        "functionName": "onBlur",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 52648,
            "endOffset": 52817,
            "count": 0
          }
        ]
      },
      {
        "functionName": "mount",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 52820,
            "endOffset": 52982,
            "count": 0
          }
        ]
      },
      {
        "functionName": "unmount",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 52985,
            "endOffset": 53000,
            "count": 0
          }
        ]
      },
      {
        "functionName": "isNodeOrChild",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 53190,
            "endOffset": 53366,
            "count": 0
          }
        ]
      },
      {
        "functionName": "fireSyntheticPointerEvent",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 53517,
            "endOffset": 53741,
            "count": 0
          }
        ]
      },
      {
        "functionName": "PressGesture",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 53787,
            "endOffset": 56214,
            "count": 0
          }
        ]
      },
      {
        "functionName": "startPress",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 56217,
            "endOffset": 56506,
            "count": 0
          }
        ]
      },
      {
        "functionName": "checkPressEnd",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 56509,
            "endOffset": 56779,
            "count": 0
          }
        ]
      },
      {
        "functionName": "cancelPress",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 56782,
            "endOffset": 56960,
            "count": 0
          }
        ]
      },
      {
        "functionName": "mount",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 56963,
            "endOffset": 57401,
            "count": 0
          }
        ]
      },
      {
        "functionName": "unmount",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 57404,
            "endOffset": 57521,
            "count": 0
          }
        ]
      },
      {
        "functionName": "fireObserverCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 57823,
            "endOffset": 57924,
            "count": 0
          }
        ]
      },
      {
        "functionName": "fireAllObserverCallbacks",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 57957,
            "endOffset": 58014,
            "count": 0
          }
        ]
      },
      {
        "functionName": "initIntersectionObserver",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 58016,
            "endOffset": 58440,
            "count": 0
          }
        ]
      },
      {
        "functionName": "observeIntersection",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 58441,
            "endOffset": 58773,
            "count": 0
          }
        ]
      },
      {
        "functionName": "InViewFeature",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 59031,
            "endOffset": 59135,
            "count": 0
          }
        ]
      },
      {
        "functionName": "startObserver",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 59138,
            "endOffset": 60204,
            "count": 0
          }
        ]
      },
      {
        "functionName": "mount",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 60207,
            "endOffset": 60246,
            "count": 0
          }
        ]
      },
      {
        "functionName": "update",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 60249,
            "endOffset": 60546,
            "count": 0
          }
        ]
      },
      {
        "functionName": "unmount",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 60549,
            "endOffset": 60564,
            "count": 0
          }
        ]
      },
      {
        "functionName": "hasViewportOptionChanged",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 60568,
            "endOffset": 60720,
            "count": 0
          }
        ]
      },
      {
        "functionName": "shallowCompare",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 61232,
            "endOffset": 61512,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getCurrent",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 61685,
            "endOffset": 61839,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getVelocity",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 61840,
            "endOffset": 62006,
            "count": 0
          }
        ]
      },
      {
        "functionName": "resolveVariant",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 62007,
            "endOffset": 62262,
            "count": 0
          }
        ]
      },
      {
        "functionName": "secondsToMilliseconds",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 62447,
            "endOffset": 62473,
            "count": 0
          }
        ]
      },
      {
        "functionName": "millisecondsToSeconds",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 62503,
            "endOffset": 62539,
            "count": 0
          }
        ]
      },
      {
        "functionName": "criticallyDampedSpring",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 62836,
            "endOffset": 62956,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getDefaultTransition",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 63136,
            "endOffset": 63408,
            "count": 0
          }
        ]
      },
      {
        "functionName": "isTransitionDefined",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 63572,
            "endOffset": 63785,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getValueTransition",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 63786,
            "endOffset": 63899,
            "count": 0
          }
        ]
      },
      {
        "functionName": "isNotNull",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 64320,
            "endOffset": 64345,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getFinalKeyframe",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 64347,
            "endOffset": 64686,
            "count": 0
          }
        ]
      },
      {
        "functionName": "clearTime",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 64850,
            "endOffset": 64890,
            "count": 0
          }
        ]
      },
      {
        "functionName": "now",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 64911,
            "endOffset": 65090,
            "count": 0
          }
        ]
      },
      {
        "functionName": "set",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 65099,
            "endOffset": 65167,
            "count": 0
          }
        ]
      },
      {
        "functionName": "isZeroValueString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 65356,
            "endOffset": 65384,
            "count": 0
          }
        ]
      },
      {
        "functionName": "isNone",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 65544,
            "endOffset": 65766,
            "count": 0
          }
        ]
      },
      {
        "functionName": "warning",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 65980,
            "endOffset": 66092,
            "count": 0
          }
        ]
      },
      {
        "functionName": "invariant",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 66108,
            "endOffset": 66189,
            "count": 0
          }
        ]
      },
      {
        "functionName": "isNumericalString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 66377,
            "endOffset": 66422,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parseCSSVariable",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 66805,
            "endOffset": 67056,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getVariableValue",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 67075,
            "endOffset": 67672,
            "count": 0
          }
        ]
      },
      {
        "functionName": "isNumOrPxType",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 68021,
            "endOffset": 68052,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getPosFromMatrix",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 68077,
            "endOffset": 68129,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getTranslateFromMatrix",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 68160,
            "endOffset": 68575,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 68176,
            "endOffset": 68575,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 68701,
            "endOffset": 68733,
            "count": 17
          }
        ]
      },
      {
        "functionName": "removeNonTranslationalTransform",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 68736,
            "endOffset": 69093,
            "count": 0
          }
        ]
      },
      {
        "functionName": "width",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 69144,
            "endOffset": 69264,
            "count": 0
          }
        ]
      },
      {
        "functionName": "height",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 69276,
            "endOffset": 69396,
            "count": 0
          }
        ]
      },
      {
        "functionName": "top",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 69405,
            "endOffset": 69440,
            "count": 0
          }
        ]
      },
      {
        "functionName": "left",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 69450,
            "endOffset": 69487,
            "count": 0
          }
        ]
      },
      {
        "functionName": "bottom",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 69499,
            "endOffset": 69552,
            "count": 0
          }
        ]
      },
      {
        "functionName": "right",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 69563,
            "endOffset": 69618,
            "count": 0
          }
        ]
      },
      {
        "functionName": "testValueType",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 69991,
            "endOffset": 70020,
            "count": 0
          }
        ]
      },
      {
        "functionName": "test",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 70210,
            "endOffset": 70229,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parse",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 70240,
            "endOffset": 70248,
            "count": 0
          }
        ]
      },
      {
        "functionName": "findDimensionValueType",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 70521,
            "endOffset": 70570,
            "count": 0
          }
        ]
      },
      {
        "functionName": "measureAllKeyframes",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 70838,
            "endOffset": 71975,
            "count": 0
          }
        ]
      },
      {
        "functionName": "readAllKeyframes",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 71976,
            "endOffset": 72156,
            "count": 0
          }
        ]
      },
      {
        "functionName": "flushKeyframeResolvers",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 72157,
            "endOffset": 72241,
            "count": 0
          }
        ]
      },
      {
        "functionName": "KeyframeResolver",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 72275,
            "endOffset": 72697,
            "count": 0
          }
        ]
      },
      {
        "functionName": "scheduleResolve",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 72700,
            "endOffset": 73026,
            "count": 0
          }
        ]
      },
      {
        "functionName": "readKeyframes",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 73029,
            "endOffset": 74147,
            "count": 0
          }
        ]
      },
      {
        "functionName": "setFinalKeyframe",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 74150,
            "endOffset": 74174,
            "count": 0
          }
        ]
      },
      {
        "functionName": "measureInitialState",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 74177,
            "endOffset": 74204,
            "count": 0
          }
        ]
      },
      {
        "functionName": "renderEndStyles",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 74207,
            "endOffset": 74230,
            "count": 0
          }
        ]
      },
      {
        "functionName": "measureEndState",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 74233,
            "endOffset": 74256,
            "count": 0
          }
        ]
      },
      {
        "functionName": "complete",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 74259,
            "endOffset": 74398,
            "count": 0
          }
        ]
      },
      {
        "functionName": "cancel",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 74401,
            "endOffset": 74511,
            "count": 0
          }
        ]
      },
      {
        "functionName": "resume",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 74514,
            "endOffset": 74584,
            "count": 0
          }
        ]
      },
      {
        "functionName": "isColorString",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 74766,
            "endOffset": 74942,
            "count": 3
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 74786,
            "endOffset": 74942,
            "count": 0
          }
        ]
      },
      {
        "functionName": "splitColor",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 74961,
            "endOffset": 75233,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 74986,
            "endOffset": 75233,
            "count": 0
          }
        ]
      },
      {
        "functionName": "clampRgbUnit",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 75411,
            "endOffset": 75434,
            "count": 0
          }
        ]
      },
      {
        "functionName": "transform",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 75478,
            "endOffset": 75512,
            "count": 0
          }
        ]
      },
      {
        "functionName": "transform",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 75624,
            "endOffset": 75819,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parseHex",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 75979,
            "endOffset": 76498,
            "count": 0
          }
        ]
      },
      {
        "functionName": "transform",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 76864,
            "endOffset": 77110,
            "count": 0
          }
        ]
      },
      {
        "functionName": "test",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 77294,
            "endOffset": 77344,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parse",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 77355,
            "endOffset": 77524,
            "count": 0
          }
        ]
      },
      {
        "functionName": "transform",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 77539,
            "endOffset": 77645,
            "count": 0
          }
        ]
      },
      {
        "functionName": "test",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 77809,
            "endOffset": 78052,
            "count": 0
          }
        ]
      },
      {
        "functionName": "analyseComplexValue",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 78436,
            "endOffset": 79257,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parseComplexValue",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 79258,
            "endOffset": 79331,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createTransformer",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 79332,
            "endOffset": 79881,
            "count": 0
          }
        ]
      },
      {
        "functionName": "convertNumbersToZero",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 79909,
            "endOffset": 79945,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getAnimatableNone",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 79947,
            "endOffset": 80119,
            "count": 0
          }
        ]
      },
      {
        "functionName": "applyDefaultFilter",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 80471,
            "endOffset": 80875,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getAnimatableNone",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 80970,
            "endOffset": 81100,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getDefaultValueType",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 81634,
            "endOffset": 81665,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getAnimatableNone2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 81840,
            "endOffset": 82099,
            "count": 0
          }
        ]
      },
      {
        "functionName": "makeNoneKeyframesAnimatable",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 82273,
            "endOffset": 82852,
            "count": 0
          }
        ]
      },
      {
        "functionName": "DOMKeyframesResolver",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 83081,
            "endOffset": 83301,
            "count": 0
          }
        ]
      },
      {
        "functionName": "readKeyframes",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 83304,
            "endOffset": 84474,
            "count": 0
          }
        ]
      },
      {
        "functionName": "resolveNoneKeyframes",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 84477,
            "endOffset": 84870,
            "count": 0
          }
        ]
      },
      {
        "functionName": "measureInitialState",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 84873,
            "endOffset": 85455,
            "count": 0
          }
        ]
      },
      {
        "functionName": "measureEndState",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 85458,
            "endOffset": 86333,
            "count": 0
          }
        ]
      },
      {
        "functionName": "memo",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 86482,
            "endOffset": 86618,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 86531,
            "endOffset": 86615,
            "count": 0
          }
        ]
      },
      {
        "functionName": "isAnimatable",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 86802,
            "endOffset": 87166,
            "count": 0
          }
        ]
      },
      {
        "functionName": "hasKeyframesChanged",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 87340,
            "endOffset": 87571,
            "count": 0
          }
        ]
      },
      {
        "functionName": "canAnimate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 87572,
            "endOffset": 88362,
            "count": 0
          }
        ]
      },
      {
        "functionName": "BaseAnimation",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 88561,
            "endOffset": 88945,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get resolved",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 89189,
            "endOffset": 89330,
            "count": 0
          }
        ]
      },
      {
        "functionName": "onKeyframesResolved",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 89567,
            "endOffset": 90471,
            "count": 0
          }
        ]
      },
      {
        "functionName": "onPostResolved",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 90474,
            "endOffset": 90496,
            "count": 0
          }
        ]
      },
      {
        "functionName": "then",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 90703,
            "endOffset": 90792,
            "count": 0
          }
        ]
      },
      {
        "functionName": "updateFinishedPromise",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 90795,
            "endOffset": 90938,
            "count": 0
          }
        ]
      },
      {
        "functionName": "velocityPerSecond",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 91102,
            "endOffset": 91220,
            "count": 0
          }
        ]
      },
      {
        "functionName": "calcGeneratorVelocity",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 91423,
            "endOffset": 91610,
            "count": 0
          }
        ]
      },
      {
        "functionName": "findSpring",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 91887,
            "endOffset": 93976,
            "count": 0
          }
        ]
      },
      {
        "functionName": "approximateRoot",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 94002,
            "endOffset": 94222,
            "count": 0
          }
        ]
      },
      {
        "functionName": "calcAngularFreq",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 94223,
            "endOffset": 94347,
            "count": 0
          }
        ]
      },
      {
        "functionName": "isSpringType",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 94611,
            "endOffset": 94707,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getSpringOptions",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 94708,
            "endOffset": 95179,
            "count": 0
          }
        ]
      },
      {
        "functionName": "spring",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 95180,
            "endOffset": 97899,
            "count": 0
          }
        ]
      },
      {
        "functionName": "inertia",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 98063,
            "endOffset": 100062,
            "count": 0
          }
        ]
      },
      {
        "functionName": "calcBezier",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 100234,
            "endOffset": 100315,
            "count": 0
          }
        ]
      },
      {
        "functionName": "binarySubdivide",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 100385,
            "endOffset": 100821,
            "count": 0
          }
        ]
      },
      {
        "functionName": "cubicBezier",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 100822,
            "endOffset": 101057,
            "count": 4
          },
          {
            "startOffset": 100883,
            "endOffset": 100897,
            "count": 1
          },
          {
            "startOffset": 100903,
            "endOffset": 100915,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getTForX",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 100935,
            "endOffset": 100978,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 100989,
            "endOffset": 101054,
            "count": 0
          }
        ]
      },
      {
        "functionName": "isEasingArray",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 101517,
            "endOffset": 101594,
            "count": 0
          }
        ]
      },
      {
        "functionName": "mirrorEasing",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 101773,
            "endOffset": 101852,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 101785,
            "endOffset": 101852,
            "count": 0
          }
        ]
      },
      {
        "functionName": "reverseEasing",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 102033,
            "endOffset": 102069,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 102045,
            "endOffset": 102069,
            "count": 0
          }
        ]
      },
      {
        "functionName": "circIn",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 102230,
            "endOffset": 102263,
            "count": 0
          }
        ]
      },
      {
        "functionName": "anticipate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 102781,
            "endOffset": 102859,
            "count": 0
          }
        ]
      },
      {
        "functionName": "easingDefinitionToFunction",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 103200,
            "endOffset": 103634,
            "count": 0
          }
        ]
      },
      {
        "functionName": "progress",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 103800,
            "endOffset": 103935,
            "count": 0
          }
        ]
      },
      {
        "functionName": "mixNumber",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 104104,
            "endOffset": 104173,
            "count": 0
          }
        ]
      },
      {
        "functionName": "hueToRgb",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 104328,
            "endOffset": 104559,
            "count": 0
          }
        ]
      },
      {
        "functionName": "hslaToRgba",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 104560,
            "endOffset": 105198,
            "count": 0
          }
        ]
      },
      {
        "functionName": "mixLinearColor",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 105370,
            "endOffset": 105515,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getColorType",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 105572,
            "endOffset": 105618,
            "count": 0
          }
        ]
      },
      {
        "functionName": "asRGBA",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 105620,
            "endOffset": 105902,
            "count": 0
          }
        ]
      },
      {
        "functionName": "mixColor",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 105918,
            "endOffset": 106353,
            "count": 0
          }
        ]
      },
      {
        "functionName": "mixImmediate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 106507,
            "endOffset": 106569,
            "count": 0
          }
        ]
      },
      {
        "functionName": "mixNumber2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 106570,
            "endOffset": 106635,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getMixer",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 106636,
            "endOffset": 107009,
            "count": 0
          }
        ]
      },
      {
        "functionName": "mixArray",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 107010,
            "endOffset": 107283,
            "count": 0
          }
        ]
      },
      {
        "functionName": "mixObject",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 107284,
            "endOffset": 107642,
            "count": 0
          }
        ]
      },
      {
        "functionName": "matchOrder",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 107643,
            "endOffset": 108099,
            "count": 0
          }
        ]
      },
      {
        "functionName": "mixComplex",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 108117,
            "endOffset": 108942,
            "count": 0
          }
        ]
      },
      {
        "functionName": "mix",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 109094,
            "endOffset": 109305,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createMixers",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 109458,
            "endOffset": 109899,
            "count": 0
          }
        ]
      },
      {
        "functionName": "interpolate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 109900,
            "endOffset": 110846,
            "count": 0
          }
        ]
      },
      {
        "functionName": "fillOffset",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 111000,
            "endOffset": 111234,
            "count": 0
          }
        ]
      },
      {
        "functionName": "defaultOffset",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 111391,
            "endOffset": 111499,
            "count": 0
          }
        ]
      },
      {
        "functionName": "convertOffsetToTimes",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 111653,
            "endOffset": 111746,
            "count": 0
          }
        ]
      },
      {
        "functionName": "defaultEasing",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 111912,
            "endOffset": 112031,
            "count": 0
          }
        ]
      },
      {
        "functionName": "keyframes",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 112032,
            "endOffset": 112977,
            "count": 0
          }
        ]
      },
      {
        "functionName": "calcGeneratorDuration",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 113185,
            "endOffset": 113505,
            "count": 0
          }
        ]
      },
      {
        "functionName": "frameloopDriver",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 113707,
            "endOffset": 114091,
            "count": 0
          }
        ]
      },
      {
        "functionName": "percentToProgress",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 114384,
            "endOffset": 114412,
            "count": 0
          }
        ]
      },
      {
        "functionName": "MainThreadAnimation",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 114472,
            "endOffset": 115290,
            "count": 0
          }
        ]
      },
      {
        "functionName": "initPlayback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 115293,
            "endOffset": 116686,
            "count": 0
          }
        ]
      },
      {
        "functionName": "onPostResolved",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 116689,
            "endOffset": 116914,
            "count": 0
          }
        ]
      },
      {
        "functionName": "tick",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 116917,
            "endOffset": 119982,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get duration",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 119985,
            "endOffset": 120114,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get time",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 120117,
            "endOffset": 120185,
            "count": 0
          }
        ]
      },
      {
        "functionName": "set time",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 120188,
            "endOffset": 120475,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get speed",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 120478,
            "endOffset": 120526,
            "count": 0
          }
        ]
      },
      {
        "functionName": "set speed",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 120529,
            "endOffset": 120732,
            "count": 0
          }
        ]
      },
      {
        "functionName": "play",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 120735,
            "endOffset": 121538,
            "count": 0
          }
        ]
      },
      {
        "functionName": "pause",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 121541,
            "endOffset": 121760,
            "count": 0
          }
        ]
      },
      {
        "functionName": "stop",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 121763,
            "endOffset": 121957,
            "count": 0
          }
        ]
      },
      {
        "functionName": "complete",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 121960,
            "endOffset": 122116,
            "count": 0
          }
        ]
      },
      {
        "functionName": "finish",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 122119,
            "endOffset": 122256,
            "count": 0
          }
        ]
      },
      {
        "functionName": "cancel",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 122259,
            "endOffset": 122404,
            "count": 0
          }
        ]
      },
      {
        "functionName": "teardown",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 122407,
            "endOffset": 122613,
            "count": 0
          }
        ]
      },
      {
        "functionName": "stopDriver",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 122616,
            "endOffset": 122720,
            "count": 0
          }
        ]
      },
      {
        "functionName": "sample",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 122723,
            "endOffset": 122801,
            "count": 0
          }
        ]
      },
      {
        "functionName": "animateValue",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 122805,
            "endOffset": 122882,
            "count": 0
          }
        ]
      },
      {
        "functionName": "isBezierDefinition",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 123076,
            "endOffset": 123142,
            "count": 0
          }
        ]
      },
      {
        "functionName": "isWaapiSupportedEasing",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 123311,
            "endOffset": 123538,
            "count": 0
          }
        ]
      },
      {
        "functionName": "cubicBezierAsString",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 123565,
            "endOffset": 123621,
            "count": 4
          }
        ]
      },
      {
        "functionName": "mapEasingToNativeEasing",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 123981,
            "endOffset": 124219,
            "count": 0
          }
        ]
      },
      {
        "functionName": "animateStyle",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 124386,
            "endOffset": 125009,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 125210,
            "endOffset": 125272,
            "count": 0
          }
        ]
      },
      {
        "functionName": "requiresPregeneratedKeyframes",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 125623,
            "endOffset": 125789,
            "count": 0
          }
        ]
      },
      {
        "functionName": "pregenerateKeyframes",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 125790,
            "endOffset": 126375,
            "count": 0
          }
        ]
      },
      {
        "functionName": "AcceleratedAnimation",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 126435,
            "endOffset": 126779,
            "count": 0
          }
        ]
      },
      {
        "functionName": "initPlayback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 126782,
            "endOffset": 128288,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get duration",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 128291,
            "endOffset": 128456,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get time",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 128459,
            "endOffset": 128639,
            "count": 0
          }
        ]
      },
      {
        "functionName": "set time",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 128642,
            "endOffset": 128825,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get speed",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 128828,
            "endOffset": 128982,
            "count": 0
          }
        ]
      },
      {
        "functionName": "set speed",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 128985,
            "endOffset": 129149,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get state",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 129152,
            "endOffset": 129308,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attachTimeline",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 129440,
            "endOffset": 129755,
            "count": 0
          }
        ]
      },
      {
        "functionName": "play",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 129758,
            "endOffset": 130018,
            "count": 0
          }
        ]
      },
      {
        "functionName": "pause",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 130021,
            "endOffset": 130157,
            "count": 0
          }
        ]
      },
      {
        "functionName": "stop",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 130160,
            "endOffset": 131086,
            "count": 0
          }
        ]
      },
      {
        "functionName": "complete",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 131089,
            "endOffset": 131202,
            "count": 0
          }
        ]
      },
      {
        "functionName": "cancel",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 131205,
            "endOffset": 131316,
            "count": 0
          }
        ]
      },
      {
        "functionName": "supports",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 131326,
            "endOffset": 131882,
            "count": 0
          }
        ]
      },
      {
        "functionName": "animateMotionValue",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 132079,
            "endOffset": 134068,
            "count": 0
          }
        ]
      },
      {
        "functionName": "isWillChangeMotionValue",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 134229,
            "endOffset": 134325,
            "count": 0
          }
        ]
      },
      {
        "functionName": "addUniqueItem",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 134472,
            "endOffset": 134561,
            "count": 0
          }
        ]
      },
      {
        "functionName": "removeItem",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 134562,
            "endOffset": 134675,
            "count": 0
          }
        ]
      },
      {
        "functionName": "moveItem",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 134676,
            "endOffset": 135017,
            "count": 0
          }
        ]
      },
      {
        "functionName": "SubscriptionManager",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 135215,
            "endOffset": 135263,
            "count": 0
          }
        ]
      },
      {
        "functionName": "add",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 135266,
            "endOffset": 135390,
            "count": 0
          }
        ]
      },
      {
        "functionName": "notify",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 135393,
            "endOffset": 135745,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getSize",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 135748,
            "endOffset": 135801,
            "count": 0
          }
        ]
      },
      {
        "functionName": "clear",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 135804,
            "endOffset": 135852,
            "count": 0
          }
        ]
      },
      {
        "functionName": "warnOnce",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 136046,
            "endOffset": 136238,
            "count": 0
          }
        ]
      },
      {
        "functionName": "isFloat",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 136428,
            "endOffset": 136478,
            "count": 0
          }
        ]
      },
      {
        "functionName": "MotionValue",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 136755,
            "endOffset": 137491,
            "count": 0
          }
        ]
      },
      {
        "functionName": "setCurrent",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 137494,
            "endOffset": 137580,
            "count": 0
          }
        ]
      },
      {
        "functionName": "setPrevFrameValue",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 137583,
            "endOffset": 137720,
            "count": 0
          }
        ]
      },
      {
        "functionName": "onChange",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 139015,
            "endOffset": 139215,
            "count": 0
          }
        ]
      },
      {
        "functionName": "on",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 139218,
            "endOffset": 139648,
            "count": 0
          }
        ]
      },
      {
        "functionName": "clearListeners",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 139651,
            "endOffset": 139768,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attach",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 139856,
            "endOffset": 139990,
            "count": 0
          }
        ]
      },
      {
        "functionName": "set",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 140283,
            "endOffset": 140461,
            "count": 0
          }
        ]
      },
      {
        "functionName": "setWithVelocity",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 140464,
            "endOffset": 140635,
            "count": 0
          }
        ]
      },
      {
        "functionName": "jump",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 140765,
            "endOffset": 140999,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 141134,
            "endOffset": 141261,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getPrevious",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 141289,
            "endOffset": 141330,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getVelocity",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 141515,
            "endOffset": 141895,
            "count": 0
          }
        ]
      },
      {
        "functionName": "start",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 142175,
            "endOffset": 142585,
            "count": 0
          }
        ]
      },
      {
        "functionName": "stop",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 142660,
            "endOffset": 142855,
            "count": 0
          }
        ]
      },
      {
        "functionName": "isAnimating",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 142946,
            "endOffset": 142994,
            "count": 0
          }
        ]
      },
      {
        "functionName": "clearAnimation",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 142997,
            "endOffset": 143046,
            "count": 0
          }
        ]
      },
      {
        "functionName": "destroy",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 143399,
            "endOffset": 143530,
            "count": 0
          }
        ]
      },
      {
        "functionName": "motionValue",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 143534,
            "endOffset": 143614,
            "count": 0
          }
        ]
      },
      {
        "functionName": "setMotionValue",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 143770,
            "endOffset": 143973,
            "count": 0
          }
        ]
      },
      {
        "functionName": "setTarget",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 143974,
            "endOffset": 144346,
            "count": 0
          }
        ]
      },
      {
        "functionName": "shouldBlockAnimation",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 144524,
            "endOffset": 144739,
            "count": 0
          }
        ]
      },
      {
        "functionName": "animateTarget",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 144740,
            "endOffset": 146687,
            "count": 0
          }
        ]
      },
      {
        "functionName": "animateVariant",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 146866,
            "endOffset": 148081,
            "count": 0
          }
        ]
      },
      {
        "functionName": "animateChildren",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 148082,
            "endOffset": 148833,
            "count": 0
          }
        ]
      },
      {
        "functionName": "sortByTreeOrder",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 148834,
            "endOffset": 148900,
            "count": 0
          }
        ]
      },
      {
        "functionName": "animateVisualElement",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 149071,
            "endOffset": 149887,
            "count": 0
          }
        ]
      },
      {
        "functionName": "animateList",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 150168,
            "endOffset": 150348,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createAnimationState",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 150349,
            "endOffset": 156277,
            "count": 0
          }
        ]
      },
      {
        "functionName": "checkVariantsDidChange",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 156278,
            "endOffset": 156481,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createTypeState",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 156482,
            "endOffset": 156632,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createState",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 156633,
            "endOffset": 156912,
            "count": 0
          }
        ]
      },
      {
        "functionName": "AnimationFeature",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 157381,
            "endOffset": 157500,
            "count": 0
          }
        ]
      },
      {
        "functionName": "updateAnimationControlsSubscription",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 157503,
            "endOffset": 157721,
            "count": 0
          }
        ]
      },
      {
        "functionName": "mount",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 157815,
            "endOffset": 157876,
            "count": 0
          }
        ]
      },
      {
        "functionName": "update",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 157879,
            "endOffset": 158105,
            "count": 0
          }
        ]
      },
      {
        "functionName": "unmount",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 158108,
            "endOffset": 158123,
            "count": 0
          }
        ]
      },
      {
        "functionName": "ExitAnimationFeature",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 158357,
            "endOffset": 158421,
            "count": 0
          }
        ]
      },
      {
        "functionName": "update",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 158424,
            "endOffset": 158923,
            "count": 0
          }
        ]
      },
      {
        "functionName": "mount",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 158926,
            "endOffset": 159063,
            "count": 0
          }
        ]
      },
      {
        "functionName": "unmount",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 159066,
            "endOffset": 159081,
            "count": 0
          }
        ]
      },
      {
        "functionName": "distance",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 159530,
            "endOffset": 159555,
            "count": 0
          }
        ]
      },
      {
        "functionName": "distance2D",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 159557,
            "endOffset": 159707,
            "count": 0
          }
        ]
      },
      {
        "functionName": "PanSession",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 159893,
            "endOffset": 162571,
            "count": 0
          }
        ]
      },
      {
        "functionName": "updateHandlers",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 162574,
            "endOffset": 162634,
            "count": 0
          }
        ]
      },
      {
        "functionName": "end",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 162637,
            "endOffset": 162735,
            "count": 0
          }
        ]
      },
      {
        "functionName": "transformPoint",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 162739,
            "endOffset": 162872,
            "count": 0
          }
        ]
      },
      {
        "functionName": "subtractPoint",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 162873,
            "endOffset": 162946,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getPanInfo",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 162947,
            "endOffset": 163196,
            "count": 0
          }
        ]
      },
      {
        "functionName": "startDevicePoint",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 163197,
            "endOffset": 163256,
            "count": 0
          }
        ]
      },
      {
        "functionName": "lastDevicePoint",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 163257,
            "endOffset": 163332,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getVelocity2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 163333,
            "endOffset": 164226,
            "count": 0
          }
        ]
      },
      {
        "functionName": "calcLength",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 164392,
            "endOffset": 164451,
            "count": 0
          }
        ]
      },
      {
        "functionName": "isNear",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 164452,
            "endOffset": 164560,
            "count": 0
          }
        ]
      },
      {
        "functionName": "calcAxisDelta",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 164561,
            "endOffset": 165027,
            "count": 0
          }
        ]
      },
      {
        "functionName": "calcBoxDelta",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 165028,
            "endOffset": 165244,
            "count": 0
          }
        ]
      },
      {
        "functionName": "calcRelativeAxis",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 165245,
            "endOffset": 165392,
            "count": 0
          }
        ]
      },
      {
        "functionName": "calcRelativeBox",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 165393,
            "endOffset": 165551,
            "count": 0
          }
        ]
      },
      {
        "functionName": "calcRelativeAxisPosition",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 165552,
            "endOffset": 165704,
            "count": 0
          }
        ]
      },
      {
        "functionName": "calcRelativePosition",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 165705,
            "endOffset": 165881,
            "count": 0
          }
        ]
      },
      {
        "functionName": "applyConstraints",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 166048,
            "endOffset": 166384,
            "count": 0
          }
        ]
      },
      {
        "functionName": "calcRelativeAxisConstraints",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 166385,
            "endOffset": 166582,
            "count": 0
          }
        ]
      },
      {
        "functionName": "calcRelativeConstraints",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 166583,
            "endOffset": 166799,
            "count": 0
          }
        ]
      },
      {
        "functionName": "calcViewportAxisConstraints",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 166800,
            "endOffset": 167110,
            "count": 0
          }
        ]
      },
      {
        "functionName": "calcViewportConstraints",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 167111,
            "endOffset": 167323,
            "count": 0
          }
        ]
      },
      {
        "functionName": "calcOrigin2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 167324,
            "endOffset": 167733,
            "count": 0
          }
        ]
      },
      {
        "functionName": "rebaseAxisConstraints",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 167734,
            "endOffset": 168056,
            "count": 0
          }
        ]
      },
      {
        "functionName": "resolveDragElastic",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 168084,
            "endOffset": 168401,
            "count": 0
          }
        ]
      },
      {
        "functionName": "resolveAxisElastic",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 168402,
            "endOffset": 168587,
            "count": 0
          }
        ]
      },
      {
        "functionName": "resolvePointElastic",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 168588,
            "endOffset": 168722,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createAxisDelta",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 168906,
            "endOffset": 168975,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createDelta",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 168995,
            "endOffset": 169053,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createAxis",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 169072,
            "endOffset": 169098,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createBox",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 169116,
            "endOffset": 169164,
            "count": 0
          }
        ]
      },
      {
        "functionName": "eachAxis",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 169327,
            "endOffset": 169399,
            "count": 0
          }
        ]
      },
      {
        "functionName": "convertBoundingBoxToBox",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 169565,
            "endOffset": 169714,
            "count": 0
          }
        ]
      },
      {
        "functionName": "convertBoxToBoundingBox",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 169715,
            "endOffset": 169828,
            "count": 0
          }
        ]
      },
      {
        "functionName": "transformBoxPoints",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 169829,
            "endOffset": 170185,
            "count": 0
          }
        ]
      },
      {
        "functionName": "isIdentityScale",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 170351,
            "endOffset": 170431,
            "count": 0
          }
        ]
      },
      {
        "functionName": "hasScale",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 170432,
            "endOffset": 170579,
            "count": 0
          }
        ]
      },
      {
        "functionName": "hasTransform",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 170580,
            "endOffset": 170763,
            "count": 0
          }
        ]
      },
      {
        "functionName": "has2DTranslate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 170764,
            "endOffset": 170860,
            "count": 0
          }
        ]
      },
      {
        "functionName": "is2DTranslate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 170861,
            "endOffset": 170928,
            "count": 0
          }
        ]
      },
      {
        "functionName": "scalePoint",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 171095,
            "endOffset": 171275,
            "count": 0
          }
        ]
      },
      {
        "functionName": "applyPointDelta",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 171276,
            "endOffset": 171505,
            "count": 0
          }
        ]
      },
      {
        "functionName": "applyAxisDelta",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 171506,
            "endOffset": 171753,
            "count": 0
          }
        ]
      },
      {
        "functionName": "applyBoxDelta",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 171754,
            "endOffset": 171919,
            "count": 0
          }
        ]
      },
      {
        "functionName": "applyTreeDeltas",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 171920,
            "endOffset": 172905,
            "count": 0
          }
        ]
      },
      {
        "functionName": "snapToDefault",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 172906,
            "endOffset": 173066,
            "count": 0
          }
        ]
      },
      {
        "functionName": "translateAxis",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 173067,
            "endOffset": 173180,
            "count": 0
          }
        ]
      },
      {
        "functionName": "transformAxis",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 173181,
            "endOffset": 173497,
            "count": 0
          }
        ]
      },
      {
        "functionName": "transformBox",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 173578,
            "endOffset": 173706,
            "count": 0
          }
        ]
      },
      {
        "functionName": "measureViewportBox",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 173866,
            "endOffset": 174029,
            "count": 0
          }
        ]
      },
      {
        "functionName": "measurePageBox",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 174030,
            "endOffset": 174376,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getContextWindow",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 174559,
            "endOffset": 174640,
            "count": 0
          }
        ]
      },
      {
        "functionName": "VisualElementDragControls",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 174915,
            "endOffset": 175223,
            "count": 0
          }
        ]
      },
      {
        "functionName": "start",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 175226,
            "endOffset": 178369,
            "count": 0
          }
        ]
      },
      {
        "functionName": "stop",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 178372,
            "endOffset": 178647,
            "count": 0
          }
        ]
      },
      {
        "functionName": "cancel",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 178650,
            "endOffset": 179142,
            "count": 0
          }
        ]
      },
      {
        "functionName": "updateAxis",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 179145,
            "endOffset": 179583,
            "count": 0
          }
        ]
      },
      {
        "functionName": "resolveConstraints",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 179586,
            "endOffset": 180683,
            "count": 0
          }
        ]
      },
      {
        "functionName": "resolveRefConstraints",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 180686,
            "endOffset": 181749,
            "count": 0
          }
        ]
      },
      {
        "functionName": "startAnimation",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 181752,
            "endOffset": 182751,
            "count": 0
          }
        ]
      },
      {
        "functionName": "startAxisValueAnimation",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 182754,
            "endOffset": 182954,
            "count": 0
          }
        ]
      },
      {
        "functionName": "stopAnimation",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 182957,
            "endOffset": 183040,
            "count": 0
          }
        ]
      },
      {
        "functionName": "pauseAnimation",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 183043,
            "endOffset": 183221,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getAnimationState",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 183224,
            "endOffset": 183370,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getAxisMotionValue",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 183623,
            "endOffset": 183943,
            "count": 0
          }
        ]
      },
      {
        "functionName": "snapToCursor",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 183946,
            "endOffset": 184412,
            "count": 0
          }
        ]
      },
      {
        "functionName": "scalePositionWithinConstraints",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 184634,
            "endOffset": 185786,
            "count": 0
          }
        ]
      },
      {
        "functionName": "addListeners",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 185789,
            "endOffset": 187486,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getProps",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 187489,
            "endOffset": 187889,
            "count": 0
          }
        ]
      },
      {
        "functionName": "shouldDrag",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 187893,
            "endOffset": 188067,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getCurrentDirection",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 188068,
            "endOffset": 188313,
            "count": 0
          }
        ]
      },
      {
        "functionName": "DragGesture",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 188512,
            "endOffset": 188679,
            "count": 0
          }
        ]
      },
      {
        "functionName": "mount",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 188682,
            "endOffset": 188913,
            "count": 0
          }
        ]
      },
      {
        "functionName": "unmount",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 188916,
            "endOffset": 188991,
            "count": 0
          }
        ]
      },
      {
        "functionName": "asyncHandler",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 189167,
            "endOffset": 189247,
            "count": 0
          }
        ]
      },
      {
        "functionName": "PanGesture",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 189292,
            "endOffset": 189379,
            "count": 0
          }
        ]
      },
      {
        "functionName": "onPointerDown",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 189382,
            "endOffset": 189617,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createPanHandlers",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 189620,
            "endOffset": 189991,
            "count": 0
          }
        ]
      },
      {
        "functionName": "mount",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 189994,
            "endOffset": 190133,
            "count": 0
          }
        ]
      },
      {
        "functionName": "update",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 190136,
            "endOffset": 190225,
            "count": 0
          }
        ]
      },
      {
        "functionName": "unmount",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 190228,
            "endOffset": 190321,
            "count": 0
          }
        ]
      },
      {
        "functionName": "usePresence",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 190770,
            "endOffset": 191225,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useIsPresent",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 191226,
            "endOffset": 191322,
            "count": 0
          }
        ]
      },
      {
        "functionName": "isPresent",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 191323,
            "endOffset": 191408,
            "count": 0
          }
        ]
      },
      {
        "functionName": "pixelsToPercent",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 192102,
            "endOffset": 192234,
            "count": 0
          }
        ]
      },
      {
        "functionName": "correct",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 192274,
            "endOffset": 192630,
            "count": 0
          }
        ]
      },
      {
        "functionName": "correct",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 192839,
            "endOffset": 193573,
            "count": 0
          }
        ]
      },
      {
        "functionName": "componentDidMount",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 194004,
            "endOffset": 194738,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getSnapshotBeforeUpdate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 194741,
            "endOffset": 195541,
            "count": 0
          }
        ]
      },
      {
        "functionName": "componentDidUpdate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 195544,
            "endOffset": 195839,
            "count": 0
          }
        ]
      },
      {
        "functionName": "componentWillUnmount",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 195842,
            "endOffset": 196268,
            "count": 0
          }
        ]
      },
      {
        "functionName": "safeToRemove",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 196271,
            "endOffset": 196368,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 196371,
            "endOffset": 196402,
            "count": 0
          }
        ]
      },
      {
        "functionName": "MeasureLayout",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 196406,
            "endOffset": 196779,
            "count": 0
          }
        ]
      },
      {
        "functionName": "asNumber",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 197505,
            "endOffset": 197569,
            "count": 0
          }
        ]
      },
      {
        "functionName": "isPx",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 197582,
            "endOffset": 197636,
            "count": 0
          }
        ]
      },
      {
        "functionName": "mixValues",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 197638,
            "endOffset": 199097,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getRadius",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 199098,
            "endOffset": 199223,
            "count": 0
          }
        ]
      },
      {
        "functionName": "compress",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 199323,
            "endOffset": 199493,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 199370,
            "endOffset": 199490,
            "count": 0
          }
        ]
      },
      {
        "functionName": "copyAxisInto",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 199653,
            "endOffset": 199754,
            "count": 0
          }
        ]
      },
      {
        "functionName": "copyBoxInto",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 199755,
            "endOffset": 199867,
            "count": 0
          }
        ]
      },
      {
        "functionName": "removePointDelta",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 200035,
            "endOffset": 200303,
            "count": 0
          }
        ]
      },
      {
        "functionName": "removeAxisDelta",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 200304,
            "endOffset": 200986,
            "count": 0
          }
        ]
      },
      {
        "functionName": "removeAxisTransforms",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 200987,
            "endOffset": 201211,
            "count": 0
          }
        ]
      },
      {
        "functionName": "removeBoxTransforms",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 201294,
            "endOffset": 201603,
            "count": 0
          }
        ]
      },
      {
        "functionName": "isAxisDeltaZero",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 201764,
            "endOffset": 201852,
            "count": 0
          }
        ]
      },
      {
        "functionName": "isDeltaZero",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 201853,
            "endOffset": 201947,
            "count": 0
          }
        ]
      },
      {
        "functionName": "boxEquals",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 201948,
            "endOffset": 202075,
            "count": 0
          }
        ]
      },
      {
        "functionName": "boxEqualsRounded",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 202076,
            "endOffset": 202306,
            "count": 0
          }
        ]
      },
      {
        "functionName": "aspectRatio",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 202307,
            "endOffset": 202384,
            "count": 0
          }
        ]
      },
      {
        "functionName": "NodeStack",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 202569,
            "endOffset": 202611,
            "count": 0
          }
        ]
      },
      {
        "functionName": "add",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 202614,
            "endOffset": 202695,
            "count": 0
          }
        ]
      },
      {
        "functionName": "remove",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 202698,
            "endOffset": 202982,
            "count": 0
          }
        ]
      },
      {
        "functionName": "relegate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 202985,
            "endOffset": 203434,
            "count": 0
          }
        ]
      },
      {
        "functionName": "promote",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 203437,
            "endOffset": 204223,
            "count": 0
          }
        ]
      },
      {
        "functionName": "exitAnimationComplete",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 204226,
            "endOffset": 204524,
            "count": 0
          }
        ]
      },
      {
        "functionName": "scheduleRender",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 204527,
            "endOffset": 204645,
            "count": 0
          }
        ]
      },
      {
        "functionName": "removeLeadSnapshot",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 204802,
            "endOffset": 204912,
            "count": 0
          }
        ]
      },
      {
        "functionName": "buildProjectionTransform",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 205078,
            "endOffset": 206312,
            "count": 0
          }
        ]
      },
      {
        "functionName": "compareByDepth",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 206498,
            "endOffset": 206525,
            "count": 0
          }
        ]
      },
      {
        "functionName": "FlatTree",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 206709,
            "endOffset": 206778,
            "count": 0
          }
        ]
      },
      {
        "functionName": "add",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 206781,
            "endOffset": 206863,
            "count": 0
          }
        ]
      },
      {
        "functionName": "remove",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 206866,
            "endOffset": 206948,
            "count": 0
          }
        ]
      },
      {
        "functionName": "forEach",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 206951,
            "endOffset": 207093,
            "count": 0
          }
        ]
      },
      {
        "functionName": "delay",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 207243,
            "endOffset": 207576,
            "count": 0
          }
        ]
      },
      {
        "functionName": "record",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 207724,
            "endOffset": 207818,
            "count": 0
          }
        ]
      },
      {
        "functionName": "isSVGElement",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 207985,
            "endOffset": 208088,
            "count": 0
          }
        ]
      },
      {
        "functionName": "animateSingleValue",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 208257,
            "endOffset": 208508,
            "count": 0
          }
        ]
      },
      {
        "functionName": "resetDistortingTransform",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 208942,
            "endOffset": 209259,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createProjectionNode",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 209260,
            "endOffset": 242934,
            "count": 2
          }
        ]
      },
      {
        "functionName": "ProjectionNode",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 209419,
            "endOffset": 211489,
            "count": 0
          }
        ]
      },
      {
        "functionName": "addEventListener",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 211494,
            "endOffset": 211705,
            "count": 0
          }
        ]
      },
      {
        "functionName": "notifyListeners",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 211710,
            "endOffset": 211878,
            "count": 0
          }
        ]
      },
      {
        "functionName": "hasListeners",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 211883,
            "endOffset": 211952,
            "count": 0
          }
        ]
      },
      {
        "functionName": "mount",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 211991,
            "endOffset": 215135,
            "count": 0
          }
        ]
      },
      {
        "functionName": "unmount",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 215140,
            "endOffset": 215443,
            "count": 0
          }
        ]
      },
      {
        "functionName": "blockUpdate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 215472,
            "endOffset": 215534,
            "count": 0
          }
        ]
      },
      {
        "functionName": "unblockUpdate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 215539,
            "endOffset": 215604,
            "count": 0
          }
        ]
      },
      {
        "functionName": "isUpdateBlocked",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 215609,
            "endOffset": 215705,
            "count": 0
          }
        ]
      },
      {
        "functionName": "isTreeAnimationBlocked",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 215710,
            "endOffset": 215844,
            "count": 0
          }
        ]
      },
      {
        "functionName": "startUpdate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 215898,
            "endOffset": 216087,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getTransformTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 216092,
            "endOffset": 216242,
            "count": 0
          }
        ]
      },
      {
        "functionName": "willUpdate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 216247,
            "endOffset": 217248,
            "count": 0
          }
        ]
      },
      {
        "functionName": "update",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 217253,
            "endOffset": 218239,
            "count": 0
          }
        ]
      },
      {
        "functionName": "didUpdate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 218244,
            "endOffset": 218388,
            "count": 0
          }
        ]
      },
      {
        "functionName": "clearAllSnapshots",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 218393,
            "endOffset": 218514,
            "count": 0
          }
        ]
      },
      {
        "functionName": "scheduleUpdateProjection",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 218519,
            "endOffset": 218714,
            "count": 0
          }
        ]
      },
      {
        "functionName": "scheduleCheckAfterUnmount",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 218719,
            "endOffset": 218930,
            "count": 0
          }
        ]
      },
      {
        "functionName": "updateSnapshot",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 218978,
            "endOffset": 219099,
            "count": 0
          }
        ]
      },
      {
        "functionName": "updateLayout",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 219104,
            "endOffset": 219934,
            "count": 0
          }
        ]
      },
      {
        "functionName": "updateScroll",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 219939,
            "endOffset": 220446,
            "count": 0
          }
        ]
      },
      {
        "functionName": "resetTransform",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 220451,
            "endOffset": 221217,
            "count": 0
          }
        ]
      },
      {
        "functionName": "measure",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 221222,
            "endOffset": 221647,
            "count": 0
          }
        ]
      },
      {
        "functionName": "measurePageBox",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 221652,
            "endOffset": 222018,
            "count": 0
          }
        ]
      },
      {
        "functionName": "removeElementScroll",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 222023,
            "endOffset": 222854,
            "count": 0
          }
        ]
      },
      {
        "functionName": "applyTransform",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 222859,
            "endOffset": 223583,
            "count": 0
          }
        ]
      },
      {
        "functionName": "removeTransform",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 223588,
            "endOffset": 224391,
            "count": 0
          }
        ]
      },
      {
        "functionName": "setTargetDelta",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 224396,
            "endOffset": 224538,
            "count": 0
          }
        ]
      },
      {
        "functionName": "setOptions",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 224543,
            "endOffset": 224722,
            "count": 0
          }
        ]
      },
      {
        "functionName": "clearMeasurements",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 224727,
            "endOffset": 224983,
            "count": 0
          }
        ]
      },
      {
        "functionName": "forceRelativeParentToResolveTarget",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 224988,
            "endOffset": 225224,
            "count": 0
          }
        ]
      },
      {
        "functionName": "resolveTargetDelta",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 225229,
            "endOffset": 228489,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getClosestProjectingParent",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 228494,
            "endOffset": 228817,
            "count": 0
          }
        ]
      },
      {
        "functionName": "isProjecting",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 228822,
            "endOffset": 228951,
            "count": 0
          }
        ]
      },
      {
        "functionName": "calcProjection",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 228956,
            "endOffset": 231295,
            "count": 0
          }
        ]
      },
      {
        "functionName": "hide",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 231300,
            "endOffset": 231344,
            "count": 0
          }
        ]
      },
      {
        "functionName": "show",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 231349,
            "endOffset": 231392,
            "count": 0
          }
        ]
      },
      {
        "functionName": "scheduleRender",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 231397,
            "endOffset": 231724,
            "count": 0
          }
        ]
      },
      {
        "functionName": "setAnimationOrigin",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 231729,
            "endOffset": 234092,
            "count": 0
          }
        ]
      },
      {
        "functionName": "startAnimation",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 234097,
            "endOffset": 235154,
            "count": 0
          }
        ]
      },
      {
        "functionName": "completeAnimation",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 235159,
            "endOffset": 235543,
            "count": 0
          }
        ]
      },
      {
        "functionName": "finishAnimation",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 235548,
            "endOffset": 235755,
            "count": 0
          }
        ]
      },
      {
        "functionName": "applyTransformsToTarget",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 235760,
            "endOffset": 236705,
            "count": 0
          }
        ]
      },
      {
        "functionName": "registerSharedNode",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 236710,
            "endOffset": 237211,
            "count": 0
          }
        ]
      },
      {
        "functionName": "isLead",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 237216,
            "endOffset": 237318,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getLead",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 237323,
            "endOffset": 237505,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getPrevLead",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 237510,
            "endOffset": 237692,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getStack",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 237697,
            "endOffset": 237828,
            "count": 0
          }
        ]
      },
      {
        "functionName": "promote",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 237833,
            "endOffset": 238176,
            "count": 0
          }
        ]
      },
      {
        "functionName": "relegate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 238181,
            "endOffset": 238337,
            "count": 0
          }
        ]
      },
      {
        "functionName": "resetSkewAndRotation",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 238342,
            "endOffset": 239533,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getProjectionStyles",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 239538,
            "endOffset": 242556,
            "count": 0
          }
        ]
      },
      {
        "functionName": "clearSnapshot",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 242561,
            "endOffset": 242632,
            "count": 0
          }
        ]
      },
      {
        "functionName": "resetTree",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 242661,
            "endOffset": 242927,
            "count": 0
          }
        ]
      },
      {
        "functionName": "updateLayout",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 242935,
            "endOffset": 242989,
            "count": 0
          }
        ]
      },
      {
        "functionName": "notifyLayoutUpdate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 242990,
            "endOffset": 245953,
            "count": 0
          }
        ]
      },
      {
        "functionName": "propagateDirtyNodes",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 245954,
            "endOffset": 246409,
            "count": 0
          }
        ]
      },
      {
        "functionName": "cleanDirtyNodes",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 246410,
            "endOffset": 246533,
            "count": 0
          }
        ]
      },
      {
        "functionName": "clearSnapshot",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 246534,
            "endOffset": 246590,
            "count": 0
          }
        ]
      },
      {
        "functionName": "clearMeasurements",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 246591,
            "endOffset": 246655,
            "count": 0
          }
        ]
      },
      {
        "functionName": "clearIsLayoutDirty",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 246656,
            "endOffset": 246723,
            "count": 0
          }
        ]
      },
      {
        "functionName": "resetTransformStyle",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 246724,
            "endOffset": 246955,
            "count": 0
          }
        ]
      },
      {
        "functionName": "finishAnimation",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 246956,
            "endOffset": 247114,
            "count": 0
          }
        ]
      },
      {
        "functionName": "resolveTargetDelta",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 247115,
            "endOffset": 247181,
            "count": 0
          }
        ]
      },
      {
        "functionName": "calcProjection",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 247182,
            "endOffset": 247240,
            "count": 0
          }
        ]
      },
      {
        "functionName": "resetSkewAndRotation",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 247241,
            "endOffset": 247311,
            "count": 0
          }
        ]
      },
      {
        "functionName": "removeLeadSnapshots",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 247312,
            "endOffset": 247381,
            "count": 0
          }
        ]
      },
      {
        "functionName": "mixAxisDelta",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 247382,
            "endOffset": 247601,
            "count": 0
          }
        ]
      },
      {
        "functionName": "mixAxis",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 247602,
            "endOffset": 247737,
            "count": 0
          }
        ]
      },
      {
        "functionName": "mixBox",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 247738,
            "endOffset": 247854,
            "count": 0
          }
        ]
      },
      {
        "functionName": "hasOpacityCrossfade",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 247855,
            "endOffset": 247971,
            "count": 0
          }
        ]
      },
      {
        "functionName": "userAgentContains",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 248074,
            "endOffset": 248195,
            "count": 2
          }
        ]
      },
      {
        "functionName": "roundAxis",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 248302,
            "endOffset": 248400,
            "count": 0
          }
        ]
      },
      {
        "functionName": "roundBox",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 248401,
            "endOffset": 248467,
            "count": 0
          }
        ]
      },
      {
        "functionName": "shouldAnimatePositionOnly",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 248468,
            "endOffset": 248679,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attachResizeListener",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 248929,
            "endOffset": 248982,
            "count": 0
          }
        ]
      },
      {
        "functionName": "measureScroll",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 249001,
            "endOffset": 249155,
            "count": 0
          }
        ]
      },
      {
        "functionName": "checkIsScrollRoot",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 249178,
            "endOffset": 249188,
            "count": 0
          }
        ]
      },
      {
        "functionName": "measureScroll",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 249475,
            "endOffset": 249550,
            "count": 0
          }
        ]
      },
      {
        "functionName": "defaultParent",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 249569,
            "endOffset": 249861,
            "count": 0
          }
        ]
      },
      {
        "functionName": "resetTransform",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 249881,
            "endOffset": 249973,
            "count": 0
          }
        ]
      },
      {
        "functionName": "checkIsScrollRoot",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 249996,
            "endOffset": 250073,
            "count": 0
          }
        ]
      },
      {
        "functionName": "initPrefersReducedMotion",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 250804,
            "endOffset": 251277,
            "count": 0
          }
        ]
      },
      {
        "functionName": "updateMotionValuesFromProps",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 251439,
            "endOffset": 252804,
            "count": 0
          }
        ]
      },
      {
        "functionName": "findValueType",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 253249,
            "endOffset": 253289,
            "count": 0
          }
        ]
      },
      {
        "functionName": "VisualElement",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 253792,
            "endOffset": 256067,
            "count": 0
          }
        ]
      },
      {
        "functionName": "scrapeMotionValuesFromProps",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 256383,
            "endOffset": 256467,
            "count": 0
          }
        ]
      },
      {
        "functionName": "mount",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 256470,
            "endOffset": 257405,
            "count": 0
          }
        ]
      },
      {
        "functionName": "unmount",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 257408,
            "endOffset": 257942,
            "count": 0
          }
        ]
      },
      {
        "functionName": "bindToMotionValue",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 257945,
            "endOffset": 258557,
            "count": 0
          }
        ]
      },
      {
        "functionName": "sortNodePosition",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 258560,
            "endOffset": 258769,
            "count": 0
          }
        ]
      },
      {
        "functionName": "loadFeatures",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 258772,
            "endOffset": 261000,
            "count": 0
          }
        ]
      },
      {
        "functionName": "updateFeatures",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 261003,
            "endOffset": 261251,
            "count": 0
          }
        ]
      },
      {
        "functionName": "triggerBuild",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 261254,
            "endOffset": 261353,
            "count": 0
          }
        ]
      },
      {
        "functionName": "measureViewportBox",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 261545,
            "endOffset": 261670,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getStaticValue",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 261673,
            "endOffset": 261733,
            "count": 0
          }
        ]
      },
      {
        "functionName": "setStaticValue",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 261736,
            "endOffset": 261804,
            "count": 0
          }
        ]
      },
      {
        "functionName": "update",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 261956,
            "endOffset": 262868,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getProps",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 262871,
            "endOffset": 262910,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getVariant",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 262980,
            "endOffset": 263071,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getDefaultTransition",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 263149,
            "endOffset": 263211,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getTransformPagePoint",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 263214,
            "endOffset": 263285,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getClosestVariantNode",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 263288,
            "endOffset": 263416,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getVariantContext",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 263419,
            "endOffset": 264073,
            "count": 0
          }
        ]
      },
      {
        "functionName": "addVariantChild",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 264144,
            "endOffset": 264429,
            "count": 0
          }
        ]
      },
      {
        "functionName": "addValue",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 264504,
            "endOffset": 264724,
            "count": 0
          }
        ]
      },
      {
        "functionName": "removeValue",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 264803,
            "endOffset": 265100,
            "count": 0
          }
        ]
      },
      {
        "functionName": "hasValue",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 265170,
            "endOffset": 265222,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getValue",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 265225,
            "endOffset": 265597,
            "count": 0
          }
        ]
      },
      {
        "functionName": "readValue",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 265829,
            "endOffset": 266546,
            "count": 0
          }
        ]
      },
      {
        "functionName": "setBaseTarget",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 266693,
            "endOffset": 266758,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getBaseTarget",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 266861,
            "endOffset": 267546,
            "count": 0
          }
        ]
      },
      {
        "functionName": "on",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 267549,
            "endOffset": 267726,
            "count": 0
          }
        ]
      },
      {
        "functionName": "notify",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 267729,
            "endOffset": 267847,
            "count": 0
          }
        ]
      },
      {
        "functionName": "DOMVisualElement",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 268068,
            "endOffset": 268162,
            "count": 0
          }
        ]
      },
      {
        "functionName": "sortInstanceNodePosition",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 268165,
            "endOffset": 268255,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getBaseTargetFromProps",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 268258,
            "endOffset": 268350,
            "count": 0
          }
        ]
      },
      {
        "functionName": "removeValueFromRenderState",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 268353,
            "endOffset": 268452,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getComputedStyle2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 268620,
            "endOffset": 268702,
            "count": 0
          }
        ]
      },
      {
        "functionName": "HTMLVisualElement",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 268762,
            "endOffset": 268830,
            "count": 0
          }
        ]
      },
      {
        "functionName": "readValueFromInstance",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 268833,
            "endOffset": 269268,
            "count": 0
          }
        ]
      },
      {
        "functionName": "measureInstanceViewportBox",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 269271,
            "endOffset": 269398,
            "count": 0
          }
        ]
      },
      {
        "functionName": "build",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 269401,
            "endOffset": 269537,
            "count": 0
          }
        ]
      },
      {
        "functionName": "scrapeMotionValuesFromProps",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 269540,
            "endOffset": 269679,
            "count": 0
          }
        ]
      },
      {
        "functionName": "handleChildMotionValue",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 269682,
            "endOffset": 270052,
            "count": 0
          }
        ]
      },
      {
        "functionName": "renderInstance",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 270055,
            "endOffset": 270183,
            "count": 0
          }
        ]
      },
      {
        "functionName": "SVGVisualElement",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 270407,
            "endOffset": 270501,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getBaseTargetFromProps",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 270504,
            "endOffset": 270567,
            "count": 0
          }
        ]
      },
      {
        "functionName": "readValueFromInstance",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 270570,
            "endOffset": 270867,
            "count": 0
          }
        ]
      },
      {
        "functionName": "measureInstanceViewportBox",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 270870,
            "endOffset": 270928,
            "count": 0
          }
        ]
      },
      {
        "functionName": "scrapeMotionValuesFromProps",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 270931,
            "endOffset": 271047,
            "count": 0
          }
        ]
      },
      {
        "functionName": "build",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 271050,
            "endOffset": 271199,
            "count": 0
          }
        ]
      },
      {
        "functionName": "renderInstance",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 271202,
            "endOffset": 271329,
            "count": 0
          }
        ]
      },
      {
        "functionName": "mount",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 271332,
            "endOffset": 271428,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createDomVisualElement",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 271628,
            "endOffset": 271835,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 272362,
            "endOffset": 272470,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createDomMotionComponent",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 272473,
            "endOffset": 272649,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useIsMounted",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 273531,
            "endOffset": 273768,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useForceUpdate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 273926,
            "endOffset": 274401,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getSnapshotBeforeUpdate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 274988,
            "endOffset": 275380,
            "count": 0
          }
        ]
      },
      {
        "functionName": "componentDidUpdate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 275465,
            "endOffset": 275491,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 275494,
            "endOffset": 275540,
            "count": 0
          }
        ]
      },
      {
        "functionName": "PopChild",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 275544,
            "endOffset": 276782,
            "count": 0
          }
        ]
      },
      {
        "functionName": "PresenceChild",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 276978,
            "endOffset": 278458,
            "count": 0
          }
        ]
      },
      {
        "functionName": "newChildrenMap",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 278460,
            "endOffset": 278525,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useUnmountEffect",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 278735,
            "endOffset": 278842,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getChildKey",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 279028,
            "endOffset": 279054,
            "count": 0
          }
        ]
      },
      {
        "functionName": "updateChildLookup",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 279056,
            "endOffset": 279216,
            "count": 0
          }
        ]
      },
      {
        "functionName": "onlyElements",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 279217,
            "endOffset": 279436,
            "count": 0
          }
        ]
      },
      {
        "functionName": "AnimatePresence",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 279459,
            "endOffset": 283310,
            "count": 0
          }
        ]
      },
      {
        "functionName": "MotionConfig",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 283568,
            "endOffset": 284062,
            "count": 0
          }
        ]
      },
      {
        "functionName": "LazyMotion",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 284317,
            "endOffset": 285075,
            "count": 0
          }
        ]
      },
      {
        "functionName": "isLazyBundle",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 285076,
            "endOffset": 285152,
            "count": 0
          }
        ]
      },
      {
        "functionName": "notify",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 285874,
            "endOffset": 285929,
            "count": 0
          }
        ]
      },
      {
        "functionName": "nodeGroup",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 285931,
            "endOffset": 286484,
            "count": 0
          }
        ]
      },
      {
        "functionName": "shouldInheritGroup",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 286673,
            "endOffset": 286702,
            "count": 0
          }
        ]
      },
      {
        "functionName": "shouldInheritId",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 286726,
            "endOffset": 286795,
            "count": 0
          }
        ]
      },
      {
        "functionName": "LayoutGroup",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 286815,
            "endOffset": 287715,
            "count": 0
          }
        ]
      },
      {
        "functionName": "checkReorder",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 288410,
            "endOffset": 289084,
            "count": 0
          }
        ]
      },
      {
        "functionName": "ReorderGroup",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 289244,
            "endOffset": 290486,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getValue",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 290545,
            "endOffset": 290593,
            "count": 0
          }
        ]
      },
      {
        "functionName": "compareMin",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 290594,
            "endOffset": 290661,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useMotionValue",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 291119,
            "endOffset": 291467,
            "count": 0
          }
        ]
      },
      {
        "functionName": "isCustomValueType",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 291642,
            "endOffset": 291698,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getMixer2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 291716,
            "endOffset": 291760,
            "count": 0
          }
        ]
      },
      {
        "functionName": "transform",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 291762,
            "endOffset": 292236,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useCombineMotionValues",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 292396,
            "endOffset": 292903,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useComputed",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 293057,
            "endOffset": 293273,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useTransform",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 293428,
            "endOffset": 293866,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useListTransform",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 293867,
            "endOffset": 294186,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useDefaultMotionValue",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 294345,
            "endOffset": 294474,
            "count": 0
          }
        ]
      },
      {
        "functionName": "ReorderItem",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 294475,
            "endOffset": 295538,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useMotionTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 296431,
            "endOffset": 296870,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useSpring",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 297072,
            "endOffset": 298281,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useMotionValueEvent",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 298495,
            "endOffset": 298652,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useVelocity",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 298806,
            "endOffset": 299168,
            "count": 0
          }
        ]
      },
      {
        "functionName": "resolveElements",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 299537,
            "endOffset": 300183,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getElementSize",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 300417,
            "endOffset": 300798,
            "count": 0
          }
        ]
      },
      {
        "functionName": "notifyTarget",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 300799,
            "endOffset": 301128,
            "count": 0
          }
        ]
      },
      {
        "functionName": "notifyAll",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 301129,
            "endOffset": 301193,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createResizeObserver",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 301194,
            "endOffset": 301330,
            "count": 0
          }
        ]
      },
      {
        "functionName": "resizeElement",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 301331,
            "endOffset": 302242,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createWindowResizeHandler",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 302483,
            "endOffset": 302852,
            "count": 0
          }
        ]
      },
      {
        "functionName": "resizeWindow",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 302853,
            "endOffset": 303140,
            "count": 0
          }
        ]
      },
      {
        "functionName": "resize",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 303299,
            "endOffset": 303398,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createAxisInfo",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 303599,
            "endOffset": 303746,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createScrollInfo",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 303771,
            "endOffset": 303838,
            "count": 0
          }
        ]
      },
      {
        "functionName": "updateAxisInfo",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 303963,
            "endOffset": 304566,
            "count": 0
          }
        ]
      },
      {
        "functionName": "updateScrollInfo",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 304567,
            "endOffset": 304729,
            "count": 0
          }
        ]
      },
      {
        "functionName": "calcInset",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 304896,
            "endOffset": 305939,
            "count": 0
          }
        ]
      },
      {
        "functionName": "resolveEdge",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 306505,
            "endOffset": 307191,
            "count": 0
          }
        ]
      },
      {
        "functionName": "resolveOffset",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 307388,
            "endOffset": 308092,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getTargetSize",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 308287,
            "endOffset": 308459,
            "count": 0
          }
        ]
      },
      {
        "functionName": "resolveOffsets",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 308460,
            "endOffset": 309674,
            "count": 0
          }
        ]
      },
      {
        "functionName": "measure",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 309845,
            "endOffset": 310760,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createOnScrollHandler",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 310761,
            "endOffset": 311122,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getEventTarget",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 311462,
            "endOffset": 311530,
            "count": 0
          }
        ]
      },
      {
        "functionName": "scrollInfo",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 311532,
            "endOffset": 313611,
            "count": 0
          }
        ]
      },
      {
        "functionName": "refWarning",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 313763,
            "endOffset": 314073,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createScrollMotionValues",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 314105,
            "endOffset": 314239,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useScroll",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 314241,
            "endOffset": 315087,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useElementScroll",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 315254,
            "endOffset": 315444,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useViewportScroll",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 315612,
            "endOffset": 315765,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useAnimationFrame",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 315976,
            "endOffset": 316553,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useTime",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 316703,
            "endOffset": 316818,
            "count": 0
          }
        ]
      },
      {
        "functionName": "WillChangeMotionValue",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 317039,
            "endOffset": 317155,
            "count": 0
          }
        ]
      },
      {
        "functionName": "add",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 317158,
            "endOffset": 317532,
            "count": 0
          }
        ]
      },
      {
        "functionName": "remove",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 317535,
            "endOffset": 317804,
            "count": 0
          }
        ]
      },
      {
        "functionName": "update",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 317807,
            "endOffset": 317891,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useWillChange",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 317895,
            "endOffset": 317986,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useReducedMotion",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 318211,
            "endOffset": 318580,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useReducedMotionConfig",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 318812,
            "endOffset": 319148,
            "count": 0
          }
        ]
      },
      {
        "functionName": "stopAnimation",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 319318,
            "endOffset": 319416,
            "count": 0
          }
        ]
      },
      {
        "functionName": "setVariants",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 319417,
            "endOffset": 319826,
            "count": 0
          }
        ]
      },
      {
        "functionName": "setValues",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 319827,
            "endOffset": 320119,
            "count": 0
          }
        ]
      },
      {
        "functionName": "animationControls",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 320120,
            "endOffset": 321369,
            "count": 0
          }
        ]
      },
      {
        "functionName": "observeTimeline",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 321530,
            "endOffset": 321941,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 322137,
            "endOffset": 322175,
            "count": 0
          }
        ]
      },
      {
        "functionName": "GroupPlaybackControls",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 322382,
            "endOffset": 322463,
            "count": 0
          }
        ]
      },
      {
        "functionName": "then",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 322466,
            "endOffset": 322570,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getAll",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 322656,
            "endOffset": 322719,
            "count": 0
          }
        ]
      },
      {
        "functionName": "setAll",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 322722,
            "endOffset": 322862,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attachTimeline",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 322865,
            "endOffset": 323427,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get time",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 323430,
            "endOffset": 323478,
            "count": 0
          }
        ]
      },
      {
        "functionName": "set time",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 323481,
            "endOffset": 323534,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get speed",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 323537,
            "endOffset": 323587,
            "count": 0
          }
        ]
      },
      {
        "functionName": "set speed",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 323590,
            "endOffset": 323645,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get duration",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 323648,
            "endOffset": 323818,
            "count": 0
          }
        ]
      },
      {
        "functionName": "runAll",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 323821,
            "endOffset": 323912,
            "count": 0
          }
        ]
      },
      {
        "functionName": "play",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 323915,
            "endOffset": 323952,
            "count": 0
          }
        ]
      },
      {
        "functionName": "pause",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 323955,
            "endOffset": 323994,
            "count": 0
          }
        ]
      },
      {
        "functionName": "stop",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 323997,
            "endOffset": 324034,
            "count": 0
          }
        ]
      },
      {
        "functionName": "cancel",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 324037,
            "endOffset": 324078,
            "count": 0
          }
        ]
      },
      {
        "functionName": "complete",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 324081,
            "endOffset": 324126,
            "count": 0
          }
        ]
      },
      {
        "functionName": "isDOMKeyframes",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 324297,
            "endOffset": 324407,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createVisualElement",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 324580,
            "endOffset": 325129,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createGeneratorEasing",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 325301,
            "endOffset": 325674,
            "count": 0
          }
        ]
      },
      {
        "functionName": "calcNextTime",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 325844,
            "endOffset": 326210,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wrap",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 326367,
            "endOffset": 326482,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getEasingForSegment",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 326654,
            "endOffset": 326774,
            "count": 0
          }
        ]
      },
      {
        "functionName": "eraseKeyframes",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 326939,
            "endOffset": 327195,
            "count": 0
          }
        ]
      },
      {
        "functionName": "addKeyframes",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 327196,
            "endOffset": 327532,
            "count": 0
          }
        ]
      },
      {
        "functionName": "compareByTime",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 327697,
            "endOffset": 327890,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createAnimationsFromSequence",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 328091,
            "endOffset": 333192,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getSubjectSequence",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 333193,
            "endOffset": 333334,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getValueSequence",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 333335,
            "endOffset": 333457,
            "count": 0
          }
        ]
      },
      {
        "functionName": "keyframesAsList",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 333458,
            "endOffset": 333562,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getValueTransition2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 333563,
            "endOffset": 333698,
            "count": 0
          }
        ]
      },
      {
        "functionName": "isNumber",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 333714,
            "endOffset": 333756,
            "count": 0
          }
        ]
      },
      {
        "functionName": "isNumberKeyframesArray",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 333787,
            "endOffset": 333829,
            "count": 0
          }
        ]
      },
      {
        "functionName": "animateElements",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 333983,
            "endOffset": 334767,
            "count": 0
          }
        ]
      },
      {
        "functionName": "isSequence",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 334785,
            "endOffset": 334843,
            "count": 0
          }
        ]
      },
      {
        "functionName": "animateSequence",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 334845,
            "endOffset": 335412,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createScopedAnimate",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 335439,
            "endOffset": 336025,
            "count": 1
          }
        ]
      },
      {
        "functionName": "scopedAnimate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 335454,
            "endOffset": 335999,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useAnimate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 336226,
            "endOffset": 336523,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useAnimationControls",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 336688,
            "endOffset": 336842,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useCycle",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 337084,
            "endOffset": 337730,
            "count": 0
          }
        ]
      },
      {
        "functionName": "inView",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 338135,
            "endOffset": 339199,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useInView",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 339352,
            "endOffset": 339910,
            "count": 0
          }
        ]
      },
      {
        "functionName": "DragControls",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 340106,
            "endOffset": 340181,
            "count": 0
          }
        ]
      },
      {
        "functionName": "subscribe",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 340306,
            "endOffset": 340431,
            "count": 0
          }
        ]
      },
      {
        "functionName": "start",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 340759,
            "endOffset": 340904,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createDragControls",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 340933,
            "endOffset": 340957,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useDragControls",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 340959,
            "endOffset": 341031,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useDomEvent",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 341237,
            "endOffset": 341510,
            "count": 0
          }
        ]
      },
      {
        "functionName": "isMotionComponent",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 341678,
            "endOffset": 341819,
            "count": 0
          }
        ]
      },
      {
        "functionName": "unwrapMotionComponent",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 341991,
            "endOffset": 342140,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useInstantLayoutTransition",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 342529,
            "endOffset": 342596,
            "count": 0
          }
        ]
      },
      {
        "functionName": "startTransition",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 342597,
            "endOffset": 342801,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useInstantTransition",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 342965,
            "endOffset": 343652,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disableInstantTransitions",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 343653,
            "endOffset": 343734,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useResetProjection",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 343944,
            "endOffset": 344143,
            "count": 0
          }
        ]
      },
      {
        "functionName": "appearStoreId",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 344334,
            "endOffset": 344368,
            "count": 0
          }
        ]
      },
      {
        "functionName": "handoffOptimizedAppearAnimation",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 344782,
            "endOffset": 345572,
            "count": 0
          }
        ]
      },
      {
        "functionName": "startOptimizedAppearAnimation",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 345780,
            "endOffset": 347438,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createObject",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 347677,
            "endOffset": 347687,
            "count": 0
          }
        ]
      },
      {
        "functionName": "build",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 347746,
            "endOffset": 347759,
            "count": 0
          }
        ]
      },
      {
        "functionName": "measureInstanceViewportBox",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 347762,
            "endOffset": 347820,
            "count": 0
          }
        ]
      },
      {
        "functionName": "resetTransform",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 347823,
            "endOffset": 347845,
            "count": 0
          }
        ]
      },
      {
        "functionName": "restoreTransform",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 347848,
            "endOffset": 347872,
            "count": 0
          }
        ]
      },
      {
        "functionName": "removeValueFromRenderState",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 347875,
            "endOffset": 347909,
            "count": 0
          }
        ]
      },
      {
        "functionName": "renderInstance",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 347912,
            "endOffset": 347934,
            "count": 0
          }
        ]
      },
      {
        "functionName": "scrapeMotionValuesFromProps",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 347937,
            "endOffset": 347999,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getBaseTargetFromProps",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 348002,
            "endOffset": 348051,
            "count": 0
          }
        ]
      },
      {
        "functionName": "readValueFromInstance",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 348054,
            "endOffset": 348146,
            "count": 0
          }
        ]
      },
      {
        "functionName": "sortInstanceNodePosition",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 348149,
            "endOffset": 348195,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useAnimatedState",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 348324,
            "endOffset": 349133,
            "count": 0
          }
        ]
      },
      {
        "functionName": "invertScale",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 349381,
            "endOffset": 349430,
            "count": 0
          }
        ]
      },
      {
        "functionName": "useInvertedScale",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 349455,
            "endOffset": 350339,
            "count": 0
          }
        ]
      },
      {
        "functionName": "AnimateSharedLayout",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 350587,
            "endOffset": 350873,
            "count": 0
          }
        ]
      },
      {
        "functionName": "scrollTimelineFallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 351033,
            "endOffset": 351288,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getTimeline",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 351336,
            "endOffset": 351736,
            "count": 0
          }
        ]
      },
      {
        "functionName": "scroll",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 351737,
            "endOffset": 351965,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getOriginIndex",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 352124,
            "endOffset": 352308,
            "count": 0
          }
        ]
      },
      {
        "functionName": "stagger",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 352309,
            "endOffset": 352815,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 353026,
            "endOffset": 353107,
            "count": 6
          }
        ]
      },
      {
        "functionName": "acc.<computed>",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 353055,
            "endOffset": 353090,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "",
    "scriptId": "51",
    "source": "\n      (() => {\n        const module = {};\n        \nvar __commonJS = obj => {\n  let required = false;\n  let result;\n  return function __require() {\n    if (!required) {\n      required = true;\n      let fn;\n      for (const name in obj) { fn = obj[name]; break; }\n      const module = { exports: {} };\n      fn(module.exports, module);\n      result = module.exports;\n    }\n    return result;\n  }\n};\nvar __export = (target, all) => {for (var name in all) target[name] = all[name];};\nvar __toESM = mod => ({ ...mod, 'default': mod });\nvar __toCommonJS = mod => ({ ...mod, __esModule: true });\n\n\n// packages/injected/src/utilityScript.ts\nvar utilityScript_exports = {};\n__export(utilityScript_exports, {\n  UtilityScript: () => UtilityScript\n});\nmodule.exports = __toCommonJS(utilityScript_exports);\n\n// packages/playwright-core/src/utils/isomorphic/builtins.ts\nfunction builtins(global) {\n  var _a, _b, _c, _d, _e, _f, _g, _h, _i;\n  global = global != null ? global : globalThis;\n  if (!global[\"__playwright_builtins__\"]) {\n    const builtins2 = {\n      setTimeout: (_a = global.setTimeout) == null ? void 0 : _a.bind(global),\n      clearTimeout: (_b = global.clearTimeout) == null ? void 0 : _b.bind(global),\n      setInterval: (_c = global.setInterval) == null ? void 0 : _c.bind(global),\n      clearInterval: (_d = global.clearInterval) == null ? void 0 : _d.bind(global),\n      requestAnimationFrame: (_e = global.requestAnimationFrame) == null ? void 0 : _e.bind(global),\n      cancelAnimationFrame: (_f = global.cancelAnimationFrame) == null ? void 0 : _f.bind(global),\n      requestIdleCallback: (_g = global.requestIdleCallback) == null ? void 0 : _g.bind(global),\n      cancelIdleCallback: (_h = global.cancelIdleCallback) == null ? void 0 : _h.bind(global),\n      performance: global.performance,\n      eval: (_i = global.eval) == null ? void 0 : _i.bind(global),\n      Intl: global.Intl,\n      Date: global.Date,\n      Map: global.Map,\n      Set: global.Set\n    };\n    Object.defineProperty(global, \"__playwright_builtins__\", { value: builtins2, configurable: false, enumerable: false, writable: false });\n  }\n  return global[\"__playwright_builtins__\"];\n}\nvar instance = builtins();\nvar setTimeout = instance.setTimeout;\nvar clearTimeout = instance.clearTimeout;\nvar setInterval = instance.setInterval;\nvar clearInterval = instance.clearInterval;\nvar requestAnimationFrame = instance.requestAnimationFrame;\nvar cancelAnimationFrame = instance.cancelAnimationFrame;\nvar requestIdleCallback = instance.requestIdleCallback;\nvar cancelIdleCallback = instance.cancelIdleCallback;\nvar performance = instance.performance;\nvar Intl = instance.Intl;\nvar Date = instance.Date;\nvar Map = instance.Map;\nvar Set = instance.Set;\n\n// packages/playwright-core/src/utils/isomorphic/utilityScriptSerializers.ts\nfunction source(builtins2) {\n  function isRegExp(obj) {\n    try {\n      return obj instanceof RegExp || Object.prototype.toString.call(obj) === \"[object RegExp]\";\n    } catch (error) {\n      return false;\n    }\n  }\n  function isDate(obj) {\n    try {\n      return obj instanceof builtins2.Date || Object.prototype.toString.call(obj) === \"[object Date]\";\n    } catch (error) {\n      return false;\n    }\n  }\n  function isURL(obj) {\n    try {\n      return obj instanceof URL || Object.prototype.toString.call(obj) === \"[object URL]\";\n    } catch (error) {\n      return false;\n    }\n  }\n  function isError(obj) {\n    var _a;\n    try {\n      return obj instanceof Error || obj && ((_a = Object.getPrototypeOf(obj)) == null ? void 0 : _a.name) === \"Error\";\n    } catch (error) {\n      return false;\n    }\n  }\n  function isTypedArray(obj, constructor) {\n    try {\n      return obj instanceof constructor || Object.prototype.toString.call(obj) === `[object ${constructor.name}]`;\n    } catch (error) {\n      return false;\n    }\n  }\n  const typedArrayConstructors = {\n    i8: Int8Array,\n    ui8: Uint8Array,\n    ui8c: Uint8ClampedArray,\n    i16: Int16Array,\n    ui16: Uint16Array,\n    i32: Int32Array,\n    ui32: Uint32Array,\n    // TODO: add Float16Array once it's in baseline\n    f32: Float32Array,\n    f64: Float64Array,\n    bi64: BigInt64Array,\n    bui64: BigUint64Array\n  };\n  function typedArrayToBase64(array) {\n    if (\"toBase64\" in array)\n      return array.toBase64();\n    const binary = Array.from(new Uint8Array(array.buffer, array.byteOffset, array.byteLength)).map((b) => String.fromCharCode(b)).join(\"\");\n    return btoa(binary);\n  }\n  function base64ToTypedArray(base64, TypedArrayConstructor) {\n    const binary = atob(base64);\n    const bytes = new Uint8Array(binary.length);\n    for (let i = 0; i < binary.length; i++)\n      bytes[i] = binary.charCodeAt(i);\n    return new TypedArrayConstructor(bytes.buffer);\n  }\n  function parseEvaluationResultValue(value, handles = [], refs = new builtins2.Map()) {\n    if (Object.is(value, void 0))\n      return void 0;\n    if (typeof value === \"object\" && value) {\n      if (\"ref\" in value)\n        return refs.get(value.ref);\n      if (\"v\" in value) {\n        if (value.v === \"undefined\")\n          return void 0;\n        if (value.v === \"null\")\n          return null;\n        if (value.v === \"NaN\")\n          return NaN;\n        if (value.v === \"Infinity\")\n          return Infinity;\n        if (value.v === \"-Infinity\")\n          return -Infinity;\n        if (value.v === \"-0\")\n          return -0;\n        return void 0;\n      }\n      if (\"d\" in value)\n        return new builtins2.Date(value.d);\n      if (\"u\" in value)\n        return new URL(value.u);\n      if (\"bi\" in value)\n        return BigInt(value.bi);\n      if (\"e\" in value) {\n        const error = new Error(value.e.m);\n        error.name = value.e.n;\n        error.stack = value.e.s;\n        return error;\n      }\n      if (\"r\" in value)\n        return new RegExp(value.r.p, value.r.f);\n      if (\"a\" in value) {\n        const result = [];\n        refs.set(value.id, result);\n        for (const a of value.a)\n          result.push(parseEvaluationResultValue(a, handles, refs));\n        return result;\n      }\n      if (\"o\" in value) {\n        const result = {};\n        refs.set(value.id, result);\n        for (const { k, v } of value.o)\n          result[k] = parseEvaluationResultValue(v, handles, refs);\n        return result;\n      }\n      if (\"h\" in value)\n        return handles[value.h];\n      if (\"ta\" in value)\n        return base64ToTypedArray(value.ta.b, typedArrayConstructors[value.ta.k]);\n    }\n    return value;\n  }\n  function serializeAsCallArgument(value, handleSerializer) {\n    return serialize(value, handleSerializer, { visited: new builtins2.Map(), lastId: 0 });\n  }\n  function serialize(value, handleSerializer, visitorInfo) {\n    if (value && typeof value === \"object\") {\n      if (typeof globalThis.Window === \"function\" && value instanceof globalThis.Window)\n        return \"ref: <Window>\";\n      if (typeof globalThis.Document === \"function\" && value instanceof globalThis.Document)\n        return \"ref: <Document>\";\n      if (typeof globalThis.Node === \"function\" && value instanceof globalThis.Node)\n        return \"ref: <Node>\";\n    }\n    return innerSerialize(value, handleSerializer, visitorInfo);\n  }\n  function innerSerialize(value, handleSerializer, visitorInfo) {\n    var _a;\n    const result = handleSerializer(value);\n    if (\"fallThrough\" in result)\n      value = result.fallThrough;\n    else\n      return result;\n    if (typeof value === \"symbol\")\n      return { v: \"undefined\" };\n    if (Object.is(value, void 0))\n      return { v: \"undefined\" };\n    if (Object.is(value, null))\n      return { v: \"null\" };\n    if (Object.is(value, NaN))\n      return { v: \"NaN\" };\n    if (Object.is(value, Infinity))\n      return { v: \"Infinity\" };\n    if (Object.is(value, -Infinity))\n      return { v: \"-Infinity\" };\n    if (Object.is(value, -0))\n      return { v: \"-0\" };\n    if (typeof value === \"boolean\")\n      return value;\n    if (typeof value === \"number\")\n      return value;\n    if (typeof value === \"string\")\n      return value;\n    if (typeof value === \"bigint\")\n      return { bi: value.toString() };\n    if (isError(value)) {\n      let stack;\n      if ((_a = value.stack) == null ? void 0 : _a.startsWith(value.name + \": \" + value.message)) {\n        stack = value.stack;\n      } else {\n        stack = `${value.name}: ${value.message}\n${value.stack}`;\n      }\n      return { e: { n: value.name, m: value.message, s: stack } };\n    }\n    if (isDate(value))\n      return { d: value.toJSON() };\n    if (isURL(value))\n      return { u: value.toJSON() };\n    if (isRegExp(value))\n      return { r: { p: value.source, f: value.flags } };\n    for (const [k, ctor] of Object.entries(typedArrayConstructors)) {\n      if (isTypedArray(value, ctor))\n        return { ta: { b: typedArrayToBase64(value), k } };\n    }\n    const id = visitorInfo.visited.get(value);\n    if (id)\n      return { ref: id };\n    if (Array.isArray(value)) {\n      const a = [];\n      const id2 = ++visitorInfo.lastId;\n      visitorInfo.visited.set(value, id2);\n      for (let i = 0; i < value.length; ++i)\n        a.push(serialize(value[i], handleSerializer, visitorInfo));\n      return { a, id: id2 };\n    }\n    if (typeof value === \"object\") {\n      const o = [];\n      const id2 = ++visitorInfo.lastId;\n      visitorInfo.visited.set(value, id2);\n      for (const name of Object.keys(value)) {\n        let item;\n        try {\n          item = value[name];\n        } catch (e) {\n          continue;\n        }\n        if (name === \"toJSON\" && typeof item === \"function\")\n          o.push({ k: name, v: { o: [], id: 0 } });\n        else\n          o.push({ k: name, v: serialize(item, handleSerializer, visitorInfo) });\n      }\n      let jsonWrapper;\n      try {\n        if (o.length === 0 && value.toJSON && typeof value.toJSON === \"function\")\n          jsonWrapper = { value: value.toJSON() };\n      } catch (e) {\n      }\n      if (jsonWrapper)\n        return innerSerialize(jsonWrapper.value, handleSerializer, visitorInfo);\n      return { o, id: id2 };\n    }\n  }\n  return { parseEvaluationResultValue, serializeAsCallArgument };\n}\n\n// packages/injected/src/utilityScript.ts\nvar UtilityScript = class {\n  constructor(isUnderTest) {\n    if (isUnderTest) {\n      globalThis.builtins = builtins();\n    }\n    const result = source(builtins());\n    this.serializeAsCallArgument = result.serializeAsCallArgument;\n    this.parseEvaluationResultValue = result.parseEvaluationResultValue;\n  }\n  evaluate(isFunction, returnByValue, expression, argCount, ...argsAndHandles) {\n    const args = argsAndHandles.slice(0, argCount);\n    const handles = argsAndHandles.slice(argCount);\n    const parameters = [];\n    for (let i = 0; i < args.length; i++)\n      parameters[i] = this.parseEvaluationResultValue(args[i], handles);\n    let result = builtins().eval(expression);\n    if (isFunction === true) {\n      result = result(...parameters);\n    } else if (isFunction === false) {\n      result = result;\n    } else {\n      if (typeof result === \"function\")\n        result = result(...parameters);\n    }\n    return returnByValue ? this._promiseAwareJsonValueNoThrow(result) : result;\n  }\n  jsonValue(returnByValue, value) {\n    if (value === void 0)\n      return void 0;\n    return this.serializeAsCallArgument(value, (value2) => ({ fallThrough: value2 }));\n  }\n  _promiseAwareJsonValueNoThrow(value) {\n    const safeJson = (value2) => {\n      try {\n        return this.jsonValue(true, value2);\n      } catch (e) {\n        return void 0;\n      }\n    };\n    if (value && typeof value === \"object\" && typeof value.then === \"function\") {\n      return (async () => {\n        const promiseValue = await value;\n        return safeJson(promiseValue);\n      })();\n    }\n    return safeJson(value);\n  }\n};\n\n        return new (module.exports.UtilityScript())(false);\n      })();",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 11771,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 8,
            "endOffset": 11767,
            "count": 1
          }
        ]
      },
      {
        "functionName": "__commonJS",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 69,
            "endOffset": 396,
            "count": 0
          }
        ]
      },
      {
        "functionName": "__export",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 413,
            "endOffset": 479,
            "count": 1
          }
        ]
      },
      {
        "functionName": "__toESM",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 495,
            "endOffset": 530,
            "count": 0
          }
        ]
      },
      {
        "functionName": "__toCommonJS",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 551,
            "endOffset": 588,
            "count": 1
          }
        ]
      },
      {
        "functionName": "UtilityScript",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 717,
            "endOffset": 736,
            "count": 1
          }
        ]
      },
      {
        "functionName": "builtins",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 857,
            "endOffset": 2162,
            "count": 7
          },
          {
            "startOffset": 953,
            "endOffset": 961,
            "count": 0
          },
          {
            "startOffset": 1018,
            "endOffset": 2116,
            "count": 0
          }
        ]
      },
      {
        "functionName": "source",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 2800,
            "endOffset": 10050,
            "count": 1
          }
        ]
      },
      {
        "functionName": "isRegExp",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 2831,
            "endOffset": 3014,
            "count": 6
          },
          {
            "startOffset": 2969,
            "endOffset": 3010,
            "count": 0
          }
        ]
      },
      {
        "functionName": "isDate",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 3017,
            "endOffset": 3204,
            "count": 6
          },
          {
            "startOffset": 3159,
            "endOffset": 3200,
            "count": 0
          }
        ]
      },
      {
        "functionName": "isURL",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 3207,
            "endOffset": 3381,
            "count": 6
          },
          {
            "startOffset": 3336,
            "endOffset": 3377,
            "count": 0
          }
        ]
      },
      {
        "functionName": "isError",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 3384,
            "endOffset": 3601,
            "count": 6
          },
          {
            "startOffset": 3517,
            "endOffset": 3525,
            "count": 0
          },
          {
            "startOffset": 3556,
            "endOffset": 3597,
            "count": 0
          }
        ]
      },
      {
        "functionName": "isTypedArray",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 3604,
            "endOffset": 3822,
            "count": 66
          },
          {
            "startOffset": 3777,
            "endOffset": 3818,
            "count": 0
          }
        ]
      },
      {
        "functionName": "typedArrayToBase64",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4171,
            "endOffset": 4437,
            "count": 0
          }
        ]
      },
      {
        "functionName": "base64ToTypedArray",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4440,
            "endOffset": 4721,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parseEvaluationResultValue",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 4724,
            "endOffset": 6443,
            "count": 5
          },
          {
            "startOffset": 4851,
            "endOffset": 4865,
            "count": 0
          },
          {
            "startOffset": 4900,
            "endOffset": 4908,
            "count": 4
          },
          {
            "startOffset": 4910,
            "endOffset": 6421,
            "count": 4
          },
          {
            "startOffset": 4946,
            "endOffset": 4973,
            "count": 0
          },
          {
            "startOffset": 5061,
            "endOffset": 6415,
            "count": 0
          },
          {
            "startOffset": 6421,
            "endOffset": 6442,
            "count": 1
          }
        ]
      },
      {
        "functionName": "serializeAsCallArgument",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 6446,
            "endOffset": 6601,
            "count": 4
          }
        ]
      },
      {
        "functionName": "serialize",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 6604,
            "endOffset": 7146,
            "count": 29
          },
          {
            "startOffset": 6677,
            "endOffset": 6705,
            "count": 20
          },
          {
            "startOffset": 6707,
            "endOffset": 7077,
            "count": 6
          },
          {
            "startOffset": 6806,
            "endOffset": 6829,
            "count": 0
          },
          {
            "startOffset": 6931,
            "endOffset": 6956,
            "count": 0
          },
          {
            "startOffset": 7050,
            "endOffset": 7071,
            "count": 0
          }
        ]
      },
      {
        "functionName": "innerSerialize",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7149,
            "endOffset": 9982,
            "count": 29
          },
          {
            "startOffset": 7335,
            "endOffset": 7365,
            "count": 0
          },
          {
            "startOffset": 7407,
            "endOffset": 7433,
            "count": 0
          },
          {
            "startOffset": 7474,
            "endOffset": 7500,
            "count": 0
          },
          {
            "startOffset": 7539,
            "endOffset": 7560,
            "count": 0
          },
          {
            "startOffset": 7598,
            "endOffset": 7618,
            "count": 1
          },
          {
            "startOffset": 7618,
            "endOffset": 7661,
            "count": 28
          },
          {
            "startOffset": 7661,
            "endOffset": 7686,
            "count": 0
          },
          {
            "startOffset": 7686,
            "endOffset": 7730,
            "count": 28
          },
          {
            "startOffset": 7730,
            "endOffset": 7756,
            "count": 0
          },
          {
            "startOffset": 7756,
            "endOffset": 7793,
            "count": 28
          },
          {
            "startOffset": 7793,
            "endOffset": 7812,
            "count": 0
          },
          {
            "startOffset": 7812,
            "endOffset": 7855,
            "count": 28
          },
          {
            "startOffset": 7855,
            "endOffset": 7868,
            "count": 3
          },
          {
            "startOffset": 7868,
            "endOffset": 7910,
            "count": 25
          },
          {
            "startOffset": 7910,
            "endOffset": 7923,
            "count": 18
          },
          {
            "startOffset": 7923,
            "endOffset": 7965,
            "count": 7
          },
          {
            "startOffset": 7965,
            "endOffset": 7978,
            "count": 1
          },
          {
            "startOffset": 7978,
            "endOffset": 8020,
            "count": 6
          },
          {
            "startOffset": 8020,
            "endOffset": 8052,
            "count": 0
          },
          {
            "startOffset": 8052,
            "endOffset": 8077,
            "count": 6
          },
          {
            "startOffset": 8077,
            "endOffset": 8386,
            "count": 0
          },
          {
            "startOffset": 8386,
            "endOffset": 8416,
            "count": 6
          },
          {
            "startOffset": 8416,
            "endOffset": 8445,
            "count": 0
          },
          {
            "startOffset": 8445,
            "endOffset": 8474,
            "count": 6
          },
          {
            "startOffset": 8474,
            "endOffset": 8503,
            "count": 0
          },
          {
            "startOffset": 8503,
            "endOffset": 8535,
            "count": 6
          },
          {
            "startOffset": 8535,
            "endOffset": 8585,
            "count": 0
          },
          {
            "startOffset": 8585,
            "endOffset": 8654,
            "count": 6
          },
          {
            "startOffset": 8654,
            "endOffset": 8758,
            "count": 66
          },
          {
            "startOffset": 8701,
            "endOffset": 8752,
            "count": 0
          },
          {
            "startOffset": 8758,
            "endOffset": 8824,
            "count": 6
          },
          {
            "startOffset": 8824,
            "endOffset": 8843,
            "count": 0
          },
          {
            "startOffset": 8843,
            "endOffset": 8874,
            "count": 6
          },
          {
            "startOffset": 8874,
            "endOffset": 9126,
            "count": 0
          },
          {
            "startOffset": 9126,
            "endOffset": 9978,
            "count": 6
          },
          {
            "startOffset": 9312,
            "endOffset": 9643,
            "count": 25
          },
          {
            "startOffset": 9386,
            "endOffset": 9427,
            "count": 0
          },
          {
            "startOffset": 9458,
            "endOffset": 9487,
            "count": 0
          },
          {
            "startOffset": 9499,
            "endOffset": 9540,
            "count": 0
          },
          {
            "startOffset": 9706,
            "endOffset": 9721,
            "count": 2
          },
          {
            "startOffset": 9722,
            "endOffset": 9759,
            "count": 0
          },
          {
            "startOffset": 9771,
            "endOffset": 9811,
            "count": 0
          },
          {
            "startOffset": 9820,
            "endOffset": 9839,
            "count": 0
          },
          {
            "startOffset": 9871,
            "endOffset": 9943,
            "count": 0
          }
        ]
      },
      {
        "functionName": "UtilityScript",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10124,
            "endOffset": 10402,
            "count": 1
          },
          {
            "startOffset": 10172,
            "endOffset": 10219,
            "count": 0
          }
        ]
      },
      {
        "functionName": "evaluate",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10405,
            "endOffset": 11089,
            "count": 5
          },
          {
            "startOffset": 10850,
            "endOffset": 11005,
            "count": 0
          },
          {
            "startOffset": 11076,
            "endOffset": 11084,
            "count": 0
          }
        ]
      },
      {
        "functionName": "jsonValue",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 11092,
            "endOffset": 11263,
            "count": 5
          },
          {
            "startOffset": 11158,
            "endOffset": 11172,
            "count": 1
          },
          {
            "startOffset": 11172,
            "endOffset": 11262,
            "count": 4
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 11220,
            "endOffset": 11257,
            "count": 29
          }
        ]
      },
      {
        "functionName": "_promiseAwareJsonValueNoThrow",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 11266,
            "endOffset": 11695,
            "count": 5
          },
          {
            "startOffset": 11469,
            "endOffset": 11497,
            "count": 4
          },
          {
            "startOffset": 11498,
            "endOffset": 11533,
            "count": 4
          },
          {
            "startOffset": 11535,
            "endOffset": 11663,
            "count": 0
          }
        ]
      },
      {
        "functionName": "safeJson",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 11326,
            "endOffset": 11453,
            "count": 5
          },
          {
            "startOffset": 11405,
            "endOffset": 11447,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 11551,
            "endOffset": 11653,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "",
    "scriptId": "57",
    "source": "((utilityScript, ...args) => utilityScript.evaluate(...args))",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 61,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1,
            "endOffset": 60,
            "count": 1
          }
        ]
      }
    ]
  },
  {
    "url": "",
    "scriptId": "58",
    "source": "() => ({\n    scrollY: window.scrollY,\n    scrollX: window.scrollX,\n    viewportHeight: window.innerHeight,\n    viewportWidth: window.innerWidth,\n    documentHeight: document.documentElement.scrollHeight,\n    documentWidth: document.documentElement.scrollWidth\n  })",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 264,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 264,
            "count": 1
          }
        ]
      }
    ]
  },
  {
    "url": "",
    "scriptId": "59",
    "source": "\n      (() => {\n        const module = {};\n        \nvar __commonJS = obj => {\n  let required = false;\n  let result;\n  return function __require() {\n    if (!required) {\n      required = true;\n      let fn;\n      for (const name in obj) { fn = obj[name]; break; }\n      const module = { exports: {} };\n      fn(module.exports, module);\n      result = module.exports;\n    }\n    return result;\n  }\n};\nvar __export = (target, all) => {for (var name in all) target[name] = all[name];};\nvar __toESM = mod => ({ ...mod, 'default': mod });\nvar __toCommonJS = mod => ({ ...mod, __esModule: true });\n\n\n// packages/injected/src/utilityScript.ts\nvar utilityScript_exports = {};\n__export(utilityScript_exports, {\n  UtilityScript: () => UtilityScript\n});\nmodule.exports = __toCommonJS(utilityScript_exports);\n\n// packages/playwright-core/src/utils/isomorphic/builtins.ts\nfunction builtins(global) {\n  var _a, _b, _c, _d, _e, _f, _g, _h, _i;\n  global = global != null ? global : globalThis;\n  if (!global[\"__playwright_builtins__\"]) {\n    const builtins2 = {\n      setTimeout: (_a = global.setTimeout) == null ? void 0 : _a.bind(global),\n      clearTimeout: (_b = global.clearTimeout) == null ? void 0 : _b.bind(global),\n      setInterval: (_c = global.setInterval) == null ? void 0 : _c.bind(global),\n      clearInterval: (_d = global.clearInterval) == null ? void 0 : _d.bind(global),\n      requestAnimationFrame: (_e = global.requestAnimationFrame) == null ? void 0 : _e.bind(global),\n      cancelAnimationFrame: (_f = global.cancelAnimationFrame) == null ? void 0 : _f.bind(global),\n      requestIdleCallback: (_g = global.requestIdleCallback) == null ? void 0 : _g.bind(global),\n      cancelIdleCallback: (_h = global.cancelIdleCallback) == null ? void 0 : _h.bind(global),\n      performance: global.performance,\n      eval: (_i = global.eval) == null ? void 0 : _i.bind(global),\n      Intl: global.Intl,\n      Date: global.Date,\n      Map: global.Map,\n      Set: global.Set\n    };\n    Object.defineProperty(global, \"__playwright_builtins__\", { value: builtins2, configurable: false, enumerable: false, writable: false });\n  }\n  return global[\"__playwright_builtins__\"];\n}\nvar instance = builtins();\nvar setTimeout = instance.setTimeout;\nvar clearTimeout = instance.clearTimeout;\nvar setInterval = instance.setInterval;\nvar clearInterval = instance.clearInterval;\nvar requestAnimationFrame = instance.requestAnimationFrame;\nvar cancelAnimationFrame = instance.cancelAnimationFrame;\nvar requestIdleCallback = instance.requestIdleCallback;\nvar cancelIdleCallback = instance.cancelIdleCallback;\nvar performance = instance.performance;\nvar Intl = instance.Intl;\nvar Date = instance.Date;\nvar Map = instance.Map;\nvar Set = instance.Set;\n\n// packages/playwright-core/src/utils/isomorphic/utilityScriptSerializers.ts\nfunction source(builtins2) {\n  function isRegExp(obj) {\n    try {\n      return obj instanceof RegExp || Object.prototype.toString.call(obj) === \"[object RegExp]\";\n    } catch (error) {\n      return false;\n    }\n  }\n  function isDate(obj) {\n    try {\n      return obj instanceof builtins2.Date || Object.prototype.toString.call(obj) === \"[object Date]\";\n    } catch (error) {\n      return false;\n    }\n  }\n  function isURL(obj) {\n    try {\n      return obj instanceof URL || Object.prototype.toString.call(obj) === \"[object URL]\";\n    } catch (error) {\n      return false;\n    }\n  }\n  function isError(obj) {\n    var _a;\n    try {\n      return obj instanceof Error || obj && ((_a = Object.getPrototypeOf(obj)) == null ? void 0 : _a.name) === \"Error\";\n    } catch (error) {\n      return false;\n    }\n  }\n  function isTypedArray(obj, constructor) {\n    try {\n      return obj instanceof constructor || Object.prototype.toString.call(obj) === `[object ${constructor.name}]`;\n    } catch (error) {\n      return false;\n    }\n  }\n  const typedArrayConstructors = {\n    i8: Int8Array,\n    ui8: Uint8Array,\n    ui8c: Uint8ClampedArray,\n    i16: Int16Array,\n    ui16: Uint16Array,\n    i32: Int32Array,\n    ui32: Uint32Array,\n    // TODO: add Float16Array once it's in baseline\n    f32: Float32Array,\n    f64: Float64Array,\n    bi64: BigInt64Array,\n    bui64: BigUint64Array\n  };\n  function typedArrayToBase64(array) {\n    if (\"toBase64\" in array)\n      return array.toBase64();\n    const binary = Array.from(new Uint8Array(array.buffer, array.byteOffset, array.byteLength)).map((b) => String.fromCharCode(b)).join(\"\");\n    return btoa(binary);\n  }\n  function base64ToTypedArray(base64, TypedArrayConstructor) {\n    const binary = atob(base64);\n    const bytes = new Uint8Array(binary.length);\n    for (let i = 0; i < binary.length; i++)\n      bytes[i] = binary.charCodeAt(i);\n    return new TypedArrayConstructor(bytes.buffer);\n  }\n  function parseEvaluationResultValue(value, handles = [], refs = new builtins2.Map()) {\n    if (Object.is(value, void 0))\n      return void 0;\n    if (typeof value === \"object\" && value) {\n      if (\"ref\" in value)\n        return refs.get(value.ref);\n      if (\"v\" in value) {\n        if (value.v === \"undefined\")\n          return void 0;\n        if (value.v === \"null\")\n          return null;\n        if (value.v === \"NaN\")\n          return NaN;\n        if (value.v === \"Infinity\")\n          return Infinity;\n        if (value.v === \"-Infinity\")\n          return -Infinity;\n        if (value.v === \"-0\")\n          return -0;\n        return void 0;\n      }\n      if (\"d\" in value)\n        return new builtins2.Date(value.d);\n      if (\"u\" in value)\n        return new URL(value.u);\n      if (\"bi\" in value)\n        return BigInt(value.bi);\n      if (\"e\" in value) {\n        const error = new Error(value.e.m);\n        error.name = value.e.n;\n        error.stack = value.e.s;\n        return error;\n      }\n      if (\"r\" in value)\n        return new RegExp(value.r.p, value.r.f);\n      if (\"a\" in value) {\n        const result = [];\n        refs.set(value.id, result);\n        for (const a of value.a)\n          result.push(parseEvaluationResultValue(a, handles, refs));\n        return result;\n      }\n      if (\"o\" in value) {\n        const result = {};\n        refs.set(value.id, result);\n        for (const { k, v } of value.o)\n          result[k] = parseEvaluationResultValue(v, handles, refs);\n        return result;\n      }\n      if (\"h\" in value)\n        return handles[value.h];\n      if (\"ta\" in value)\n        return base64ToTypedArray(value.ta.b, typedArrayConstructors[value.ta.k]);\n    }\n    return value;\n  }\n  function serializeAsCallArgument(value, handleSerializer) {\n    return serialize(value, handleSerializer, { visited: new builtins2.Map(), lastId: 0 });\n  }\n  function serialize(value, handleSerializer, visitorInfo) {\n    if (value && typeof value === \"object\") {\n      if (typeof globalThis.Window === \"function\" && value instanceof globalThis.Window)\n        return \"ref: <Window>\";\n      if (typeof globalThis.Document === \"function\" && value instanceof globalThis.Document)\n        return \"ref: <Document>\";\n      if (typeof globalThis.Node === \"function\" && value instanceof globalThis.Node)\n        return \"ref: <Node>\";\n    }\n    return innerSerialize(value, handleSerializer, visitorInfo);\n  }\n  function innerSerialize(value, handleSerializer, visitorInfo) {\n    var _a;\n    const result = handleSerializer(value);\n    if (\"fallThrough\" in result)\n      value = result.fallThrough;\n    else\n      return result;\n    if (typeof value === \"symbol\")\n      return { v: \"undefined\" };\n    if (Object.is(value, void 0))\n      return { v: \"undefined\" };\n    if (Object.is(value, null))\n      return { v: \"null\" };\n    if (Object.is(value, NaN))\n      return { v: \"NaN\" };\n    if (Object.is(value, Infinity))\n      return { v: \"Infinity\" };\n    if (Object.is(value, -Infinity))\n      return { v: \"-Infinity\" };\n    if (Object.is(value, -0))\n      return { v: \"-0\" };\n    if (typeof value === \"boolean\")\n      return value;\n    if (typeof value === \"number\")\n      return value;\n    if (typeof value === \"string\")\n      return value;\n    if (typeof value === \"bigint\")\n      return { bi: value.toString() };\n    if (isError(value)) {\n      let stack;\n      if ((_a = value.stack) == null ? void 0 : _a.startsWith(value.name + \": \" + value.message)) {\n        stack = value.stack;\n      } else {\n        stack = `${value.name}: ${value.message}\n${value.stack}`;\n      }\n      return { e: { n: value.name, m: value.message, s: stack } };\n    }\n    if (isDate(value))\n      return { d: value.toJSON() };\n    if (isURL(value))\n      return { u: value.toJSON() };\n    if (isRegExp(value))\n      return { r: { p: value.source, f: value.flags } };\n    for (const [k, ctor] of Object.entries(typedArrayConstructors)) {\n      if (isTypedArray(value, ctor))\n        return { ta: { b: typedArrayToBase64(value), k } };\n    }\n    const id = visitorInfo.visited.get(value);\n    if (id)\n      return { ref: id };\n    if (Array.isArray(value)) {\n      const a = [];\n      const id2 = ++visitorInfo.lastId;\n      visitorInfo.visited.set(value, id2);\n      for (let i = 0; i < value.length; ++i)\n        a.push(serialize(value[i], handleSerializer, visitorInfo));\n      return { a, id: id2 };\n    }\n    if (typeof value === \"object\") {\n      const o = [];\n      const id2 = ++visitorInfo.lastId;\n      visitorInfo.visited.set(value, id2);\n      for (const name of Object.keys(value)) {\n        let item;\n        try {\n          item = value[name];\n        } catch (e) {\n          continue;\n        }\n        if (name === \"toJSON\" && typeof item === \"function\")\n          o.push({ k: name, v: { o: [], id: 0 } });\n        else\n          o.push({ k: name, v: serialize(item, handleSerializer, visitorInfo) });\n      }\n      let jsonWrapper;\n      try {\n        if (o.length === 0 && value.toJSON && typeof value.toJSON === \"function\")\n          jsonWrapper = { value: value.toJSON() };\n      } catch (e) {\n      }\n      if (jsonWrapper)\n        return innerSerialize(jsonWrapper.value, handleSerializer, visitorInfo);\n      return { o, id: id2 };\n    }\n  }\n  return { parseEvaluationResultValue, serializeAsCallArgument };\n}\n\n// packages/injected/src/utilityScript.ts\nvar UtilityScript = class {\n  constructor(isUnderTest) {\n    if (isUnderTest) {\n      globalThis.builtins = builtins();\n    }\n    const result = source(builtins());\n    this.serializeAsCallArgument = result.serializeAsCallArgument;\n    this.parseEvaluationResultValue = result.parseEvaluationResultValue;\n  }\n  evaluate(isFunction, returnByValue, expression, argCount, ...argsAndHandles) {\n    const args = argsAndHandles.slice(0, argCount);\n    const handles = argsAndHandles.slice(argCount);\n    const parameters = [];\n    for (let i = 0; i < args.length; i++)\n      parameters[i] = this.parseEvaluationResultValue(args[i], handles);\n    let result = builtins().eval(expression);\n    if (isFunction === true) {\n      result = result(...parameters);\n    } else if (isFunction === false) {\n      result = result;\n    } else {\n      if (typeof result === \"function\")\n        result = result(...parameters);\n    }\n    return returnByValue ? this._promiseAwareJsonValueNoThrow(result) : result;\n  }\n  jsonValue(returnByValue, value) {\n    if (value === void 0)\n      return void 0;\n    return this.serializeAsCallArgument(value, (value2) => ({ fallThrough: value2 }));\n  }\n  _promiseAwareJsonValueNoThrow(value) {\n    const safeJson = (value2) => {\n      try {\n        return this.jsonValue(true, value2);\n      } catch (e) {\n        return void 0;\n      }\n    };\n    if (value && typeof value === \"object\" && typeof value.then === \"function\") {\n      return (async () => {\n        const promiseValue = await value;\n        return safeJson(promiseValue);\n      })();\n    }\n    return safeJson(value);\n  }\n};\n\n        return new (module.exports.UtilityScript())(false);\n      })();",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 11771,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 8,
            "endOffset": 11767,
            "count": 1
          }
        ]
      },
      {
        "functionName": "__commonJS",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 69,
            "endOffset": 396,
            "count": 0
          }
        ]
      },
      {
        "functionName": "__export",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 413,
            "endOffset": 479,
            "count": 1
          }
        ]
      },
      {
        "functionName": "__toESM",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 495,
            "endOffset": 530,
            "count": 0
          }
        ]
      },
      {
        "functionName": "__toCommonJS",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 551,
            "endOffset": 588,
            "count": 1
          }
        ]
      },
      {
        "functionName": "UtilityScript",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 717,
            "endOffset": 736,
            "count": 1
          }
        ]
      },
      {
        "functionName": "builtins",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 857,
            "endOffset": 2162,
            "count": 13
          },
          {
            "startOffset": 953,
            "endOffset": 961,
            "count": 0
          },
          {
            "startOffset": 1018,
            "endOffset": 2116,
            "count": 1
          },
          {
            "startOffset": 1095,
            "endOffset": 1103,
            "count": 0
          },
          {
            "startOffset": 1178,
            "endOffset": 1186,
            "count": 0
          },
          {
            "startOffset": 1259,
            "endOffset": 1267,
            "count": 0
          },
          {
            "startOffset": 1344,
            "endOffset": 1352,
            "count": 0
          },
          {
            "startOffset": 1445,
            "endOffset": 1453,
            "count": 0
          },
          {
            "startOffset": 1544,
            "endOffset": 1552,
            "count": 0
          },
          {
            "startOffset": 1641,
            "endOffset": 1649,
            "count": 0
          },
          {
            "startOffset": 1736,
            "endOffset": 1744,
            "count": 0
          },
          {
            "startOffset": 1842,
            "endOffset": 1850,
            "count": 0
          }
        ]
      },
      {
        "functionName": "source",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 2800,
            "endOffset": 10050,
            "count": 1
          }
        ]
      },
      {
        "functionName": "isRegExp",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 2831,
            "endOffset": 3014,
            "count": 3
          },
          {
            "startOffset": 2969,
            "endOffset": 3010,
            "count": 0
          }
        ]
      },
      {
        "functionName": "isDate",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 3017,
            "endOffset": 3204,
            "count": 3
          },
          {
            "startOffset": 3159,
            "endOffset": 3200,
            "count": 0
          }
        ]
      },
      {
        "functionName": "isURL",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 3207,
            "endOffset": 3381,
            "count": 3
          },
          {
            "startOffset": 3336,
            "endOffset": 3377,
            "count": 0
          }
        ]
      },
      {
        "functionName": "isError",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 3384,
            "endOffset": 3601,
            "count": 3
          },
          {
            "startOffset": 3517,
            "endOffset": 3525,
            "count": 0
          },
          {
            "startOffset": 3556,
            "endOffset": 3597,
            "count": 0
          }
        ]
      },
      {
        "functionName": "isTypedArray",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 3604,
            "endOffset": 3822,
            "count": 33
          },
          {
            "startOffset": 3777,
            "endOffset": 3818,
            "count": 0
          }
        ]
      },
      {
        "functionName": "typedArrayToBase64",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4171,
            "endOffset": 4437,
            "count": 0
          }
        ]
      },
      {
        "functionName": "base64ToTypedArray",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4440,
            "endOffset": 4721,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parseEvaluationResultValue",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 4724,
            "endOffset": 6443,
            "count": 17
          },
          {
            "startOffset": 4851,
            "endOffset": 4865,
            "count": 0
          },
          {
            "startOffset": 4900,
            "endOffset": 4908,
            "count": 15
          },
          {
            "startOffset": 4910,
            "endOffset": 6421,
            "count": 15
          },
          {
            "startOffset": 4946,
            "endOffset": 4973,
            "count": 0
          },
          {
            "startOffset": 4998,
            "endOffset": 5379,
            "count": 12
          },
          {
            "startOffset": 5061,
            "endOffset": 5379,
            "count": 0
          },
          {
            "startOffset": 5379,
            "endOffset": 5412,
            "count": 3
          },
          {
            "startOffset": 5412,
            "endOffset": 5447,
            "count": 0
          },
          {
            "startOffset": 5447,
            "endOffset": 5480,
            "count": 3
          },
          {
            "startOffset": 5480,
            "endOffset": 5504,
            "count": 0
          },
          {
            "startOffset": 5504,
            "endOffset": 5538,
            "count": 3
          },
          {
            "startOffset": 5538,
            "endOffset": 5562,
            "count": 0
          },
          {
            "startOffset": 5562,
            "endOffset": 5587,
            "count": 3
          },
          {
            "startOffset": 5587,
            "endOffset": 5727,
            "count": 0
          },
          {
            "startOffset": 5727,
            "endOffset": 5760,
            "count": 3
          },
          {
            "startOffset": 5760,
            "endOffset": 5800,
            "count": 0
          },
          {
            "startOffset": 5800,
            "endOffset": 5825,
            "count": 3
          },
          {
            "startOffset": 5825,
            "endOffset": 6022,
            "count": 0
          },
          {
            "startOffset": 6022,
            "endOffset": 6047,
            "count": 3
          },
          {
            "startOffset": 6047,
            "endOffset": 6250,
            "count": 1
          },
          {
            "startOffset": 6162,
            "endOffset": 6219,
            "count": 4
          },
          {
            "startOffset": 6250,
            "endOffset": 6307,
            "count": 2
          },
          {
            "startOffset": 6307,
            "endOffset": 6415,
            "count": 0
          },
          {
            "startOffset": 6421,
            "endOffset": 6442,
            "count": 2
          }
        ]
      },
      {
        "functionName": "serializeAsCallArgument",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 6446,
            "endOffset": 6601,
            "count": 3
          }
        ]
      },
      {
        "functionName": "serialize",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 6604,
            "endOffset": 7146,
            "count": 3
          },
          {
            "startOffset": 6806,
            "endOffset": 6829,
            "count": 0
          },
          {
            "startOffset": 6931,
            "endOffset": 6956,
            "count": 0
          },
          {
            "startOffset": 7050,
            "endOffset": 7071,
            "count": 0
          }
        ]
      },
      {
        "functionName": "innerSerialize",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7149,
            "endOffset": 9982,
            "count": 3
          },
          {
            "startOffset": 7335,
            "endOffset": 7365,
            "count": 0
          },
          {
            "startOffset": 7407,
            "endOffset": 7433,
            "count": 0
          },
          {
            "startOffset": 7474,
            "endOffset": 7500,
            "count": 0
          },
          {
            "startOffset": 7539,
            "endOffset": 7560,
            "count": 0
          },
          {
            "startOffset": 7598,
            "endOffset": 7618,
            "count": 0
          },
          {
            "startOffset": 7661,
            "endOffset": 7686,
            "count": 0
          },
          {
            "startOffset": 7730,
            "endOffset": 7756,
            "count": 0
          },
          {
            "startOffset": 7793,
            "endOffset": 7812,
            "count": 0
          },
          {
            "startOffset": 7855,
            "endOffset": 7868,
            "count": 0
          },
          {
            "startOffset": 7910,
            "endOffset": 7923,
            "count": 0
          },
          {
            "startOffset": 7965,
            "endOffset": 7978,
            "count": 0
          },
          {
            "startOffset": 8020,
            "endOffset": 8052,
            "count": 0
          },
          {
            "startOffset": 8077,
            "endOffset": 8386,
            "count": 0
          },
          {
            "startOffset": 8416,
            "endOffset": 8445,
            "count": 0
          },
          {
            "startOffset": 8474,
            "endOffset": 8503,
            "count": 0
          },
          {
            "startOffset": 8535,
            "endOffset": 8585,
            "count": 0
          },
          {
            "startOffset": 8654,
            "endOffset": 8758,
            "count": 33
          },
          {
            "startOffset": 8701,
            "endOffset": 8752,
            "count": 0
          },
          {
            "startOffset": 8824,
            "endOffset": 8843,
            "count": 0
          },
          {
            "startOffset": 8874,
            "endOffset": 9126,
            "count": 0
          },
          {
            "startOffset": 9312,
            "endOffset": 9643,
            "count": 0
          },
          {
            "startOffset": 9722,
            "endOffset": 9759,
            "count": 0
          },
          {
            "startOffset": 9771,
            "endOffset": 9811,
            "count": 0
          },
          {
            "startOffset": 9820,
            "endOffset": 9839,
            "count": 0
          },
          {
            "startOffset": 9871,
            "endOffset": 9943,
            "count": 0
          }
        ]
      },
      {
        "functionName": "UtilityScript",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10124,
            "endOffset": 10402,
            "count": 1
          },
          {
            "startOffset": 10172,
            "endOffset": 10219,
            "count": 0
          }
        ]
      },
      {
        "functionName": "evaluate",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10405,
            "endOffset": 11089,
            "count": 11
          },
          {
            "startOffset": 10663,
            "endOffset": 10729,
            "count": 13
          },
          {
            "startOffset": 10805,
            "endOffset": 10850,
            "count": 2
          },
          {
            "startOffset": 10850,
            "endOffset": 11005,
            "count": 9
          },
          {
            "startOffset": 10912,
            "endOffset": 11005,
            "count": 0
          },
          {
            "startOffset": 11031,
            "endOffset": 11075,
            "count": 9
          },
          {
            "startOffset": 11076,
            "endOffset": 11084,
            "count": 2
          }
        ]
      },
      {
        "functionName": "jsonValue",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 11092,
            "endOffset": 11263,
            "count": 9
          },
          {
            "startOffset": 11158,
            "endOffset": 11172,
            "count": 6
          },
          {
            "startOffset": 11172,
            "endOffset": 11262,
            "count": 3
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 11220,
            "endOffset": 11257,
            "count": 3
          }
        ]
      },
      {
        "functionName": "_promiseAwareJsonValueNoThrow",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 11266,
            "endOffset": 11695,
            "count": 9
          },
          {
            "startOffset": 11469,
            "endOffset": 11497,
            "count": 3
          },
          {
            "startOffset": 11498,
            "endOffset": 11533,
            "count": 3
          },
          {
            "startOffset": 11535,
            "endOffset": 11663,
            "count": 3
          },
          {
            "startOffset": 11663,
            "endOffset": 11694,
            "count": 6
          }
        ]
      },
      {
        "functionName": "safeJson",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 11326,
            "endOffset": 11453,
            "count": 9
          },
          {
            "startOffset": 11405,
            "endOffset": 11447,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 11551,
            "endOffset": 11653,
            "count": 3
          }
        ]
      }
    ]
  },
  {
    "url": "",
    "scriptId": "65",
    "source": "((utilityScript, ...args) => utilityScript.evaluate(...args))",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 61,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1,
            "endOffset": 60,
            "count": 1
          }
        ]
      }
    ]
  },
  {
    "url": "",
    "scriptId": "66",
    "source": "(function inPagePrepareForScreenshots(screenshotStyle, hideCaret, disableAnimations, syncAnimations) {\n  if (syncAnimations) {\n    const style = document.createElement(\"style\");\n    style.textContent = \"body {}\";\n    document.head.appendChild(style);\n    document.documentElement.getBoundingClientRect();\n    style.remove();\n  }\n  if (!screenshotStyle && !hideCaret && !disableAnimations)\n    return;\n  const collectRoots = (root, roots2 = []) => {\n    roots2.push(root);\n    const walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT);\n    do {\n      const node = walker.currentNode;\n      const shadowRoot = node instanceof Element ? node.shadowRoot : null;\n      if (shadowRoot)\n        collectRoots(shadowRoot, roots2);\n    } while (walker.nextNode());\n    return roots2;\n  };\n  const roots = collectRoots(document);\n  const cleanupCallbacks = [];\n  if (screenshotStyle) {\n    for (const root of roots) {\n      const styleTag = document.createElement(\"style\");\n      styleTag.textContent = screenshotStyle;\n      if (root === document)\n        document.documentElement.append(styleTag);\n      else\n        root.append(styleTag);\n      cleanupCallbacks.push(() => {\n        styleTag.remove();\n      });\n    }\n  }\n  if (hideCaret) {\n    const elements = /* @__PURE__ */ new Map();\n    for (const root of roots) {\n      root.querySelectorAll(\"input,textarea,[contenteditable]\").forEach((element) => {\n        elements.set(element, {\n          value: element.style.getPropertyValue(\"caret-color\"),\n          priority: element.style.getPropertyPriority(\"caret-color\")\n        });\n        element.style.setProperty(\"caret-color\", \"transparent\", \"important\");\n      });\n    }\n    cleanupCallbacks.push(() => {\n      for (const [element, value] of elements)\n        element.style.setProperty(\"caret-color\", value.value, value.priority);\n    });\n  }\n  if (disableAnimations) {\n    const infiniteAnimationsToResume = /* @__PURE__ */ new Set();\n    const handleAnimations = (root) => {\n      for (const animation of root.getAnimations()) {\n        if (!animation.effect || animation.playbackRate === 0 || infiniteAnimationsToResume.has(animation))\n          continue;\n        const endTime = animation.effect.getComputedTiming().endTime;\n        if (Number.isFinite(endTime)) {\n          try {\n            animation.finish();\n          } catch (e) {\n          }\n        } else {\n          try {\n            animation.cancel();\n            infiniteAnimationsToResume.add(animation);\n          } catch (e) {\n          }\n        }\n      }\n    };\n    for (const root of roots) {\n      const handleRootAnimations = handleAnimations.bind(null, root);\n      handleRootAnimations();\n      root.addEventListener(\"transitionrun\", handleRootAnimations);\n      root.addEventListener(\"animationstart\", handleRootAnimations);\n      cleanupCallbacks.push(() => {\n        root.removeEventListener(\"transitionrun\", handleRootAnimations);\n        root.removeEventListener(\"animationstart\", handleRootAnimations);\n      });\n    }\n    cleanupCallbacks.push(() => {\n      for (const animation of infiniteAnimationsToResume) {\n        try {\n          animation.play();\n        } catch (e) {\n        }\n      }\n    });\n  }\n  window.__pwCleanupScreenshot = () => {\n    for (const cleanupCallback of cleanupCallbacks)\n      cleanupCallback();\n    delete window.__pwCleanupScreenshot;\n  };\n})(undefined, true, false, false)",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 3401,
            "count": 1
          }
        ]
      },
      {
        "functionName": "inPagePrepareForScreenshots",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1,
            "endOffset": 3369,
            "count": 1
          },
          {
            "startOffset": 125,
            "endOffset": 328,
            "count": 0
          },
          {
            "startOffset": 366,
            "endOffset": 387,
            "count": 0
          },
          {
            "startOffset": 393,
            "endOffset": 400,
            "count": 0
          },
          {
            "startOffset": 887,
            "endOffset": 1227,
            "count": 0
          },
          {
            "startOffset": 1882,
            "endOffset": 3203,
            "count": 0
          }
        ]
      },
      {
        "functionName": "collectRoots",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 424,
            "endOffset": 791,
            "count": 1
          },
          {
            "startOffset": 556,
            "endOffset": 741,
            "count": 111
          },
          {
            "startOffset": 646,
            "endOffset": 663,
            "count": 110
          },
          {
            "startOffset": 664,
            "endOffset": 670,
            "count": 1
          },
          {
            "startOffset": 702,
            "endOffset": 735,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1173,
            "endOffset": 1215,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1399,
            "endOffset": 1676,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1711,
            "endOffset": 1850,
            "count": 1
          },
          {
            "startOffset": 1774,
            "endOffset": 1844,
            "count": 0
          }
        ]
      },
      {
        "functionName": "handleAnimations",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1979,
            "endOffset": 2546,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2845,
            "endOffset": 3007,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 3042,
            "endOffset": 3197,
            "count": 0
          }
        ]
      },
      {
        "functionName": "window.__pwCleanupScreenshot",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 3237,
            "endOffset": 3366,
            "count": 1
          }
        ]
      }
    ]
  },
  {
    "url": "",
    "scriptId": "72",
    "source": "((utilityScript, ...args) => utilityScript.evaluate(...args))",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 61,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1,
            "endOffset": 60,
            "count": 1
          }
        ]
      }
    ]
  },
  {
    "url": "",
    "scriptId": "73",
    "source": "document.fonts.ready",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 20,
            "count": 1
          }
        ]
      }
    ]
  },
  {
    "url": "",
    "scriptId": "79",
    "source": "((utilityScript, ...args) => utilityScript.evaluate(...args))",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 61,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1,
            "endOffset": 60,
            "count": 1
          }
        ]
      }
    ]
  },
  {
    "url": "",
    "scriptId": "80",
    "source": "window.__pwCleanupScreenshot && window.__pwCleanupScreenshot()",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 62,
            "count": 1
          }
        ]
      }
    ]
  },
  {
    "url": "",
    "scriptId": "86",
    "source": "((utilityScript, ...args) => utilityScript.evaluate(...args))",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 61,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1,
            "endOffset": 60,
            "count": 1
          }
        ]
      }
    ]
  },
  {
    "url": "",
    "scriptId": "87",
    "source": "target => {\n    window.scrollTo(0, target);\n  }",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 47,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 47,
            "count": 1
          }
        ]
      }
    ]
  },
  {
    "url": "",
    "scriptId": "93",
    "source": "((utilityScript, ...args) => utilityScript.evaluate(...args))",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 61,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1,
            "endOffset": 60,
            "count": 1
          }
        ]
      }
    ]
  },
  {
    "url": "",
    "scriptId": "94",
    "source": "() => ({\n    scrollY: window.scrollY,\n    scrollX: window.scrollX,\n    viewportHeight: window.innerHeight,\n    viewportWidth: window.innerWidth,\n    documentHeight: document.documentElement.scrollHeight,\n    documentWidth: document.documentElement.scrollWidth,\n    scrolledPercentage: window.scrollY / (document.documentElement.scrollHeight - window.innerHeight) * 100\n  })",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 373,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 373,
            "count": 1
          }
        ]
      }
    ]
  },
  {
    "url": "",
    "scriptId": "100",
    "source": "((utilityScript, ...args) => utilityScript.evaluate(...args))",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 61,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1,
            "endOffset": 60,
            "count": 1
          }
        ]
      }
    ]
  },
  {
    "url": "",
    "scriptId": "101",
    "source": "(function inPagePrepareForScreenshots(screenshotStyle, hideCaret, disableAnimations, syncAnimations) {\n  if (syncAnimations) {\n    const style = document.createElement(\"style\");\n    style.textContent = \"body {}\";\n    document.head.appendChild(style);\n    document.documentElement.getBoundingClientRect();\n    style.remove();\n  }\n  if (!screenshotStyle && !hideCaret && !disableAnimations)\n    return;\n  const collectRoots = (root, roots2 = []) => {\n    roots2.push(root);\n    const walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT);\n    do {\n      const node = walker.currentNode;\n      const shadowRoot = node instanceof Element ? node.shadowRoot : null;\n      if (shadowRoot)\n        collectRoots(shadowRoot, roots2);\n    } while (walker.nextNode());\n    return roots2;\n  };\n  const roots = collectRoots(document);\n  const cleanupCallbacks = [];\n  if (screenshotStyle) {\n    for (const root of roots) {\n      const styleTag = document.createElement(\"style\");\n      styleTag.textContent = screenshotStyle;\n      if (root === document)\n        document.documentElement.append(styleTag);\n      else\n        root.append(styleTag);\n      cleanupCallbacks.push(() => {\n        styleTag.remove();\n      });\n    }\n  }\n  if (hideCaret) {\n    const elements = /* @__PURE__ */ new Map();\n    for (const root of roots) {\n      root.querySelectorAll(\"input,textarea,[contenteditable]\").forEach((element) => {\n        elements.set(element, {\n          value: element.style.getPropertyValue(\"caret-color\"),\n          priority: element.style.getPropertyPriority(\"caret-color\")\n        });\n        element.style.setProperty(\"caret-color\", \"transparent\", \"important\");\n      });\n    }\n    cleanupCallbacks.push(() => {\n      for (const [element, value] of elements)\n        element.style.setProperty(\"caret-color\", value.value, value.priority);\n    });\n  }\n  if (disableAnimations) {\n    const infiniteAnimationsToResume = /* @__PURE__ */ new Set();\n    const handleAnimations = (root) => {\n      for (const animation of root.getAnimations()) {\n        if (!animation.effect || animation.playbackRate === 0 || infiniteAnimationsToResume.has(animation))\n          continue;\n        const endTime = animation.effect.getComputedTiming().endTime;\n        if (Number.isFinite(endTime)) {\n          try {\n            animation.finish();\n          } catch (e) {\n          }\n        } else {\n          try {\n            animation.cancel();\n            infiniteAnimationsToResume.add(animation);\n          } catch (e) {\n          }\n        }\n      }\n    };\n    for (const root of roots) {\n      const handleRootAnimations = handleAnimations.bind(null, root);\n      handleRootAnimations();\n      root.addEventListener(\"transitionrun\", handleRootAnimations);\n      root.addEventListener(\"animationstart\", handleRootAnimations);\n      cleanupCallbacks.push(() => {\n        root.removeEventListener(\"transitionrun\", handleRootAnimations);\n        root.removeEventListener(\"animationstart\", handleRootAnimations);\n      });\n    }\n    cleanupCallbacks.push(() => {\n      for (const animation of infiniteAnimationsToResume) {\n        try {\n          animation.play();\n        } catch (e) {\n        }\n      }\n    });\n  }\n  window.__pwCleanupScreenshot = () => {\n    for (const cleanupCallback of cleanupCallbacks)\n      cleanupCallback();\n    delete window.__pwCleanupScreenshot;\n  };\n})(undefined, true, false, false)",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 3401,
            "count": 1
          }
        ]
      },
      {
        "functionName": "inPagePrepareForScreenshots",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1,
            "endOffset": 3369,
            "count": 1
          },
          {
            "startOffset": 125,
            "endOffset": 328,
            "count": 0
          },
          {
            "startOffset": 366,
            "endOffset": 387,
            "count": 0
          },
          {
            "startOffset": 393,
            "endOffset": 400,
            "count": 0
          },
          {
            "startOffset": 887,
            "endOffset": 1227,
            "count": 0
          },
          {
            "startOffset": 1882,
            "endOffset": 3203,
            "count": 0
          }
        ]
      },
      {
        "functionName": "collectRoots",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 424,
            "endOffset": 791,
            "count": 1
          },
          {
            "startOffset": 556,
            "endOffset": 741,
            "count": 111
          },
          {
            "startOffset": 646,
            "endOffset": 663,
            "count": 110
          },
          {
            "startOffset": 664,
            "endOffset": 670,
            "count": 1
          },
          {
            "startOffset": 702,
            "endOffset": 735,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1173,
            "endOffset": 1215,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1399,
            "endOffset": 1676,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1711,
            "endOffset": 1850,
            "count": 1
          },
          {
            "startOffset": 1774,
            "endOffset": 1844,
            "count": 0
          }
        ]
      },
      {
        "functionName": "handleAnimations",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1979,
            "endOffset": 2546,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2845,
            "endOffset": 3007,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 3042,
            "endOffset": 3197,
            "count": 0
          }
        ]
      },
      {
        "functionName": "window.__pwCleanupScreenshot",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 3237,
            "endOffset": 3366,
            "count": 1
          }
        ]
      }
    ]
  },
  {
    "url": "",
    "scriptId": "107",
    "source": "((utilityScript, ...args) => utilityScript.evaluate(...args))",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 61,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1,
            "endOffset": 60,
            "count": 1
          }
        ]
      }
    ]
  },
  {
    "url": "",
    "scriptId": "108",
    "source": "document.fonts.ready",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 20,
            "count": 1
          }
        ]
      }
    ]
  },
  {
    "url": "",
    "scriptId": "114",
    "source": "((utilityScript, ...args) => utilityScript.evaluate(...args))",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 61,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1,
            "endOffset": 60,
            "count": 1
          }
        ]
      }
    ]
  },
  {
    "url": "",
    "scriptId": "115",
    "source": "window.__pwCleanupScreenshot && window.__pwCleanupScreenshot()",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 62,
            "count": 1
          }
        ]
      }
    ]
  },
  {
    "url": "",
    "scriptId": "121",
    "source": "((utilityScript, ...args) => utilityScript.evaluate(...args))",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 61,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1,
            "endOffset": 60,
            "count": 1
          }
        ]
      }
    ]
  },
  {
    "url": "",
    "scriptId": "122",
    "source": "() => {\n    const header = document.querySelector('#sticky-header-container');\n    const hero = document.querySelector('.heroTitle');\n    const scrollIndicator = document.querySelector('[data-testid=\"scroll-indicator\"]');\n    return {\n      headerVisible: header ? window.getComputedStyle(header).opacity !== '0' : false,\n      heroVisible: hero ? window.getComputedStyle(hero).opacity !== '0' : false,\n      scrollIndicatorVisible: scrollIndicator ? window.getComputedStyle(scrollIndicator).display !== 'none' : false\n    };\n  }",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 529,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 529,
            "count": 1
          },
          {
            "startOffset": 313,
            "endOffset": 320,
            "count": 0
          },
          {
            "startOffset": 394,
            "endOffset": 401,
            "count": 0
          },
          {
            "startOffset": 449,
            "endOffset": 510,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "",
    "scriptId": "128",
    "source": "((utilityScript, ...args) => utilityScript.evaluate(...args))",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 61,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1,
            "endOffset": 60,
            "count": 1
          }
        ]
      }
    ]
  },
  {
    "url": "",
    "scriptId": "129",
    "source": "(function inPagePrepareForScreenshots(screenshotStyle, hideCaret, disableAnimations, syncAnimations) {\n  if (syncAnimations) {\n    const style = document.createElement(\"style\");\n    style.textContent = \"body {}\";\n    document.head.appendChild(style);\n    document.documentElement.getBoundingClientRect();\n    style.remove();\n  }\n  if (!screenshotStyle && !hideCaret && !disableAnimations)\n    return;\n  const collectRoots = (root, roots2 = []) => {\n    roots2.push(root);\n    const walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT);\n    do {\n      const node = walker.currentNode;\n      const shadowRoot = node instanceof Element ? node.shadowRoot : null;\n      if (shadowRoot)\n        collectRoots(shadowRoot, roots2);\n    } while (walker.nextNode());\n    return roots2;\n  };\n  const roots = collectRoots(document);\n  const cleanupCallbacks = [];\n  if (screenshotStyle) {\n    for (const root of roots) {\n      const styleTag = document.createElement(\"style\");\n      styleTag.textContent = screenshotStyle;\n      if (root === document)\n        document.documentElement.append(styleTag);\n      else\n        root.append(styleTag);\n      cleanupCallbacks.push(() => {\n        styleTag.remove();\n      });\n    }\n  }\n  if (hideCaret) {\n    const elements = /* @__PURE__ */ new Map();\n    for (const root of roots) {\n      root.querySelectorAll(\"input,textarea,[contenteditable]\").forEach((element) => {\n        elements.set(element, {\n          value: element.style.getPropertyValue(\"caret-color\"),\n          priority: element.style.getPropertyPriority(\"caret-color\")\n        });\n        element.style.setProperty(\"caret-color\", \"transparent\", \"important\");\n      });\n    }\n    cleanupCallbacks.push(() => {\n      for (const [element, value] of elements)\n        element.style.setProperty(\"caret-color\", value.value, value.priority);\n    });\n  }\n  if (disableAnimations) {\n    const infiniteAnimationsToResume = /* @__PURE__ */ new Set();\n    const handleAnimations = (root) => {\n      for (const animation of root.getAnimations()) {\n        if (!animation.effect || animation.playbackRate === 0 || infiniteAnimationsToResume.has(animation))\n          continue;\n        const endTime = animation.effect.getComputedTiming().endTime;\n        if (Number.isFinite(endTime)) {\n          try {\n            animation.finish();\n          } catch (e) {\n          }\n        } else {\n          try {\n            animation.cancel();\n            infiniteAnimationsToResume.add(animation);\n          } catch (e) {\n          }\n        }\n      }\n    };\n    for (const root of roots) {\n      const handleRootAnimations = handleAnimations.bind(null, root);\n      handleRootAnimations();\n      root.addEventListener(\"transitionrun\", handleRootAnimations);\n      root.addEventListener(\"animationstart\", handleRootAnimations);\n      cleanupCallbacks.push(() => {\n        root.removeEventListener(\"transitionrun\", handleRootAnimations);\n        root.removeEventListener(\"animationstart\", handleRootAnimations);\n      });\n    }\n    cleanupCallbacks.push(() => {\n      for (const animation of infiniteAnimationsToResume) {\n        try {\n          animation.play();\n        } catch (e) {\n        }\n      }\n    });\n  }\n  window.__pwCleanupScreenshot = () => {\n    for (const cleanupCallback of cleanupCallbacks)\n      cleanupCallback();\n    delete window.__pwCleanupScreenshot;\n  };\n})(undefined, true, false, false)",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 3401,
            "count": 1
          }
        ]
      },
      {
        "functionName": "inPagePrepareForScreenshots",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1,
            "endOffset": 3369,
            "count": 1
          },
          {
            "startOffset": 125,
            "endOffset": 328,
            "count": 0
          },
          {
            "startOffset": 366,
            "endOffset": 387,
            "count": 0
          },
          {
            "startOffset": 393,
            "endOffset": 400,
            "count": 0
          },
          {
            "startOffset": 887,
            "endOffset": 1227,
            "count": 0
          },
          {
            "startOffset": 1882,
            "endOffset": 3203,
            "count": 0
          }
        ]
      },
      {
        "functionName": "collectRoots",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 424,
            "endOffset": 791,
            "count": 1
          },
          {
            "startOffset": 556,
            "endOffset": 741,
            "count": 111
          },
          {
            "startOffset": 646,
            "endOffset": 663,
            "count": 110
          },
          {
            "startOffset": 664,
            "endOffset": 670,
            "count": 1
          },
          {
            "startOffset": 702,
            "endOffset": 735,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1173,
            "endOffset": 1215,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1399,
            "endOffset": 1676,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1711,
            "endOffset": 1850,
            "count": 1
          },
          {
            "startOffset": 1774,
            "endOffset": 1844,
            "count": 0
          }
        ]
      },
      {
        "functionName": "handleAnimations",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1979,
            "endOffset": 2546,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2845,
            "endOffset": 3007,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 3042,
            "endOffset": 3197,
            "count": 0
          }
        ]
      },
      {
        "functionName": "window.__pwCleanupScreenshot",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 3237,
            "endOffset": 3366,
            "count": 1
          }
        ]
      }
    ]
  },
  {
    "url": "",
    "scriptId": "135",
    "source": "((utilityScript, ...args) => utilityScript.evaluate(...args))",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 61,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1,
            "endOffset": 60,
            "count": 1
          }
        ]
      }
    ]
  },
  {
    "url": "",
    "scriptId": "136",
    "source": "document.fonts.ready",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 20,
            "count": 1
          }
        ]
      }
    ]
  },
  {
    "url": "",
    "scriptId": "137",
    "source": "\n        (() => {\n        const module = {};\n        \nvar __commonJS = obj => {\n  let required = false;\n  let result;\n  return function __require() {\n    if (!required) {\n      required = true;\n      let fn;\n      for (const name in obj) { fn = obj[name]; break; }\n      const module = { exports: {} };\n      fn(module.exports, module);\n      result = module.exports;\n    }\n    return result;\n  }\n};\nvar __export = (target, all) => {for (var name in all) target[name] = all[name];};\nvar __toESM = mod => ({ ...mod, 'default': mod });\nvar __toCommonJS = mod => ({ ...mod, __esModule: true });\n\n\n// packages/injected/src/injectedScript.ts\nvar injectedScript_exports = {};\n__export(injectedScript_exports, {\n  InjectedScript: () => InjectedScript\n});\nmodule.exports = __toCommonJS(injectedScript_exports);\n\n// packages/playwright-core/src/utils/isomorphic/ariaSnapshot.ts\nfunction parseAriaSnapshot(yaml, text, options = {}) {\n  var _a;\n  const lineCounter = new yaml.LineCounter();\n  const parseOptions = {\n    keepSourceTokens: true,\n    lineCounter,\n    ...options\n  };\n  const yamlDoc = yaml.parseDocument(text, parseOptions);\n  const errors = [];\n  const convertRange = (range) => {\n    return [lineCounter.linePos(range[0]), lineCounter.linePos(range[1])];\n  };\n  const addError = (error) => {\n    errors.push({\n      message: error.message,\n      range: [lineCounter.linePos(error.pos[0]), lineCounter.linePos(error.pos[1])]\n    });\n  };\n  const convertSeq = (container, seq) => {\n    for (const item of seq.items) {\n      const itemIsString = item instanceof yaml.Scalar && typeof item.value === \"string\";\n      if (itemIsString) {\n        const childNode = KeyParser.parse(item, parseOptions, errors);\n        if (childNode) {\n          container.children = container.children || [];\n          container.children.push(childNode);\n        }\n        continue;\n      }\n      const itemIsMap = item instanceof yaml.YAMLMap;\n      if (itemIsMap) {\n        convertMap(container, item);\n        continue;\n      }\n      errors.push({\n        message: \"Sequence items should be strings or maps\",\n        range: convertRange(item.range || seq.range)\n      });\n    }\n  };\n  const convertMap = (container, map) => {\n    var _a2;\n    for (const entry of map.items) {\n      container.children = container.children || [];\n      const keyIsString = entry.key instanceof yaml.Scalar && typeof entry.key.value === \"string\";\n      if (!keyIsString) {\n        errors.push({\n          message: \"Only string keys are supported\",\n          range: convertRange(entry.key.range || map.range)\n        });\n        continue;\n      }\n      const key = entry.key;\n      const value = entry.value;\n      if (key.value === \"text\") {\n        const valueIsString = value instanceof yaml.Scalar && typeof value.value === \"string\";\n        if (!valueIsString) {\n          errors.push({\n            message: \"Text value should be a string\",\n            range: convertRange(entry.value.range || map.range)\n          });\n          continue;\n        }\n        container.children.push({\n          kind: \"text\",\n          text: valueOrRegex(value.value)\n        });\n        continue;\n      }\n      if (key.value === \"/children\") {\n        const valueIsString = value instanceof yaml.Scalar && typeof value.value === \"string\";\n        if (!valueIsString || value.value !== \"contain\" && value.value !== \"equal\" && value.value !== \"deep-equal\") {\n          errors.push({\n            message: 'Strict value should be \"contain\", \"equal\" or \"deep-equal\"',\n            range: convertRange(entry.value.range || map.range)\n          });\n          continue;\n        }\n        container.containerMode = value.value;\n        continue;\n      }\n      if (key.value.startsWith(\"/\")) {\n        const valueIsString = value instanceof yaml.Scalar && typeof value.value === \"string\";\n        if (!valueIsString) {\n          errors.push({\n            message: \"Property value should be a string\",\n            range: convertRange(entry.value.range || map.range)\n          });\n          continue;\n        }\n        container.props = (_a2 = container.props) != null ? _a2 : {};\n        container.props[key.value.slice(1)] = valueOrRegex(value.value);\n        continue;\n      }\n      const childNode = KeyParser.parse(key, parseOptions, errors);\n      if (!childNode)\n        continue;\n      const valueIsScalar = value instanceof yaml.Scalar;\n      if (valueIsScalar) {\n        const type = typeof value.value;\n        if (type !== \"string\" && type !== \"number\" && type !== \"boolean\") {\n          errors.push({\n            message: \"Node value should be a string or a sequence\",\n            range: convertRange(entry.value.range || map.range)\n          });\n          continue;\n        }\n        container.children.push({\n          ...childNode,\n          children: [{\n            kind: \"text\",\n            text: valueOrRegex(String(value.value))\n          }]\n        });\n        continue;\n      }\n      const valueIsSequence = value instanceof yaml.YAMLSeq;\n      if (valueIsSequence) {\n        container.children.push(childNode);\n        convertSeq(childNode, value);\n        continue;\n      }\n      errors.push({\n        message: \"Map values should be strings or sequences\",\n        range: convertRange(entry.value.range || map.range)\n      });\n    }\n  };\n  const fragment = { kind: \"role\", role: \"fragment\" };\n  yamlDoc.errors.forEach(addError);\n  if (errors.length)\n    return { errors, fragment };\n  if (!(yamlDoc.contents instanceof yaml.YAMLSeq)) {\n    errors.push({\n      message: 'Aria snapshot must be a YAML sequence, elements starting with \" -\"',\n      range: yamlDoc.contents ? convertRange(yamlDoc.contents.range) : [{ line: 0, col: 0 }, { line: 0, col: 0 }]\n    });\n  }\n  if (errors.length)\n    return { errors, fragment };\n  convertSeq(fragment, yamlDoc.contents);\n  if (errors.length)\n    return { errors, fragment: emptyFragment };\n  if (((_a = fragment.children) == null ? void 0 : _a.length) === 1)\n    return { fragment: fragment.children[0], errors };\n  return { fragment, errors };\n}\nvar emptyFragment = { kind: \"role\", role: \"fragment\" };\nfunction normalizeWhitespace(text) {\n  return text.replace(/[\\u200b\\u00ad]/g, \"\").replace(/[\\r\\n\\s\\t]+/g, \" \").trim();\n}\nfunction valueOrRegex(value) {\n  return value.startsWith(\"/\") && value.endsWith(\"/\") && value.length > 1 ? { pattern: value.slice(1, -1) } : normalizeWhitespace(value);\n}\nvar KeyParser = class _KeyParser {\n  static parse(text, options, errors) {\n    try {\n      return new _KeyParser(text.value)._parse();\n    } catch (e) {\n      if (e instanceof ParserError) {\n        const message = options.prettyErrors === false ? e.message : e.message + \":\\n\\n\" + text.value + \"\\n\" + \" \".repeat(e.pos) + \"^\\n\";\n        errors.push({\n          message,\n          range: [options.lineCounter.linePos(text.range[0]), options.lineCounter.linePos(text.range[0] + e.pos)]\n        });\n        return null;\n      }\n      throw e;\n    }\n  }\n  constructor(input) {\n    this._input = input;\n    this._pos = 0;\n    this._length = input.length;\n  }\n  _peek() {\n    return this._input[this._pos] || \"\";\n  }\n  _next() {\n    if (this._pos < this._length)\n      return this._input[this._pos++];\n    return null;\n  }\n  _eof() {\n    return this._pos >= this._length;\n  }\n  _isWhitespace() {\n    return !this._eof() && /\\s/.test(this._peek());\n  }\n  _skipWhitespace() {\n    while (this._isWhitespace())\n      this._pos++;\n  }\n  _readIdentifier(type) {\n    if (this._eof())\n      this._throwError(`Unexpected end of input when expecting ${type}`);\n    const start = this._pos;\n    while (!this._eof() && /[a-zA-Z]/.test(this._peek()))\n      this._pos++;\n    return this._input.slice(start, this._pos);\n  }\n  _readString() {\n    let result = \"\";\n    let escaped = false;\n    while (!this._eof()) {\n      const ch = this._next();\n      if (escaped) {\n        result += ch;\n        escaped = false;\n      } else if (ch === \"\\\\\") {\n        escaped = true;\n      } else if (ch === '\"') {\n        return result;\n      } else {\n        result += ch;\n      }\n    }\n    this._throwError(\"Unterminated string\");\n  }\n  _throwError(message, offset = 0) {\n    throw new ParserError(message, offset || this._pos);\n  }\n  _readRegex() {\n    let result = \"\";\n    let escaped = false;\n    let insideClass = false;\n    while (!this._eof()) {\n      const ch = this._next();\n      if (escaped) {\n        result += ch;\n        escaped = false;\n      } else if (ch === \"\\\\\") {\n        escaped = true;\n        result += ch;\n      } else if (ch === \"/\" && !insideClass) {\n        return { pattern: result };\n      } else if (ch === \"[\") {\n        insideClass = true;\n        result += ch;\n      } else if (ch === \"]\" && insideClass) {\n        result += ch;\n        insideClass = false;\n      } else {\n        result += ch;\n      }\n    }\n    this._throwError(\"Unterminated regex\");\n  }\n  _readStringOrRegex() {\n    const ch = this._peek();\n    if (ch === '\"') {\n      this._next();\n      return normalizeWhitespace(this._readString());\n    }\n    if (ch === \"/\") {\n      this._next();\n      return this._readRegex();\n    }\n    return null;\n  }\n  _readAttributes(result) {\n    let errorPos = this._pos;\n    while (true) {\n      this._skipWhitespace();\n      if (this._peek() === \"[\") {\n        this._next();\n        this._skipWhitespace();\n        errorPos = this._pos;\n        const flagName = this._readIdentifier(\"attribute\");\n        this._skipWhitespace();\n        let flagValue = \"\";\n        if (this._peek() === \"=\") {\n          this._next();\n          this._skipWhitespace();\n          errorPos = this._pos;\n          while (this._peek() !== \"]\" && !this._isWhitespace() && !this._eof())\n            flagValue += this._next();\n        }\n        this._skipWhitespace();\n        if (this._peek() !== \"]\")\n          this._throwError(\"Expected ]\");\n        this._next();\n        this._applyAttribute(result, flagName, flagValue || \"true\", errorPos);\n      } else {\n        break;\n      }\n    }\n  }\n  _parse() {\n    this._skipWhitespace();\n    const role = this._readIdentifier(\"role\");\n    this._skipWhitespace();\n    const name = this._readStringOrRegex() || \"\";\n    const result = { kind: \"role\", role, name };\n    this._readAttributes(result);\n    this._skipWhitespace();\n    if (!this._eof())\n      this._throwError(\"Unexpected input\");\n    return result;\n  }\n  _applyAttribute(node, key, value, errorPos) {\n    if (key === \"checked\") {\n      this._assert(value === \"true\" || value === \"false\" || value === \"mixed\", 'Value of \"checked\" attribute must be a boolean or \"mixed\"', errorPos);\n      node.checked = value === \"true\" ? true : value === \"false\" ? false : \"mixed\";\n      return;\n    }\n    if (key === \"disabled\") {\n      this._assert(value === \"true\" || value === \"false\", 'Value of \"disabled\" attribute must be a boolean', errorPos);\n      node.disabled = value === \"true\";\n      return;\n    }\n    if (key === \"expanded\") {\n      this._assert(value === \"true\" || value === \"false\", 'Value of \"expanded\" attribute must be a boolean', errorPos);\n      node.expanded = value === \"true\";\n      return;\n    }\n    if (key === \"level\") {\n      this._assert(!isNaN(Number(value)), 'Value of \"level\" attribute must be a number', errorPos);\n      node.level = Number(value);\n      return;\n    }\n    if (key === \"pressed\") {\n      this._assert(value === \"true\" || value === \"false\" || value === \"mixed\", 'Value of \"pressed\" attribute must be a boolean or \"mixed\"', errorPos);\n      node.pressed = value === \"true\" ? true : value === \"false\" ? false : \"mixed\";\n      return;\n    }\n    if (key === \"selected\") {\n      this._assert(value === \"true\" || value === \"false\", 'Value of \"selected\" attribute must be a boolean', errorPos);\n      node.selected = value === \"true\";\n      return;\n    }\n    this._assert(false, `Unsupported attribute [${key}]`, errorPos);\n  }\n  _assert(value, message, valuePos) {\n    if (!value)\n      this._throwError(message || \"Assertion error\", valuePos);\n  }\n};\nvar ParserError = class extends Error {\n  constructor(message, pos) {\n    super(message);\n    this.pos = pos;\n  }\n};\n\n// packages/playwright-core/src/utils/isomorphic/builtins.ts\nfunction builtins(global) {\n  var _a, _b, _c, _d, _e, _f, _g, _h, _i;\n  global = global != null ? global : globalThis;\n  if (!global[\"__playwright_builtins__\"]) {\n    const builtins2 = {\n      setTimeout: (_a = global.setTimeout) == null ? void 0 : _a.bind(global),\n      clearTimeout: (_b = global.clearTimeout) == null ? void 0 : _b.bind(global),\n      setInterval: (_c = global.setInterval) == null ? void 0 : _c.bind(global),\n      clearInterval: (_d = global.clearInterval) == null ? void 0 : _d.bind(global),\n      requestAnimationFrame: (_e = global.requestAnimationFrame) == null ? void 0 : _e.bind(global),\n      cancelAnimationFrame: (_f = global.cancelAnimationFrame) == null ? void 0 : _f.bind(global),\n      requestIdleCallback: (_g = global.requestIdleCallback) == null ? void 0 : _g.bind(global),\n      cancelIdleCallback: (_h = global.cancelIdleCallback) == null ? void 0 : _h.bind(global),\n      performance: global.performance,\n      eval: (_i = global.eval) == null ? void 0 : _i.bind(global),\n      Intl: global.Intl,\n      Date: global.Date,\n      Map: global.Map,\n      Set: global.Set\n    };\n    Object.defineProperty(global, \"__playwright_builtins__\", { value: builtins2, configurable: false, enumerable: false, writable: false });\n  }\n  return global[\"__playwright_builtins__\"];\n}\nvar instance = builtins();\nvar setTimeout = instance.setTimeout;\nvar clearTimeout = instance.clearTimeout;\nvar setInterval = instance.setInterval;\nvar clearInterval = instance.clearInterval;\nvar requestAnimationFrame = instance.requestAnimationFrame;\nvar cancelAnimationFrame = instance.cancelAnimationFrame;\nvar requestIdleCallback = instance.requestIdleCallback;\nvar cancelIdleCallback = instance.cancelIdleCallback;\nvar performance = instance.performance;\nvar Intl = instance.Intl;\nvar Date = instance.Date;\nvar Map = instance.Map;\nvar Set = instance.Set;\n\n// packages/playwright-core/src/utils/isomorphic/cssTokenizer.ts\nvar between = function(num, first, last) {\n  return num >= first && num <= last;\n};\nfunction digit(code) {\n  return between(code, 48, 57);\n}\nfunction hexdigit(code) {\n  return digit(code) || between(code, 65, 70) || between(code, 97, 102);\n}\nfunction uppercaseletter(code) {\n  return between(code, 65, 90);\n}\nfunction lowercaseletter(code) {\n  return between(code, 97, 122);\n}\nfunction letter(code) {\n  return uppercaseletter(code) || lowercaseletter(code);\n}\nfunction nonascii(code) {\n  return code >= 128;\n}\nfunction namestartchar(code) {\n  return letter(code) || nonascii(code) || code === 95;\n}\nfunction namechar(code) {\n  return namestartchar(code) || digit(code) || code === 45;\n}\nfunction nonprintable(code) {\n  return between(code, 0, 8) || code === 11 || between(code, 14, 31) || code === 127;\n}\nfunction newline(code) {\n  return code === 10;\n}\nfunction whitespace(code) {\n  return newline(code) || code === 9 || code === 32;\n}\nvar maximumallowedcodepoint = 1114111;\nvar InvalidCharacterError = class extends Error {\n  constructor(message) {\n    super(message);\n    this.name = \"InvalidCharacterError\";\n  }\n};\nfunction preprocess(str) {\n  const codepoints = [];\n  for (let i = 0; i < str.length; i++) {\n    let code = str.charCodeAt(i);\n    if (code === 13 && str.charCodeAt(i + 1) === 10) {\n      code = 10;\n      i++;\n    }\n    if (code === 13 || code === 12)\n      code = 10;\n    if (code === 0)\n      code = 65533;\n    if (between(code, 55296, 56319) && between(str.charCodeAt(i + 1), 56320, 57343)) {\n      const lead = code - 55296;\n      const trail = str.charCodeAt(i + 1) - 56320;\n      code = Math.pow(2, 16) + lead * Math.pow(2, 10) + trail;\n      i++;\n    }\n    codepoints.push(code);\n  }\n  return codepoints;\n}\nfunction stringFromCode(code) {\n  if (code <= 65535)\n    return String.fromCharCode(code);\n  code -= Math.pow(2, 16);\n  const lead = Math.floor(code / Math.pow(2, 10)) + 55296;\n  const trail = code % Math.pow(2, 10) + 56320;\n  return String.fromCharCode(lead) + String.fromCharCode(trail);\n}\nfunction tokenize(str1) {\n  const str = preprocess(str1);\n  let i = -1;\n  const tokens = [];\n  let code;\n  let line = 0;\n  let column = 0;\n  let lastLineLength = 0;\n  const incrLineno = function() {\n    line += 1;\n    lastLineLength = column;\n    column = 0;\n  };\n  const locStart = { line, column };\n  const codepoint = function(i2) {\n    if (i2 >= str.length)\n      return -1;\n    return str[i2];\n  };\n  const next = function(num) {\n    if (num === void 0)\n      num = 1;\n    if (num > 3)\n      throw \"Spec Error: no more than three codepoints of lookahead.\";\n    return codepoint(i + num);\n  };\n  const consume = function(num) {\n    if (num === void 0)\n      num = 1;\n    i += num;\n    code = codepoint(i);\n    if (newline(code))\n      incrLineno();\n    else\n      column += num;\n    return true;\n  };\n  const reconsume = function() {\n    i -= 1;\n    if (newline(code)) {\n      line -= 1;\n      column = lastLineLength;\n    } else {\n      column -= 1;\n    }\n    locStart.line = line;\n    locStart.column = column;\n    return true;\n  };\n  const eof = function(codepoint2) {\n    if (codepoint2 === void 0)\n      codepoint2 = code;\n    return codepoint2 === -1;\n  };\n  const donothing = function() {\n  };\n  const parseerror = function() {\n  };\n  const consumeAToken = function() {\n    consumeComments();\n    consume();\n    if (whitespace(code)) {\n      while (whitespace(next()))\n        consume();\n      return new WhitespaceToken();\n    } else if (code === 34) {\n      return consumeAStringToken();\n    } else if (code === 35) {\n      if (namechar(next()) || areAValidEscape(next(1), next(2))) {\n        const token = new HashToken(\"\");\n        if (wouldStartAnIdentifier(next(1), next(2), next(3)))\n          token.type = \"id\";\n        token.value = consumeAName();\n        return token;\n      } else {\n        return new DelimToken(code);\n      }\n    } else if (code === 36) {\n      if (next() === 61) {\n        consume();\n        return new SuffixMatchToken();\n      } else {\n        return new DelimToken(code);\n      }\n    } else if (code === 39) {\n      return consumeAStringToken();\n    } else if (code === 40) {\n      return new OpenParenToken();\n    } else if (code === 41) {\n      return new CloseParenToken();\n    } else if (code === 42) {\n      if (next() === 61) {\n        consume();\n        return new SubstringMatchToken();\n      } else {\n        return new DelimToken(code);\n      }\n    } else if (code === 43) {\n      if (startsWithANumber()) {\n        reconsume();\n        return consumeANumericToken();\n      } else {\n        return new DelimToken(code);\n      }\n    } else if (code === 44) {\n      return new CommaToken();\n    } else if (code === 45) {\n      if (startsWithANumber()) {\n        reconsume();\n        return consumeANumericToken();\n      } else if (next(1) === 45 && next(2) === 62) {\n        consume(2);\n        return new CDCToken();\n      } else if (startsWithAnIdentifier()) {\n        reconsume();\n        return consumeAnIdentlikeToken();\n      } else {\n        return new DelimToken(code);\n      }\n    } else if (code === 46) {\n      if (startsWithANumber()) {\n        reconsume();\n        return consumeANumericToken();\n      } else {\n        return new DelimToken(code);\n      }\n    } else if (code === 58) {\n      return new ColonToken();\n    } else if (code === 59) {\n      return new SemicolonToken();\n    } else if (code === 60) {\n      if (next(1) === 33 && next(2) === 45 && next(3) === 45) {\n        consume(3);\n        return new CDOToken();\n      } else {\n        return new DelimToken(code);\n      }\n    } else if (code === 64) {\n      if (wouldStartAnIdentifier(next(1), next(2), next(3)))\n        return new AtKeywordToken(consumeAName());\n      else\n        return new DelimToken(code);\n    } else if (code === 91) {\n      return new OpenSquareToken();\n    } else if (code === 92) {\n      if (startsWithAValidEscape()) {\n        reconsume();\n        return consumeAnIdentlikeToken();\n      } else {\n        parseerror();\n        return new DelimToken(code);\n      }\n    } else if (code === 93) {\n      return new CloseSquareToken();\n    } else if (code === 94) {\n      if (next() === 61) {\n        consume();\n        return new PrefixMatchToken();\n      } else {\n        return new DelimToken(code);\n      }\n    } else if (code === 123) {\n      return new OpenCurlyToken();\n    } else if (code === 124) {\n      if (next() === 61) {\n        consume();\n        return new DashMatchToken();\n      } else if (next() === 124) {\n        consume();\n        return new ColumnToken();\n      } else {\n        return new DelimToken(code);\n      }\n    } else if (code === 125) {\n      return new CloseCurlyToken();\n    } else if (code === 126) {\n      if (next() === 61) {\n        consume();\n        return new IncludeMatchToken();\n      } else {\n        return new DelimToken(code);\n      }\n    } else if (digit(code)) {\n      reconsume();\n      return consumeANumericToken();\n    } else if (namestartchar(code)) {\n      reconsume();\n      return consumeAnIdentlikeToken();\n    } else if (eof()) {\n      return new EOFToken();\n    } else {\n      return new DelimToken(code);\n    }\n  };\n  const consumeComments = function() {\n    while (next(1) === 47 && next(2) === 42) {\n      consume(2);\n      while (true) {\n        consume();\n        if (code === 42 && next() === 47) {\n          consume();\n          break;\n        } else if (eof()) {\n          parseerror();\n          return;\n        }\n      }\n    }\n  };\n  const consumeANumericToken = function() {\n    const num = consumeANumber();\n    if (wouldStartAnIdentifier(next(1), next(2), next(3))) {\n      const token = new DimensionToken();\n      token.value = num.value;\n      token.repr = num.repr;\n      token.type = num.type;\n      token.unit = consumeAName();\n      return token;\n    } else if (next() === 37) {\n      consume();\n      const token = new PercentageToken();\n      token.value = num.value;\n      token.repr = num.repr;\n      return token;\n    } else {\n      const token = new NumberToken();\n      token.value = num.value;\n      token.repr = num.repr;\n      token.type = num.type;\n      return token;\n    }\n  };\n  const consumeAnIdentlikeToken = function() {\n    const str2 = consumeAName();\n    if (str2.toLowerCase() === \"url\" && next() === 40) {\n      consume();\n      while (whitespace(next(1)) && whitespace(next(2)))\n        consume();\n      if (next() === 34 || next() === 39)\n        return new FunctionToken(str2);\n      else if (whitespace(next()) && (next(2) === 34 || next(2) === 39))\n        return new FunctionToken(str2);\n      else\n        return consumeAURLToken();\n    } else if (next() === 40) {\n      consume();\n      return new FunctionToken(str2);\n    } else {\n      return new IdentToken(str2);\n    }\n  };\n  const consumeAStringToken = function(endingCodePoint) {\n    if (endingCodePoint === void 0)\n      endingCodePoint = code;\n    let string = \"\";\n    while (consume()) {\n      if (code === endingCodePoint || eof()) {\n        return new StringToken(string);\n      } else if (newline(code)) {\n        parseerror();\n        reconsume();\n        return new BadStringToken();\n      } else if (code === 92) {\n        if (eof(next()))\n          donothing();\n        else if (newline(next()))\n          consume();\n        else\n          string += stringFromCode(consumeEscape());\n      } else {\n        string += stringFromCode(code);\n      }\n    }\n    throw new Error(\"Internal error\");\n  };\n  const consumeAURLToken = function() {\n    const token = new URLToken(\"\");\n    while (whitespace(next()))\n      consume();\n    if (eof(next()))\n      return token;\n    while (consume()) {\n      if (code === 41 || eof()) {\n        return token;\n      } else if (whitespace(code)) {\n        while (whitespace(next()))\n          consume();\n        if (next() === 41 || eof(next())) {\n          consume();\n          return token;\n        } else {\n          consumeTheRemnantsOfABadURL();\n          return new BadURLToken();\n        }\n      } else if (code === 34 || code === 39 || code === 40 || nonprintable(code)) {\n        parseerror();\n        consumeTheRemnantsOfABadURL();\n        return new BadURLToken();\n      } else if (code === 92) {\n        if (startsWithAValidEscape()) {\n          token.value += stringFromCode(consumeEscape());\n        } else {\n          parseerror();\n          consumeTheRemnantsOfABadURL();\n          return new BadURLToken();\n        }\n      } else {\n        token.value += stringFromCode(code);\n      }\n    }\n    throw new Error(\"Internal error\");\n  };\n  const consumeEscape = function() {\n    consume();\n    if (hexdigit(code)) {\n      const digits = [code];\n      for (let total = 0; total < 5; total++) {\n        if (hexdigit(next())) {\n          consume();\n          digits.push(code);\n        } else {\n          break;\n        }\n      }\n      if (whitespace(next()))\n        consume();\n      let value = parseInt(digits.map(function(x) {\n        return String.fromCharCode(x);\n      }).join(\"\"), 16);\n      if (value > maximumallowedcodepoint)\n        value = 65533;\n      return value;\n    } else if (eof()) {\n      return 65533;\n    } else {\n      return code;\n    }\n  };\n  const areAValidEscape = function(c1, c2) {\n    if (c1 !== 92)\n      return false;\n    if (newline(c2))\n      return false;\n    return true;\n  };\n  const startsWithAValidEscape = function() {\n    return areAValidEscape(code, next());\n  };\n  const wouldStartAnIdentifier = function(c1, c2, c3) {\n    if (c1 === 45)\n      return namestartchar(c2) || c2 === 45 || areAValidEscape(c2, c3);\n    else if (namestartchar(c1))\n      return true;\n    else if (c1 === 92)\n      return areAValidEscape(c1, c2);\n    else\n      return false;\n  };\n  const startsWithAnIdentifier = function() {\n    return wouldStartAnIdentifier(code, next(1), next(2));\n  };\n  const wouldStartANumber = function(c1, c2, c3) {\n    if (c1 === 43 || c1 === 45) {\n      if (digit(c2))\n        return true;\n      if (c2 === 46 && digit(c3))\n        return true;\n      return false;\n    } else if (c1 === 46) {\n      if (digit(c2))\n        return true;\n      return false;\n    } else if (digit(c1)) {\n      return true;\n    } else {\n      return false;\n    }\n  };\n  const startsWithANumber = function() {\n    return wouldStartANumber(code, next(1), next(2));\n  };\n  const consumeAName = function() {\n    let result = \"\";\n    while (consume()) {\n      if (namechar(code)) {\n        result += stringFromCode(code);\n      } else if (startsWithAValidEscape()) {\n        result += stringFromCode(consumeEscape());\n      } else {\n        reconsume();\n        return result;\n      }\n    }\n    throw new Error(\"Internal parse error\");\n  };\n  const consumeANumber = function() {\n    let repr = \"\";\n    let type = \"integer\";\n    if (next() === 43 || next() === 45) {\n      consume();\n      repr += stringFromCode(code);\n    }\n    while (digit(next())) {\n      consume();\n      repr += stringFromCode(code);\n    }\n    if (next(1) === 46 && digit(next(2))) {\n      consume();\n      repr += stringFromCode(code);\n      consume();\n      repr += stringFromCode(code);\n      type = \"number\";\n      while (digit(next())) {\n        consume();\n        repr += stringFromCode(code);\n      }\n    }\n    const c1 = next(1), c2 = next(2), c3 = next(3);\n    if ((c1 === 69 || c1 === 101) && digit(c2)) {\n      consume();\n      repr += stringFromCode(code);\n      consume();\n      repr += stringFromCode(code);\n      type = \"number\";\n      while (digit(next())) {\n        consume();\n        repr += stringFromCode(code);\n      }\n    } else if ((c1 === 69 || c1 === 101) && (c2 === 43 || c2 === 45) && digit(c3)) {\n      consume();\n      repr += stringFromCode(code);\n      consume();\n      repr += stringFromCode(code);\n      consume();\n      repr += stringFromCode(code);\n      type = \"number\";\n      while (digit(next())) {\n        consume();\n        repr += stringFromCode(code);\n      }\n    }\n    const value = convertAStringToANumber(repr);\n    return { type, value, repr };\n  };\n  const convertAStringToANumber = function(string) {\n    return +string;\n  };\n  const consumeTheRemnantsOfABadURL = function() {\n    while (consume()) {\n      if (code === 41 || eof()) {\n        return;\n      } else if (startsWithAValidEscape()) {\n        consumeEscape();\n        donothing();\n      } else {\n        donothing();\n      }\n    }\n  };\n  let iterationCount = 0;\n  while (!eof(next())) {\n    tokens.push(consumeAToken());\n    iterationCount++;\n    if (iterationCount > str.length * 2)\n      throw new Error(\"I'm infinite-looping!\");\n  }\n  return tokens;\n}\nvar CSSParserToken = class {\n  constructor() {\n    this.tokenType = \"\";\n  }\n  toJSON() {\n    return { token: this.tokenType };\n  }\n  toString() {\n    return this.tokenType;\n  }\n  toSource() {\n    return \"\" + this;\n  }\n};\nvar BadStringToken = class extends CSSParserToken {\n  constructor() {\n    super(...arguments);\n    this.tokenType = \"BADSTRING\";\n  }\n};\nvar BadURLToken = class extends CSSParserToken {\n  constructor() {\n    super(...arguments);\n    this.tokenType = \"BADURL\";\n  }\n};\nvar WhitespaceToken = class extends CSSParserToken {\n  constructor() {\n    super(...arguments);\n    this.tokenType = \"WHITESPACE\";\n  }\n  toString() {\n    return \"WS\";\n  }\n  toSource() {\n    return \" \";\n  }\n};\nvar CDOToken = class extends CSSParserToken {\n  constructor() {\n    super(...arguments);\n    this.tokenType = \"CDO\";\n  }\n  toSource() {\n    return \"<!--\";\n  }\n};\nvar CDCToken = class extends CSSParserToken {\n  constructor() {\n    super(...arguments);\n    this.tokenType = \"CDC\";\n  }\n  toSource() {\n    return \"-->\";\n  }\n};\nvar ColonToken = class extends CSSParserToken {\n  constructor() {\n    super(...arguments);\n    this.tokenType = \":\";\n  }\n};\nvar SemicolonToken = class extends CSSParserToken {\n  constructor() {\n    super(...arguments);\n    this.tokenType = \";\";\n  }\n};\nvar CommaToken = class extends CSSParserToken {\n  constructor() {\n    super(...arguments);\n    this.tokenType = \",\";\n  }\n};\nvar GroupingToken = class extends CSSParserToken {\n  constructor() {\n    super(...arguments);\n    this.value = \"\";\n    this.mirror = \"\";\n  }\n};\nvar OpenCurlyToken = class extends GroupingToken {\n  constructor() {\n    super();\n    this.tokenType = \"{\";\n    this.value = \"{\";\n    this.mirror = \"}\";\n  }\n};\nvar CloseCurlyToken = class extends GroupingToken {\n  constructor() {\n    super();\n    this.tokenType = \"}\";\n    this.value = \"}\";\n    this.mirror = \"{\";\n  }\n};\nvar OpenSquareToken = class extends GroupingToken {\n  constructor() {\n    super();\n    this.tokenType = \"[\";\n    this.value = \"[\";\n    this.mirror = \"]\";\n  }\n};\nvar CloseSquareToken = class extends GroupingToken {\n  constructor() {\n    super();\n    this.tokenType = \"]\";\n    this.value = \"]\";\n    this.mirror = \"[\";\n  }\n};\nvar OpenParenToken = class extends GroupingToken {\n  constructor() {\n    super();\n    this.tokenType = \"(\";\n    this.value = \"(\";\n    this.mirror = \")\";\n  }\n};\nvar CloseParenToken = class extends GroupingToken {\n  constructor() {\n    super();\n    this.tokenType = \")\";\n    this.value = \")\";\n    this.mirror = \"(\";\n  }\n};\nvar IncludeMatchToken = class extends CSSParserToken {\n  constructor() {\n    super(...arguments);\n    this.tokenType = \"~=\";\n  }\n};\nvar DashMatchToken = class extends CSSParserToken {\n  constructor() {\n    super(...arguments);\n    this.tokenType = \"|=\";\n  }\n};\nvar PrefixMatchToken = class extends CSSParserToken {\n  constructor() {\n    super(...arguments);\n    this.tokenType = \"^=\";\n  }\n};\nvar SuffixMatchToken = class extends CSSParserToken {\n  constructor() {\n    super(...arguments);\n    this.tokenType = \"$=\";\n  }\n};\nvar SubstringMatchToken = class extends CSSParserToken {\n  constructor() {\n    super(...arguments);\n    this.tokenType = \"*=\";\n  }\n};\nvar ColumnToken = class extends CSSParserToken {\n  constructor() {\n    super(...arguments);\n    this.tokenType = \"||\";\n  }\n};\nvar EOFToken = class extends CSSParserToken {\n  constructor() {\n    super(...arguments);\n    this.tokenType = \"EOF\";\n  }\n  toSource() {\n    return \"\";\n  }\n};\nvar DelimToken = class extends CSSParserToken {\n  constructor(code) {\n    super();\n    this.tokenType = \"DELIM\";\n    this.value = \"\";\n    this.value = stringFromCode(code);\n  }\n  toString() {\n    return \"DELIM(\" + this.value + \")\";\n  }\n  toJSON() {\n    const json = this.constructor.prototype.constructor.prototype.toJSON.call(this);\n    json.value = this.value;\n    return json;\n  }\n  toSource() {\n    if (this.value === \"\\\\\")\n      return \"\\\\\\n\";\n    else\n      return this.value;\n  }\n};\nvar StringValuedToken = class extends CSSParserToken {\n  constructor() {\n    super(...arguments);\n    this.value = \"\";\n  }\n  ASCIIMatch(str) {\n    return this.value.toLowerCase() === str.toLowerCase();\n  }\n  toJSON() {\n    const json = this.constructor.prototype.constructor.prototype.toJSON.call(this);\n    json.value = this.value;\n    return json;\n  }\n};\nvar IdentToken = class extends StringValuedToken {\n  constructor(val) {\n    super();\n    this.tokenType = \"IDENT\";\n    this.value = val;\n  }\n  toString() {\n    return \"IDENT(\" + this.value + \")\";\n  }\n  toSource() {\n    return escapeIdent(this.value);\n  }\n};\nvar FunctionToken = class extends StringValuedToken {\n  constructor(val) {\n    super();\n    this.tokenType = \"FUNCTION\";\n    this.value = val;\n    this.mirror = \")\";\n  }\n  toString() {\n    return \"FUNCTION(\" + this.value + \")\";\n  }\n  toSource() {\n    return escapeIdent(this.value) + \"(\";\n  }\n};\nvar AtKeywordToken = class extends StringValuedToken {\n  constructor(val) {\n    super();\n    this.tokenType = \"AT-KEYWORD\";\n    this.value = val;\n  }\n  toString() {\n    return \"AT(\" + this.value + \")\";\n  }\n  toSource() {\n    return \"@\" + escapeIdent(this.value);\n  }\n};\nvar HashToken = class extends StringValuedToken {\n  constructor(val) {\n    super();\n    this.tokenType = \"HASH\";\n    this.value = val;\n    this.type = \"unrestricted\";\n  }\n  toString() {\n    return \"HASH(\" + this.value + \")\";\n  }\n  toJSON() {\n    const json = this.constructor.prototype.constructor.prototype.toJSON.call(this);\n    json.value = this.value;\n    json.type = this.type;\n    return json;\n  }\n  toSource() {\n    if (this.type === \"id\")\n      return \"#\" + escapeIdent(this.value);\n    else\n      return \"#\" + escapeHash(this.value);\n  }\n};\nvar StringToken = class extends StringValuedToken {\n  constructor(val) {\n    super();\n    this.tokenType = \"STRING\";\n    this.value = val;\n  }\n  toString() {\n    return '\"' + escapeString(this.value) + '\"';\n  }\n};\nvar URLToken = class extends StringValuedToken {\n  constructor(val) {\n    super();\n    this.tokenType = \"URL\";\n    this.value = val;\n  }\n  toString() {\n    return \"URL(\" + this.value + \")\";\n  }\n  toSource() {\n    return 'url(\"' + escapeString(this.value) + '\")';\n  }\n};\nvar NumberToken = class extends CSSParserToken {\n  constructor() {\n    super();\n    this.tokenType = \"NUMBER\";\n    this.type = \"integer\";\n    this.repr = \"\";\n  }\n  toString() {\n    if (this.type === \"integer\")\n      return \"INT(\" + this.value + \")\";\n    return \"NUMBER(\" + this.value + \")\";\n  }\n  toJSON() {\n    const json = super.toJSON();\n    json.value = this.value;\n    json.type = this.type;\n    json.repr = this.repr;\n    return json;\n  }\n  toSource() {\n    return this.repr;\n  }\n};\nvar PercentageToken = class extends CSSParserToken {\n  constructor() {\n    super();\n    this.tokenType = \"PERCENTAGE\";\n    this.repr = \"\";\n  }\n  toString() {\n    return \"PERCENTAGE(\" + this.value + \")\";\n  }\n  toJSON() {\n    const json = this.constructor.prototype.constructor.prototype.toJSON.call(this);\n    json.value = this.value;\n    json.repr = this.repr;\n    return json;\n  }\n  toSource() {\n    return this.repr + \"%\";\n  }\n};\nvar DimensionToken = class extends CSSParserToken {\n  constructor() {\n    super();\n    this.tokenType = \"DIMENSION\";\n    this.type = \"integer\";\n    this.repr = \"\";\n    this.unit = \"\";\n  }\n  toString() {\n    return \"DIM(\" + this.value + \",\" + this.unit + \")\";\n  }\n  toJSON() {\n    const json = this.constructor.prototype.constructor.prototype.toJSON.call(this);\n    json.value = this.value;\n    json.type = this.type;\n    json.repr = this.repr;\n    json.unit = this.unit;\n    return json;\n  }\n  toSource() {\n    const source = this.repr;\n    let unit = escapeIdent(this.unit);\n    if (unit[0].toLowerCase() === \"e\" && (unit[1] === \"-\" || between(unit.charCodeAt(1), 48, 57))) {\n      unit = \"\\\\65 \" + unit.slice(1, unit.length);\n    }\n    return source + unit;\n  }\n};\nfunction escapeIdent(string) {\n  string = \"\" + string;\n  let result = \"\";\n  const firstcode = string.charCodeAt(0);\n  for (let i = 0; i < string.length; i++) {\n    const code = string.charCodeAt(i);\n    if (code === 0)\n      throw new InvalidCharacterError(\"Invalid character: the input contains U+0000.\");\n    if (between(code, 1, 31) || code === 127 || i === 0 && between(code, 48, 57) || i === 1 && between(code, 48, 57) && firstcode === 45)\n      result += \"\\\\\" + code.toString(16) + \" \";\n    else if (code >= 128 || code === 45 || code === 95 || between(code, 48, 57) || between(code, 65, 90) || between(code, 97, 122))\n      result += string[i];\n    else\n      result += \"\\\\\" + string[i];\n  }\n  return result;\n}\nfunction escapeHash(string) {\n  string = \"\" + string;\n  let result = \"\";\n  for (let i = 0; i < string.length; i++) {\n    const code = string.charCodeAt(i);\n    if (code === 0)\n      throw new InvalidCharacterError(\"Invalid character: the input contains U+0000.\");\n    if (code >= 128 || code === 45 || code === 95 || between(code, 48, 57) || between(code, 65, 90) || between(code, 97, 122))\n      result += string[i];\n    else\n      result += \"\\\\\" + code.toString(16) + \" \";\n  }\n  return result;\n}\nfunction escapeString(string) {\n  string = \"\" + string;\n  let result = \"\";\n  for (let i = 0; i < string.length; i++) {\n    const code = string.charCodeAt(i);\n    if (code === 0)\n      throw new InvalidCharacterError(\"Invalid character: the input contains U+0000.\");\n    if (between(code, 1, 31) || code === 127)\n      result += \"\\\\\" + code.toString(16) + \" \";\n    else if (code === 34 || code === 92)\n      result += \"\\\\\" + string[i];\n    else\n      result += string[i];\n  }\n  return result;\n}\n\n// packages/playwright-core/src/utils/isomorphic/cssParser.ts\nvar InvalidSelectorError = class extends Error {\n};\nfunction parseCSS(selector, customNames) {\n  let tokens;\n  try {\n    tokens = tokenize(selector);\n    if (!(tokens[tokens.length - 1] instanceof EOFToken))\n      tokens.push(new EOFToken());\n  } catch (e) {\n    const newMessage = e.message + ` while parsing css selector \"${selector}\". Did you mean to CSS.escape it?`;\n    const index = (e.stack || \"\").indexOf(e.message);\n    if (index !== -1)\n      e.stack = e.stack.substring(0, index) + newMessage + e.stack.substring(index + e.message.length);\n    e.message = newMessage;\n    throw e;\n  }\n  const unsupportedToken = tokens.find((token) => {\n    return token instanceof AtKeywordToken || token instanceof BadStringToken || token instanceof BadURLToken || token instanceof ColumnToken || token instanceof CDOToken || token instanceof CDCToken || token instanceof SemicolonToken || // TODO: Consider using these for something, e.g. to escape complex strings.\n    // For example :xpath{ (//div/bar[@attr=\"foo\"])[2]/baz }\n    // Or this way :xpath( {complex-xpath-goes-here(\"hello\")} )\n    token instanceof OpenCurlyToken || token instanceof CloseCurlyToken || // TODO: Consider treating these as strings?\n    token instanceof URLToken || token instanceof PercentageToken;\n  });\n  if (unsupportedToken)\n    throw new InvalidSelectorError(`Unsupported token \"${unsupportedToken.toSource()}\" while parsing css selector \"${selector}\". Did you mean to CSS.escape it?`);\n  let pos = 0;\n  const names = new Set();\n  function unexpected() {\n    return new InvalidSelectorError(`Unexpected token \"${tokens[pos].toSource()}\" while parsing css selector \"${selector}\". Did you mean to CSS.escape it?`);\n  }\n  function skipWhitespace() {\n    while (tokens[pos] instanceof WhitespaceToken)\n      pos++;\n  }\n  function isIdent(p = pos) {\n    return tokens[p] instanceof IdentToken;\n  }\n  function isString(p = pos) {\n    return tokens[p] instanceof StringToken;\n  }\n  function isNumber(p = pos) {\n    return tokens[p] instanceof NumberToken;\n  }\n  function isComma(p = pos) {\n    return tokens[p] instanceof CommaToken;\n  }\n  function isOpenParen(p = pos) {\n    return tokens[p] instanceof OpenParenToken;\n  }\n  function isCloseParen(p = pos) {\n    return tokens[p] instanceof CloseParenToken;\n  }\n  function isFunction(p = pos) {\n    return tokens[p] instanceof FunctionToken;\n  }\n  function isStar(p = pos) {\n    return tokens[p] instanceof DelimToken && tokens[p].value === \"*\";\n  }\n  function isEOF(p = pos) {\n    return tokens[p] instanceof EOFToken;\n  }\n  function isClauseCombinator(p = pos) {\n    return tokens[p] instanceof DelimToken && [\">\", \"+\", \"~\"].includes(tokens[p].value);\n  }\n  function isSelectorClauseEnd(p = pos) {\n    return isComma(p) || isCloseParen(p) || isEOF(p) || isClauseCombinator(p) || tokens[p] instanceof WhitespaceToken;\n  }\n  function consumeFunctionArguments() {\n    const result2 = [consumeArgument()];\n    while (true) {\n      skipWhitespace();\n      if (!isComma())\n        break;\n      pos++;\n      result2.push(consumeArgument());\n    }\n    return result2;\n  }\n  function consumeArgument() {\n    skipWhitespace();\n    if (isNumber())\n      return tokens[pos++].value;\n    if (isString())\n      return tokens[pos++].value;\n    return consumeComplexSelector();\n  }\n  function consumeComplexSelector() {\n    const result2 = { simples: [] };\n    skipWhitespace();\n    if (isClauseCombinator()) {\n      result2.simples.push({ selector: { functions: [{ name: \"scope\", args: [] }] }, combinator: \"\" });\n    } else {\n      result2.simples.push({ selector: consumeSimpleSelector(), combinator: \"\" });\n    }\n    while (true) {\n      skipWhitespace();\n      if (isClauseCombinator()) {\n        result2.simples[result2.simples.length - 1].combinator = tokens[pos++].value;\n        skipWhitespace();\n      } else if (isSelectorClauseEnd()) {\n        break;\n      }\n      result2.simples.push({ combinator: \"\", selector: consumeSimpleSelector() });\n    }\n    return result2;\n  }\n  function consumeSimpleSelector() {\n    let rawCSSString = \"\";\n    const functions = [];\n    while (!isSelectorClauseEnd()) {\n      if (isIdent() || isStar()) {\n        rawCSSString += tokens[pos++].toSource();\n      } else if (tokens[pos] instanceof HashToken) {\n        rawCSSString += tokens[pos++].toSource();\n      } else if (tokens[pos] instanceof DelimToken && tokens[pos].value === \".\") {\n        pos++;\n        if (isIdent())\n          rawCSSString += \".\" + tokens[pos++].toSource();\n        else\n          throw unexpected();\n      } else if (tokens[pos] instanceof ColonToken) {\n        pos++;\n        if (isIdent()) {\n          if (!customNames.has(tokens[pos].value.toLowerCase())) {\n            rawCSSString += \":\" + tokens[pos++].toSource();\n          } else {\n            const name = tokens[pos++].value.toLowerCase();\n            functions.push({ name, args: [] });\n            names.add(name);\n          }\n        } else if (isFunction()) {\n          const name = tokens[pos++].value.toLowerCase();\n          if (!customNames.has(name)) {\n            rawCSSString += `:${name}(${consumeBuiltinFunctionArguments()})`;\n          } else {\n            functions.push({ name, args: consumeFunctionArguments() });\n            names.add(name);\n          }\n          skipWhitespace();\n          if (!isCloseParen())\n            throw unexpected();\n          pos++;\n        } else {\n          throw unexpected();\n        }\n      } else if (tokens[pos] instanceof OpenSquareToken) {\n        rawCSSString += \"[\";\n        pos++;\n        while (!(tokens[pos] instanceof CloseSquareToken) && !isEOF())\n          rawCSSString += tokens[pos++].toSource();\n        if (!(tokens[pos] instanceof CloseSquareToken))\n          throw unexpected();\n        rawCSSString += \"]\";\n        pos++;\n      } else {\n        throw unexpected();\n      }\n    }\n    if (!rawCSSString && !functions.length)\n      throw unexpected();\n    return { css: rawCSSString || void 0, functions };\n  }\n  function consumeBuiltinFunctionArguments() {\n    let s = \"\";\n    let balance = 1;\n    while (!isEOF()) {\n      if (isOpenParen() || isFunction())\n        balance++;\n      if (isCloseParen())\n        balance--;\n      if (!balance)\n        break;\n      s += tokens[pos++].toSource();\n    }\n    return s;\n  }\n  const result = consumeFunctionArguments();\n  if (!isEOF())\n    throw unexpected();\n  if (result.some((arg) => typeof arg !== \"object\" || !(\"simples\" in arg)))\n    throw new InvalidSelectorError(`Error while parsing css selector \"${selector}\". Did you mean to CSS.escape it?`);\n  return { selector: result, names: Array.from(names) };\n}\n\n// packages/playwright-core/src/utils/isomorphic/selectorParser.ts\nvar kNestedSelectorNames = new Set([\"internal:has\", \"internal:has-not\", \"internal:and\", \"internal:or\", \"internal:chain\", \"left-of\", \"right-of\", \"above\", \"below\", \"near\"]);\nvar kNestedSelectorNamesWithDistance = new Set([\"left-of\", \"right-of\", \"above\", \"below\", \"near\"]);\nvar customCSSNames = new Set([\"not\", \"is\", \"where\", \"has\", \"scope\", \"light\", \"visible\", \"text\", \"text-matches\", \"text-is\", \"has-text\", \"above\", \"below\", \"right-of\", \"left-of\", \"near\", \"nth-match\"]);\nfunction parseSelector(selector) {\n  const parsedStrings = parseSelectorString(selector);\n  const parts = [];\n  for (const part of parsedStrings.parts) {\n    if (part.name === \"css\" || part.name === \"css:light\") {\n      if (part.name === \"css:light\")\n        part.body = \":light(\" + part.body + \")\";\n      const parsedCSS = parseCSS(part.body, customCSSNames);\n      parts.push({\n        name: \"css\",\n        body: parsedCSS.selector,\n        source: part.body\n      });\n      continue;\n    }\n    if (kNestedSelectorNames.has(part.name)) {\n      let innerSelector;\n      let distance;\n      try {\n        const unescaped = JSON.parse(\"[\" + part.body + \"]\");\n        if (!Array.isArray(unescaped) || unescaped.length < 1 || unescaped.length > 2 || typeof unescaped[0] !== \"string\")\n          throw new InvalidSelectorError(`Malformed selector: ${part.name}=` + part.body);\n        innerSelector = unescaped[0];\n        if (unescaped.length === 2) {\n          if (typeof unescaped[1] !== \"number\" || !kNestedSelectorNamesWithDistance.has(part.name))\n            throw new InvalidSelectorError(`Malformed selector: ${part.name}=` + part.body);\n          distance = unescaped[1];\n        }\n      } catch (e) {\n        throw new InvalidSelectorError(`Malformed selector: ${part.name}=` + part.body);\n      }\n      const nested = { name: part.name, source: part.body, body: { parsed: parseSelector(innerSelector), distance } };\n      const lastFrame = [...nested.body.parsed.parts].reverse().find((part2) => part2.name === \"internal:control\" && part2.body === \"enter-frame\");\n      const lastFrameIndex = lastFrame ? nested.body.parsed.parts.indexOf(lastFrame) : -1;\n      if (lastFrameIndex !== -1 && selectorPartsEqual(nested.body.parsed.parts.slice(0, lastFrameIndex + 1), parts.slice(0, lastFrameIndex + 1)))\n        nested.body.parsed.parts.splice(0, lastFrameIndex + 1);\n      parts.push(nested);\n      continue;\n    }\n    parts.push({ ...part, source: part.body });\n  }\n  if (kNestedSelectorNames.has(parts[0].name))\n    throw new InvalidSelectorError(`\"${parts[0].name}\" selector cannot be first`);\n  return {\n    capture: parsedStrings.capture,\n    parts\n  };\n}\nfunction selectorPartsEqual(list1, list2) {\n  return stringifySelector({ parts: list1 }) === stringifySelector({ parts: list2 });\n}\nfunction stringifySelector(selector, forceEngineName) {\n  if (typeof selector === \"string\")\n    return selector;\n  return selector.parts.map((p, i) => {\n    let includeEngine = true;\n    if (!forceEngineName && i !== selector.capture) {\n      if (p.name === \"css\")\n        includeEngine = false;\n      else if (p.name === \"xpath\" && p.source.startsWith(\"//\") || p.source.startsWith(\"..\"))\n        includeEngine = false;\n    }\n    const prefix = includeEngine ? p.name + \"=\" : \"\";\n    return `${i === selector.capture ? \"*\" : \"\"}${prefix}${p.source}`;\n  }).join(\" >> \");\n}\nfunction visitAllSelectorParts(selector, visitor) {\n  const visit = (selector2, nested) => {\n    for (const part of selector2.parts) {\n      visitor(part, nested);\n      if (kNestedSelectorNames.has(part.name))\n        visit(part.body.parsed, true);\n    }\n  };\n  visit(selector, false);\n}\nfunction parseSelectorString(selector) {\n  let index = 0;\n  let quote;\n  let start = 0;\n  const result = { parts: [] };\n  const append = () => {\n    const part = selector.substring(start, index).trim();\n    const eqIndex = part.indexOf(\"=\");\n    let name;\n    let body;\n    if (eqIndex !== -1 && part.substring(0, eqIndex).trim().match(/^[a-zA-Z_0-9-+:*]+$/)) {\n      name = part.substring(0, eqIndex).trim();\n      body = part.substring(eqIndex + 1);\n    } else if (part.length > 1 && part[0] === '\"' && part[part.length - 1] === '\"') {\n      name = \"text\";\n      body = part;\n    } else if (part.length > 1 && part[0] === \"'\" && part[part.length - 1] === \"'\") {\n      name = \"text\";\n      body = part;\n    } else if (/^\\(*\\/\\//.test(part) || part.startsWith(\"..\")) {\n      name = \"xpath\";\n      body = part;\n    } else {\n      name = \"css\";\n      body = part;\n    }\n    let capture = false;\n    if (name[0] === \"*\") {\n      capture = true;\n      name = name.substring(1);\n    }\n    result.parts.push({ name, body });\n    if (capture) {\n      if (result.capture !== void 0)\n        throw new InvalidSelectorError(`Only one of the selectors can capture using * modifier`);\n      result.capture = result.parts.length - 1;\n    }\n  };\n  if (!selector.includes(\">>\")) {\n    index = selector.length;\n    append();\n    return result;\n  }\n  const shouldIgnoreTextSelectorQuote = () => {\n    const prefix = selector.substring(start, index);\n    const match = prefix.match(/^\\s*text\\s*=(.*)$/);\n    return !!match && !!match[1];\n  };\n  while (index < selector.length) {\n    const c = selector[index];\n    if (c === \"\\\\\" && index + 1 < selector.length) {\n      index += 2;\n    } else if (c === quote) {\n      quote = void 0;\n      index++;\n    } else if (!quote && (c === '\"' || c === \"'\" || c === \"`\") && !shouldIgnoreTextSelectorQuote()) {\n      quote = c;\n      index++;\n    } else if (!quote && c === \">\" && selector[index + 1] === \">\") {\n      append();\n      index += 2;\n      start = index;\n    } else {\n      index++;\n    }\n  }\n  append();\n  return result;\n}\nfunction parseAttributeSelector(selector, allowUnquotedStrings) {\n  let wp = 0;\n  let EOL = selector.length === 0;\n  const next = () => selector[wp] || \"\";\n  const eat1 = () => {\n    const result2 = next();\n    ++wp;\n    EOL = wp >= selector.length;\n    return result2;\n  };\n  const syntaxError = (stage) => {\n    if (EOL)\n      throw new InvalidSelectorError(`Unexpected end of selector while parsing selector \\`${selector}\\``);\n    throw new InvalidSelectorError(`Error while parsing selector \\`${selector}\\` - unexpected symbol \"${next()}\" at position ${wp}` + (stage ? \" during \" + stage : \"\"));\n  };\n  function skipSpaces() {\n    while (!EOL && /\\s/.test(next()))\n      eat1();\n  }\n  function isCSSNameChar(char) {\n    return char >= \"\\x80\" || char >= \"0\" && char <= \"9\" || char >= \"A\" && char <= \"Z\" || char >= \"a\" && char <= \"z\" || char >= \"0\" && char <= \"9\" || char === \"_\" || char === \"-\";\n  }\n  function readIdentifier() {\n    let result2 = \"\";\n    skipSpaces();\n    while (!EOL && isCSSNameChar(next()))\n      result2 += eat1();\n    return result2;\n  }\n  function readQuotedString(quote) {\n    let result2 = eat1();\n    if (result2 !== quote)\n      syntaxError(\"parsing quoted string\");\n    while (!EOL && next() !== quote) {\n      if (next() === \"\\\\\")\n        eat1();\n      result2 += eat1();\n    }\n    if (next() !== quote)\n      syntaxError(\"parsing quoted string\");\n    result2 += eat1();\n    return result2;\n  }\n  function readRegularExpression() {\n    if (eat1() !== \"/\")\n      syntaxError(\"parsing regular expression\");\n    let source = \"\";\n    let inClass = false;\n    while (!EOL) {\n      if (next() === \"\\\\\") {\n        source += eat1();\n        if (EOL)\n          syntaxError(\"parsing regular expression\");\n      } else if (inClass && next() === \"]\") {\n        inClass = false;\n      } else if (!inClass && next() === \"[\") {\n        inClass = true;\n      } else if (!inClass && next() === \"/\") {\n        break;\n      }\n      source += eat1();\n    }\n    if (eat1() !== \"/\")\n      syntaxError(\"parsing regular expression\");\n    let flags = \"\";\n    while (!EOL && next().match(/[dgimsuy]/))\n      flags += eat1();\n    try {\n      return new RegExp(source, flags);\n    } catch (e) {\n      throw new InvalidSelectorError(`Error while parsing selector \\`${selector}\\`: ${e.message}`);\n    }\n  }\n  function readAttributeToken() {\n    let token = \"\";\n    skipSpaces();\n    if (next() === `'` || next() === `\"`)\n      token = readQuotedString(next()).slice(1, -1);\n    else\n      token = readIdentifier();\n    if (!token)\n      syntaxError(\"parsing property path\");\n    return token;\n  }\n  function readOperator() {\n    skipSpaces();\n    let op = \"\";\n    if (!EOL)\n      op += eat1();\n    if (!EOL && op !== \"=\")\n      op += eat1();\n    if (![\"=\", \"*=\", \"^=\", \"$=\", \"|=\", \"~=\"].includes(op))\n      syntaxError(\"parsing operator\");\n    return op;\n  }\n  function readAttribute() {\n    eat1();\n    const jsonPath = [];\n    jsonPath.push(readAttributeToken());\n    skipSpaces();\n    while (next() === \".\") {\n      eat1();\n      jsonPath.push(readAttributeToken());\n      skipSpaces();\n    }\n    if (next() === \"]\") {\n      eat1();\n      return { name: jsonPath.join(\".\"), jsonPath, op: \"<truthy>\", value: null, caseSensitive: false };\n    }\n    const operator = readOperator();\n    let value = void 0;\n    let caseSensitive = true;\n    skipSpaces();\n    if (next() === \"/\") {\n      if (operator !== \"=\")\n        throw new InvalidSelectorError(`Error while parsing selector \\`${selector}\\` - cannot use ${operator} in attribute with regular expression`);\n      value = readRegularExpression();\n    } else if (next() === `'` || next() === `\"`) {\n      value = readQuotedString(next()).slice(1, -1);\n      skipSpaces();\n      if (next() === \"i\" || next() === \"I\") {\n        caseSensitive = false;\n        eat1();\n      } else if (next() === \"s\" || next() === \"S\") {\n        caseSensitive = true;\n        eat1();\n      }\n    } else {\n      value = \"\";\n      while (!EOL && (isCSSNameChar(next()) || next() === \"+\" || next() === \".\"))\n        value += eat1();\n      if (value === \"true\") {\n        value = true;\n      } else if (value === \"false\") {\n        value = false;\n      } else {\n        if (!allowUnquotedStrings) {\n          value = +value;\n          if (Number.isNaN(value))\n            syntaxError(\"parsing attribute value\");\n        }\n      }\n    }\n    skipSpaces();\n    if (next() !== \"]\")\n      syntaxError(\"parsing attribute value\");\n    eat1();\n    if (operator !== \"=\" && typeof value !== \"string\")\n      throw new InvalidSelectorError(`Error while parsing selector \\`${selector}\\` - cannot use ${operator} in attribute with non-string matching value - ${value}`);\n    return { name: jsonPath.join(\".\"), jsonPath, op: operator, value, caseSensitive };\n  }\n  const result = {\n    name: \"\",\n    attributes: []\n  };\n  result.name = readIdentifier();\n  skipSpaces();\n  while (next() === \"[\") {\n    result.attributes.push(readAttribute());\n    skipSpaces();\n  }\n  if (!EOL)\n    syntaxError(void 0);\n  if (!result.name && !result.attributes.length)\n    throw new InvalidSelectorError(`Error while parsing selector \\`${selector}\\` - selector cannot be empty`);\n  return result;\n}\n\n// packages/playwright-core/src/utils/isomorphic/stringUtils.ts\nfunction escapeWithQuotes(text, char = \"'\") {\n  const stringified = JSON.stringify(text);\n  const escapedText = stringified.substring(1, stringified.length - 1).replace(/\\\\\"/g, '\"');\n  if (char === \"'\")\n    return char + escapedText.replace(/[']/g, \"\\\\'\") + char;\n  if (char === '\"')\n    return char + escapedText.replace(/[\"]/g, '\\\\\"') + char;\n  if (char === \"`\")\n    return char + escapedText.replace(/[`]/g, \"`\") + char;\n  throw new Error(\"Invalid escape char\");\n}\nfunction toTitleCase(name) {\n  return name.charAt(0).toUpperCase() + name.substring(1);\n}\nfunction toSnakeCase(name) {\n  return name.replace(/([a-z0-9])([A-Z])/g, \"$1_$2\").replace(/([A-Z])([A-Z][a-z])/g, \"$1_$2\").toLowerCase();\n}\nfunction cssEscape(s) {\n  let result = \"\";\n  for (let i = 0; i < s.length; i++)\n    result += cssEscapeOne(s, i);\n  return result;\n}\nfunction quoteCSSAttributeValue(text) {\n  return `\"${cssEscape(text).replace(/\\\\ /g, \" \")}\"`;\n}\nfunction cssEscapeOne(s, i) {\n  const c = s.charCodeAt(i);\n  if (c === 0)\n    return \"\\uFFFD\";\n  if (c >= 1 && c <= 31 || c >= 48 && c <= 57 && (i === 0 || i === 1 && s.charCodeAt(0) === 45))\n    return \"\\\\\" + c.toString(16) + \" \";\n  if (i === 0 && c === 45 && s.length === 1)\n    return \"\\\\\" + s.charAt(i);\n  if (c >= 128 || c === 45 || c === 95 || c >= 48 && c <= 57 || c >= 65 && c <= 90 || c >= 97 && c <= 122)\n    return s.charAt(i);\n  return \"\\\\\" + s.charAt(i);\n}\nvar normalizedWhitespaceCache;\nfunction cacheNormalizedWhitespaces() {\n  normalizedWhitespaceCache = new Map();\n}\nfunction normalizeWhiteSpace(text) {\n  let result = normalizedWhitespaceCache == null ? void 0 : normalizedWhitespaceCache.get(text);\n  if (result === void 0) {\n    result = text.replace(/[\\u200b\\u00ad]/g, \"\").trim().replace(/\\s+/g, \" \");\n    normalizedWhitespaceCache == null ? void 0 : normalizedWhitespaceCache.set(text, result);\n  }\n  return result;\n}\nfunction normalizeEscapedRegexQuotes(source) {\n  return source.replace(/(^|[^\\\\])(\\\\\\\\)*\\\\(['\"`])/g, \"$1$2$3\");\n}\nfunction escapeRegexForSelector(re) {\n  if (re.unicode || re.unicodeSets)\n    return String(re);\n  return String(re).replace(/(^|[^\\\\])(\\\\\\\\)*([\"'`])/g, \"$1$2\\\\$3\").replace(/>>/g, \"\\\\>\\\\>\");\n}\nfunction escapeForTextSelector(text, exact) {\n  if (typeof text !== \"string\")\n    return escapeRegexForSelector(text);\n  return `${JSON.stringify(text)}${exact ? \"s\" : \"i\"}`;\n}\nfunction escapeForAttributeSelector(value, exact) {\n  if (typeof value !== \"string\")\n    return escapeRegexForSelector(value);\n  return `\"${value.replace(/\\\\/g, \"\\\\\\\\\").replace(/[\"]/g, '\\\\\"')}\"${exact ? \"s\" : \"i\"}`;\n}\nfunction trimString(input, cap, suffix = \"\") {\n  if (input.length <= cap)\n    return input;\n  const chars = [...input];\n  if (chars.length > cap)\n    return chars.slice(0, cap - suffix.length).join(\"\") + suffix;\n  return chars.join(\"\");\n}\nfunction trimStringWithEllipsis(input, cap) {\n  return trimString(input, cap, \"\\u2026\");\n}\nfunction escapeRegExp(s) {\n  return s.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n}\nfunction longestCommonSubstring(s1, s2) {\n  const n = s1.length;\n  const m = s2.length;\n  let maxLen = 0;\n  let endingIndex = 0;\n  const dp = Array(n + 1).fill(null).map(() => Array(m + 1).fill(0));\n  for (let i = 1; i <= n; i++) {\n    for (let j = 1; j <= m; j++) {\n      if (s1[i - 1] === s2[j - 1]) {\n        dp[i][j] = dp[i - 1][j - 1] + 1;\n        if (dp[i][j] > maxLen) {\n          maxLen = dp[i][j];\n          endingIndex = i;\n        }\n      }\n    }\n  }\n  return s1.slice(endingIndex - maxLen, endingIndex);\n}\n\n// packages/playwright-core/src/utils/isomorphic/locatorGenerators.ts\nfunction asLocator(lang, selector, isFrameLocator = false) {\n  return asLocators(lang, selector, isFrameLocator, 1)[0];\n}\nfunction asLocators(lang, selector, isFrameLocator = false, maxOutputSize = 20, preferredQuote) {\n  try {\n    return innerAsLocators(new generators[lang](preferredQuote), parseSelector(selector), isFrameLocator, maxOutputSize);\n  } catch (e) {\n    return [selector];\n  }\n}\nfunction innerAsLocators(factory, parsed, isFrameLocator = false, maxOutputSize = 20) {\n  const parts = [...parsed.parts];\n  const tokens = [];\n  let nextBase = isFrameLocator ? \"frame-locator\" : \"page\";\n  for (let index = 0; index < parts.length; index++) {\n    const part = parts[index];\n    const base = nextBase;\n    nextBase = \"locator\";\n    if (part.name === \"nth\") {\n      if (part.body === \"0\")\n        tokens.push([factory.generateLocator(base, \"first\", \"\"), factory.generateLocator(base, \"nth\", \"0\")]);\n      else if (part.body === \"-1\")\n        tokens.push([factory.generateLocator(base, \"last\", \"\"), factory.generateLocator(base, \"nth\", \"-1\")]);\n      else\n        tokens.push([factory.generateLocator(base, \"nth\", part.body)]);\n      continue;\n    }\n    if (part.name === \"visible\") {\n      tokens.push([factory.generateLocator(base, \"visible\", part.body), factory.generateLocator(base, \"default\", `visible=${part.body}`)]);\n      continue;\n    }\n    if (part.name === \"internal:text\") {\n      const { exact, text } = detectExact(part.body);\n      tokens.push([factory.generateLocator(base, \"text\", text, { exact })]);\n      continue;\n    }\n    if (part.name === \"internal:has-text\") {\n      const { exact, text } = detectExact(part.body);\n      if (!exact) {\n        tokens.push([factory.generateLocator(base, \"has-text\", text, { exact })]);\n        continue;\n      }\n    }\n    if (part.name === \"internal:has-not-text\") {\n      const { exact, text } = detectExact(part.body);\n      if (!exact) {\n        tokens.push([factory.generateLocator(base, \"has-not-text\", text, { exact })]);\n        continue;\n      }\n    }\n    if (part.name === \"internal:has\") {\n      const inners = innerAsLocators(factory, part.body.parsed, false, maxOutputSize);\n      tokens.push(inners.map((inner) => factory.generateLocator(base, \"has\", inner)));\n      continue;\n    }\n    if (part.name === \"internal:has-not\") {\n      const inners = innerAsLocators(factory, part.body.parsed, false, maxOutputSize);\n      tokens.push(inners.map((inner) => factory.generateLocator(base, \"hasNot\", inner)));\n      continue;\n    }\n    if (part.name === \"internal:and\") {\n      const inners = innerAsLocators(factory, part.body.parsed, false, maxOutputSize);\n      tokens.push(inners.map((inner) => factory.generateLocator(base, \"and\", inner)));\n      continue;\n    }\n    if (part.name === \"internal:or\") {\n      const inners = innerAsLocators(factory, part.body.parsed, false, maxOutputSize);\n      tokens.push(inners.map((inner) => factory.generateLocator(base, \"or\", inner)));\n      continue;\n    }\n    if (part.name === \"internal:chain\") {\n      const inners = innerAsLocators(factory, part.body.parsed, false, maxOutputSize);\n      tokens.push(inners.map((inner) => factory.generateLocator(base, \"chain\", inner)));\n      continue;\n    }\n    if (part.name === \"internal:label\") {\n      const { exact, text } = detectExact(part.body);\n      tokens.push([factory.generateLocator(base, \"label\", text, { exact })]);\n      continue;\n    }\n    if (part.name === \"internal:role\") {\n      const attrSelector = parseAttributeSelector(part.body, true);\n      const options = { attrs: [] };\n      for (const attr of attrSelector.attributes) {\n        if (attr.name === \"name\") {\n          options.exact = attr.caseSensitive;\n          options.name = attr.value;\n        } else {\n          if (attr.name === \"level\" && typeof attr.value === \"string\")\n            attr.value = +attr.value;\n          options.attrs.push({ name: attr.name === \"include-hidden\" ? \"includeHidden\" : attr.name, value: attr.value });\n        }\n      }\n      tokens.push([factory.generateLocator(base, \"role\", attrSelector.name, options)]);\n      continue;\n    }\n    if (part.name === \"internal:testid\") {\n      const attrSelector = parseAttributeSelector(part.body, true);\n      const { value } = attrSelector.attributes[0];\n      tokens.push([factory.generateLocator(base, \"test-id\", value)]);\n      continue;\n    }\n    if (part.name === \"internal:attr\") {\n      const attrSelector = parseAttributeSelector(part.body, true);\n      const { name, value, caseSensitive } = attrSelector.attributes[0];\n      const text = value;\n      const exact = !!caseSensitive;\n      if (name === \"placeholder\") {\n        tokens.push([factory.generateLocator(base, \"placeholder\", text, { exact })]);\n        continue;\n      }\n      if (name === \"alt\") {\n        tokens.push([factory.generateLocator(base, \"alt\", text, { exact })]);\n        continue;\n      }\n      if (name === \"title\") {\n        tokens.push([factory.generateLocator(base, \"title\", text, { exact })]);\n        continue;\n      }\n    }\n    if (part.name === \"internal:control\" && part.body === \"enter-frame\") {\n      const lastTokens = tokens[tokens.length - 1];\n      const lastPart = parts[index - 1];\n      const transformed = lastTokens.map((token) => factory.chainLocators([token, factory.generateLocator(base, \"frame\", \"\")]));\n      if ([\"xpath\", \"css\"].includes(lastPart.name)) {\n        transformed.push(\n          factory.generateLocator(base, \"frame-locator\", stringifySelector({ parts: [lastPart] })),\n          factory.generateLocator(base, \"frame-locator\", stringifySelector({ parts: [lastPart] }, true))\n        );\n      }\n      lastTokens.splice(0, lastTokens.length, ...transformed);\n      nextBase = \"frame-locator\";\n      continue;\n    }\n    const nextPart = parts[index + 1];\n    const selectorPart = stringifySelector({ parts: [part] });\n    const locatorPart = factory.generateLocator(base, \"default\", selectorPart);\n    if (nextPart && [\"internal:has-text\", \"internal:has-not-text\"].includes(nextPart.name)) {\n      const { exact, text } = detectExact(nextPart.body);\n      if (!exact) {\n        const nextLocatorPart = factory.generateLocator(\"locator\", nextPart.name === \"internal:has-text\" ? \"has-text\" : \"has-not-text\", text, { exact });\n        const options = {};\n        if (nextPart.name === \"internal:has-text\")\n          options.hasText = text;\n        else\n          options.hasNotText = text;\n        const combinedPart = factory.generateLocator(base, \"default\", selectorPart, options);\n        tokens.push([factory.chainLocators([locatorPart, nextLocatorPart]), combinedPart]);\n        index++;\n        continue;\n      }\n    }\n    let locatorPartWithEngine;\n    if ([\"xpath\", \"css\"].includes(part.name)) {\n      const selectorPart2 = stringifySelector(\n        { parts: [part] },\n        /* forceEngineName */\n        true\n      );\n      locatorPartWithEngine = factory.generateLocator(base, \"default\", selectorPart2);\n    }\n    tokens.push([locatorPart, locatorPartWithEngine].filter(Boolean));\n  }\n  return combineTokens(factory, tokens, maxOutputSize);\n}\nfunction combineTokens(factory, tokens, maxOutputSize) {\n  const currentTokens = tokens.map(() => \"\");\n  const result = [];\n  const visit = (index) => {\n    if (index === tokens.length) {\n      result.push(factory.chainLocators(currentTokens));\n      return result.length < maxOutputSize;\n    }\n    for (const taken of tokens[index]) {\n      currentTokens[index] = taken;\n      if (!visit(index + 1))\n        return false;\n    }\n    return true;\n  };\n  visit(0);\n  return result;\n}\nfunction detectExact(text) {\n  let exact = false;\n  const match = text.match(/^\\/(.*)\\/([igm]*)$/);\n  if (match)\n    return { text: new RegExp(match[1], match[2]) };\n  if (text.endsWith('\"')) {\n    text = JSON.parse(text);\n    exact = true;\n  } else if (text.endsWith('\"s')) {\n    text = JSON.parse(text.substring(0, text.length - 1));\n    exact = true;\n  } else if (text.endsWith('\"i')) {\n    text = JSON.parse(text.substring(0, text.length - 1));\n    exact = false;\n  }\n  return { exact, text };\n}\nvar JavaScriptLocatorFactory = class {\n  constructor(preferredQuote) {\n    this.preferredQuote = preferredQuote;\n  }\n  generateLocator(base, kind, body, options = {}) {\n    switch (kind) {\n      case \"default\":\n        if (options.hasText !== void 0)\n          return `locator(${this.quote(body)}, { hasText: ${this.toHasText(options.hasText)} })`;\n        if (options.hasNotText !== void 0)\n          return `locator(${this.quote(body)}, { hasNotText: ${this.toHasText(options.hasNotText)} })`;\n        return `locator(${this.quote(body)})`;\n      case \"frame-locator\":\n        return `frameLocator(${this.quote(body)})`;\n      case \"frame\":\n        return `contentFrame()`;\n      case \"nth\":\n        return `nth(${body})`;\n      case \"first\":\n        return `first()`;\n      case \"last\":\n        return `last()`;\n      case \"visible\":\n        return `filter({ visible: ${body === \"true\" ? \"true\" : \"false\"} })`;\n      case \"role\":\n        const attrs = [];\n        if (isRegExp(options.name)) {\n          attrs.push(`name: ${this.regexToSourceString(options.name)}`);\n        } else if (typeof options.name === \"string\") {\n          attrs.push(`name: ${this.quote(options.name)}`);\n          if (options.exact)\n            attrs.push(`exact: true`);\n        }\n        for (const { name, value } of options.attrs)\n          attrs.push(`${name}: ${typeof value === \"string\" ? this.quote(value) : value}`);\n        const attrString = attrs.length ? `, { ${attrs.join(\", \")} }` : \"\";\n        return `getByRole(${this.quote(body)}${attrString})`;\n      case \"has-text\":\n        return `filter({ hasText: ${this.toHasText(body)} })`;\n      case \"has-not-text\":\n        return `filter({ hasNotText: ${this.toHasText(body)} })`;\n      case \"has\":\n        return `filter({ has: ${body} })`;\n      case \"hasNot\":\n        return `filter({ hasNot: ${body} })`;\n      case \"and\":\n        return `and(${body})`;\n      case \"or\":\n        return `or(${body})`;\n      case \"chain\":\n        return `locator(${body})`;\n      case \"test-id\":\n        return `getByTestId(${this.toTestIdValue(body)})`;\n      case \"text\":\n        return this.toCallWithExact(\"getByText\", body, !!options.exact);\n      case \"alt\":\n        return this.toCallWithExact(\"getByAltText\", body, !!options.exact);\n      case \"placeholder\":\n        return this.toCallWithExact(\"getByPlaceholder\", body, !!options.exact);\n      case \"label\":\n        return this.toCallWithExact(\"getByLabel\", body, !!options.exact);\n      case \"title\":\n        return this.toCallWithExact(\"getByTitle\", body, !!options.exact);\n      default:\n        throw new Error(\"Unknown selector kind \" + kind);\n    }\n  }\n  chainLocators(locators) {\n    return locators.join(\".\");\n  }\n  regexToSourceString(re) {\n    return normalizeEscapedRegexQuotes(String(re));\n  }\n  toCallWithExact(method, body, exact) {\n    if (isRegExp(body))\n      return `${method}(${this.regexToSourceString(body)})`;\n    return exact ? `${method}(${this.quote(body)}, { exact: true })` : `${method}(${this.quote(body)})`;\n  }\n  toHasText(body) {\n    if (isRegExp(body))\n      return this.regexToSourceString(body);\n    return this.quote(body);\n  }\n  toTestIdValue(value) {\n    if (isRegExp(value))\n      return this.regexToSourceString(value);\n    return this.quote(value);\n  }\n  quote(text) {\n    var _a;\n    return escapeWithQuotes(text, (_a = this.preferredQuote) != null ? _a : \"'\");\n  }\n};\nvar PythonLocatorFactory = class {\n  generateLocator(base, kind, body, options = {}) {\n    switch (kind) {\n      case \"default\":\n        if (options.hasText !== void 0)\n          return `locator(${this.quote(body)}, has_text=${this.toHasText(options.hasText)})`;\n        if (options.hasNotText !== void 0)\n          return `locator(${this.quote(body)}, has_not_text=${this.toHasText(options.hasNotText)})`;\n        return `locator(${this.quote(body)})`;\n      case \"frame-locator\":\n        return `frame_locator(${this.quote(body)})`;\n      case \"frame\":\n        return `content_frame`;\n      case \"nth\":\n        return `nth(${body})`;\n      case \"first\":\n        return `first`;\n      case \"last\":\n        return `last`;\n      case \"visible\":\n        return `filter(visible=${body === \"true\" ? \"True\" : \"False\"})`;\n      case \"role\":\n        const attrs = [];\n        if (isRegExp(options.name)) {\n          attrs.push(`name=${this.regexToString(options.name)}`);\n        } else if (typeof options.name === \"string\") {\n          attrs.push(`name=${this.quote(options.name)}`);\n          if (options.exact)\n            attrs.push(`exact=True`);\n        }\n        for (const { name, value } of options.attrs) {\n          let valueString = typeof value === \"string\" ? this.quote(value) : value;\n          if (typeof value === \"boolean\")\n            valueString = value ? \"True\" : \"False\";\n          attrs.push(`${toSnakeCase(name)}=${valueString}`);\n        }\n        const attrString = attrs.length ? `, ${attrs.join(\", \")}` : \"\";\n        return `get_by_role(${this.quote(body)}${attrString})`;\n      case \"has-text\":\n        return `filter(has_text=${this.toHasText(body)})`;\n      case \"has-not-text\":\n        return `filter(has_not_text=${this.toHasText(body)})`;\n      case \"has\":\n        return `filter(has=${body})`;\n      case \"hasNot\":\n        return `filter(has_not=${body})`;\n      case \"and\":\n        return `and_(${body})`;\n      case \"or\":\n        return `or_(${body})`;\n      case \"chain\":\n        return `locator(${body})`;\n      case \"test-id\":\n        return `get_by_test_id(${this.toTestIdValue(body)})`;\n      case \"text\":\n        return this.toCallWithExact(\"get_by_text\", body, !!options.exact);\n      case \"alt\":\n        return this.toCallWithExact(\"get_by_alt_text\", body, !!options.exact);\n      case \"placeholder\":\n        return this.toCallWithExact(\"get_by_placeholder\", body, !!options.exact);\n      case \"label\":\n        return this.toCallWithExact(\"get_by_label\", body, !!options.exact);\n      case \"title\":\n        return this.toCallWithExact(\"get_by_title\", body, !!options.exact);\n      default:\n        throw new Error(\"Unknown selector kind \" + kind);\n    }\n  }\n  chainLocators(locators) {\n    return locators.join(\".\");\n  }\n  regexToString(body) {\n    const suffix = body.flags.includes(\"i\") ? \", re.IGNORECASE\" : \"\";\n    return `re.compile(r\"${normalizeEscapedRegexQuotes(body.source).replace(/\\\\\\//, \"/\").replace(/\"/g, '\\\\\"')}\"${suffix})`;\n  }\n  toCallWithExact(method, body, exact) {\n    if (isRegExp(body))\n      return `${method}(${this.regexToString(body)})`;\n    if (exact)\n      return `${method}(${this.quote(body)}, exact=True)`;\n    return `${method}(${this.quote(body)})`;\n  }\n  toHasText(body) {\n    if (isRegExp(body))\n      return this.regexToString(body);\n    return `${this.quote(body)}`;\n  }\n  toTestIdValue(value) {\n    if (isRegExp(value))\n      return this.regexToString(value);\n    return this.quote(value);\n  }\n  quote(text) {\n    return escapeWithQuotes(text, '\"');\n  }\n};\nvar JavaLocatorFactory = class {\n  generateLocator(base, kind, body, options = {}) {\n    let clazz;\n    switch (base) {\n      case \"page\":\n        clazz = \"Page\";\n        break;\n      case \"frame-locator\":\n        clazz = \"FrameLocator\";\n        break;\n      case \"locator\":\n        clazz = \"Locator\";\n        break;\n    }\n    switch (kind) {\n      case \"default\":\n        if (options.hasText !== void 0)\n          return `locator(${this.quote(body)}, new ${clazz}.LocatorOptions().setHasText(${this.toHasText(options.hasText)}))`;\n        if (options.hasNotText !== void 0)\n          return `locator(${this.quote(body)}, new ${clazz}.LocatorOptions().setHasNotText(${this.toHasText(options.hasNotText)}))`;\n        return `locator(${this.quote(body)})`;\n      case \"frame-locator\":\n        return `frameLocator(${this.quote(body)})`;\n      case \"frame\":\n        return `contentFrame()`;\n      case \"nth\":\n        return `nth(${body})`;\n      case \"first\":\n        return `first()`;\n      case \"last\":\n        return `last()`;\n      case \"visible\":\n        return `filter(new ${clazz}.FilterOptions().setVisible(${body === \"true\" ? \"true\" : \"false\"}))`;\n      case \"role\":\n        const attrs = [];\n        if (isRegExp(options.name)) {\n          attrs.push(`.setName(${this.regexToString(options.name)})`);\n        } else if (typeof options.name === \"string\") {\n          attrs.push(`.setName(${this.quote(options.name)})`);\n          if (options.exact)\n            attrs.push(`.setExact(true)`);\n        }\n        for (const { name, value } of options.attrs)\n          attrs.push(`.set${toTitleCase(name)}(${typeof value === \"string\" ? this.quote(value) : value})`);\n        const attrString = attrs.length ? `, new ${clazz}.GetByRoleOptions()${attrs.join(\"\")}` : \"\";\n        return `getByRole(AriaRole.${toSnakeCase(body).toUpperCase()}${attrString})`;\n      case \"has-text\":\n        return `filter(new ${clazz}.FilterOptions().setHasText(${this.toHasText(body)}))`;\n      case \"has-not-text\":\n        return `filter(new ${clazz}.FilterOptions().setHasNotText(${this.toHasText(body)}))`;\n      case \"has\":\n        return `filter(new ${clazz}.FilterOptions().setHas(${body}))`;\n      case \"hasNot\":\n        return `filter(new ${clazz}.FilterOptions().setHasNot(${body}))`;\n      case \"and\":\n        return `and(${body})`;\n      case \"or\":\n        return `or(${body})`;\n      case \"chain\":\n        return `locator(${body})`;\n      case \"test-id\":\n        return `getByTestId(${this.toTestIdValue(body)})`;\n      case \"text\":\n        return this.toCallWithExact(clazz, \"getByText\", body, !!options.exact);\n      case \"alt\":\n        return this.toCallWithExact(clazz, \"getByAltText\", body, !!options.exact);\n      case \"placeholder\":\n        return this.toCallWithExact(clazz, \"getByPlaceholder\", body, !!options.exact);\n      case \"label\":\n        return this.toCallWithExact(clazz, \"getByLabel\", body, !!options.exact);\n      case \"title\":\n        return this.toCallWithExact(clazz, \"getByTitle\", body, !!options.exact);\n      default:\n        throw new Error(\"Unknown selector kind \" + kind);\n    }\n  }\n  chainLocators(locators) {\n    return locators.join(\".\");\n  }\n  regexToString(body) {\n    const suffix = body.flags.includes(\"i\") ? \", Pattern.CASE_INSENSITIVE\" : \"\";\n    return `Pattern.compile(${this.quote(normalizeEscapedRegexQuotes(body.source))}${suffix})`;\n  }\n  toCallWithExact(clazz, method, body, exact) {\n    if (isRegExp(body))\n      return `${method}(${this.regexToString(body)})`;\n    if (exact)\n      return `${method}(${this.quote(body)}, new ${clazz}.${toTitleCase(method)}Options().setExact(true))`;\n    return `${method}(${this.quote(body)})`;\n  }\n  toHasText(body) {\n    if (isRegExp(body))\n      return this.regexToString(body);\n    return this.quote(body);\n  }\n  toTestIdValue(value) {\n    if (isRegExp(value))\n      return this.regexToString(value);\n    return this.quote(value);\n  }\n  quote(text) {\n    return escapeWithQuotes(text, '\"');\n  }\n};\nvar CSharpLocatorFactory = class {\n  generateLocator(base, kind, body, options = {}) {\n    switch (kind) {\n      case \"default\":\n        if (options.hasText !== void 0)\n          return `Locator(${this.quote(body)}, new() { ${this.toHasText(options.hasText)} })`;\n        if (options.hasNotText !== void 0)\n          return `Locator(${this.quote(body)}, new() { ${this.toHasNotText(options.hasNotText)} })`;\n        return `Locator(${this.quote(body)})`;\n      case \"frame-locator\":\n        return `FrameLocator(${this.quote(body)})`;\n      case \"frame\":\n        return `ContentFrame`;\n      case \"nth\":\n        return `Nth(${body})`;\n      case \"first\":\n        return `First`;\n      case \"last\":\n        return `Last`;\n      case \"visible\":\n        return `Filter(new() { Visible = ${body === \"true\" ? \"true\" : \"false\"} })`;\n      case \"role\":\n        const attrs = [];\n        if (isRegExp(options.name)) {\n          attrs.push(`NameRegex = ${this.regexToString(options.name)}`);\n        } else if (typeof options.name === \"string\") {\n          attrs.push(`Name = ${this.quote(options.name)}`);\n          if (options.exact)\n            attrs.push(`Exact = true`);\n        }\n        for (const { name, value } of options.attrs)\n          attrs.push(`${toTitleCase(name)} = ${typeof value === \"string\" ? this.quote(value) : value}`);\n        const attrString = attrs.length ? `, new() { ${attrs.join(\", \")} }` : \"\";\n        return `GetByRole(AriaRole.${toTitleCase(body)}${attrString})`;\n      case \"has-text\":\n        return `Filter(new() { ${this.toHasText(body)} })`;\n      case \"has-not-text\":\n        return `Filter(new() { ${this.toHasNotText(body)} })`;\n      case \"has\":\n        return `Filter(new() { Has = ${body} })`;\n      case \"hasNot\":\n        return `Filter(new() { HasNot = ${body} })`;\n      case \"and\":\n        return `And(${body})`;\n      case \"or\":\n        return `Or(${body})`;\n      case \"chain\":\n        return `Locator(${body})`;\n      case \"test-id\":\n        return `GetByTestId(${this.toTestIdValue(body)})`;\n      case \"text\":\n        return this.toCallWithExact(\"GetByText\", body, !!options.exact);\n      case \"alt\":\n        return this.toCallWithExact(\"GetByAltText\", body, !!options.exact);\n      case \"placeholder\":\n        return this.toCallWithExact(\"GetByPlaceholder\", body, !!options.exact);\n      case \"label\":\n        return this.toCallWithExact(\"GetByLabel\", body, !!options.exact);\n      case \"title\":\n        return this.toCallWithExact(\"GetByTitle\", body, !!options.exact);\n      default:\n        throw new Error(\"Unknown selector kind \" + kind);\n    }\n  }\n  chainLocators(locators) {\n    return locators.join(\".\");\n  }\n  regexToString(body) {\n    const suffix = body.flags.includes(\"i\") ? \", RegexOptions.IgnoreCase\" : \"\";\n    return `new Regex(${this.quote(normalizeEscapedRegexQuotes(body.source))}${suffix})`;\n  }\n  toCallWithExact(method, body, exact) {\n    if (isRegExp(body))\n      return `${method}(${this.regexToString(body)})`;\n    if (exact)\n      return `${method}(${this.quote(body)}, new() { Exact = true })`;\n    return `${method}(${this.quote(body)})`;\n  }\n  toHasText(body) {\n    if (isRegExp(body))\n      return `HasTextRegex = ${this.regexToString(body)}`;\n    return `HasText = ${this.quote(body)}`;\n  }\n  toTestIdValue(value) {\n    if (isRegExp(value))\n      return this.regexToString(value);\n    return this.quote(value);\n  }\n  toHasNotText(body) {\n    if (isRegExp(body))\n      return `HasNotTextRegex = ${this.regexToString(body)}`;\n    return `HasNotText = ${this.quote(body)}`;\n  }\n  quote(text) {\n    return escapeWithQuotes(text, '\"');\n  }\n};\nvar JsonlLocatorFactory = class {\n  generateLocator(base, kind, body, options = {}) {\n    return JSON.stringify({\n      kind,\n      body,\n      options\n    });\n  }\n  chainLocators(locators) {\n    const objects = locators.map((l) => JSON.parse(l));\n    for (let i = 0; i < objects.length - 1; ++i)\n      objects[i].next = objects[i + 1];\n    return JSON.stringify(objects[0]);\n  }\n};\nvar generators = {\n  javascript: JavaScriptLocatorFactory,\n  python: PythonLocatorFactory,\n  java: JavaLocatorFactory,\n  csharp: CSharpLocatorFactory,\n  jsonl: JsonlLocatorFactory\n};\nfunction isRegExp(obj) {\n  return obj instanceof RegExp;\n}\n\n// packages/injected/src/domUtils.ts\nvar globalOptions = {};\nfunction setGlobalOptions(options) {\n  globalOptions = options;\n}\nfunction getGlobalOptions() {\n  return globalOptions;\n}\nfunction isInsideScope(scope, element) {\n  while (element) {\n    if (scope.contains(element))\n      return true;\n    element = enclosingShadowHost(element);\n  }\n  return false;\n}\nfunction parentElementOrShadowHost(element) {\n  if (element.parentElement)\n    return element.parentElement;\n  if (!element.parentNode)\n    return;\n  if (element.parentNode.nodeType === 11 && element.parentNode.host)\n    return element.parentNode.host;\n}\nfunction enclosingShadowRootOrDocument(element) {\n  let node = element;\n  while (node.parentNode)\n    node = node.parentNode;\n  if (node.nodeType === 11 || node.nodeType === 9)\n    return node;\n}\nfunction enclosingShadowHost(element) {\n  while (element.parentElement)\n    element = element.parentElement;\n  return parentElementOrShadowHost(element);\n}\nfunction closestCrossShadow(element, css, scope) {\n  while (element) {\n    const closest = element.closest(css);\n    if (scope && closest !== scope && (closest == null ? void 0 : closest.contains(scope)))\n      return;\n    if (closest)\n      return closest;\n    element = enclosingShadowHost(element);\n  }\n}\nfunction getElementComputedStyle(element, pseudo) {\n  return element.ownerDocument && element.ownerDocument.defaultView ? element.ownerDocument.defaultView.getComputedStyle(element, pseudo) : void 0;\n}\nfunction isElementStyleVisibilityVisible(element, style) {\n  style = style != null ? style : getElementComputedStyle(element);\n  if (!style)\n    return true;\n  if (Element.prototype.checkVisibility && globalOptions.browserNameForWorkarounds !== \"webkit\") {\n    if (!element.checkVisibility())\n      return false;\n  } else {\n    const detailsOrSummary = element.closest(\"details,summary\");\n    if (detailsOrSummary !== element && (detailsOrSummary == null ? void 0 : detailsOrSummary.nodeName) === \"DETAILS\" && !detailsOrSummary.open)\n      return false;\n  }\n  if (style.visibility !== \"visible\")\n    return false;\n  return true;\n}\nfunction isElementVisible(element) {\n  const style = getElementComputedStyle(element);\n  if (!style)\n    return true;\n  if (style.display === \"contents\") {\n    for (let child = element.firstChild; child; child = child.nextSibling) {\n      if (child.nodeType === 1 && isElementVisible(child))\n        return true;\n      if (child.nodeType === 3 && isVisibleTextNode(child))\n        return true;\n    }\n    return false;\n  }\n  if (!isElementStyleVisibilityVisible(element, style))\n    return false;\n  const rect = element.getBoundingClientRect();\n  return rect.width > 0 && rect.height > 0;\n}\nfunction isVisibleTextNode(node) {\n  const range = node.ownerDocument.createRange();\n  range.selectNode(node);\n  const rect = range.getBoundingClientRect();\n  return rect.width > 0 && rect.height > 0;\n}\nfunction elementSafeTagName(element) {\n  if (element instanceof HTMLFormElement)\n    return \"FORM\";\n  return element.tagName.toUpperCase();\n}\n\n// packages/injected/src/roleUtils.ts\nfunction hasExplicitAccessibleName(e) {\n  return e.hasAttribute(\"aria-label\") || e.hasAttribute(\"aria-labelledby\");\n}\nvar kAncestorPreventingLandmark = \"article:not([role]), aside:not([role]), main:not([role]), nav:not([role]), section:not([role]), [role=article], [role=complementary], [role=main], [role=navigation], [role=region]\";\nvar kGlobalAriaAttributes = [\n  [\"aria-atomic\", void 0],\n  [\"aria-busy\", void 0],\n  [\"aria-controls\", void 0],\n  [\"aria-current\", void 0],\n  [\"aria-describedby\", void 0],\n  [\"aria-details\", void 0],\n  // Global use deprecated in ARIA 1.2\n  // ['aria-disabled', undefined],\n  [\"aria-dropeffect\", void 0],\n  // Global use deprecated in ARIA 1.2\n  // ['aria-errormessage', undefined],\n  [\"aria-flowto\", void 0],\n  [\"aria-grabbed\", void 0],\n  // Global use deprecated in ARIA 1.2\n  // ['aria-haspopup', undefined],\n  [\"aria-hidden\", void 0],\n  // Global use deprecated in ARIA 1.2\n  // ['aria-invalid', undefined],\n  [\"aria-keyshortcuts\", void 0],\n  [\"aria-label\", [\"caption\", \"code\", \"deletion\", \"emphasis\", \"generic\", \"insertion\", \"paragraph\", \"presentation\", \"strong\", \"subscript\", \"superscript\"]],\n  [\"aria-labelledby\", [\"caption\", \"code\", \"deletion\", \"emphasis\", \"generic\", \"insertion\", \"paragraph\", \"presentation\", \"strong\", \"subscript\", \"superscript\"]],\n  [\"aria-live\", void 0],\n  [\"aria-owns\", void 0],\n  [\"aria-relevant\", void 0],\n  [\"aria-roledescription\", [\"generic\"]]\n];\nfunction hasGlobalAriaAttribute(element, forRole) {\n  return kGlobalAriaAttributes.some(([attr, prohibited]) => {\n    return !(prohibited == null ? void 0 : prohibited.includes(forRole || \"\")) && element.hasAttribute(attr);\n  });\n}\nfunction hasTabIndex(element) {\n  return !Number.isNaN(Number(String(element.getAttribute(\"tabindex\"))));\n}\nfunction isFocusable(element) {\n  return !isNativelyDisabled(element) && (isNativelyFocusable(element) || hasTabIndex(element));\n}\nfunction isNativelyFocusable(element) {\n  const tagName = elementSafeTagName(element);\n  if ([\"BUTTON\", \"DETAILS\", \"SELECT\", \"TEXTAREA\"].includes(tagName))\n    return true;\n  if (tagName === \"A\" || tagName === \"AREA\")\n    return element.hasAttribute(\"href\");\n  if (tagName === \"INPUT\")\n    return !element.hidden;\n  return false;\n}\nvar kImplicitRoleByTagName = {\n  \"A\": (e) => {\n    return e.hasAttribute(\"href\") ? \"link\" : null;\n  },\n  \"AREA\": (e) => {\n    return e.hasAttribute(\"href\") ? \"link\" : null;\n  },\n  \"ARTICLE\": () => \"article\",\n  \"ASIDE\": () => \"complementary\",\n  \"BLOCKQUOTE\": () => \"blockquote\",\n  \"BUTTON\": () => \"button\",\n  \"CAPTION\": () => \"caption\",\n  \"CODE\": () => \"code\",\n  \"DATALIST\": () => \"listbox\",\n  \"DD\": () => \"definition\",\n  \"DEL\": () => \"deletion\",\n  \"DETAILS\": () => \"group\",\n  \"DFN\": () => \"term\",\n  \"DIALOG\": () => \"dialog\",\n  \"DT\": () => \"term\",\n  \"EM\": () => \"emphasis\",\n  \"FIELDSET\": () => \"group\",\n  \"FIGURE\": () => \"figure\",\n  \"FOOTER\": (e) => closestCrossShadow(e, kAncestorPreventingLandmark) ? null : \"contentinfo\",\n  \"FORM\": (e) => hasExplicitAccessibleName(e) ? \"form\" : null,\n  \"H1\": () => \"heading\",\n  \"H2\": () => \"heading\",\n  \"H3\": () => \"heading\",\n  \"H4\": () => \"heading\",\n  \"H5\": () => \"heading\",\n  \"H6\": () => \"heading\",\n  \"HEADER\": (e) => closestCrossShadow(e, kAncestorPreventingLandmark) ? null : \"banner\",\n  \"HR\": () => \"separator\",\n  \"HTML\": () => \"document\",\n  \"IMG\": (e) => e.getAttribute(\"alt\") === \"\" && !e.getAttribute(\"title\") && !hasGlobalAriaAttribute(e) && !hasTabIndex(e) ? \"presentation\" : \"img\",\n  \"INPUT\": (e) => {\n    const type = e.type.toLowerCase();\n    if (type === \"search\")\n      return e.hasAttribute(\"list\") ? \"combobox\" : \"searchbox\";\n    if ([\"email\", \"tel\", \"text\", \"url\", \"\"].includes(type)) {\n      const list = getIdRefs(e, e.getAttribute(\"list\"))[0];\n      return list && elementSafeTagName(list) === \"DATALIST\" ? \"combobox\" : \"textbox\";\n    }\n    if (type === \"hidden\")\n      return null;\n    if (type === \"file\" && !getGlobalOptions().inputFileRoleTextbox)\n      return \"button\";\n    return inputTypeToRole[type] || \"textbox\";\n  },\n  \"INS\": () => \"insertion\",\n  \"LI\": () => \"listitem\",\n  \"MAIN\": () => \"main\",\n  \"MARK\": () => \"mark\",\n  \"MATH\": () => \"math\",\n  \"MENU\": () => \"list\",\n  \"METER\": () => \"meter\",\n  \"NAV\": () => \"navigation\",\n  \"OL\": () => \"list\",\n  \"OPTGROUP\": () => \"group\",\n  \"OPTION\": () => \"option\",\n  \"OUTPUT\": () => \"status\",\n  \"P\": () => \"paragraph\",\n  \"PROGRESS\": () => \"progressbar\",\n  \"SECTION\": (e) => hasExplicitAccessibleName(e) ? \"region\" : null,\n  \"SELECT\": (e) => e.hasAttribute(\"multiple\") || e.size > 1 ? \"listbox\" : \"combobox\",\n  \"STRONG\": () => \"strong\",\n  \"SUB\": () => \"subscript\",\n  \"SUP\": () => \"superscript\",\n  // For <svg> we default to Chrome behavior:\n  // - Chrome reports 'img'.\n  // - Firefox reports 'diagram' that is not in official ARIA spec yet.\n  // - Safari reports 'no role', but still computes accessible name.\n  \"SVG\": () => \"img\",\n  \"TABLE\": () => \"table\",\n  \"TBODY\": () => \"rowgroup\",\n  \"TD\": (e) => {\n    const table = closestCrossShadow(e, \"table\");\n    const role = table ? getExplicitAriaRole(table) : \"\";\n    return role === \"grid\" || role === \"treegrid\" ? \"gridcell\" : \"cell\";\n  },\n  \"TEXTAREA\": () => \"textbox\",\n  \"TFOOT\": () => \"rowgroup\",\n  \"TH\": (e) => {\n    if (e.getAttribute(\"scope\") === \"col\")\n      return \"columnheader\";\n    if (e.getAttribute(\"scope\") === \"row\")\n      return \"rowheader\";\n    const table = closestCrossShadow(e, \"table\");\n    const role = table ? getExplicitAriaRole(table) : \"\";\n    return role === \"grid\" || role === \"treegrid\" ? \"gridcell\" : \"cell\";\n  },\n  \"THEAD\": () => \"rowgroup\",\n  \"TIME\": () => \"time\",\n  \"TR\": () => \"row\",\n  \"UL\": () => \"list\"\n};\nvar kPresentationInheritanceParents = {\n  \"DD\": [\"DL\", \"DIV\"],\n  \"DIV\": [\"DL\"],\n  \"DT\": [\"DL\", \"DIV\"],\n  \"LI\": [\"OL\", \"UL\"],\n  \"TBODY\": [\"TABLE\"],\n  \"TD\": [\"TR\"],\n  \"TFOOT\": [\"TABLE\"],\n  \"TH\": [\"TR\"],\n  \"THEAD\": [\"TABLE\"],\n  \"TR\": [\"THEAD\", \"TBODY\", \"TFOOT\", \"TABLE\"]\n};\nfunction getImplicitAriaRole(element) {\n  var _a;\n  const implicitRole = ((_a = kImplicitRoleByTagName[elementSafeTagName(element)]) == null ? void 0 : _a.call(kImplicitRoleByTagName, element)) || \"\";\n  if (!implicitRole)\n    return null;\n  let ancestor = element;\n  while (ancestor) {\n    const parent = parentElementOrShadowHost(ancestor);\n    const parents = kPresentationInheritanceParents[elementSafeTagName(ancestor)];\n    if (!parents || !parent || !parents.includes(elementSafeTagName(parent)))\n      break;\n    const parentExplicitRole = getExplicitAriaRole(parent);\n    if ((parentExplicitRole === \"none\" || parentExplicitRole === \"presentation\") && !hasPresentationConflictResolution(parent, parentExplicitRole))\n      return parentExplicitRole;\n    ancestor = parent;\n  }\n  return implicitRole;\n}\nvar validRoles = [\n  \"alert\",\n  \"alertdialog\",\n  \"application\",\n  \"article\",\n  \"banner\",\n  \"blockquote\",\n  \"button\",\n  \"caption\",\n  \"cell\",\n  \"checkbox\",\n  \"code\",\n  \"columnheader\",\n  \"combobox\",\n  \"complementary\",\n  \"contentinfo\",\n  \"definition\",\n  \"deletion\",\n  \"dialog\",\n  \"directory\",\n  \"document\",\n  \"emphasis\",\n  \"feed\",\n  \"figure\",\n  \"form\",\n  \"generic\",\n  \"grid\",\n  \"gridcell\",\n  \"group\",\n  \"heading\",\n  \"img\",\n  \"insertion\",\n  \"link\",\n  \"list\",\n  \"listbox\",\n  \"listitem\",\n  \"log\",\n  \"main\",\n  \"mark\",\n  \"marquee\",\n  \"math\",\n  \"meter\",\n  \"menu\",\n  \"menubar\",\n  \"menuitem\",\n  \"menuitemcheckbox\",\n  \"menuitemradio\",\n  \"navigation\",\n  \"none\",\n  \"note\",\n  \"option\",\n  \"paragraph\",\n  \"presentation\",\n  \"progressbar\",\n  \"radio\",\n  \"radiogroup\",\n  \"region\",\n  \"row\",\n  \"rowgroup\",\n  \"rowheader\",\n  \"scrollbar\",\n  \"search\",\n  \"searchbox\",\n  \"separator\",\n  \"slider\",\n  \"spinbutton\",\n  \"status\",\n  \"strong\",\n  \"subscript\",\n  \"superscript\",\n  \"switch\",\n  \"tab\",\n  \"table\",\n  \"tablist\",\n  \"tabpanel\",\n  \"term\",\n  \"textbox\",\n  \"time\",\n  \"timer\",\n  \"toolbar\",\n  \"tooltip\",\n  \"tree\",\n  \"treegrid\",\n  \"treeitem\"\n];\nfunction getExplicitAriaRole(element) {\n  const roles = (element.getAttribute(\"role\") || \"\").split(\" \").map((role) => role.trim());\n  return roles.find((role) => validRoles.includes(role)) || null;\n}\nfunction hasPresentationConflictResolution(element, role) {\n  return hasGlobalAriaAttribute(element, role) || isFocusable(element);\n}\nfunction getAriaRole(element) {\n  const explicitRole = getExplicitAriaRole(element);\n  if (!explicitRole)\n    return getImplicitAriaRole(element);\n  if (explicitRole === \"none\" || explicitRole === \"presentation\") {\n    const implicitRole = getImplicitAriaRole(element);\n    if (hasPresentationConflictResolution(element, implicitRole))\n      return implicitRole;\n  }\n  return explicitRole;\n}\nfunction getAriaBoolean(attr) {\n  return attr === null ? void 0 : attr.toLowerCase() === \"true\";\n}\nfunction isElementIgnoredForAria(element) {\n  return [\"STYLE\", \"SCRIPT\", \"NOSCRIPT\", \"TEMPLATE\"].includes(elementSafeTagName(element));\n}\nfunction isElementHiddenForAria(element) {\n  if (isElementIgnoredForAria(element))\n    return true;\n  const style = getElementComputedStyle(element);\n  const isSlot = element.nodeName === \"SLOT\";\n  if ((style == null ? void 0 : style.display) === \"contents\" && !isSlot) {\n    for (let child = element.firstChild; child; child = child.nextSibling) {\n      if (child.nodeType === 1 && !isElementHiddenForAria(child))\n        return false;\n      if (child.nodeType === 3 && isVisibleTextNode(child))\n        return false;\n    }\n    return true;\n  }\n  const isOptionInsideSelect = element.nodeName === \"OPTION\" && !!element.closest(\"select\");\n  if (!isOptionInsideSelect && !isSlot && !isElementStyleVisibilityVisible(element, style))\n    return true;\n  return belongsToDisplayNoneOrAriaHiddenOrNonSlotted(element);\n}\nfunction belongsToDisplayNoneOrAriaHiddenOrNonSlotted(element) {\n  let hidden = cacheIsHidden == null ? void 0 : cacheIsHidden.get(element);\n  if (hidden === void 0) {\n    hidden = false;\n    if (element.parentElement && element.parentElement.shadowRoot && !element.assignedSlot)\n      hidden = true;\n    if (!hidden) {\n      const style = getElementComputedStyle(element);\n      hidden = !style || style.display === \"none\" || getAriaBoolean(element.getAttribute(\"aria-hidden\")) === true;\n    }\n    if (!hidden) {\n      const parent = parentElementOrShadowHost(element);\n      if (parent)\n        hidden = belongsToDisplayNoneOrAriaHiddenOrNonSlotted(parent);\n    }\n    cacheIsHidden == null ? void 0 : cacheIsHidden.set(element, hidden);\n  }\n  return hidden;\n}\nfunction getIdRefs(element, ref) {\n  if (!ref)\n    return [];\n  const root = enclosingShadowRootOrDocument(element);\n  if (!root)\n    return [];\n  try {\n    const ids = ref.split(\" \").filter((id) => !!id);\n    const result = [];\n    for (const id of ids) {\n      const firstElement = root.querySelector(\"#\" + CSS.escape(id));\n      if (firstElement && !result.includes(firstElement))\n        result.push(firstElement);\n    }\n    return result;\n  } catch (e) {\n    return [];\n  }\n}\nfunction trimFlatString(s) {\n  return s.trim();\n}\nfunction asFlatString(s) {\n  return s.split(\"\\xA0\").map((chunk) => chunk.replace(/\\r\\n/g, \"\\n\").replace(/[\\u200b\\u00ad]/g, \"\").replace(/\\s\\s*/g, \" \")).join(\"\\xA0\").trim();\n}\nfunction queryInAriaOwned(element, selector) {\n  const result = [...element.querySelectorAll(selector)];\n  for (const owned of getIdRefs(element, element.getAttribute(\"aria-owns\"))) {\n    if (owned.matches(selector))\n      result.push(owned);\n    result.push(...owned.querySelectorAll(selector));\n  }\n  return result;\n}\nfunction getPseudoContent(element, pseudo) {\n  const cache = pseudo === \"::before\" ? cachePseudoContentBefore : cachePseudoContentAfter;\n  if (cache == null ? void 0 : cache.has(element))\n    return (cache == null ? void 0 : cache.get(element)) || \"\";\n  const pseudoStyle = getElementComputedStyle(element, pseudo);\n  const content = getPseudoContentImpl(element, pseudoStyle);\n  if (cache)\n    cache.set(element, content);\n  return content;\n}\nfunction getPseudoContentImpl(element, pseudoStyle) {\n  if (!pseudoStyle || pseudoStyle.display === \"none\" || pseudoStyle.visibility === \"hidden\")\n    return \"\";\n  const content = pseudoStyle.content;\n  let resolvedContent;\n  if (content[0] === \"'\" && content[content.length - 1] === \"'\" || content[0] === '\"' && content[content.length - 1] === '\"') {\n    resolvedContent = content.substring(1, content.length - 1);\n  } else if (content.startsWith(\"attr(\") && content.endsWith(\")\")) {\n    const attrName = content.substring(\"attr(\".length, content.length - 1).trim();\n    resolvedContent = element.getAttribute(attrName) || \"\";\n  }\n  if (resolvedContent !== void 0) {\n    const display = pseudoStyle.display || \"inline\";\n    if (display !== \"inline\")\n      return \" \" + resolvedContent + \" \";\n    return resolvedContent;\n  }\n  return \"\";\n}\nfunction getAriaLabelledByElements(element) {\n  const ref = element.getAttribute(\"aria-labelledby\");\n  if (ref === null)\n    return null;\n  const refs = getIdRefs(element, ref);\n  return refs.length ? refs : null;\n}\nfunction allowsNameFromContent(role, targetDescendant) {\n  const alwaysAllowsNameFromContent = [\"button\", \"cell\", \"checkbox\", \"columnheader\", \"gridcell\", \"heading\", \"link\", \"menuitem\", \"menuitemcheckbox\", \"menuitemradio\", \"option\", \"radio\", \"row\", \"rowheader\", \"switch\", \"tab\", \"tooltip\", \"treeitem\"].includes(role);\n  const descendantAllowsNameFromContent = targetDescendant && [\"\", \"caption\", \"code\", \"contentinfo\", \"definition\", \"deletion\", \"emphasis\", \"insertion\", \"list\", \"listitem\", \"mark\", \"none\", \"paragraph\", \"presentation\", \"region\", \"row\", \"rowgroup\", \"section\", \"strong\", \"subscript\", \"superscript\", \"table\", \"term\", \"time\"].includes(role);\n  return alwaysAllowsNameFromContent || descendantAllowsNameFromContent;\n}\nfunction getElementAccessibleName(element, includeHidden) {\n  const cache = includeHidden ? cacheAccessibleNameHidden : cacheAccessibleName;\n  let accessibleName = cache == null ? void 0 : cache.get(element);\n  if (accessibleName === void 0) {\n    accessibleName = \"\";\n    const elementProhibitsNaming = [\"caption\", \"code\", \"definition\", \"deletion\", \"emphasis\", \"generic\", \"insertion\", \"mark\", \"paragraph\", \"presentation\", \"strong\", \"subscript\", \"suggestion\", \"superscript\", \"term\", \"time\"].includes(getAriaRole(element) || \"\");\n    if (!elementProhibitsNaming) {\n      accessibleName = asFlatString(getTextAlternativeInternal(element, {\n        includeHidden,\n        visitedElements: new Set(),\n        embeddedInTargetElement: \"self\"\n      }));\n    }\n    cache == null ? void 0 : cache.set(element, accessibleName);\n  }\n  return accessibleName;\n}\nfunction getElementAccessibleDescription(element, includeHidden) {\n  const cache = includeHidden ? cacheAccessibleDescriptionHidden : cacheAccessibleDescription;\n  let accessibleDescription = cache == null ? void 0 : cache.get(element);\n  if (accessibleDescription === void 0) {\n    accessibleDescription = \"\";\n    if (element.hasAttribute(\"aria-describedby\")) {\n      const describedBy = getIdRefs(element, element.getAttribute(\"aria-describedby\"));\n      accessibleDescription = asFlatString(describedBy.map((ref) => getTextAlternativeInternal(ref, {\n        includeHidden,\n        visitedElements: new Set(),\n        embeddedInDescribedBy: { element: ref, hidden: isElementHiddenForAria(ref) }\n      })).join(\" \"));\n    } else if (element.hasAttribute(\"aria-description\")) {\n      accessibleDescription = asFlatString(element.getAttribute(\"aria-description\") || \"\");\n    } else {\n      accessibleDescription = asFlatString(element.getAttribute(\"title\") || \"\");\n    }\n    cache == null ? void 0 : cache.set(element, accessibleDescription);\n  }\n  return accessibleDescription;\n}\nvar kAriaInvalidRoles = [\"application\", \"checkbox\", \"combobox\", \"gridcell\", \"listbox\", \"radiogroup\", \"slider\", \"spinbutton\", \"textbox\", \"tree\", \"columnheader\", \"rowheader\", \"searchbox\", \"switch\", \"treegrid\"];\nfunction getAriaInvalid(element) {\n  const role = getAriaRole(element) || \"\";\n  if (!role || !kAriaInvalidRoles.includes(role))\n    return \"false\";\n  const ariaInvalid = element.getAttribute(\"aria-invalid\");\n  if (!ariaInvalid || ariaInvalid.trim() === \"\" || ariaInvalid.toLocaleLowerCase() === \"false\")\n    return \"false\";\n  if (ariaInvalid === \"true\" || ariaInvalid === \"grammar\" || ariaInvalid === \"spelling\")\n    return ariaInvalid;\n  return \"true\";\n}\nfunction getValidityInvalid(element) {\n  if (\"validity\" in element) {\n    const validity = element.validity;\n    return (validity == null ? void 0 : validity.valid) === false;\n  }\n  return false;\n}\nfunction getElementAccessibleErrorMessage(element) {\n  const cache = cacheAccessibleErrorMessage;\n  let accessibleErrorMessage = cacheAccessibleErrorMessage == null ? void 0 : cacheAccessibleErrorMessage.get(element);\n  if (accessibleErrorMessage === void 0) {\n    accessibleErrorMessage = \"\";\n    const isAriaInvalid = getAriaInvalid(element) !== \"false\";\n    const isValidityInvalid = getValidityInvalid(element);\n    if (isAriaInvalid || isValidityInvalid) {\n      const errorMessageId = element.getAttribute(\"aria-errormessage\");\n      const errorMessages = getIdRefs(element, errorMessageId);\n      const parts = errorMessages.map((errorMessage) => asFlatString(\n        getTextAlternativeInternal(errorMessage, {\n          visitedElements: new Set(),\n          embeddedInDescribedBy: { element: errorMessage, hidden: isElementHiddenForAria(errorMessage) }\n        })\n      ));\n      accessibleErrorMessage = parts.join(\" \").trim();\n    }\n    cache == null ? void 0 : cache.set(element, accessibleErrorMessage);\n  }\n  return accessibleErrorMessage;\n}\nfunction getTextAlternativeInternal(element, options) {\n  var _a, _b, _c, _d;\n  if (options.visitedElements.has(element))\n    return \"\";\n  const childOptions = {\n    ...options,\n    embeddedInTargetElement: options.embeddedInTargetElement === \"self\" ? \"descendant\" : options.embeddedInTargetElement\n  };\n  if (!options.includeHidden) {\n    const isEmbeddedInHiddenReferenceTraversal = !!((_a = options.embeddedInLabelledBy) == null ? void 0 : _a.hidden) || !!((_b = options.embeddedInDescribedBy) == null ? void 0 : _b.hidden) || !!((_c = options.embeddedInNativeTextAlternative) == null ? void 0 : _c.hidden) || !!((_d = options.embeddedInLabel) == null ? void 0 : _d.hidden);\n    if (isElementIgnoredForAria(element) || !isEmbeddedInHiddenReferenceTraversal && isElementHiddenForAria(element)) {\n      options.visitedElements.add(element);\n      return \"\";\n    }\n  }\n  const labelledBy = getAriaLabelledByElements(element);\n  if (!options.embeddedInLabelledBy) {\n    const accessibleName = (labelledBy || []).map((ref) => getTextAlternativeInternal(ref, {\n      ...options,\n      embeddedInLabelledBy: { element: ref, hidden: isElementHiddenForAria(ref) },\n      embeddedInDescribedBy: void 0,\n      embeddedInTargetElement: void 0,\n      embeddedInLabel: void 0,\n      embeddedInNativeTextAlternative: void 0\n    })).join(\" \");\n    if (accessibleName)\n      return accessibleName;\n  }\n  const role = getAriaRole(element) || \"\";\n  const tagName = elementSafeTagName(element);\n  if (!!options.embeddedInLabel || !!options.embeddedInLabelledBy || options.embeddedInTargetElement === \"descendant\") {\n    const isOwnLabel = [...element.labels || []].includes(element);\n    const isOwnLabelledBy = (labelledBy || []).includes(element);\n    if (!isOwnLabel && !isOwnLabelledBy) {\n      if (role === \"textbox\") {\n        options.visitedElements.add(element);\n        if (tagName === \"INPUT\" || tagName === \"TEXTAREA\")\n          return element.value;\n        return element.textContent || \"\";\n      }\n      if ([\"combobox\", \"listbox\"].includes(role)) {\n        options.visitedElements.add(element);\n        let selectedOptions;\n        if (tagName === \"SELECT\") {\n          selectedOptions = [...element.selectedOptions];\n          if (!selectedOptions.length && element.options.length)\n            selectedOptions.push(element.options[0]);\n        } else {\n          const listbox = role === \"combobox\" ? queryInAriaOwned(element, \"*\").find((e) => getAriaRole(e) === \"listbox\") : element;\n          selectedOptions = listbox ? queryInAriaOwned(listbox, '[aria-selected=\"true\"]').filter((e) => getAriaRole(e) === \"option\") : [];\n        }\n        if (!selectedOptions.length && tagName === \"INPUT\") {\n          return element.value;\n        }\n        return selectedOptions.map((option) => getTextAlternativeInternal(option, childOptions)).join(\" \");\n      }\n      if ([\"progressbar\", \"scrollbar\", \"slider\", \"spinbutton\", \"meter\"].includes(role)) {\n        options.visitedElements.add(element);\n        if (element.hasAttribute(\"aria-valuetext\"))\n          return element.getAttribute(\"aria-valuetext\") || \"\";\n        if (element.hasAttribute(\"aria-valuenow\"))\n          return element.getAttribute(\"aria-valuenow\") || \"\";\n        return element.getAttribute(\"value\") || \"\";\n      }\n      if ([\"menu\"].includes(role)) {\n        options.visitedElements.add(element);\n        return \"\";\n      }\n    }\n  }\n  const ariaLabel = element.getAttribute(\"aria-label\") || \"\";\n  if (trimFlatString(ariaLabel)) {\n    options.visitedElements.add(element);\n    return ariaLabel;\n  }\n  if (![\"presentation\", \"none\"].includes(role)) {\n    if (tagName === \"INPUT\" && [\"button\", \"submit\", \"reset\"].includes(element.type)) {\n      options.visitedElements.add(element);\n      const value = element.value || \"\";\n      if (trimFlatString(value))\n        return value;\n      if (element.type === \"submit\")\n        return \"Submit\";\n      if (element.type === \"reset\")\n        return \"Reset\";\n      const title = element.getAttribute(\"title\") || \"\";\n      return title;\n    }\n    if (!getGlobalOptions().inputFileRoleTextbox && tagName === \"INPUT\" && element.type === \"file\") {\n      options.visitedElements.add(element);\n      const labels = element.labels || [];\n      if (labels.length && !options.embeddedInLabelledBy)\n        return getAccessibleNameFromAssociatedLabels(labels, options);\n      return \"Choose File\";\n    }\n    if (tagName === \"INPUT\" && element.type === \"image\") {\n      options.visitedElements.add(element);\n      const labels = element.labels || [];\n      if (labels.length && !options.embeddedInLabelledBy)\n        return getAccessibleNameFromAssociatedLabels(labels, options);\n      const alt = element.getAttribute(\"alt\") || \"\";\n      if (trimFlatString(alt))\n        return alt;\n      const title = element.getAttribute(\"title\") || \"\";\n      if (trimFlatString(title))\n        return title;\n      return \"Submit\";\n    }\n    if (!labelledBy && tagName === \"BUTTON\") {\n      options.visitedElements.add(element);\n      const labels = element.labels || [];\n      if (labels.length)\n        return getAccessibleNameFromAssociatedLabels(labels, options);\n    }\n    if (!labelledBy && tagName === \"OUTPUT\") {\n      options.visitedElements.add(element);\n      const labels = element.labels || [];\n      if (labels.length)\n        return getAccessibleNameFromAssociatedLabels(labels, options);\n      return element.getAttribute(\"title\") || \"\";\n    }\n    if (!labelledBy && (tagName === \"TEXTAREA\" || tagName === \"SELECT\" || tagName === \"INPUT\")) {\n      options.visitedElements.add(element);\n      const labels = element.labels || [];\n      if (labels.length)\n        return getAccessibleNameFromAssociatedLabels(labels, options);\n      const usePlaceholder = tagName === \"INPUT\" && [\"text\", \"password\", \"search\", \"tel\", \"email\", \"url\"].includes(element.type) || tagName === \"TEXTAREA\";\n      const placeholder = element.getAttribute(\"placeholder\") || \"\";\n      const title = element.getAttribute(\"title\") || \"\";\n      if (!usePlaceholder || title)\n        return title;\n      return placeholder;\n    }\n    if (!labelledBy && tagName === \"FIELDSET\") {\n      options.visitedElements.add(element);\n      for (let child = element.firstElementChild; child; child = child.nextElementSibling) {\n        if (elementSafeTagName(child) === \"LEGEND\") {\n          return getTextAlternativeInternal(child, {\n            ...childOptions,\n            embeddedInNativeTextAlternative: { element: child, hidden: isElementHiddenForAria(child) }\n          });\n        }\n      }\n      const title = element.getAttribute(\"title\") || \"\";\n      return title;\n    }\n    if (!labelledBy && tagName === \"FIGURE\") {\n      options.visitedElements.add(element);\n      for (let child = element.firstElementChild; child; child = child.nextElementSibling) {\n        if (elementSafeTagName(child) === \"FIGCAPTION\") {\n          return getTextAlternativeInternal(child, {\n            ...childOptions,\n            embeddedInNativeTextAlternative: { element: child, hidden: isElementHiddenForAria(child) }\n          });\n        }\n      }\n      const title = element.getAttribute(\"title\") || \"\";\n      return title;\n    }\n    if (tagName === \"IMG\") {\n      options.visitedElements.add(element);\n      const alt = element.getAttribute(\"alt\") || \"\";\n      if (trimFlatString(alt))\n        return alt;\n      const title = element.getAttribute(\"title\") || \"\";\n      return title;\n    }\n    if (tagName === \"TABLE\") {\n      options.visitedElements.add(element);\n      for (let child = element.firstElementChild; child; child = child.nextElementSibling) {\n        if (elementSafeTagName(child) === \"CAPTION\") {\n          return getTextAlternativeInternal(child, {\n            ...childOptions,\n            embeddedInNativeTextAlternative: { element: child, hidden: isElementHiddenForAria(child) }\n          });\n        }\n      }\n      const summary = element.getAttribute(\"summary\") || \"\";\n      if (summary)\n        return summary;\n    }\n    if (tagName === \"AREA\") {\n      options.visitedElements.add(element);\n      const alt = element.getAttribute(\"alt\") || \"\";\n      if (trimFlatString(alt))\n        return alt;\n      const title = element.getAttribute(\"title\") || \"\";\n      return title;\n    }\n    if (tagName === \"SVG\" || element.ownerSVGElement) {\n      options.visitedElements.add(element);\n      for (let child = element.firstElementChild; child; child = child.nextElementSibling) {\n        if (elementSafeTagName(child) === \"TITLE\" && child.ownerSVGElement) {\n          return getTextAlternativeInternal(child, {\n            ...childOptions,\n            embeddedInLabelledBy: { element: child, hidden: isElementHiddenForAria(child) }\n          });\n        }\n      }\n    }\n    if (element.ownerSVGElement && tagName === \"A\") {\n      const title = element.getAttribute(\"xlink:title\") || \"\";\n      if (trimFlatString(title)) {\n        options.visitedElements.add(element);\n        return title;\n      }\n    }\n  }\n  const shouldNameFromContentForSummary = tagName === \"SUMMARY\" && ![\"presentation\", \"none\"].includes(role);\n  if (allowsNameFromContent(role, options.embeddedInTargetElement === \"descendant\") || shouldNameFromContentForSummary || !!options.embeddedInLabelledBy || !!options.embeddedInDescribedBy || !!options.embeddedInLabel || !!options.embeddedInNativeTextAlternative) {\n    options.visitedElements.add(element);\n    const accessibleName = innerAccumulatedElementText(element, childOptions);\n    const maybeTrimmedAccessibleName = options.embeddedInTargetElement === \"self\" ? trimFlatString(accessibleName) : accessibleName;\n    if (maybeTrimmedAccessibleName)\n      return accessibleName;\n  }\n  if (![\"presentation\", \"none\"].includes(role) || tagName === \"IFRAME\") {\n    options.visitedElements.add(element);\n    const title = element.getAttribute(\"title\") || \"\";\n    if (trimFlatString(title))\n      return title;\n  }\n  options.visitedElements.add(element);\n  return \"\";\n}\nfunction innerAccumulatedElementText(element, options) {\n  const tokens = [];\n  const visit = (node, skipSlotted) => {\n    var _a;\n    if (skipSlotted && node.assignedSlot)\n      return;\n    if (node.nodeType === 1) {\n      const display = ((_a = getElementComputedStyle(node)) == null ? void 0 : _a.display) || \"inline\";\n      let token = getTextAlternativeInternal(node, options);\n      if (display !== \"inline\" || node.nodeName === \"BR\")\n        token = \" \" + token + \" \";\n      tokens.push(token);\n    } else if (node.nodeType === 3) {\n      tokens.push(node.textContent || \"\");\n    }\n  };\n  tokens.push(getPseudoContent(element, \"::before\"));\n  const assignedNodes = element.nodeName === \"SLOT\" ? element.assignedNodes() : [];\n  if (assignedNodes.length) {\n    for (const child of assignedNodes)\n      visit(child, false);\n  } else {\n    for (let child = element.firstChild; child; child = child.nextSibling)\n      visit(child, true);\n    if (element.shadowRoot) {\n      for (let child = element.shadowRoot.firstChild; child; child = child.nextSibling)\n        visit(child, true);\n    }\n    for (const owned of getIdRefs(element, element.getAttribute(\"aria-owns\")))\n      visit(owned, true);\n  }\n  tokens.push(getPseudoContent(element, \"::after\"));\n  return tokens.join(\"\");\n}\nvar kAriaSelectedRoles = [\"gridcell\", \"option\", \"row\", \"tab\", \"rowheader\", \"columnheader\", \"treeitem\"];\nfunction getAriaSelected(element) {\n  if (elementSafeTagName(element) === \"OPTION\")\n    return element.selected;\n  if (kAriaSelectedRoles.includes(getAriaRole(element) || \"\"))\n    return getAriaBoolean(element.getAttribute(\"aria-selected\")) === true;\n  return false;\n}\nvar kAriaCheckedRoles = [\"checkbox\", \"menuitemcheckbox\", \"option\", \"radio\", \"switch\", \"menuitemradio\", \"treeitem\"];\nfunction getAriaChecked(element) {\n  const result = getChecked(element, true);\n  return result === \"error\" ? false : result;\n}\nfunction getCheckedAllowMixed(element) {\n  return getChecked(element, true);\n}\nfunction getCheckedWithoutMixed(element) {\n  const result = getChecked(element, false);\n  return result;\n}\nfunction getChecked(element, allowMixed) {\n  const tagName = elementSafeTagName(element);\n  if (allowMixed && tagName === \"INPUT\" && element.indeterminate)\n    return \"mixed\";\n  if (tagName === \"INPUT\" && [\"checkbox\", \"radio\"].includes(element.type))\n    return element.checked;\n  if (kAriaCheckedRoles.includes(getAriaRole(element) || \"\")) {\n    const checked = element.getAttribute(\"aria-checked\");\n    if (checked === \"true\")\n      return true;\n    if (allowMixed && checked === \"mixed\")\n      return \"mixed\";\n    return false;\n  }\n  return \"error\";\n}\nvar kAriaReadonlyRoles = [\"checkbox\", \"combobox\", \"grid\", \"gridcell\", \"listbox\", \"radiogroup\", \"slider\", \"spinbutton\", \"textbox\", \"columnheader\", \"rowheader\", \"searchbox\", \"switch\", \"treegrid\"];\nfunction getReadonly(element) {\n  const tagName = elementSafeTagName(element);\n  if ([\"INPUT\", \"TEXTAREA\", \"SELECT\"].includes(tagName))\n    return element.hasAttribute(\"readonly\");\n  if (kAriaReadonlyRoles.includes(getAriaRole(element) || \"\"))\n    return element.getAttribute(\"aria-readonly\") === \"true\";\n  if (element.isContentEditable)\n    return false;\n  return \"error\";\n}\nvar kAriaPressedRoles = [\"button\"];\nfunction getAriaPressed(element) {\n  if (kAriaPressedRoles.includes(getAriaRole(element) || \"\")) {\n    const pressed = element.getAttribute(\"aria-pressed\");\n    if (pressed === \"true\")\n      return true;\n    if (pressed === \"mixed\")\n      return \"mixed\";\n  }\n  return false;\n}\nvar kAriaExpandedRoles = [\"application\", \"button\", \"checkbox\", \"combobox\", \"gridcell\", \"link\", \"listbox\", \"menuitem\", \"row\", \"rowheader\", \"tab\", \"treeitem\", \"columnheader\", \"menuitemcheckbox\", \"menuitemradio\", \"rowheader\", \"switch\"];\nfunction getAriaExpanded(element) {\n  if (elementSafeTagName(element) === \"DETAILS\")\n    return element.open;\n  if (kAriaExpandedRoles.includes(getAriaRole(element) || \"\")) {\n    const expanded = element.getAttribute(\"aria-expanded\");\n    if (expanded === null)\n      return void 0;\n    if (expanded === \"true\")\n      return true;\n    return false;\n  }\n  return void 0;\n}\nvar kAriaLevelRoles = [\"heading\", \"listitem\", \"row\", \"treeitem\"];\nfunction getAriaLevel(element) {\n  const native = { \"H1\": 1, \"H2\": 2, \"H3\": 3, \"H4\": 4, \"H5\": 5, \"H6\": 6 }[elementSafeTagName(element)];\n  if (native)\n    return native;\n  if (kAriaLevelRoles.includes(getAriaRole(element) || \"\")) {\n    const attr = element.getAttribute(\"aria-level\");\n    const value = attr === null ? Number.NaN : Number(attr);\n    if (Number.isInteger(value) && value >= 1)\n      return value;\n  }\n  return 0;\n}\nvar kAriaDisabledRoles = [\"application\", \"button\", \"composite\", \"gridcell\", \"group\", \"input\", \"link\", \"menuitem\", \"scrollbar\", \"separator\", \"tab\", \"checkbox\", \"columnheader\", \"combobox\", \"grid\", \"listbox\", \"menu\", \"menubar\", \"menuitemcheckbox\", \"menuitemradio\", \"option\", \"radio\", \"radiogroup\", \"row\", \"rowheader\", \"searchbox\", \"select\", \"slider\", \"spinbutton\", \"switch\", \"tablist\", \"textbox\", \"toolbar\", \"tree\", \"treegrid\", \"treeitem\"];\nfunction getAriaDisabled(element) {\n  return isNativelyDisabled(element) || hasExplicitAriaDisabled(element);\n}\nfunction isNativelyDisabled(element) {\n  const isNativeFormControl = [\"BUTTON\", \"INPUT\", \"SELECT\", \"TEXTAREA\", \"OPTION\", \"OPTGROUP\"].includes(element.tagName);\n  return isNativeFormControl && (element.hasAttribute(\"disabled\") || belongsToDisabledFieldSet(element));\n}\nfunction belongsToDisabledFieldSet(element) {\n  const fieldSetElement = element == null ? void 0 : element.closest(\"FIELDSET[DISABLED]\");\n  if (!fieldSetElement)\n    return false;\n  const legendElement = fieldSetElement.querySelector(\":scope > LEGEND\");\n  return !legendElement || !legendElement.contains(element);\n}\nfunction hasExplicitAriaDisabled(element, isAncestor = false) {\n  if (!element)\n    return false;\n  if (isAncestor || kAriaDisabledRoles.includes(getAriaRole(element) || \"\")) {\n    const attribute = (element.getAttribute(\"aria-disabled\") || \"\").toLowerCase();\n    if (attribute === \"true\")\n      return true;\n    if (attribute === \"false\")\n      return false;\n    return hasExplicitAriaDisabled(parentElementOrShadowHost(element), true);\n  }\n  return false;\n}\nfunction getAccessibleNameFromAssociatedLabels(labels, options) {\n  return [...labels].map((label) => getTextAlternativeInternal(label, {\n    ...options,\n    embeddedInLabel: { element: label, hidden: isElementHiddenForAria(label) },\n    embeddedInNativeTextAlternative: void 0,\n    embeddedInLabelledBy: void 0,\n    embeddedInDescribedBy: void 0,\n    embeddedInTargetElement: void 0\n  })).filter((accessibleName) => !!accessibleName).join(\" \");\n}\nvar cacheAccessibleName;\nvar cacheAccessibleNameHidden;\nvar cacheAccessibleDescription;\nvar cacheAccessibleDescriptionHidden;\nvar cacheAccessibleErrorMessage;\nvar cacheIsHidden;\nvar cachePseudoContentBefore;\nvar cachePseudoContentAfter;\nvar cachesCounter = 0;\nfunction beginAriaCaches() {\n  ++cachesCounter;\n  cacheAccessibleName != null ? cacheAccessibleName : cacheAccessibleName = new Map();\n  cacheAccessibleNameHidden != null ? cacheAccessibleNameHidden : cacheAccessibleNameHidden = new Map();\n  cacheAccessibleDescription != null ? cacheAccessibleDescription : cacheAccessibleDescription = new Map();\n  cacheAccessibleDescriptionHidden != null ? cacheAccessibleDescriptionHidden : cacheAccessibleDescriptionHidden = new Map();\n  cacheAccessibleErrorMessage != null ? cacheAccessibleErrorMessage : cacheAccessibleErrorMessage = new Map();\n  cacheIsHidden != null ? cacheIsHidden : cacheIsHidden = new Map();\n  cachePseudoContentBefore != null ? cachePseudoContentBefore : cachePseudoContentBefore = new Map();\n  cachePseudoContentAfter != null ? cachePseudoContentAfter : cachePseudoContentAfter = new Map();\n}\nfunction endAriaCaches() {\n  if (!--cachesCounter) {\n    cacheAccessibleName = void 0;\n    cacheAccessibleNameHidden = void 0;\n    cacheAccessibleDescription = void 0;\n    cacheAccessibleDescriptionHidden = void 0;\n    cacheAccessibleErrorMessage = void 0;\n    cacheIsHidden = void 0;\n    cachePseudoContentBefore = void 0;\n    cachePseudoContentAfter = void 0;\n  }\n}\nvar inputTypeToRole = {\n  \"button\": \"button\",\n  \"checkbox\": \"checkbox\",\n  \"image\": \"button\",\n  \"number\": \"spinbutton\",\n  \"radio\": \"radio\",\n  \"range\": \"slider\",\n  \"reset\": \"button\",\n  \"submit\": \"button\"\n};\n\n// packages/injected/src/yaml.ts\nfunction yamlEscapeKeyIfNeeded(str) {\n  if (!yamlStringNeedsQuotes(str))\n    return str;\n  return `'` + str.replace(/'/g, `''`) + `'`;\n}\nfunction yamlEscapeValueIfNeeded(str) {\n  if (!yamlStringNeedsQuotes(str))\n    return str;\n  return '\"' + str.replace(/[\\\\\"\\x00-\\x1f\\x7f-\\x9f]/g, (c) => {\n    switch (c) {\n      case \"\\\\\":\n        return \"\\\\\\\\\";\n      case '\"':\n        return '\\\\\"';\n      case \"\\b\":\n        return \"\\\\b\";\n      case \"\\f\":\n        return \"\\\\f\";\n      case \"\\n\":\n        return \"\\\\n\";\n      case \"\\r\":\n        return \"\\\\r\";\n      case \"\t\":\n        return \"\\\\t\";\n      default:\n        const code = c.charCodeAt(0);\n        return \"\\\\x\" + code.toString(16).padStart(2, \"0\");\n    }\n  }) + '\"';\n}\nfunction yamlStringNeedsQuotes(str) {\n  if (str.length === 0)\n    return true;\n  if (/^\\s|\\s$/.test(str))\n    return true;\n  if (/[\\x00-\\x08\\x0b\\x0c\\x0e-\\x1f\\x7f-\\x9f]/.test(str))\n    return true;\n  if (/^-/.test(str))\n    return true;\n  if (/[\\n:](\\s|$)/.test(str))\n    return true;\n  if (/\\s#/.test(str))\n    return true;\n  if (/[\\n\\r]/.test(str))\n    return true;\n  if (/^[&*\\],?!>|@\"'#%]/.test(str))\n    return true;\n  if (/[{}`]/.test(str))\n    return true;\n  if (/^\\[/.test(str))\n    return true;\n  if (!isNaN(Number(str)) || [\"y\", \"n\", \"yes\", \"no\", \"true\", \"false\", \"on\", \"off\", \"null\"].includes(str.toLowerCase()))\n    return true;\n  return false;\n}\n\n// packages/injected/src/ariaSnapshot.ts\nfunction generateAriaTree(rootElement, generation) {\n  const visited = new Set();\n  const snapshot = {\n    root: { role: \"fragment\", name: \"\", children: [], element: rootElement, props: {} },\n    elements: new Map(),\n    generation,\n    ids: new Map()\n  };\n  const addElement = (element) => {\n    const id = snapshot.elements.size + 1;\n    snapshot.elements.set(id, element);\n    snapshot.ids.set(element, id);\n  };\n  addElement(rootElement);\n  const visit = (ariaNode, node) => {\n    if (visited.has(node))\n      return;\n    visited.add(node);\n    if (node.nodeType === Node.TEXT_NODE && node.nodeValue) {\n      const text = node.nodeValue;\n      if (ariaNode.role !== \"textbox\" && text)\n        ariaNode.children.push(node.nodeValue || \"\");\n      return;\n    }\n    if (node.nodeType !== Node.ELEMENT_NODE)\n      return;\n    const element = node;\n    if (isElementHiddenForAria(element))\n      return;\n    const ariaChildren = [];\n    if (element.hasAttribute(\"aria-owns\")) {\n      const ids = element.getAttribute(\"aria-owns\").split(/\\s+/);\n      for (const id of ids) {\n        const ownedElement = rootElement.ownerDocument.getElementById(id);\n        if (ownedElement)\n          ariaChildren.push(ownedElement);\n      }\n    }\n    addElement(element);\n    const childAriaNode = toAriaNode(element);\n    if (childAriaNode)\n      ariaNode.children.push(childAriaNode);\n    processElement(childAriaNode || ariaNode, element, ariaChildren);\n  };\n  function processElement(ariaNode, element, ariaChildren = []) {\n    var _a;\n    const display = ((_a = getElementComputedStyle(element)) == null ? void 0 : _a.display) || \"inline\";\n    const treatAsBlock = display !== \"inline\" || element.nodeName === \"BR\" ? \" \" : \"\";\n    if (treatAsBlock)\n      ariaNode.children.push(treatAsBlock);\n    ariaNode.children.push(getPseudoContent(element, \"::before\"));\n    const assignedNodes = element.nodeName === \"SLOT\" ? element.assignedNodes() : [];\n    if (assignedNodes.length) {\n      for (const child of assignedNodes)\n        visit(ariaNode, child);\n    } else {\n      for (let child = element.firstChild; child; child = child.nextSibling) {\n        if (!child.assignedSlot)\n          visit(ariaNode, child);\n      }\n      if (element.shadowRoot) {\n        for (let child = element.shadowRoot.firstChild; child; child = child.nextSibling)\n          visit(ariaNode, child);\n      }\n    }\n    for (const child of ariaChildren)\n      visit(ariaNode, child);\n    ariaNode.children.push(getPseudoContent(element, \"::after\"));\n    if (treatAsBlock)\n      ariaNode.children.push(treatAsBlock);\n    if (ariaNode.children.length === 1 && ariaNode.name === ariaNode.children[0])\n      ariaNode.children = [];\n    if (ariaNode.role === \"link\" && element.hasAttribute(\"href\")) {\n      const href = element.getAttribute(\"href\");\n      ariaNode.props[\"url\"] = href;\n    }\n  }\n  beginAriaCaches();\n  try {\n    visit(snapshot.root, rootElement);\n  } finally {\n    endAriaCaches();\n  }\n  normalizeStringChildren(snapshot.root);\n  return snapshot;\n}\nfunction toAriaNode(element) {\n  if (element.nodeName === \"IFRAME\")\n    return { role: \"iframe\", name: \"\", children: [], props: {}, element };\n  const role = getAriaRole(element);\n  if (!role || role === \"presentation\" || role === \"none\")\n    return null;\n  const name = normalizeWhiteSpace(getElementAccessibleName(element, false) || \"\");\n  const result = { role, name, children: [], props: {}, element };\n  if (kAriaCheckedRoles.includes(role))\n    result.checked = getAriaChecked(element);\n  if (kAriaDisabledRoles.includes(role))\n    result.disabled = getAriaDisabled(element);\n  if (kAriaExpandedRoles.includes(role))\n    result.expanded = getAriaExpanded(element);\n  if (kAriaLevelRoles.includes(role))\n    result.level = getAriaLevel(element);\n  if (kAriaPressedRoles.includes(role))\n    result.pressed = getAriaPressed(element);\n  if (kAriaSelectedRoles.includes(role))\n    result.selected = getAriaSelected(element);\n  if (element instanceof HTMLInputElement || element instanceof HTMLTextAreaElement) {\n    if (element.type !== \"checkbox\" && element.type !== \"radio\" && (element.type !== \"file\" || getGlobalOptions().inputFileRoleTextbox))\n      result.children = [element.value];\n  }\n  return result;\n}\nfunction normalizeStringChildren(rootA11yNode) {\n  const flushChildren = (buffer, normalizedChildren) => {\n    if (!buffer.length)\n      return;\n    const text = normalizeWhiteSpace(buffer.join(\"\"));\n    if (text)\n      normalizedChildren.push(text);\n    buffer.length = 0;\n  };\n  const visit = (ariaNode) => {\n    const normalizedChildren = [];\n    const buffer = [];\n    for (const child of ariaNode.children || []) {\n      if (typeof child === \"string\") {\n        buffer.push(child);\n      } else {\n        flushChildren(buffer, normalizedChildren);\n        visit(child);\n        normalizedChildren.push(child);\n      }\n    }\n    flushChildren(buffer, normalizedChildren);\n    ariaNode.children = normalizedChildren.length ? normalizedChildren : [];\n    if (ariaNode.children.length === 1 && ariaNode.children[0] === ariaNode.name)\n      ariaNode.children = [];\n  };\n  visit(rootA11yNode);\n}\nfunction matchesText(text, template) {\n  if (!template)\n    return true;\n  if (!text)\n    return false;\n  if (typeof template === \"string\")\n    return text === template;\n  return !!text.match(new RegExp(template.pattern));\n}\nfunction matchesTextNode(text, template) {\n  return matchesText(text, template.text);\n}\nfunction matchesName(text, template) {\n  return matchesText(text, template.name);\n}\nfunction matchesAriaTree(rootElement, template) {\n  const snapshot = generateAriaTree(rootElement, 0);\n  const matches = matchesNodeDeep(snapshot.root, template, false, false);\n  return {\n    matches,\n    received: {\n      raw: renderAriaTree(snapshot, { mode: \"raw\" }),\n      regex: renderAriaTree(snapshot, { mode: \"regex\" })\n    }\n  };\n}\nfunction getAllByAria(rootElement, template) {\n  const root = generateAriaTree(rootElement, 0).root;\n  const matches = matchesNodeDeep(root, template, true, false);\n  return matches.map((n) => n.element);\n}\nfunction matchesNode(node, template, isDeepEqual) {\n  var _a;\n  if (typeof node === \"string\" && template.kind === \"text\")\n    return matchesTextNode(node, template);\n  if (node === null || typeof node !== \"object\" || template.kind !== \"role\")\n    return false;\n  if (template.role !== \"fragment\" && template.role !== node.role)\n    return false;\n  if (template.checked !== void 0 && template.checked !== node.checked)\n    return false;\n  if (template.disabled !== void 0 && template.disabled !== node.disabled)\n    return false;\n  if (template.expanded !== void 0 && template.expanded !== node.expanded)\n    return false;\n  if (template.level !== void 0 && template.level !== node.level)\n    return false;\n  if (template.pressed !== void 0 && template.pressed !== node.pressed)\n    return false;\n  if (template.selected !== void 0 && template.selected !== node.selected)\n    return false;\n  if (!matchesName(node.name, template))\n    return false;\n  if (!matchesText(node.props.url, (_a = template.props) == null ? void 0 : _a.url))\n    return false;\n  if (template.containerMode === \"contain\")\n    return containsList(node.children || [], template.children || []);\n  if (template.containerMode === \"equal\")\n    return listEqual(node.children || [], template.children || [], false);\n  if (template.containerMode === \"deep-equal\" || isDeepEqual)\n    return listEqual(node.children || [], template.children || [], true);\n  return containsList(node.children || [], template.children || []);\n}\nfunction listEqual(children, template, isDeepEqual) {\n  if (template.length !== children.length)\n    return false;\n  for (let i = 0; i < template.length; ++i) {\n    if (!matchesNode(children[i], template[i], isDeepEqual))\n      return false;\n  }\n  return true;\n}\nfunction containsList(children, template) {\n  if (template.length > children.length)\n    return false;\n  const cc = children.slice();\n  const tt = template.slice();\n  for (const t of tt) {\n    let c = cc.shift();\n    while (c) {\n      if (matchesNode(c, t, false))\n        break;\n      c = cc.shift();\n    }\n    if (!c)\n      return false;\n  }\n  return true;\n}\nfunction matchesNodeDeep(root, template, collectAll, isDeepEqual) {\n  const results = [];\n  const visit = (node, parent) => {\n    if (matchesNode(node, template, isDeepEqual)) {\n      const result = typeof node === \"string\" ? parent : node;\n      if (result)\n        results.push(result);\n      return !collectAll;\n    }\n    if (typeof node === \"string\")\n      return false;\n    for (const child of node.children || []) {\n      if (visit(child, node))\n        return true;\n    }\n    return false;\n  };\n  visit(root, null);\n  return results;\n}\nfunction renderAriaTree(ariaSnapshot, options) {\n  const lines = [];\n  const includeText = (options == null ? void 0 : options.mode) === \"regex\" ? textContributesInfo : () => true;\n  const renderString = (options == null ? void 0 : options.mode) === \"regex\" ? convertToBestGuessRegex : (str) => str;\n  const visit = (ariaNode2, parentAriaNode, indent) => {\n    if (typeof ariaNode2 === \"string\") {\n      if (parentAriaNode && !includeText(parentAriaNode, ariaNode2))\n        return;\n      const text = yamlEscapeValueIfNeeded(renderString(ariaNode2));\n      if (text)\n        lines.push(indent + \"- text: \" + text);\n      return;\n    }\n    let key = ariaNode2.role;\n    if (ariaNode2.name && ariaNode2.name.length <= 900) {\n      const name = renderString(ariaNode2.name);\n      if (name) {\n        const stringifiedName = name.startsWith(\"/\") && name.endsWith(\"/\") ? name : JSON.stringify(name);\n        key += \" \" + stringifiedName;\n      }\n    }\n    if (ariaNode2.checked === \"mixed\")\n      key += ` [checked=mixed]`;\n    if (ariaNode2.checked === true)\n      key += ` [checked]`;\n    if (ariaNode2.disabled)\n      key += ` [disabled]`;\n    if (ariaNode2.expanded)\n      key += ` [expanded]`;\n    if (ariaNode2.level)\n      key += ` [level=${ariaNode2.level}]`;\n    if (ariaNode2.pressed === \"mixed\")\n      key += ` [pressed=mixed]`;\n    if (ariaNode2.pressed === true)\n      key += ` [pressed]`;\n    if (ariaNode2.selected === true)\n      key += ` [selected]`;\n    if (options == null ? void 0 : options.ref) {\n      const id = ariaSnapshot.ids.get(ariaNode2.element);\n      if (id)\n        key += ` [ref=s${ariaSnapshot.generation}e${id}]`;\n    }\n    const escapedKey = indent + \"- \" + yamlEscapeKeyIfNeeded(key);\n    const hasProps = !!Object.keys(ariaNode2.props).length;\n    if (!ariaNode2.children.length && !hasProps) {\n      lines.push(escapedKey);\n    } else if (ariaNode2.children.length === 1 && typeof ariaNode2.children[0] === \"string\" && !hasProps) {\n      const text = includeText(ariaNode2, ariaNode2.children[0]) ? renderString(ariaNode2.children[0]) : null;\n      if (text)\n        lines.push(escapedKey + \": \" + yamlEscapeValueIfNeeded(text));\n      else\n        lines.push(escapedKey);\n    } else {\n      lines.push(escapedKey + \":\");\n      for (const [name, value] of Object.entries(ariaNode2.props))\n        lines.push(indent + \"  - /\" + name + \": \" + yamlEscapeValueIfNeeded(value));\n      for (const child of ariaNode2.children || [])\n        visit(child, ariaNode2, indent + \"  \");\n    }\n  };\n  const ariaNode = ariaSnapshot.root;\n  if (ariaNode.role === \"fragment\") {\n    for (const child of ariaNode.children || [])\n      visit(child, ariaNode, \"\");\n  } else {\n    visit(ariaNode, null, \"\");\n  }\n  return lines.join(\"\\n\");\n}\nfunction convertToBestGuessRegex(text) {\n  const dynamicContent = [\n    // 2mb\n    { regex: /\\b[\\d,.]+[bkmBKM]+\\b/, replacement: \"[\\\\d,.]+[bkmBKM]+\" },\n    // 2ms, 20s\n    { regex: /\\b\\d+[hmsp]+\\b/, replacement: \"\\\\d+[hmsp]+\" },\n    { regex: /\\b[\\d,.]+[hmsp]+\\b/, replacement: \"[\\\\d,.]+[hmsp]+\" },\n    // Do not replace single digits with regex by default.\n    // 2+ digits: [Issue 22, 22.3, 2.33, 2,333]\n    { regex: /\\b\\d+,\\d+\\b/, replacement: \"\\\\d+,\\\\d+\" },\n    { regex: /\\b\\d+\\.\\d{2,}\\b/, replacement: \"\\\\d+\\\\.\\\\d+\" },\n    { regex: /\\b\\d{2,}\\.\\d+\\b/, replacement: \"\\\\d+\\\\.\\\\d+\" },\n    { regex: /\\b\\d{2,}\\b/, replacement: \"\\\\d+\" }\n  ];\n  let pattern = \"\";\n  let lastIndex = 0;\n  const combinedRegex = new RegExp(dynamicContent.map((r) => \"(\" + r.regex.source + \")\").join(\"|\"), \"g\");\n  text.replace(combinedRegex, (match, ...args) => {\n    const offset = args[args.length - 2];\n    const groups = args.slice(0, -2);\n    pattern += escapeRegExp(text.slice(lastIndex, offset));\n    for (let i = 0; i < groups.length; i++) {\n      if (groups[i]) {\n        const { replacement } = dynamicContent[i];\n        pattern += replacement;\n        break;\n      }\n    }\n    lastIndex = offset + match.length;\n    return match;\n  });\n  if (!pattern)\n    return text;\n  pattern += escapeRegExp(text.slice(lastIndex));\n  return String(new RegExp(pattern));\n}\nfunction textContributesInfo(node, text) {\n  if (!text.length)\n    return false;\n  if (!node.name)\n    return true;\n  if (node.name.length > text.length)\n    return false;\n  const substr = text.length <= 200 && node.name.length <= 200 ? longestCommonSubstring(text, node.name) : \"\";\n  let filtered = text;\n  while (substr && filtered.includes(substr))\n    filtered = filtered.replace(substr, \"\");\n  return filtered.trim().length / text.length > 0.1;\n}\n\n// packages/injected/src/highlight.css?inline\nvar highlight_default = \":host{font-size:13px;font-family:system-ui,Ubuntu,Droid Sans,sans-serif;color:#333}svg{position:absolute;height:0}x-pw-tooltip{backdrop-filter:blur(5px);background-color:#fff;border-radius:6px;box-shadow:0 .5rem 1.2rem #0000004d;display:none;font-size:12.8px;font-weight:400;left:0;line-height:1.5;max-width:600px;position:absolute;top:0;padding:0;flex-direction:column;overflow:hidden}x-pw-tooltip-line{display:flex;max-width:600px;padding:6px;user-select:none;cursor:pointer}x-pw-tooltip-line.selectable:hover{background-color:#f2f2f2;overflow:hidden}x-pw-tooltip-footer{display:flex;max-width:600px;padding:6px;user-select:none;color:#777}x-pw-dialog{background-color:#fff;pointer-events:auto;border-radius:6px;box-shadow:0 .5rem 1.2rem #0000004d;display:flex;flex-direction:column;position:absolute;width:400px;height:150px;z-index:10;font-size:13px}x-pw-dialog-body{display:flex;flex-direction:column;flex:auto}x-pw-dialog-body label{margin:5px 8px;display:flex;flex-direction:row;align-items:center}x-pw-highlight{position:absolute;top:0;left:0;width:0;height:0}x-pw-action-point{position:absolute;width:20px;height:20px;background:red;border-radius:10px;margin:-10px 0 0 -10px;z-index:2}x-pw-separator{height:1px;margin:6px 9px;background:#949494e5}x-pw-tool-gripper{height:28px;width:24px;margin:2px 0;cursor:grab}x-pw-tool-gripper:active{cursor:grabbing}x-pw-tool-gripper>x-div{width:16px;height:16px;margin:6px 4px;clip-path:url(#icon-gripper);background-color:#555}x-pw-tools-list>label{display:flex;align-items:center;margin:0 10px;user-select:none}x-pw-tools-list{display:flex;width:100%;border-bottom:1px solid #dddddd}x-pw-tool-item{pointer-events:auto;height:28px;width:28px;border-radius:3px}x-pw-tool-item:not(.disabled){cursor:pointer}x-pw-tool-item:not(.disabled):hover{background-color:#dbdbdb}x-pw-tool-item.toggled{background-color:#8acae480}x-pw-tool-item.toggled:not(.disabled):hover{background-color:#8acae4c4}x-pw-tool-item>x-div{width:16px;height:16px;margin:6px;background-color:#3a3a3a}x-pw-tool-item.disabled>x-div{background-color:#61616180;cursor:default}x-pw-tool-item.record.toggled{background-color:transparent}x-pw-tool-item.record.toggled:not(.disabled):hover{background-color:#dbdbdb}x-pw-tool-item.record.toggled>x-div{background-color:#a1260d}x-pw-tool-item.record.disabled.toggled>x-div{opacity:.8}x-pw-tool-item.accept>x-div{background-color:#388a34}x-pw-tool-item.record>x-div{clip-path:url(#icon-circle-large-filled)}x-pw-tool-item.pick-locator>x-div{clip-path:url(#icon-inspect)}x-pw-tool-item.text>x-div{clip-path:url(#icon-whole-word)}x-pw-tool-item.visibility>x-div{clip-path:url(#icon-eye)}x-pw-tool-item.value>x-div{clip-path:url(#icon-symbol-constant)}x-pw-tool-item.snapshot>x-div{clip-path:url(#icon-gist)}x-pw-tool-item.accept>x-div{clip-path:url(#icon-check)}x-pw-tool-item.cancel>x-div{clip-path:url(#icon-close)}x-pw-tool-item.succeeded>x-div{clip-path:url(#icon-pass);background-color:#388a34!important}x-pw-overlay{position:absolute;top:0;max-width:min-content;z-index:2147483647;background:transparent;pointer-events:auto}x-pw-overlay x-pw-tools-list{background-color:#fffd;box-shadow:#0000001a 0 5px 5px;border-radius:3px;border-bottom:none}x-pw-overlay x-pw-tool-item{margin:2px}textarea.text-editor{font-family:system-ui,Ubuntu,Droid Sans,sans-serif;flex:auto;border:none;margin:6px 10px;color:#333;outline:1px solid transparent!important;resize:none;padding:0;font-size:13px}textarea.text-editor.does-not-match{outline:1px solid red!important}x-div{display:block}x-spacer{flex:auto}*{box-sizing:border-box}*[hidden]{display:none!important}x-locator-editor{flex:none;width:100%;height:60px;padding:4px;border-bottom:1px solid #dddddd;outline:1px solid transparent}x-locator-editor.does-not-match{outline:1px solid red}.CodeMirror{width:100%!important;height:100%!important}\\n\";\n\n// packages/injected/src/highlight.ts\nvar Highlight = class {\n  constructor(injectedScript) {\n    this._renderedEntries = [];\n    this._language = \"javascript\";\n    this._injectedScript = injectedScript;\n    const document = injectedScript.document;\n    this._isUnderTest = injectedScript.isUnderTest;\n    this._glassPaneElement = document.createElement(\"x-pw-glass\");\n    this._glassPaneElement.style.position = \"fixed\";\n    this._glassPaneElement.style.top = \"0\";\n    this._glassPaneElement.style.right = \"0\";\n    this._glassPaneElement.style.bottom = \"0\";\n    this._glassPaneElement.style.left = \"0\";\n    this._glassPaneElement.style.zIndex = \"2147483646\";\n    this._glassPaneElement.style.pointerEvents = \"none\";\n    this._glassPaneElement.style.display = \"flex\";\n    this._glassPaneElement.style.backgroundColor = \"transparent\";\n    for (const eventName of [\"click\", \"auxclick\", \"dragstart\", \"input\", \"keydown\", \"keyup\", \"pointerdown\", \"pointerup\", \"mousedown\", \"mouseup\", \"mouseleave\", \"focus\", \"scroll\"]) {\n      this._glassPaneElement.addEventListener(eventName, (e) => {\n        e.stopPropagation();\n        e.stopImmediatePropagation();\n      });\n    }\n    this._actionPointElement = document.createElement(\"x-pw-action-point\");\n    this._actionPointElement.setAttribute(\"hidden\", \"true\");\n    this._glassPaneShadow = this._glassPaneElement.attachShadow({ mode: this._isUnderTest ? \"open\" : \"closed\" });\n    if (typeof this._glassPaneShadow.adoptedStyleSheets.push === \"function\") {\n      const sheet = new this._injectedScript.window.CSSStyleSheet();\n      sheet.replaceSync(highlight_default);\n      this._glassPaneShadow.adoptedStyleSheets.push(sheet);\n    } else {\n      const styleElement = this._injectedScript.document.createElement(\"style\");\n      styleElement.textContent = highlight_default;\n      this._glassPaneShadow.appendChild(styleElement);\n    }\n    this._glassPaneShadow.appendChild(this._actionPointElement);\n  }\n  install() {\n    if (this._injectedScript.document.documentElement && !this._injectedScript.document.documentElement.contains(this._glassPaneElement))\n      this._injectedScript.document.documentElement.appendChild(this._glassPaneElement);\n  }\n  setLanguage(language) {\n    this._language = language;\n  }\n  runHighlightOnRaf(selector) {\n    if (this._rafRequest)\n      cancelAnimationFrame(this._rafRequest);\n    const elements = this._injectedScript.querySelectorAll(selector, this._injectedScript.document.documentElement);\n    const locator = asLocator(this._language, stringifySelector(selector));\n    const color = elements.length > 1 ? \"#f6b26b7f\" : \"#6fa8dc7f\";\n    this.updateHighlight(elements.map((element, index) => {\n      const suffix = elements.length > 1 ? ` [${index + 1} of ${elements.length}]` : \"\";\n      return { element, color, tooltipText: locator + suffix };\n    }));\n    this._rafRequest = requestAnimationFrame(() => this.runHighlightOnRaf(selector));\n  }\n  uninstall() {\n    if (this._rafRequest)\n      cancelAnimationFrame(this._rafRequest);\n    this._glassPaneElement.remove();\n  }\n  showActionPoint(x, y) {\n    this._actionPointElement.style.top = y + \"px\";\n    this._actionPointElement.style.left = x + \"px\";\n    this._actionPointElement.hidden = false;\n  }\n  hideActionPoint() {\n    this._actionPointElement.hidden = true;\n  }\n  clearHighlight() {\n    var _a, _b;\n    for (const entry of this._renderedEntries) {\n      (_a = entry.highlightElement) == null ? void 0 : _a.remove();\n      (_b = entry.tooltipElement) == null ? void 0 : _b.remove();\n    }\n    this._renderedEntries = [];\n  }\n  maskElements(elements, color) {\n    this.updateHighlight(elements.map((element) => ({ element, color })));\n  }\n  updateHighlight(entries) {\n    if (this._highlightIsUpToDate(entries))\n      return;\n    this.clearHighlight();\n    for (const entry of entries) {\n      const highlightElement = this._createHighlightElement();\n      this._glassPaneShadow.appendChild(highlightElement);\n      let tooltipElement;\n      if (entry.tooltipText) {\n        tooltipElement = this._injectedScript.document.createElement(\"x-pw-tooltip\");\n        this._glassPaneShadow.appendChild(tooltipElement);\n        tooltipElement.style.top = \"0\";\n        tooltipElement.style.left = \"0\";\n        tooltipElement.style.display = \"flex\";\n        const lineElement = this._injectedScript.document.createElement(\"x-pw-tooltip-line\");\n        lineElement.textContent = entry.tooltipText;\n        tooltipElement.appendChild(lineElement);\n      }\n      this._renderedEntries.push({ targetElement: entry.element, color: entry.color, tooltipElement, highlightElement });\n    }\n    for (const entry of this._renderedEntries) {\n      entry.box = entry.targetElement.getBoundingClientRect();\n      if (!entry.tooltipElement)\n        continue;\n      const { anchorLeft, anchorTop } = this.tooltipPosition(entry.box, entry.tooltipElement);\n      entry.tooltipTop = anchorTop;\n      entry.tooltipLeft = anchorLeft;\n    }\n    for (const entry of this._renderedEntries) {\n      if (entry.tooltipElement) {\n        entry.tooltipElement.style.top = entry.tooltipTop + \"px\";\n        entry.tooltipElement.style.left = entry.tooltipLeft + \"px\";\n      }\n      const box = entry.box;\n      entry.highlightElement.style.backgroundColor = entry.color;\n      entry.highlightElement.style.left = box.x + \"px\";\n      entry.highlightElement.style.top = box.y + \"px\";\n      entry.highlightElement.style.width = box.width + \"px\";\n      entry.highlightElement.style.height = box.height + \"px\";\n      entry.highlightElement.style.display = \"block\";\n      if (this._isUnderTest)\n        console.error(\"Highlight box for test: \" + JSON.stringify({ x: box.x, y: box.y, width: box.width, height: box.height }));\n    }\n  }\n  firstBox() {\n    var _a;\n    return (_a = this._renderedEntries[0]) == null ? void 0 : _a.box;\n  }\n  tooltipPosition(box, tooltipElement) {\n    const tooltipWidth = tooltipElement.offsetWidth;\n    const tooltipHeight = tooltipElement.offsetHeight;\n    const totalWidth = this._glassPaneElement.offsetWidth;\n    const totalHeight = this._glassPaneElement.offsetHeight;\n    let anchorLeft = box.left;\n    if (anchorLeft + tooltipWidth > totalWidth - 5)\n      anchorLeft = totalWidth - tooltipWidth - 5;\n    let anchorTop = box.bottom + 5;\n    if (anchorTop + tooltipHeight > totalHeight - 5) {\n      if (box.top > tooltipHeight + 5) {\n        anchorTop = box.top - tooltipHeight - 5;\n      } else {\n        anchorTop = totalHeight - 5 - tooltipHeight;\n      }\n    }\n    return { anchorLeft, anchorTop };\n  }\n  _highlightIsUpToDate(entries) {\n    if (entries.length !== this._renderedEntries.length)\n      return false;\n    for (let i = 0; i < this._renderedEntries.length; ++i) {\n      if (entries[i].element !== this._renderedEntries[i].targetElement)\n        return false;\n      if (entries[i].color !== this._renderedEntries[i].color)\n        return false;\n      const oldBox = this._renderedEntries[i].box;\n      if (!oldBox)\n        return false;\n      const box = entries[i].element.getBoundingClientRect();\n      if (box.top !== oldBox.top || box.right !== oldBox.right || box.bottom !== oldBox.bottom || box.left !== oldBox.left)\n        return false;\n    }\n    return true;\n  }\n  _createHighlightElement() {\n    return this._injectedScript.document.createElement(\"x-pw-highlight\");\n  }\n  appendChild(element) {\n    this._glassPaneShadow.appendChild(element);\n  }\n};\n\n// packages/injected/src/layoutSelectorUtils.ts\nfunction boxRightOf(box1, box2, maxDistance) {\n  const distance = box1.left - box2.right;\n  if (distance < 0 || maxDistance !== void 0 && distance > maxDistance)\n    return;\n  return distance + Math.max(box2.bottom - box1.bottom, 0) + Math.max(box1.top - box2.top, 0);\n}\nfunction boxLeftOf(box1, box2, maxDistance) {\n  const distance = box2.left - box1.right;\n  if (distance < 0 || maxDistance !== void 0 && distance > maxDistance)\n    return;\n  return distance + Math.max(box2.bottom - box1.bottom, 0) + Math.max(box1.top - box2.top, 0);\n}\nfunction boxAbove(box1, box2, maxDistance) {\n  const distance = box2.top - box1.bottom;\n  if (distance < 0 || maxDistance !== void 0 && distance > maxDistance)\n    return;\n  return distance + Math.max(box1.left - box2.left, 0) + Math.max(box2.right - box1.right, 0);\n}\nfunction boxBelow(box1, box2, maxDistance) {\n  const distance = box1.top - box2.bottom;\n  if (distance < 0 || maxDistance !== void 0 && distance > maxDistance)\n    return;\n  return distance + Math.max(box1.left - box2.left, 0) + Math.max(box2.right - box1.right, 0);\n}\nfunction boxNear(box1, box2, maxDistance) {\n  const kThreshold = maxDistance === void 0 ? 50 : maxDistance;\n  let score = 0;\n  if (box1.left - box2.right >= 0)\n    score += box1.left - box2.right;\n  if (box2.left - box1.right >= 0)\n    score += box2.left - box1.right;\n  if (box2.top - box1.bottom >= 0)\n    score += box2.top - box1.bottom;\n  if (box1.top - box2.bottom >= 0)\n    score += box1.top - box2.bottom;\n  return score > kThreshold ? void 0 : score;\n}\nvar kLayoutSelectorNames = [\"left-of\", \"right-of\", \"above\", \"below\", \"near\"];\nfunction layoutSelectorScore(name, element, inner, maxDistance) {\n  const box = element.getBoundingClientRect();\n  const scorer = { \"left-of\": boxLeftOf, \"right-of\": boxRightOf, \"above\": boxAbove, \"below\": boxBelow, \"near\": boxNear }[name];\n  let bestScore;\n  for (const e of inner) {\n    if (e === element)\n      continue;\n    const score = scorer(box, e.getBoundingClientRect(), maxDistance);\n    if (score === void 0)\n      continue;\n    if (bestScore === void 0 || score < bestScore)\n      bestScore = score;\n  }\n  return bestScore;\n}\n\n// packages/injected/src/selectorUtils.ts\nfunction matchesComponentAttribute(obj, attr) {\n  for (const token of attr.jsonPath) {\n    if (obj !== void 0 && obj !== null)\n      obj = obj[token];\n  }\n  return matchesAttributePart(obj, attr);\n}\nfunction matchesAttributePart(value, attr) {\n  const objValue = typeof value === \"string\" && !attr.caseSensitive ? value.toUpperCase() : value;\n  const attrValue = typeof attr.value === \"string\" && !attr.caseSensitive ? attr.value.toUpperCase() : attr.value;\n  if (attr.op === \"<truthy>\")\n    return !!objValue;\n  if (attr.op === \"=\") {\n    if (attrValue instanceof RegExp)\n      return typeof objValue === \"string\" && !!objValue.match(attrValue);\n    return objValue === attrValue;\n  }\n  if (typeof objValue !== \"string\" || typeof attrValue !== \"string\")\n    return false;\n  if (attr.op === \"*=\")\n    return objValue.includes(attrValue);\n  if (attr.op === \"^=\")\n    return objValue.startsWith(attrValue);\n  if (attr.op === \"$=\")\n    return objValue.endsWith(attrValue);\n  if (attr.op === \"|=\")\n    return objValue === attrValue || objValue.startsWith(attrValue + \"-\");\n  if (attr.op === \"~=\")\n    return objValue.split(\" \").includes(attrValue);\n  return false;\n}\nfunction shouldSkipForTextMatching(element) {\n  const document = element.ownerDocument;\n  return element.nodeName === \"SCRIPT\" || element.nodeName === \"NOSCRIPT\" || element.nodeName === \"STYLE\" || document.head && document.head.contains(element);\n}\nfunction elementText(cache, root) {\n  let value = cache.get(root);\n  if (value === void 0) {\n    value = { full: \"\", normalized: \"\", immediate: [] };\n    if (!shouldSkipForTextMatching(root)) {\n      let currentImmediate = \"\";\n      if (root instanceof HTMLInputElement && (root.type === \"submit\" || root.type === \"button\")) {\n        value = { full: root.value, normalized: normalizeWhiteSpace(root.value), immediate: [root.value] };\n      } else {\n        for (let child = root.firstChild; child; child = child.nextSibling) {\n          if (child.nodeType === Node.TEXT_NODE) {\n            value.full += child.nodeValue || \"\";\n            currentImmediate += child.nodeValue || \"\";\n          } else if (child.nodeType === Node.COMMENT_NODE) {\n            continue;\n          } else {\n            if (currentImmediate)\n              value.immediate.push(currentImmediate);\n            currentImmediate = \"\";\n            if (child.nodeType === Node.ELEMENT_NODE)\n              value.full += elementText(cache, child).full;\n          }\n        }\n        if (currentImmediate)\n          value.immediate.push(currentImmediate);\n        if (root.shadowRoot)\n          value.full += elementText(cache, root.shadowRoot).full;\n        if (value.full)\n          value.normalized = normalizeWhiteSpace(value.full);\n      }\n    }\n    cache.set(root, value);\n  }\n  return value;\n}\nfunction elementMatchesText(cache, element, matcher) {\n  if (shouldSkipForTextMatching(element))\n    return \"none\";\n  if (!matcher(elementText(cache, element)))\n    return \"none\";\n  for (let child = element.firstChild; child; child = child.nextSibling) {\n    if (child.nodeType === Node.ELEMENT_NODE && matcher(elementText(cache, child)))\n      return \"selfAndChildren\";\n  }\n  if (element.shadowRoot && matcher(elementText(cache, element.shadowRoot)))\n    return \"selfAndChildren\";\n  return \"self\";\n}\nfunction getElementLabels(textCache, element) {\n  const labels = getAriaLabelledByElements(element);\n  if (labels)\n    return labels.map((label) => elementText(textCache, label));\n  const ariaLabel = element.getAttribute(\"aria-label\");\n  if (ariaLabel !== null && !!ariaLabel.trim())\n    return [{ full: ariaLabel, normalized: normalizeWhiteSpace(ariaLabel), immediate: [ariaLabel] }];\n  const isNonHiddenInput = element.nodeName === \"INPUT\" && element.type !== \"hidden\";\n  if ([\"BUTTON\", \"METER\", \"OUTPUT\", \"PROGRESS\", \"SELECT\", \"TEXTAREA\"].includes(element.nodeName) || isNonHiddenInput) {\n    const labels2 = element.labels;\n    if (labels2)\n      return [...labels2].map((label) => elementText(textCache, label));\n  }\n  return [];\n}\n\n// packages/injected/src/reactSelectorEngine.ts\nfunction getFunctionComponentName(component) {\n  return component.displayName || component.name || \"Anonymous\";\n}\nfunction getComponentName(reactElement) {\n  if (reactElement.type) {\n    switch (typeof reactElement.type) {\n      case \"function\":\n        return getFunctionComponentName(reactElement.type);\n      case \"string\":\n        return reactElement.type;\n      case \"object\":\n        return reactElement.type.displayName || (reactElement.type.render ? getFunctionComponentName(reactElement.type.render) : \"\");\n    }\n  }\n  if (reactElement._currentElement) {\n    const elementType = reactElement._currentElement.type;\n    if (typeof elementType === \"string\")\n      return elementType;\n    if (typeof elementType === \"function\")\n      return elementType.displayName || elementType.name || \"Anonymous\";\n  }\n  return \"\";\n}\nfunction getComponentKey(reactElement) {\n  var _a, _b;\n  return (_b = reactElement.key) != null ? _b : (_a = reactElement._currentElement) == null ? void 0 : _a.key;\n}\nfunction getChildren(reactElement) {\n  if (reactElement.child) {\n    const children = [];\n    for (let child = reactElement.child; child; child = child.sibling)\n      children.push(child);\n    return children;\n  }\n  if (!reactElement._currentElement)\n    return [];\n  const isKnownElement = (reactElement2) => {\n    var _a;\n    const elementType = (_a = reactElement2._currentElement) == null ? void 0 : _a.type;\n    return typeof elementType === \"function\" || typeof elementType === \"string\";\n  };\n  if (reactElement._renderedComponent) {\n    const child = reactElement._renderedComponent;\n    return isKnownElement(child) ? [child] : [];\n  }\n  if (reactElement._renderedChildren)\n    return [...Object.values(reactElement._renderedChildren)].filter(isKnownElement);\n  return [];\n}\nfunction getProps(reactElement) {\n  var _a;\n  const props = (\n    // React 16+\n    reactElement.memoizedProps || // React 15\n    ((_a = reactElement._currentElement) == null ? void 0 : _a.props)\n  );\n  if (!props || typeof props === \"string\")\n    return props;\n  const result = { ...props };\n  delete result.children;\n  return result;\n}\nfunction buildComponentsTree(reactElement) {\n  var _a;\n  const treeNode = {\n    key: getComponentKey(reactElement),\n    name: getComponentName(reactElement),\n    children: getChildren(reactElement).map(buildComponentsTree),\n    rootElements: [],\n    props: getProps(reactElement)\n  };\n  const rootElement = (\n    // React 16+\n    // @see https://github.com/baruchvlz/resq/blob/5c15a5e04d3f7174087248f5a158c3d6dcc1ec72/src/utils.js#L29\n    reactElement.stateNode || // React 15\n    reactElement._hostNode || ((_a = reactElement._renderedComponent) == null ? void 0 : _a._hostNode)\n  );\n  if (rootElement instanceof Element) {\n    treeNode.rootElements.push(rootElement);\n  } else {\n    for (const child of treeNode.children)\n      treeNode.rootElements.push(...child.rootElements);\n  }\n  return treeNode;\n}\nfunction filterComponentsTree(treeNode, searchFn, result = []) {\n  if (searchFn(treeNode))\n    result.push(treeNode);\n  for (const child of treeNode.children)\n    filterComponentsTree(child, searchFn, result);\n  return result;\n}\nfunction findReactRoots(root, roots = []) {\n  const document = root.ownerDocument || root;\n  const walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT);\n  do {\n    const node = walker.currentNode;\n    const reactNode = node;\n    const rootKey = Object.keys(reactNode).find((key) => key.startsWith(\"__reactContainer\") && reactNode[key] !== null);\n    if (rootKey) {\n      roots.push(reactNode[rootKey].stateNode.current);\n    } else {\n      const legacyRootKey = \"_reactRootContainer\";\n      if (reactNode.hasOwnProperty(legacyRootKey) && reactNode[legacyRootKey] !== null) {\n        roots.push(reactNode[legacyRootKey]._internalRoot.current);\n      }\n    }\n    if (node instanceof Element && node.hasAttribute(\"data-reactroot\")) {\n      for (const key of Object.keys(node)) {\n        if (key.startsWith(\"__reactInternalInstance\") || key.startsWith(\"__reactFiber\"))\n          roots.push(node[key]);\n      }\n    }\n    const shadowRoot = node instanceof Element ? node.shadowRoot : null;\n    if (shadowRoot)\n      findReactRoots(shadowRoot, roots);\n  } while (walker.nextNode());\n  return roots;\n}\nvar createReactEngine = () => ({\n  queryAll(scope, selector) {\n    const { name, attributes } = parseAttributeSelector(selector, false);\n    const reactRoots = findReactRoots(scope.ownerDocument || scope);\n    const trees = reactRoots.map((reactRoot) => buildComponentsTree(reactRoot));\n    const treeNodes = trees.map((tree) => filterComponentsTree(tree, (treeNode) => {\n      var _a;\n      const props = (_a = treeNode.props) != null ? _a : {};\n      if (treeNode.key !== void 0)\n        props.key = treeNode.key;\n      if (name && treeNode.name !== name)\n        return false;\n      if (treeNode.rootElements.some((domNode) => !isInsideScope(scope, domNode)))\n        return false;\n      for (const attr of attributes) {\n        if (!matchesComponentAttribute(props, attr))\n          return false;\n      }\n      return true;\n    })).flat();\n    const allRootElements = new Set();\n    for (const treeNode of treeNodes) {\n      for (const domNode of treeNode.rootElements)\n        allRootElements.add(domNode);\n    }\n    return [...allRootElements];\n  }\n});\n\n// packages/injected/src/roleSelectorEngine.ts\nvar kSupportedAttributes = [\"selected\", \"checked\", \"pressed\", \"expanded\", \"level\", \"disabled\", \"name\", \"include-hidden\"];\nkSupportedAttributes.sort();\nfunction validateSupportedRole(attr, roles, role) {\n  if (!roles.includes(role))\n    throw new Error(`\"${attr}\" attribute is only supported for roles: ${roles.slice().sort().map((role2) => `\"${role2}\"`).join(\", \")}`);\n}\nfunction validateSupportedValues(attr, values) {\n  if (attr.op !== \"<truthy>\" && !values.includes(attr.value))\n    throw new Error(`\"${attr.name}\" must be one of ${values.map((v) => JSON.stringify(v)).join(\", \")}`);\n}\nfunction validateSupportedOp(attr, ops) {\n  if (!ops.includes(attr.op))\n    throw new Error(`\"${attr.name}\" does not support \"${attr.op}\" matcher`);\n}\nfunction validateAttributes(attrs, role) {\n  const options = { role };\n  for (const attr of attrs) {\n    switch (attr.name) {\n      case \"checked\": {\n        validateSupportedRole(attr.name, kAriaCheckedRoles, role);\n        validateSupportedValues(attr, [true, false, \"mixed\"]);\n        validateSupportedOp(attr, [\"<truthy>\", \"=\"]);\n        options.checked = attr.op === \"<truthy>\" ? true : attr.value;\n        break;\n      }\n      case \"pressed\": {\n        validateSupportedRole(attr.name, kAriaPressedRoles, role);\n        validateSupportedValues(attr, [true, false, \"mixed\"]);\n        validateSupportedOp(attr, [\"<truthy>\", \"=\"]);\n        options.pressed = attr.op === \"<truthy>\" ? true : attr.value;\n        break;\n      }\n      case \"selected\": {\n        validateSupportedRole(attr.name, kAriaSelectedRoles, role);\n        validateSupportedValues(attr, [true, false]);\n        validateSupportedOp(attr, [\"<truthy>\", \"=\"]);\n        options.selected = attr.op === \"<truthy>\" ? true : attr.value;\n        break;\n      }\n      case \"expanded\": {\n        validateSupportedRole(attr.name, kAriaExpandedRoles, role);\n        validateSupportedValues(attr, [true, false]);\n        validateSupportedOp(attr, [\"<truthy>\", \"=\"]);\n        options.expanded = attr.op === \"<truthy>\" ? true : attr.value;\n        break;\n      }\n      case \"level\": {\n        validateSupportedRole(attr.name, kAriaLevelRoles, role);\n        if (typeof attr.value === \"string\")\n          attr.value = +attr.value;\n        if (attr.op !== \"=\" || typeof attr.value !== \"number\" || Number.isNaN(attr.value))\n          throw new Error(`\"level\" attribute must be compared to a number`);\n        options.level = attr.value;\n        break;\n      }\n      case \"disabled\": {\n        validateSupportedValues(attr, [true, false]);\n        validateSupportedOp(attr, [\"<truthy>\", \"=\"]);\n        options.disabled = attr.op === \"<truthy>\" ? true : attr.value;\n        break;\n      }\n      case \"name\": {\n        if (attr.op === \"<truthy>\")\n          throw new Error(`\"name\" attribute must have a value`);\n        if (typeof attr.value !== \"string\" && !(attr.value instanceof RegExp))\n          throw new Error(`\"name\" attribute must be a string or a regular expression`);\n        options.name = attr.value;\n        options.nameOp = attr.op;\n        options.exact = attr.caseSensitive;\n        break;\n      }\n      case \"include-hidden\": {\n        validateSupportedValues(attr, [true, false]);\n        validateSupportedOp(attr, [\"<truthy>\", \"=\"]);\n        options.includeHidden = attr.op === \"<truthy>\" ? true : attr.value;\n        break;\n      }\n      default: {\n        throw new Error(`Unknown attribute \"${attr.name}\", must be one of ${kSupportedAttributes.map((a) => `\"${a}\"`).join(\", \")}.`);\n      }\n    }\n  }\n  return options;\n}\nfunction queryRole(scope, options, internal) {\n  const result = [];\n  const match = (element) => {\n    if (getAriaRole(element) !== options.role)\n      return;\n    if (options.selected !== void 0 && getAriaSelected(element) !== options.selected)\n      return;\n    if (options.checked !== void 0 && getAriaChecked(element) !== options.checked)\n      return;\n    if (options.pressed !== void 0 && getAriaPressed(element) !== options.pressed)\n      return;\n    if (options.expanded !== void 0 && getAriaExpanded(element) !== options.expanded)\n      return;\n    if (options.level !== void 0 && getAriaLevel(element) !== options.level)\n      return;\n    if (options.disabled !== void 0 && getAriaDisabled(element) !== options.disabled)\n      return;\n    if (!options.includeHidden) {\n      const isHidden = isElementHiddenForAria(element);\n      if (isHidden)\n        return;\n    }\n    if (options.name !== void 0) {\n      const accessibleName = normalizeWhiteSpace(getElementAccessibleName(element, !!options.includeHidden));\n      if (typeof options.name === \"string\")\n        options.name = normalizeWhiteSpace(options.name);\n      if (internal && !options.exact && options.nameOp === \"=\")\n        options.nameOp = \"*=\";\n      if (!matchesAttributePart(accessibleName, { name: \"\", jsonPath: [], op: options.nameOp || \"=\", value: options.name, caseSensitive: !!options.exact }))\n        return;\n    }\n    result.push(element);\n  };\n  const query = (root) => {\n    const shadows = [];\n    if (root.shadowRoot)\n      shadows.push(root.shadowRoot);\n    for (const element of root.querySelectorAll(\"*\")) {\n      match(element);\n      if (element.shadowRoot)\n        shadows.push(element.shadowRoot);\n    }\n    shadows.forEach(query);\n  };\n  query(scope);\n  return result;\n}\nfunction createRoleEngine(internal) {\n  return {\n    queryAll: (scope, selector) => {\n      const parsed = parseAttributeSelector(selector, true);\n      const role = parsed.name.toLowerCase();\n      if (!role)\n        throw new Error(`Role must not be empty`);\n      const options = validateAttributes(parsed.attributes, role);\n      beginAriaCaches();\n      try {\n        return queryRole(scope, options, internal);\n      } finally {\n        endAriaCaches();\n      }\n    }\n  };\n}\n\n// packages/injected/src/selectorEvaluator.ts\nvar SelectorEvaluatorImpl = class {\n  constructor() {\n    this._retainCacheCounter = 0;\n    this._cacheText = new Map();\n    this._cacheQueryCSS = new Map();\n    this._cacheMatches = new Map();\n    this._cacheQuery = new Map();\n    this._cacheMatchesSimple = new Map();\n    this._cacheMatchesParents = new Map();\n    this._cacheCallMatches = new Map();\n    this._cacheCallQuery = new Map();\n    this._cacheQuerySimple = new Map();\n    this._engines = new Map();\n    this._engines.set(\"not\", notEngine);\n    this._engines.set(\"is\", isEngine);\n    this._engines.set(\"where\", isEngine);\n    this._engines.set(\"has\", hasEngine);\n    this._engines.set(\"scope\", scopeEngine);\n    this._engines.set(\"light\", lightEngine);\n    this._engines.set(\"visible\", visibleEngine);\n    this._engines.set(\"text\", textEngine);\n    this._engines.set(\"text-is\", textIsEngine);\n    this._engines.set(\"text-matches\", textMatchesEngine);\n    this._engines.set(\"has-text\", hasTextEngine);\n    this._engines.set(\"right-of\", createLayoutEngine(\"right-of\"));\n    this._engines.set(\"left-of\", createLayoutEngine(\"left-of\"));\n    this._engines.set(\"above\", createLayoutEngine(\"above\"));\n    this._engines.set(\"below\", createLayoutEngine(\"below\"));\n    this._engines.set(\"near\", createLayoutEngine(\"near\"));\n    this._engines.set(\"nth-match\", nthMatchEngine);\n    const allNames = [...this._engines.keys()];\n    allNames.sort();\n    const parserNames = [...customCSSNames];\n    parserNames.sort();\n    if (allNames.join(\"|\") !== parserNames.join(\"|\"))\n      throw new Error(`Please keep customCSSNames in sync with evaluator engines: ${allNames.join(\"|\")} vs ${parserNames.join(\"|\")}`);\n  }\n  begin() {\n    ++this._retainCacheCounter;\n  }\n  end() {\n    --this._retainCacheCounter;\n    if (!this._retainCacheCounter) {\n      this._cacheQueryCSS.clear();\n      this._cacheMatches.clear();\n      this._cacheQuery.clear();\n      this._cacheMatchesSimple.clear();\n      this._cacheMatchesParents.clear();\n      this._cacheCallMatches.clear();\n      this._cacheCallQuery.clear();\n      this._cacheQuerySimple.clear();\n      this._cacheText.clear();\n    }\n  }\n  _cached(cache, main, rest, cb) {\n    if (!cache.has(main))\n      cache.set(main, []);\n    const entries = cache.get(main);\n    const entry = entries.find((e) => rest.every((value, index) => e.rest[index] === value));\n    if (entry)\n      return entry.result;\n    const result = cb();\n    entries.push({ rest, result });\n    return result;\n  }\n  _checkSelector(s) {\n    const wellFormed = typeof s === \"object\" && s && (Array.isArray(s) || \"simples\" in s && s.simples.length);\n    if (!wellFormed)\n      throw new Error(`Malformed selector \"${s}\"`);\n    return s;\n  }\n  matches(element, s, context) {\n    const selector = this._checkSelector(s);\n    this.begin();\n    try {\n      return this._cached(this._cacheMatches, element, [selector, context.scope, context.pierceShadow, context.originalScope], () => {\n        if (Array.isArray(selector))\n          return this._matchesEngine(isEngine, element, selector, context);\n        if (this._hasScopeClause(selector))\n          context = this._expandContextForScopeMatching(context);\n        if (!this._matchesSimple(element, selector.simples[selector.simples.length - 1].selector, context))\n          return false;\n        return this._matchesParents(element, selector, selector.simples.length - 2, context);\n      });\n    } finally {\n      this.end();\n    }\n  }\n  query(context, s) {\n    const selector = this._checkSelector(s);\n    this.begin();\n    try {\n      return this._cached(this._cacheQuery, selector, [context.scope, context.pierceShadow, context.originalScope], () => {\n        if (Array.isArray(selector))\n          return this._queryEngine(isEngine, context, selector);\n        if (this._hasScopeClause(selector))\n          context = this._expandContextForScopeMatching(context);\n        const previousScoreMap = this._scoreMap;\n        this._scoreMap = new Map();\n        let elements = this._querySimple(context, selector.simples[selector.simples.length - 1].selector);\n        elements = elements.filter((element) => this._matchesParents(element, selector, selector.simples.length - 2, context));\n        if (this._scoreMap.size) {\n          elements.sort((a, b) => {\n            const aScore = this._scoreMap.get(a);\n            const bScore = this._scoreMap.get(b);\n            if (aScore === bScore)\n              return 0;\n            if (aScore === void 0)\n              return 1;\n            if (bScore === void 0)\n              return -1;\n            return aScore - bScore;\n          });\n        }\n        this._scoreMap = previousScoreMap;\n        return elements;\n      });\n    } finally {\n      this.end();\n    }\n  }\n  _markScore(element, score) {\n    if (this._scoreMap)\n      this._scoreMap.set(element, score);\n  }\n  _hasScopeClause(selector) {\n    return selector.simples.some((simple) => simple.selector.functions.some((f) => f.name === \"scope\"));\n  }\n  _expandContextForScopeMatching(context) {\n    if (context.scope.nodeType !== 1)\n      return context;\n    const scope = parentElementOrShadowHost(context.scope);\n    if (!scope)\n      return context;\n    return { ...context, scope, originalScope: context.originalScope || context.scope };\n  }\n  _matchesSimple(element, simple, context) {\n    return this._cached(this._cacheMatchesSimple, element, [simple, context.scope, context.pierceShadow, context.originalScope], () => {\n      if (element === context.scope)\n        return false;\n      if (simple.css && !this._matchesCSS(element, simple.css))\n        return false;\n      for (const func of simple.functions) {\n        if (!this._matchesEngine(this._getEngine(func.name), element, func.args, context))\n          return false;\n      }\n      return true;\n    });\n  }\n  _querySimple(context, simple) {\n    if (!simple.functions.length)\n      return this._queryCSS(context, simple.css || \"*\");\n    return this._cached(this._cacheQuerySimple, simple, [context.scope, context.pierceShadow, context.originalScope], () => {\n      let css = simple.css;\n      const funcs = simple.functions;\n      if (css === \"*\" && funcs.length)\n        css = void 0;\n      let elements;\n      let firstIndex = -1;\n      if (css !== void 0) {\n        elements = this._queryCSS(context, css);\n      } else {\n        firstIndex = funcs.findIndex((func) => this._getEngine(func.name).query !== void 0);\n        if (firstIndex === -1)\n          firstIndex = 0;\n        elements = this._queryEngine(this._getEngine(funcs[firstIndex].name), context, funcs[firstIndex].args);\n      }\n      for (let i = 0; i < funcs.length; i++) {\n        if (i === firstIndex)\n          continue;\n        const engine = this._getEngine(funcs[i].name);\n        if (engine.matches !== void 0)\n          elements = elements.filter((e) => this._matchesEngine(engine, e, funcs[i].args, context));\n      }\n      for (let i = 0; i < funcs.length; i++) {\n        if (i === firstIndex)\n          continue;\n        const engine = this._getEngine(funcs[i].name);\n        if (engine.matches === void 0)\n          elements = elements.filter((e) => this._matchesEngine(engine, e, funcs[i].args, context));\n      }\n      return elements;\n    });\n  }\n  _matchesParents(element, complex, index, context) {\n    if (index < 0)\n      return true;\n    return this._cached(this._cacheMatchesParents, element, [complex, index, context.scope, context.pierceShadow, context.originalScope], () => {\n      const { selector: simple, combinator } = complex.simples[index];\n      if (combinator === \">\") {\n        const parent = parentElementOrShadowHostInContext(element, context);\n        if (!parent || !this._matchesSimple(parent, simple, context))\n          return false;\n        return this._matchesParents(parent, complex, index - 1, context);\n      }\n      if (combinator === \"+\") {\n        const previousSibling = previousSiblingInContext(element, context);\n        if (!previousSibling || !this._matchesSimple(previousSibling, simple, context))\n          return false;\n        return this._matchesParents(previousSibling, complex, index - 1, context);\n      }\n      if (combinator === \"\") {\n        let parent = parentElementOrShadowHostInContext(element, context);\n        while (parent) {\n          if (this._matchesSimple(parent, simple, context)) {\n            if (this._matchesParents(parent, complex, index - 1, context))\n              return true;\n            if (complex.simples[index - 1].combinator === \"\")\n              break;\n          }\n          parent = parentElementOrShadowHostInContext(parent, context);\n        }\n        return false;\n      }\n      if (combinator === \"~\") {\n        let previousSibling = previousSiblingInContext(element, context);\n        while (previousSibling) {\n          if (this._matchesSimple(previousSibling, simple, context)) {\n            if (this._matchesParents(previousSibling, complex, index - 1, context))\n              return true;\n            if (complex.simples[index - 1].combinator === \"~\")\n              break;\n          }\n          previousSibling = previousSiblingInContext(previousSibling, context);\n        }\n        return false;\n      }\n      if (combinator === \">=\") {\n        let parent = element;\n        while (parent) {\n          if (this._matchesSimple(parent, simple, context)) {\n            if (this._matchesParents(parent, complex, index - 1, context))\n              return true;\n            if (complex.simples[index - 1].combinator === \"\")\n              break;\n          }\n          parent = parentElementOrShadowHostInContext(parent, context);\n        }\n        return false;\n      }\n      throw new Error(`Unsupported combinator \"${combinator}\"`);\n    });\n  }\n  _matchesEngine(engine, element, args, context) {\n    if (engine.matches)\n      return this._callMatches(engine, element, args, context);\n    if (engine.query)\n      return this._callQuery(engine, args, context).includes(element);\n    throw new Error(`Selector engine should implement \"matches\" or \"query\"`);\n  }\n  _queryEngine(engine, context, args) {\n    if (engine.query)\n      return this._callQuery(engine, args, context);\n    if (engine.matches)\n      return this._queryCSS(context, \"*\").filter((element) => this._callMatches(engine, element, args, context));\n    throw new Error(`Selector engine should implement \"matches\" or \"query\"`);\n  }\n  _callMatches(engine, element, args, context) {\n    return this._cached(this._cacheCallMatches, element, [engine, context.scope, context.pierceShadow, context.originalScope, ...args], () => {\n      return engine.matches(element, args, context, this);\n    });\n  }\n  _callQuery(engine, args, context) {\n    return this._cached(this._cacheCallQuery, engine, [context.scope, context.pierceShadow, context.originalScope, ...args], () => {\n      return engine.query(context, args, this);\n    });\n  }\n  _matchesCSS(element, css) {\n    return element.matches(css);\n  }\n  _queryCSS(context, css) {\n    return this._cached(this._cacheQueryCSS, css, [context.scope, context.pierceShadow, context.originalScope], () => {\n      let result = [];\n      function query(root) {\n        result = result.concat([...root.querySelectorAll(css)]);\n        if (!context.pierceShadow)\n          return;\n        if (root.shadowRoot)\n          query(root.shadowRoot);\n        for (const element of root.querySelectorAll(\"*\")) {\n          if (element.shadowRoot)\n            query(element.shadowRoot);\n        }\n      }\n      query(context.scope);\n      return result;\n    });\n  }\n  _getEngine(name) {\n    const engine = this._engines.get(name);\n    if (!engine)\n      throw new Error(`Unknown selector engine \"${name}\"`);\n    return engine;\n  }\n};\nvar isEngine = {\n  matches(element, args, context, evaluator) {\n    if (args.length === 0)\n      throw new Error(`\"is\" engine expects non-empty selector list`);\n    return args.some((selector) => evaluator.matches(element, selector, context));\n  },\n  query(context, args, evaluator) {\n    if (args.length === 0)\n      throw new Error(`\"is\" engine expects non-empty selector list`);\n    let elements = [];\n    for (const arg of args)\n      elements = elements.concat(evaluator.query(context, arg));\n    return args.length === 1 ? elements : sortInDOMOrder(elements);\n  }\n};\nvar hasEngine = {\n  matches(element, args, context, evaluator) {\n    if (args.length === 0)\n      throw new Error(`\"has\" engine expects non-empty selector list`);\n    return evaluator.query({ ...context, scope: element }, args).length > 0;\n  }\n  // TODO: we can implement efficient \"query\" by matching \"args\" and returning\n  // all parents/descendants, just have to be careful with the \":scope\" matching.\n};\nvar scopeEngine = {\n  matches(element, args, context, evaluator) {\n    if (args.length !== 0)\n      throw new Error(`\"scope\" engine expects no arguments`);\n    const actualScope = context.originalScope || context.scope;\n    if (actualScope.nodeType === 9)\n      return element === actualScope.documentElement;\n    return element === actualScope;\n  },\n  query(context, args, evaluator) {\n    if (args.length !== 0)\n      throw new Error(`\"scope\" engine expects no arguments`);\n    const actualScope = context.originalScope || context.scope;\n    if (actualScope.nodeType === 9) {\n      const root = actualScope.documentElement;\n      return root ? [root] : [];\n    }\n    if (actualScope.nodeType === 1)\n      return [actualScope];\n    return [];\n  }\n};\nvar notEngine = {\n  matches(element, args, context, evaluator) {\n    if (args.length === 0)\n      throw new Error(`\"not\" engine expects non-empty selector list`);\n    return !evaluator.matches(element, args, context);\n  }\n};\nvar lightEngine = {\n  query(context, args, evaluator) {\n    return evaluator.query({ ...context, pierceShadow: false }, args);\n  },\n  matches(element, args, context, evaluator) {\n    return evaluator.matches(element, args, { ...context, pierceShadow: false });\n  }\n};\nvar visibleEngine = {\n  matches(element, args, context, evaluator) {\n    if (args.length)\n      throw new Error(`\"visible\" engine expects no arguments`);\n    return isElementVisible(element);\n  }\n};\nvar textEngine = {\n  matches(element, args, context, evaluator) {\n    if (args.length !== 1 || typeof args[0] !== \"string\")\n      throw new Error(`\"text\" engine expects a single string`);\n    const text = normalizeWhiteSpace(args[0]).toLowerCase();\n    const matcher = (elementText2) => elementText2.normalized.toLowerCase().includes(text);\n    return elementMatchesText(evaluator._cacheText, element, matcher) === \"self\";\n  }\n};\nvar textIsEngine = {\n  matches(element, args, context, evaluator) {\n    if (args.length !== 1 || typeof args[0] !== \"string\")\n      throw new Error(`\"text-is\" engine expects a single string`);\n    const text = normalizeWhiteSpace(args[0]);\n    const matcher = (elementText2) => {\n      if (!text && !elementText2.immediate.length)\n        return true;\n      return elementText2.immediate.some((s) => normalizeWhiteSpace(s) === text);\n    };\n    return elementMatchesText(evaluator._cacheText, element, matcher) !== \"none\";\n  }\n};\nvar textMatchesEngine = {\n  matches(element, args, context, evaluator) {\n    if (args.length === 0 || typeof args[0] !== \"string\" || args.length > 2 || args.length === 2 && typeof args[1] !== \"string\")\n      throw new Error(`\"text-matches\" engine expects a regexp body and optional regexp flags`);\n    const re = new RegExp(args[0], args.length === 2 ? args[1] : void 0);\n    const matcher = (elementText2) => re.test(elementText2.full);\n    return elementMatchesText(evaluator._cacheText, element, matcher) === \"self\";\n  }\n};\nvar hasTextEngine = {\n  matches(element, args, context, evaluator) {\n    if (args.length !== 1 || typeof args[0] !== \"string\")\n      throw new Error(`\"has-text\" engine expects a single string`);\n    if (shouldSkipForTextMatching(element))\n      return false;\n    const text = normalizeWhiteSpace(args[0]).toLowerCase();\n    const matcher = (elementText2) => elementText2.normalized.toLowerCase().includes(text);\n    return matcher(elementText(evaluator._cacheText, element));\n  }\n};\nfunction createLayoutEngine(name) {\n  return {\n    matches(element, args, context, evaluator) {\n      const maxDistance = args.length && typeof args[args.length - 1] === \"number\" ? args[args.length - 1] : void 0;\n      const queryArgs = maxDistance === void 0 ? args : args.slice(0, args.length - 1);\n      if (args.length < 1 + (maxDistance === void 0 ? 0 : 1))\n        throw new Error(`\"${name}\" engine expects a selector list and optional maximum distance in pixels`);\n      const inner = evaluator.query(context, queryArgs);\n      const score = layoutSelectorScore(name, element, inner, maxDistance);\n      if (score === void 0)\n        return false;\n      evaluator._markScore(element, score);\n      return true;\n    }\n  };\n}\nvar nthMatchEngine = {\n  query(context, args, evaluator) {\n    let index = args[args.length - 1];\n    if (args.length < 2)\n      throw new Error(`\"nth-match\" engine expects non-empty selector list and an index argument`);\n    if (typeof index !== \"number\" || index < 1)\n      throw new Error(`\"nth-match\" engine expects a one-based index as the last argument`);\n    const elements = isEngine.query(context, args.slice(0, args.length - 1), evaluator);\n    index--;\n    return index < elements.length ? [elements[index]] : [];\n  }\n};\nfunction parentElementOrShadowHostInContext(element, context) {\n  if (element === context.scope)\n    return;\n  if (!context.pierceShadow)\n    return element.parentElement || void 0;\n  return parentElementOrShadowHost(element);\n}\nfunction previousSiblingInContext(element, context) {\n  if (element === context.scope)\n    return;\n  return element.previousElementSibling || void 0;\n}\nfunction sortInDOMOrder(elements) {\n  const elementToEntry = new Map();\n  const roots = [];\n  const result = [];\n  function append(element) {\n    let entry = elementToEntry.get(element);\n    if (entry)\n      return entry;\n    const parent = parentElementOrShadowHost(element);\n    if (parent) {\n      const parentEntry = append(parent);\n      parentEntry.children.push(element);\n    } else {\n      roots.push(element);\n    }\n    entry = { children: [], taken: false };\n    elementToEntry.set(element, entry);\n    return entry;\n  }\n  for (const e of elements)\n    append(e).taken = true;\n  function visit(element) {\n    const entry = elementToEntry.get(element);\n    if (entry.taken)\n      result.push(element);\n    if (entry.children.length > 1) {\n      const set = new Set(entry.children);\n      entry.children = [];\n      let child = element.firstElementChild;\n      while (child && entry.children.length < set.size) {\n        if (set.has(child))\n          entry.children.push(child);\n        child = child.nextElementSibling;\n      }\n      child = element.shadowRoot ? element.shadowRoot.firstElementChild : null;\n      while (child && entry.children.length < set.size) {\n        if (set.has(child))\n          entry.children.push(child);\n        child = child.nextElementSibling;\n      }\n    }\n    entry.children.forEach(visit);\n  }\n  roots.forEach(visit);\n  return result;\n}\n\n// packages/injected/src/selectorGenerator.ts\nvar kTextScoreRange = 10;\nvar kExactPenalty = kTextScoreRange / 2;\nvar kTestIdScore = 1;\nvar kOtherTestIdScore = 2;\nvar kIframeByAttributeScore = 10;\nvar kBeginPenalizedScore = 50;\nvar kRoleWithNameScore = 100;\nvar kPlaceholderScore = 120;\nvar kLabelScore = 140;\nvar kAltTextScore = 160;\nvar kTextScore = 180;\nvar kTitleScore = 200;\nvar kTextScoreRegex = 250;\nvar kPlaceholderScoreExact = kPlaceholderScore + kExactPenalty;\nvar kLabelScoreExact = kLabelScore + kExactPenalty;\nvar kRoleWithNameScoreExact = kRoleWithNameScore + kExactPenalty;\nvar kAltTextScoreExact = kAltTextScore + kExactPenalty;\nvar kTextScoreExact = kTextScore + kExactPenalty;\nvar kTitleScoreExact = kTitleScore + kExactPenalty;\nvar kEndPenalizedScore = 300;\nvar kCSSIdScore = 500;\nvar kRoleWithoutNameScore = 510;\nvar kCSSInputTypeNameScore = 520;\nvar kCSSTagNameScore = 530;\nvar kNthScore = 1e4;\nvar kCSSFallbackScore = 1e7;\nvar kScoreThresholdForTextExpect = 1e3;\nfunction generateSelector(injectedScript, targetElement, options) {\n  var _a;\n  injectedScript._evaluator.begin();\n  const cache = { allowText: new Map(), disallowText: new Map() };\n  beginAriaCaches();\n  try {\n    let selectors = [];\n    if (options.forTextExpect) {\n      let targetTokens = cssFallback(injectedScript, targetElement.ownerDocument.documentElement, options);\n      for (let element = targetElement; element; element = parentElementOrShadowHost(element)) {\n        const tokens = generateSelectorFor(cache, injectedScript, element, { ...options, noText: true });\n        if (!tokens)\n          continue;\n        const score = combineScores(tokens);\n        if (score <= kScoreThresholdForTextExpect) {\n          targetTokens = tokens;\n          break;\n        }\n      }\n      selectors = [joinTokens(targetTokens)];\n    } else {\n      if (!targetElement.matches(\"input,textarea,select\") && !targetElement.isContentEditable) {\n        const interactiveParent = closestCrossShadow(targetElement, \"button,select,input,[role=button],[role=checkbox],[role=radio],a,[role=link]\", options.root);\n        if (interactiveParent && isElementVisible(interactiveParent))\n          targetElement = interactiveParent;\n      }\n      if (options.multiple) {\n        const withText = generateSelectorFor(cache, injectedScript, targetElement, options);\n        const withoutText = generateSelectorFor(cache, injectedScript, targetElement, { ...options, noText: true });\n        let tokens = [withText, withoutText];\n        cache.allowText.clear();\n        cache.disallowText.clear();\n        if (withText && hasCSSIdToken(withText))\n          tokens.push(generateSelectorFor(cache, injectedScript, targetElement, { ...options, noCSSId: true }));\n        if (withoutText && hasCSSIdToken(withoutText))\n          tokens.push(generateSelectorFor(cache, injectedScript, targetElement, { ...options, noText: true, noCSSId: true }));\n        tokens = tokens.filter(Boolean);\n        if (!tokens.length) {\n          const css = cssFallback(injectedScript, targetElement, options);\n          tokens.push(css);\n          if (hasCSSIdToken(css))\n            tokens.push(cssFallback(injectedScript, targetElement, { ...options, noCSSId: true }));\n        }\n        selectors = [...new Set(tokens.map((t) => joinTokens(t)))];\n      } else {\n        const targetTokens = generateSelectorFor(cache, injectedScript, targetElement, options) || cssFallback(injectedScript, targetElement, options);\n        selectors = [joinTokens(targetTokens)];\n      }\n    }\n    const selector = selectors[0];\n    const parsedSelector = injectedScript.parseSelector(selector);\n    return {\n      selector,\n      selectors,\n      elements: injectedScript.querySelectorAll(parsedSelector, (_a = options.root) != null ? _a : targetElement.ownerDocument)\n    };\n  } finally {\n    endAriaCaches();\n    injectedScript._evaluator.end();\n  }\n}\nfunction filterRegexTokens(textCandidates) {\n  return textCandidates.filter((c) => c[0].selector[0] !== \"/\");\n}\nfunction generateSelectorFor(cache, injectedScript, targetElement, options) {\n  if (options.root && !isInsideScope(options.root, targetElement))\n    throw new Error(`Target element must belong to the root's subtree`);\n  if (targetElement === options.root)\n    return [{ engine: \"css\", selector: \":scope\", score: 1 }];\n  if (targetElement.ownerDocument.documentElement === targetElement)\n    return [{ engine: \"css\", selector: \"html\", score: 1 }];\n  const calculate = (element, allowText) => {\n    var _a;\n    const allowNthMatch = element === targetElement;\n    let textCandidates = allowText ? buildTextCandidates(injectedScript, element, element === targetElement) : [];\n    if (element !== targetElement) {\n      textCandidates = filterRegexTokens(textCandidates);\n    }\n    const noTextCandidates = buildNoTextCandidates(injectedScript, element, options).filter((token) => !options.omitInternalEngines || !token.engine.startsWith(\"internal:\")).map((token) => [token]);\n    let result = chooseFirstSelector(injectedScript, (_a = options.root) != null ? _a : targetElement.ownerDocument, element, [...textCandidates, ...noTextCandidates], allowNthMatch);\n    textCandidates = filterRegexTokens(textCandidates);\n    const checkWithText = (textCandidatesToUse) => {\n      const allowParentText = allowText && !textCandidatesToUse.length;\n      const candidates = [...textCandidatesToUse, ...noTextCandidates].filter((c) => {\n        if (!result)\n          return true;\n        return combineScores(c) < combineScores(result);\n      });\n      let bestPossibleInParent = candidates[0];\n      if (!bestPossibleInParent)\n        return;\n      for (let parent = parentElementOrShadowHost(element); parent && parent !== options.root; parent = parentElementOrShadowHost(parent)) {\n        const parentTokens = calculateCached(parent, allowParentText);\n        if (!parentTokens)\n          continue;\n        if (result && combineScores([...parentTokens, ...bestPossibleInParent]) >= combineScores(result))\n          continue;\n        bestPossibleInParent = chooseFirstSelector(injectedScript, parent, element, candidates, allowNthMatch);\n        if (!bestPossibleInParent)\n          return;\n        const combined = [...parentTokens, ...bestPossibleInParent];\n        if (!result || combineScores(combined) < combineScores(result))\n          result = combined;\n      }\n    };\n    checkWithText(textCandidates);\n    if (element === targetElement && textCandidates.length)\n      checkWithText([]);\n    return result;\n  };\n  const calculateCached = (element, allowText) => {\n    const map = allowText ? cache.allowText : cache.disallowText;\n    let value = map.get(element);\n    if (value === void 0) {\n      value = calculate(element, allowText);\n      map.set(element, value);\n    }\n    return value;\n  };\n  return calculate(targetElement, !options.noText);\n}\nfunction buildNoTextCandidates(injectedScript, element, options) {\n  const candidates = [];\n  {\n    for (const attr of [\"data-testid\", \"data-test-id\", \"data-test\"]) {\n      if (attr !== options.testIdAttributeName && element.getAttribute(attr))\n        candidates.push({ engine: \"css\", selector: `[${attr}=${quoteCSSAttributeValue(element.getAttribute(attr))}]`, score: kOtherTestIdScore });\n    }\n    if (!options.noCSSId) {\n      const idAttr = element.getAttribute(\"id\");\n      if (idAttr && !isGuidLike(idAttr))\n        candidates.push({ engine: \"css\", selector: makeSelectorForId(idAttr), score: kCSSIdScore });\n    }\n    candidates.push({ engine: \"css\", selector: cssEscape(element.nodeName.toLowerCase()), score: kCSSTagNameScore });\n  }\n  if (element.nodeName === \"IFRAME\") {\n    for (const attribute of [\"name\", \"title\"]) {\n      if (element.getAttribute(attribute))\n        candidates.push({ engine: \"css\", selector: `${cssEscape(element.nodeName.toLowerCase())}[${attribute}=${quoteCSSAttributeValue(element.getAttribute(attribute))}]`, score: kIframeByAttributeScore });\n    }\n    if (element.getAttribute(options.testIdAttributeName))\n      candidates.push({ engine: \"css\", selector: `[${options.testIdAttributeName}=${quoteCSSAttributeValue(element.getAttribute(options.testIdAttributeName))}]`, score: kTestIdScore });\n    penalizeScoreForLength([candidates]);\n    return candidates;\n  }\n  if (element.getAttribute(options.testIdAttributeName))\n    candidates.push({ engine: \"internal:testid\", selector: `[${options.testIdAttributeName}=${escapeForAttributeSelector(element.getAttribute(options.testIdAttributeName), true)}]`, score: kTestIdScore });\n  if (element.nodeName === \"INPUT\" || element.nodeName === \"TEXTAREA\") {\n    const input = element;\n    if (input.placeholder) {\n      candidates.push({ engine: \"internal:attr\", selector: `[placeholder=${escapeForAttributeSelector(input.placeholder, true)}]`, score: kPlaceholderScoreExact });\n      for (const alternative of suitableTextAlternatives(input.placeholder))\n        candidates.push({ engine: \"internal:attr\", selector: `[placeholder=${escapeForAttributeSelector(alternative.text, false)}]`, score: kPlaceholderScore - alternative.scoreBonus });\n    }\n  }\n  const labels = getElementLabels(injectedScript._evaluator._cacheText, element);\n  for (const label of labels) {\n    const labelText = label.normalized;\n    candidates.push({ engine: \"internal:label\", selector: escapeForTextSelector(labelText, true), score: kLabelScoreExact });\n    for (const alternative of suitableTextAlternatives(labelText))\n      candidates.push({ engine: \"internal:label\", selector: escapeForTextSelector(alternative.text, false), score: kLabelScore - alternative.scoreBonus });\n  }\n  const ariaRole = getAriaRole(element);\n  if (ariaRole && ![\"none\", \"presentation\"].includes(ariaRole))\n    candidates.push({ engine: \"internal:role\", selector: ariaRole, score: kRoleWithoutNameScore });\n  if (element.getAttribute(\"name\") && [\"BUTTON\", \"FORM\", \"FIELDSET\", \"FRAME\", \"IFRAME\", \"INPUT\", \"KEYGEN\", \"OBJECT\", \"OUTPUT\", \"SELECT\", \"TEXTAREA\", \"MAP\", \"META\", \"PARAM\"].includes(element.nodeName))\n    candidates.push({ engine: \"css\", selector: `${cssEscape(element.nodeName.toLowerCase())}[name=${quoteCSSAttributeValue(element.getAttribute(\"name\"))}]`, score: kCSSInputTypeNameScore });\n  if ([\"INPUT\", \"TEXTAREA\"].includes(element.nodeName) && element.getAttribute(\"type\") !== \"hidden\") {\n    if (element.getAttribute(\"type\"))\n      candidates.push({ engine: \"css\", selector: `${cssEscape(element.nodeName.toLowerCase())}[type=${quoteCSSAttributeValue(element.getAttribute(\"type\"))}]`, score: kCSSInputTypeNameScore });\n  }\n  if ([\"INPUT\", \"TEXTAREA\", \"SELECT\"].includes(element.nodeName) && element.getAttribute(\"type\") !== \"hidden\")\n    candidates.push({ engine: \"css\", selector: cssEscape(element.nodeName.toLowerCase()), score: kCSSInputTypeNameScore + 1 });\n  penalizeScoreForLength([candidates]);\n  return candidates;\n}\nfunction buildTextCandidates(injectedScript, element, isTargetNode) {\n  if (element.nodeName === \"SELECT\")\n    return [];\n  const candidates = [];\n  const title = element.getAttribute(\"title\");\n  if (title) {\n    candidates.push([{ engine: \"internal:attr\", selector: `[title=${escapeForAttributeSelector(title, true)}]`, score: kTitleScoreExact }]);\n    for (const alternative of suitableTextAlternatives(title))\n      candidates.push([{ engine: \"internal:attr\", selector: `[title=${escapeForAttributeSelector(alternative.text, false)}]`, score: kTitleScore - alternative.scoreBonus }]);\n  }\n  const alt = element.getAttribute(\"alt\");\n  if (alt && [\"APPLET\", \"AREA\", \"IMG\", \"INPUT\"].includes(element.nodeName)) {\n    candidates.push([{ engine: \"internal:attr\", selector: `[alt=${escapeForAttributeSelector(alt, true)}]`, score: kAltTextScoreExact }]);\n    for (const alternative of suitableTextAlternatives(alt))\n      candidates.push([{ engine: \"internal:attr\", selector: `[alt=${escapeForAttributeSelector(alternative.text, false)}]`, score: kAltTextScore - alternative.scoreBonus }]);\n  }\n  const text = elementText(injectedScript._evaluator._cacheText, element).normalized;\n  const textAlternatives = text ? suitableTextAlternatives(text) : [];\n  if (text) {\n    if (isTargetNode) {\n      if (text.length <= 80)\n        candidates.push([{ engine: \"internal:text\", selector: escapeForTextSelector(text, true), score: kTextScoreExact }]);\n      for (const alternative of textAlternatives)\n        candidates.push([{ engine: \"internal:text\", selector: escapeForTextSelector(alternative.text, false), score: kTextScore - alternative.scoreBonus }]);\n    }\n    const cssToken = { engine: \"css\", selector: cssEscape(element.nodeName.toLowerCase()), score: kCSSTagNameScore };\n    for (const alternative of textAlternatives)\n      candidates.push([cssToken, { engine: \"internal:has-text\", selector: escapeForTextSelector(alternative.text, false), score: kTextScore - alternative.scoreBonus }]);\n    if (text.length <= 80) {\n      const re = new RegExp(\"^\" + escapeRegExp(text) + \"$\");\n      candidates.push([cssToken, { engine: \"internal:has-text\", selector: escapeForTextSelector(re, false), score: kTextScoreRegex }]);\n    }\n  }\n  const ariaRole = getAriaRole(element);\n  if (ariaRole && ![\"none\", \"presentation\"].includes(ariaRole)) {\n    const ariaName = getElementAccessibleName(element, false);\n    if (ariaName) {\n      const roleToken = { engine: \"internal:role\", selector: `${ariaRole}[name=${escapeForAttributeSelector(ariaName, true)}]`, score: kRoleWithNameScoreExact };\n      candidates.push([roleToken]);\n      for (const alternative of suitableTextAlternatives(ariaName))\n        candidates.push([{ engine: \"internal:role\", selector: `${ariaRole}[name=${escapeForAttributeSelector(alternative.text, false)}]`, score: kRoleWithNameScore - alternative.scoreBonus }]);\n    } else {\n      const roleToken = { engine: \"internal:role\", selector: `${ariaRole}`, score: kRoleWithoutNameScore };\n      for (const alternative of textAlternatives)\n        candidates.push([roleToken, { engine: \"internal:has-text\", selector: escapeForTextSelector(alternative.text, false), score: kTextScore - alternative.scoreBonus }]);\n      if (text.length <= 80) {\n        const re = new RegExp(\"^\" + escapeRegExp(text) + \"$\");\n        candidates.push([roleToken, { engine: \"internal:has-text\", selector: escapeForTextSelector(re, false), score: kTextScoreRegex }]);\n      }\n    }\n  }\n  penalizeScoreForLength(candidates);\n  return candidates;\n}\nfunction makeSelectorForId(id) {\n  return /^[a-zA-Z][a-zA-Z0-9\\-\\_]+$/.test(id) ? \"#\" + id : `[id=\"${cssEscape(id)}\"]`;\n}\nfunction hasCSSIdToken(tokens) {\n  return tokens.some((token) => token.engine === \"css\" && (token.selector.startsWith(\"#\") || token.selector.startsWith('[id=\"')));\n}\nfunction cssFallback(injectedScript, targetElement, options) {\n  var _a;\n  const root = (_a = options.root) != null ? _a : targetElement.ownerDocument;\n  const tokens = [];\n  function uniqueCSSSelector(prefix) {\n    const path = tokens.slice();\n    if (prefix)\n      path.unshift(prefix);\n    const selector = path.join(\" > \");\n    const parsedSelector = injectedScript.parseSelector(selector);\n    const node = injectedScript.querySelector(parsedSelector, root, false);\n    return node === targetElement ? selector : void 0;\n  }\n  function makeStrict(selector) {\n    const token = { engine: \"css\", selector, score: kCSSFallbackScore };\n    const parsedSelector = injectedScript.parseSelector(selector);\n    const elements = injectedScript.querySelectorAll(parsedSelector, root);\n    if (elements.length === 1)\n      return [token];\n    const nth = { engine: \"nth\", selector: String(elements.indexOf(targetElement)), score: kNthScore };\n    return [token, nth];\n  }\n  for (let element = targetElement; element && element !== root; element = parentElementOrShadowHost(element)) {\n    const nodeName = element.nodeName.toLowerCase();\n    let bestTokenForLevel = \"\";\n    if (element.id && !options.noCSSId) {\n      const token = makeSelectorForId(element.id);\n      const selector = uniqueCSSSelector(token);\n      if (selector)\n        return makeStrict(selector);\n      bestTokenForLevel = token;\n    }\n    const parent = element.parentNode;\n    const classes = [...element.classList];\n    for (let i = 0; i < classes.length; ++i) {\n      const token = \".\" + cssEscape(classes.slice(0, i + 1).join(\".\"));\n      const selector = uniqueCSSSelector(token);\n      if (selector)\n        return makeStrict(selector);\n      if (!bestTokenForLevel && parent) {\n        const sameClassSiblings = parent.querySelectorAll(token);\n        if (sameClassSiblings.length === 1)\n          bestTokenForLevel = token;\n      }\n    }\n    if (parent) {\n      const siblings = [...parent.children];\n      const sameTagSiblings = siblings.filter((sibling) => sibling.nodeName.toLowerCase() === nodeName);\n      const token = sameTagSiblings.indexOf(element) === 0 ? cssEscape(nodeName) : `${cssEscape(nodeName)}:nth-child(${1 + siblings.indexOf(element)})`;\n      const selector = uniqueCSSSelector(token);\n      if (selector)\n        return makeStrict(selector);\n      if (!bestTokenForLevel)\n        bestTokenForLevel = token;\n    } else if (!bestTokenForLevel) {\n      bestTokenForLevel = cssEscape(nodeName);\n    }\n    tokens.unshift(bestTokenForLevel);\n  }\n  return makeStrict(uniqueCSSSelector());\n}\nfunction penalizeScoreForLength(groups) {\n  for (const group of groups) {\n    for (const token of group) {\n      if (token.score > kBeginPenalizedScore && token.score < kEndPenalizedScore)\n        token.score += Math.min(kTextScoreRange, token.selector.length / 10 | 0);\n    }\n  }\n}\nfunction joinTokens(tokens) {\n  const parts = [];\n  let lastEngine = \"\";\n  for (const { engine, selector } of tokens) {\n    if (parts.length && (lastEngine !== \"css\" || engine !== \"css\" || selector.startsWith(\":nth-match(\")))\n      parts.push(\">>\");\n    lastEngine = engine;\n    if (engine === \"css\")\n      parts.push(selector);\n    else\n      parts.push(`${engine}=${selector}`);\n  }\n  return parts.join(\" \");\n}\nfunction combineScores(tokens) {\n  let score = 0;\n  for (let i = 0; i < tokens.length; i++)\n    score += tokens[i].score * (tokens.length - i);\n  return score;\n}\nfunction chooseFirstSelector(injectedScript, scope, targetElement, selectors, allowNthMatch) {\n  const joined = selectors.map((tokens) => ({ tokens, score: combineScores(tokens) }));\n  joined.sort((a, b) => a.score - b.score);\n  let bestWithIndex = null;\n  for (const { tokens } of joined) {\n    const parsedSelector = injectedScript.parseSelector(joinTokens(tokens));\n    const result = injectedScript.querySelectorAll(parsedSelector, scope);\n    if (result[0] === targetElement && result.length === 1) {\n      return tokens;\n    }\n    const index = result.indexOf(targetElement);\n    if (!allowNthMatch || bestWithIndex || index === -1 || result.length > 5)\n      continue;\n    const nth = { engine: \"nth\", selector: String(index), score: kNthScore };\n    bestWithIndex = [...tokens, nth];\n  }\n  return bestWithIndex;\n}\nfunction isGuidLike(id) {\n  let lastCharacterType;\n  let transitionCount = 0;\n  for (let i = 0; i < id.length; ++i) {\n    const c = id[i];\n    let characterType;\n    if (c === \"-\" || c === \"_\")\n      continue;\n    if (c >= \"a\" && c <= \"z\")\n      characterType = \"lower\";\n    else if (c >= \"A\" && c <= \"Z\")\n      characterType = \"upper\";\n    else if (c >= \"0\" && c <= \"9\")\n      characterType = \"digit\";\n    else\n      characterType = \"other\";\n    if (characterType === \"lower\" && lastCharacterType === \"upper\") {\n      lastCharacterType = characterType;\n      continue;\n    }\n    if (lastCharacterType && lastCharacterType !== characterType)\n      ++transitionCount;\n    lastCharacterType = characterType;\n  }\n  return transitionCount >= id.length / 4;\n}\nfunction trimWordBoundary(text, maxLength) {\n  if (text.length <= maxLength)\n    return text;\n  text = text.substring(0, maxLength);\n  const match = text.match(/^(.*)\\b(.+?)$/);\n  if (!match)\n    return \"\";\n  return match[1].trimEnd();\n}\nfunction suitableTextAlternatives(text) {\n  let result = [];\n  {\n    const match = text.match(/^([\\d.,]+)[^.,\\w]/);\n    const leadingNumberLength = match ? match[1].length : 0;\n    if (leadingNumberLength) {\n      const alt = trimWordBoundary(text.substring(leadingNumberLength).trimStart(), 80);\n      result.push({ text: alt, scoreBonus: alt.length <= 30 ? 2 : 1 });\n    }\n  }\n  {\n    const match = text.match(/[^.,\\w]([\\d.,]+)$/);\n    const trailingNumberLength = match ? match[1].length : 0;\n    if (trailingNumberLength) {\n      const alt = trimWordBoundary(text.substring(0, text.length - trailingNumberLength).trimEnd(), 80);\n      result.push({ text: alt, scoreBonus: alt.length <= 30 ? 2 : 1 });\n    }\n  }\n  if (text.length <= 30) {\n    result.push({ text, scoreBonus: 0 });\n  } else {\n    result.push({ text: trimWordBoundary(text, 80), scoreBonus: 0 });\n    result.push({ text: trimWordBoundary(text, 30), scoreBonus: 1 });\n  }\n  result = result.filter((r) => r.text);\n  if (!result.length)\n    result.push({ text: text.substring(0, 80), scoreBonus: 0 });\n  return result;\n}\n\n// packages/injected/src/vueSelectorEngine.ts\nfunction basename(filename, ext) {\n  const normalized = filename.replace(/^[a-zA-Z]:/, \"\").replace(/\\\\/g, \"/\");\n  let result = normalized.substring(normalized.lastIndexOf(\"/\") + 1);\n  if (ext && result.endsWith(ext))\n    result = result.substring(0, result.length - ext.length);\n  return result;\n}\nfunction toUpper(_, c) {\n  return c ? c.toUpperCase() : \"\";\n}\nvar classifyRE = /(?:^|[-_/])(\\w)/g;\nvar classify = (str) => {\n  return str && str.replace(classifyRE, toUpper);\n};\nfunction buildComponentsTreeVue3(instance2) {\n  function getComponentTypeName(options) {\n    const name = options.name || options._componentTag || options.__playwright_guessedName;\n    if (name)\n      return name;\n    const file = options.__file;\n    if (file)\n      return classify(basename(file, \".vue\"));\n  }\n  function saveComponentName(instance3, key) {\n    instance3.type.__playwright_guessedName = key;\n    return key;\n  }\n  function getInstanceName(instance3) {\n    var _a, _b, _c, _d;\n    const name = getComponentTypeName(instance3.type || {});\n    if (name)\n      return name;\n    if (instance3.root === instance3)\n      return \"Root\";\n    for (const key in (_b = (_a = instance3.parent) == null ? void 0 : _a.type) == null ? void 0 : _b.components) {\n      if (((_c = instance3.parent) == null ? void 0 : _c.type.components[key]) === instance3.type)\n        return saveComponentName(instance3, key);\n    }\n    for (const key in (_d = instance3.appContext) == null ? void 0 : _d.components) {\n      if (instance3.appContext.components[key] === instance3.type)\n        return saveComponentName(instance3, key);\n    }\n    return \"Anonymous Component\";\n  }\n  function isBeingDestroyed(instance3) {\n    return instance3._isBeingDestroyed || instance3.isUnmounted;\n  }\n  function isFragment(instance3) {\n    return instance3.subTree.type.toString() === \"Symbol(Fragment)\";\n  }\n  function getInternalInstanceChildren(subTree) {\n    const list = [];\n    if (subTree.component)\n      list.push(subTree.component);\n    if (subTree.suspense)\n      list.push(...getInternalInstanceChildren(subTree.suspense.activeBranch));\n    if (Array.isArray(subTree.children)) {\n      subTree.children.forEach((childSubTree) => {\n        if (childSubTree.component)\n          list.push(childSubTree.component);\n        else\n          list.push(...getInternalInstanceChildren(childSubTree));\n      });\n    }\n    return list.filter((child) => {\n      var _a;\n      return !isBeingDestroyed(child) && !((_a = child.type.devtools) == null ? void 0 : _a.hide);\n    });\n  }\n  function getRootElementsFromComponentInstance(instance3) {\n    if (isFragment(instance3))\n      return getFragmentRootElements(instance3.subTree);\n    return [instance3.subTree.el];\n  }\n  function getFragmentRootElements(vnode) {\n    if (!vnode.children)\n      return [];\n    const list = [];\n    for (let i = 0, l = vnode.children.length; i < l; i++) {\n      const childVnode = vnode.children[i];\n      if (childVnode.component)\n        list.push(...getRootElementsFromComponentInstance(childVnode.component));\n      else if (childVnode.el)\n        list.push(childVnode.el);\n    }\n    return list;\n  }\n  function buildComponentsTree2(instance3) {\n    return {\n      name: getInstanceName(instance3),\n      children: getInternalInstanceChildren(instance3.subTree).map(buildComponentsTree2),\n      rootElements: getRootElementsFromComponentInstance(instance3),\n      props: instance3.props\n    };\n  }\n  return buildComponentsTree2(instance2);\n}\nfunction buildComponentsTreeVue2(instance2) {\n  function getComponentName2(options) {\n    const name = options.displayName || options.name || options._componentTag;\n    if (name)\n      return name;\n    const file = options.__file;\n    if (file)\n      return classify(basename(file, \".vue\"));\n  }\n  function getInstanceName(instance3) {\n    const name = getComponentName2(instance3.$options || instance3.fnOptions || {});\n    if (name)\n      return name;\n    return instance3.$root === instance3 ? \"Root\" : \"Anonymous Component\";\n  }\n  function getInternalInstanceChildren(instance3) {\n    if (instance3.$children)\n      return instance3.$children;\n    if (Array.isArray(instance3.subTree.children))\n      return instance3.subTree.children.filter((vnode) => !!vnode.component).map((vnode) => vnode.component);\n    return [];\n  }\n  function buildComponentsTree2(instance3) {\n    return {\n      name: getInstanceName(instance3),\n      children: getInternalInstanceChildren(instance3).map(buildComponentsTree2),\n      rootElements: [instance3.$el],\n      props: instance3._props\n    };\n  }\n  return buildComponentsTree2(instance2);\n}\nfunction filterComponentsTree2(treeNode, searchFn, result = []) {\n  if (searchFn(treeNode))\n    result.push(treeNode);\n  for (const child of treeNode.children)\n    filterComponentsTree2(child, searchFn, result);\n  return result;\n}\nfunction findVueRoots(root, roots = []) {\n  const document = root.ownerDocument || root;\n  const walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT);\n  const vue2Roots = new Set();\n  do {\n    const node = walker.currentNode;\n    if (node.__vue__)\n      vue2Roots.add(node.__vue__.$root);\n    if (node.__vue_app__ && node._vnode && node._vnode.component)\n      roots.push({ root: node._vnode.component, version: 3 });\n    const shadowRoot = node instanceof Element ? node.shadowRoot : null;\n    if (shadowRoot)\n      findVueRoots(shadowRoot, roots);\n  } while (walker.nextNode());\n  for (const vue2root of vue2Roots) {\n    roots.push({\n      version: 2,\n      root: vue2root\n    });\n  }\n  return roots;\n}\nvar createVueEngine = () => ({\n  queryAll(scope, selector) {\n    const document = scope.ownerDocument || scope;\n    const { name, attributes } = parseAttributeSelector(selector, false);\n    const vueRoots = findVueRoots(document);\n    const trees = vueRoots.map((vueRoot) => vueRoot.version === 3 ? buildComponentsTreeVue3(vueRoot.root) : buildComponentsTreeVue2(vueRoot.root));\n    const treeNodes = trees.map((tree) => filterComponentsTree2(tree, (treeNode) => {\n      if (name && treeNode.name !== name)\n        return false;\n      if (treeNode.rootElements.some((rootElement) => !isInsideScope(scope, rootElement)))\n        return false;\n      for (const attr of attributes) {\n        if (!matchesComponentAttribute(treeNode.props, attr))\n          return false;\n      }\n      return true;\n    })).flat();\n    const allRootElements = new Set();\n    for (const treeNode of treeNodes) {\n      for (const rootElement of treeNode.rootElements)\n        allRootElements.add(rootElement);\n    }\n    return [...allRootElements];\n  }\n});\n\n// packages/injected/src/xpathSelectorEngine.ts\nvar XPathEngine = {\n  queryAll(root, selector) {\n    if (selector.startsWith(\"/\") && root.nodeType !== Node.DOCUMENT_NODE)\n      selector = \".\" + selector;\n    const result = [];\n    const document = root.ownerDocument || root;\n    if (!document)\n      return result;\n    const it = document.evaluate(selector, root, null, XPathResult.ORDERED_NODE_ITERATOR_TYPE);\n    for (let node = it.iterateNext(); node; node = it.iterateNext()) {\n      if (node.nodeType === Node.ELEMENT_NODE)\n        result.push(node);\n    }\n    return result;\n  }\n};\n\n// packages/injected/src/injectedScript.ts\nvar InjectedScript = class {\n  // eslint-disable-next-line no-restricted-globals\n  constructor(window, isUnderTest, sdkLanguage, testIdAttributeNameForStrictErrorAndConsoleCodegen, stableRafCount, browserName, inputFileRoleTextbox, customEngines) {\n    this._testIdAttributeNameForStrictErrorAndConsoleCodegen = \"data-testid\";\n    // Recorder must use any external dependencies through InjectedScript.\n    // Otherwise it will end up with a copy of all modules it uses, and any\n    // module-level globals will be duplicated, which leads to subtle bugs.\n    this.utils = {\n      asLocator,\n      cacheNormalizedWhitespaces,\n      elementText,\n      getAriaRole,\n      getElementAccessibleDescription,\n      getElementAccessibleName,\n      isElementVisible,\n      isInsideScope,\n      normalizeWhiteSpace,\n      parseAriaSnapshot,\n      builtins: builtins()\n    };\n    this.window = window;\n    this.document = window.document;\n    this.isUnderTest = isUnderTest;\n    this.utils.builtins = builtins(window);\n    this._sdkLanguage = sdkLanguage;\n    this._testIdAttributeNameForStrictErrorAndConsoleCodegen = testIdAttributeNameForStrictErrorAndConsoleCodegen;\n    this._evaluator = new SelectorEvaluatorImpl();\n    this.onGlobalListenersRemoved = new Set();\n    this._autoClosingTags = new Set([\"AREA\", \"BASE\", \"BR\", \"COL\", \"COMMAND\", \"EMBED\", \"HR\", \"IMG\", \"INPUT\", \"KEYGEN\", \"LINK\", \"MENUITEM\", \"META\", \"PARAM\", \"SOURCE\", \"TRACK\", \"WBR\"]);\n    this._booleanAttributes = new Set([\"checked\", \"selected\", \"disabled\", \"readonly\", \"multiple\"]);\n    this._eventTypes = new Map([\n      [\"auxclick\", \"mouse\"],\n      [\"click\", \"mouse\"],\n      [\"dblclick\", \"mouse\"],\n      [\"mousedown\", \"mouse\"],\n      [\"mouseeenter\", \"mouse\"],\n      [\"mouseleave\", \"mouse\"],\n      [\"mousemove\", \"mouse\"],\n      [\"mouseout\", \"mouse\"],\n      [\"mouseover\", \"mouse\"],\n      [\"mouseup\", \"mouse\"],\n      [\"mouseleave\", \"mouse\"],\n      [\"mousewheel\", \"mouse\"],\n      [\"keydown\", \"keyboard\"],\n      [\"keyup\", \"keyboard\"],\n      [\"keypress\", \"keyboard\"],\n      [\"textInput\", \"keyboard\"],\n      [\"touchstart\", \"touch\"],\n      [\"touchmove\", \"touch\"],\n      [\"touchend\", \"touch\"],\n      [\"touchcancel\", \"touch\"],\n      [\"pointerover\", \"pointer\"],\n      [\"pointerout\", \"pointer\"],\n      [\"pointerenter\", \"pointer\"],\n      [\"pointerleave\", \"pointer\"],\n      [\"pointerdown\", \"pointer\"],\n      [\"pointerup\", \"pointer\"],\n      [\"pointermove\", \"pointer\"],\n      [\"pointercancel\", \"pointer\"],\n      [\"gotpointercapture\", \"pointer\"],\n      [\"lostpointercapture\", \"pointer\"],\n      [\"focus\", \"focus\"],\n      [\"blur\", \"focus\"],\n      [\"drag\", \"drag\"],\n      [\"dragstart\", \"drag\"],\n      [\"dragend\", \"drag\"],\n      [\"dragover\", \"drag\"],\n      [\"dragenter\", \"drag\"],\n      [\"dragleave\", \"drag\"],\n      [\"dragexit\", \"drag\"],\n      [\"drop\", \"drag\"],\n      [\"wheel\", \"wheel\"],\n      [\"deviceorientation\", \"deviceorientation\"],\n      [\"deviceorientationabsolute\", \"deviceorientation\"],\n      [\"devicemotion\", \"devicemotion\"]\n    ]);\n    this._hoverHitTargetInterceptorEvents = new Set([\"mousemove\"]);\n    this._tapHitTargetInterceptorEvents = new Set([\"pointerdown\", \"pointerup\", \"touchstart\", \"touchend\", \"touchcancel\"]);\n    this._mouseHitTargetInterceptorEvents = new Set([\"mousedown\", \"mouseup\", \"pointerdown\", \"pointerup\", \"click\", \"auxclick\", \"dblclick\", \"contextmenu\"]);\n    this._allHitTargetInterceptorEvents = new Set([...this._hoverHitTargetInterceptorEvents, ...this._tapHitTargetInterceptorEvents, ...this._mouseHitTargetInterceptorEvents]);\n    this._engines = new Map();\n    this._engines.set(\"xpath\", XPathEngine);\n    this._engines.set(\"xpath:light\", XPathEngine);\n    this._engines.set(\"_react\", createReactEngine());\n    this._engines.set(\"_vue\", createVueEngine());\n    this._engines.set(\"role\", createRoleEngine(false));\n    this._engines.set(\"text\", this._createTextEngine(true, false));\n    this._engines.set(\"text:light\", this._createTextEngine(false, false));\n    this._engines.set(\"id\", this._createAttributeEngine(\"id\", true));\n    this._engines.set(\"id:light\", this._createAttributeEngine(\"id\", false));\n    this._engines.set(\"data-testid\", this._createAttributeEngine(\"data-testid\", true));\n    this._engines.set(\"data-testid:light\", this._createAttributeEngine(\"data-testid\", false));\n    this._engines.set(\"data-test-id\", this._createAttributeEngine(\"data-test-id\", true));\n    this._engines.set(\"data-test-id:light\", this._createAttributeEngine(\"data-test-id\", false));\n    this._engines.set(\"data-test\", this._createAttributeEngine(\"data-test\", true));\n    this._engines.set(\"data-test:light\", this._createAttributeEngine(\"data-test\", false));\n    this._engines.set(\"css\", this._createCSSEngine());\n    this._engines.set(\"nth\", { queryAll: () => [] });\n    this._engines.set(\"visible\", this._createVisibleEngine());\n    this._engines.set(\"internal:control\", this._createControlEngine());\n    this._engines.set(\"internal:has\", this._createHasEngine());\n    this._engines.set(\"internal:has-not\", this._createHasNotEngine());\n    this._engines.set(\"internal:and\", { queryAll: () => [] });\n    this._engines.set(\"internal:or\", { queryAll: () => [] });\n    this._engines.set(\"internal:chain\", this._createInternalChainEngine());\n    this._engines.set(\"internal:label\", this._createInternalLabelEngine());\n    this._engines.set(\"internal:text\", this._createTextEngine(true, true));\n    this._engines.set(\"internal:has-text\", this._createInternalHasTextEngine());\n    this._engines.set(\"internal:has-not-text\", this._createInternalHasNotTextEngine());\n    this._engines.set(\"internal:attr\", this._createNamedAttributeEngine());\n    this._engines.set(\"internal:testid\", this._createNamedAttributeEngine());\n    this._engines.set(\"internal:role\", createRoleEngine(true));\n    this._engines.set(\"aria-ref\", this._createAriaIdEngine());\n    for (const { name, engine } of customEngines)\n      this._engines.set(name, engine);\n    this._stableRafCount = stableRafCount;\n    this._browserName = browserName;\n    setGlobalOptions({ browserNameForWorkarounds: browserName, inputFileRoleTextbox });\n    this._setupGlobalListenersRemovalDetection();\n    this._setupHitTargetInterceptors();\n    if (isUnderTest)\n      this.window.__injectedScript = this;\n  }\n  eval(expression) {\n    return this.window.eval(expression);\n  }\n  testIdAttributeNameForStrictErrorAndConsoleCodegen() {\n    return this._testIdAttributeNameForStrictErrorAndConsoleCodegen;\n  }\n  parseSelector(selector) {\n    const result = parseSelector(selector);\n    visitAllSelectorParts(result, (part) => {\n      if (!this._engines.has(part.name))\n        throw this.createStacklessError(`Unknown engine \"${part.name}\" while parsing selector ${selector}`);\n    });\n    return result;\n  }\n  generateSelector(targetElement, options) {\n    return generateSelector(this, targetElement, options);\n  }\n  generateSelectorSimple(targetElement, options) {\n    return generateSelector(this, targetElement, { ...options, testIdAttributeName: this._testIdAttributeNameForStrictErrorAndConsoleCodegen }).selector;\n  }\n  querySelector(selector, root, strict) {\n    const result = this.querySelectorAll(selector, root);\n    if (strict && result.length > 1)\n      throw this.strictModeViolationError(selector, result);\n    return result[0];\n  }\n  _queryNth(elements, part) {\n    const list = [...elements];\n    let nth = +part.body;\n    if (nth === -1)\n      nth = list.length - 1;\n    return new Set(list.slice(nth, nth + 1));\n  }\n  _queryLayoutSelector(elements, part, originalRoot) {\n    const name = part.name;\n    const body = part.body;\n    const result = [];\n    const inner = this.querySelectorAll(body.parsed, originalRoot);\n    for (const element of elements) {\n      const score = layoutSelectorScore(name, element, inner, body.distance);\n      if (score !== void 0)\n        result.push({ element, score });\n    }\n    result.sort((a, b) => a.score - b.score);\n    return new Set(result.map((r) => r.element));\n  }\n  ariaSnapshot(node, options) {\n    var _a;\n    if (node.nodeType !== Node.ELEMENT_NODE)\n      throw this.createStacklessError(\"Can only capture aria snapshot of Element nodes.\");\n    const generation = (((_a = this._lastAriaSnapshot) == null ? void 0 : _a.generation) || 0) + 1;\n    this._lastAriaSnapshot = generateAriaTree(node, generation);\n    return renderAriaTree(this._lastAriaSnapshot, options);\n  }\n  ariaSnapshotElement(snapshot, elementId) {\n    return snapshot.elements.get(elementId) || null;\n  }\n  getAllByAria(document, template) {\n    return getAllByAria(document.documentElement, template);\n  }\n  querySelectorAll(selector, root) {\n    if (selector.capture !== void 0) {\n      if (selector.parts.some((part) => part.name === \"nth\"))\n        throw this.createStacklessError(`Can't query n-th element in a request with the capture.`);\n      const withHas = { parts: selector.parts.slice(0, selector.capture + 1) };\n      if (selector.capture < selector.parts.length - 1) {\n        const parsed = { parts: selector.parts.slice(selector.capture + 1) };\n        const has = { name: \"internal:has\", body: { parsed }, source: stringifySelector(parsed) };\n        withHas.parts.push(has);\n      }\n      return this.querySelectorAll(withHas, root);\n    }\n    if (!root[\"querySelectorAll\"])\n      throw this.createStacklessError(\"Node is not queryable.\");\n    if (selector.capture !== void 0) {\n      throw this.createStacklessError(\"Internal error: there should not be a capture in the selector.\");\n    }\n    if (root.nodeType === 11 && selector.parts.length === 1 && selector.parts[0].name === \"css\" && selector.parts[0].source === \":scope\")\n      return [root];\n    this._evaluator.begin();\n    try {\n      let roots = new Set([root]);\n      for (const part of selector.parts) {\n        if (part.name === \"nth\") {\n          roots = this._queryNth(roots, part);\n        } else if (part.name === \"internal:and\") {\n          const andElements = this.querySelectorAll(part.body.parsed, root);\n          roots = new Set(andElements.filter((e) => roots.has(e)));\n        } else if (part.name === \"internal:or\") {\n          const orElements = this.querySelectorAll(part.body.parsed, root);\n          roots = new Set(sortInDOMOrder(new Set([...roots, ...orElements])));\n        } else if (kLayoutSelectorNames.includes(part.name)) {\n          roots = this._queryLayoutSelector(roots, part, root);\n        } else {\n          const next = new Set();\n          for (const root2 of roots) {\n            const all = this._queryEngineAll(part, root2);\n            for (const one of all)\n              next.add(one);\n          }\n          roots = next;\n        }\n      }\n      return [...roots];\n    } finally {\n      this._evaluator.end();\n    }\n  }\n  _queryEngineAll(part, root) {\n    const result = this._engines.get(part.name).queryAll(root, part.body);\n    for (const element of result) {\n      if (!(\"nodeName\" in element))\n        throw this.createStacklessError(`Expected a Node but got ${Object.prototype.toString.call(element)}`);\n    }\n    return result;\n  }\n  _createAttributeEngine(attribute, shadow) {\n    const toCSS = (selector) => {\n      const css = `[${attribute}=${JSON.stringify(selector)}]`;\n      return [{ simples: [{ selector: { css, functions: [] }, combinator: \"\" }] }];\n    };\n    return {\n      queryAll: (root, selector) => {\n        return this._evaluator.query({ scope: root, pierceShadow: shadow }, toCSS(selector));\n      }\n    };\n  }\n  _createCSSEngine() {\n    return {\n      queryAll: (root, body) => {\n        return this._evaluator.query({ scope: root, pierceShadow: true }, body);\n      }\n    };\n  }\n  _createTextEngine(shadow, internal) {\n    const queryAll = (root, selector) => {\n      const { matcher, kind } = createTextMatcher(selector, internal);\n      const result = [];\n      let lastDidNotMatchSelf = null;\n      const appendElement = (element) => {\n        if (kind === \"lax\" && lastDidNotMatchSelf && lastDidNotMatchSelf.contains(element))\n          return false;\n        const matches = elementMatchesText(this._evaluator._cacheText, element, matcher);\n        if (matches === \"none\")\n          lastDidNotMatchSelf = element;\n        if (matches === \"self\" || matches === \"selfAndChildren\" && kind === \"strict\" && !internal)\n          result.push(element);\n      };\n      if (root.nodeType === Node.ELEMENT_NODE)\n        appendElement(root);\n      const elements = this._evaluator._queryCSS({ scope: root, pierceShadow: shadow }, \"*\");\n      for (const element of elements)\n        appendElement(element);\n      return result;\n    };\n    return { queryAll };\n  }\n  _createInternalHasTextEngine() {\n    return {\n      queryAll: (root, selector) => {\n        if (root.nodeType !== 1)\n          return [];\n        const element = root;\n        const text = elementText(this._evaluator._cacheText, element);\n        const { matcher } = createTextMatcher(selector, true);\n        return matcher(text) ? [element] : [];\n      }\n    };\n  }\n  _createInternalHasNotTextEngine() {\n    return {\n      queryAll: (root, selector) => {\n        if (root.nodeType !== 1)\n          return [];\n        const element = root;\n        const text = elementText(this._evaluator._cacheText, element);\n        const { matcher } = createTextMatcher(selector, true);\n        return matcher(text) ? [] : [element];\n      }\n    };\n  }\n  _createInternalLabelEngine() {\n    return {\n      queryAll: (root, selector) => {\n        const { matcher } = createTextMatcher(selector, true);\n        const allElements = this._evaluator._queryCSS({ scope: root, pierceShadow: true }, \"*\");\n        return allElements.filter((element) => {\n          return getElementLabels(this._evaluator._cacheText, element).some((label) => matcher(label));\n        });\n      }\n    };\n  }\n  _createNamedAttributeEngine() {\n    const queryAll = (root, selector) => {\n      const parsed = parseAttributeSelector(selector, true);\n      if (parsed.name || parsed.attributes.length !== 1)\n        throw new Error(\"Malformed attribute selector: \" + selector);\n      const { name, value, caseSensitive } = parsed.attributes[0];\n      const lowerCaseValue = caseSensitive ? null : value.toLowerCase();\n      let matcher;\n      if (value instanceof RegExp)\n        matcher = (s) => !!s.match(value);\n      else if (caseSensitive)\n        matcher = (s) => s === value;\n      else\n        matcher = (s) => s.toLowerCase().includes(lowerCaseValue);\n      const elements = this._evaluator._queryCSS({ scope: root, pierceShadow: true }, `[${name}]`);\n      return elements.filter((e) => matcher(e.getAttribute(name)));\n    };\n    return { queryAll };\n  }\n  _createControlEngine() {\n    return {\n      queryAll(root, body) {\n        if (body === \"enter-frame\")\n          return [];\n        if (body === \"return-empty\")\n          return [];\n        if (body === \"component\") {\n          if (root.nodeType !== 1)\n            return [];\n          return [root.childElementCount === 1 ? root.firstElementChild : root];\n        }\n        throw new Error(`Internal error, unknown internal:control selector ${body}`);\n      }\n    };\n  }\n  _createHasEngine() {\n    const queryAll = (root, body) => {\n      if (root.nodeType !== 1)\n        return [];\n      const has = !!this.querySelector(body.parsed, root, false);\n      return has ? [root] : [];\n    };\n    return { queryAll };\n  }\n  _createHasNotEngine() {\n    const queryAll = (root, body) => {\n      if (root.nodeType !== 1)\n        return [];\n      const has = !!this.querySelector(body.parsed, root, false);\n      return has ? [] : [root];\n    };\n    return { queryAll };\n  }\n  _createVisibleEngine() {\n    const queryAll = (root, body) => {\n      if (root.nodeType !== 1)\n        return [];\n      const visible = body === \"true\";\n      return isElementVisible(root) === visible ? [root] : [];\n    };\n    return { queryAll };\n  }\n  _createInternalChainEngine() {\n    const queryAll = (root, body) => {\n      return this.querySelectorAll(body.parsed, root);\n    };\n    return { queryAll };\n  }\n  extend(source, params) {\n    const constrFunction = this.window.eval(`\n    (() => {\n      const module = {};\n      ${source}\n      return module.exports.default();\n    })()`);\n    return new constrFunction(this, params);\n  }\n  async viewportRatio(element) {\n    return await new Promise((resolve) => {\n      const observer = new IntersectionObserver((entries) => {\n        resolve(entries[0].intersectionRatio);\n        observer.disconnect();\n      });\n      observer.observe(element);\n      requestAnimationFrame(() => {\n      });\n    });\n  }\n  getElementBorderWidth(node) {\n    if (node.nodeType !== Node.ELEMENT_NODE || !node.ownerDocument || !node.ownerDocument.defaultView)\n      return { left: 0, top: 0 };\n    const style = node.ownerDocument.defaultView.getComputedStyle(node);\n    return { left: parseInt(style.borderLeftWidth || \"\", 10), top: parseInt(style.borderTopWidth || \"\", 10) };\n  }\n  describeIFrameStyle(iframe) {\n    if (!iframe.ownerDocument || !iframe.ownerDocument.defaultView)\n      return \"error:notconnected\";\n    const defaultView = iframe.ownerDocument.defaultView;\n    for (let e = iframe; e; e = parentElementOrShadowHost(e)) {\n      if (defaultView.getComputedStyle(e).transform !== \"none\")\n        return \"transformed\";\n    }\n    const iframeStyle = defaultView.getComputedStyle(iframe);\n    return {\n      left: parseInt(iframeStyle.borderLeftWidth || \"\", 10) + parseInt(iframeStyle.paddingLeft || \"\", 10),\n      top: parseInt(iframeStyle.borderTopWidth || \"\", 10) + parseInt(iframeStyle.paddingTop || \"\", 10)\n    };\n  }\n  retarget(node, behavior) {\n    let element = node.nodeType === Node.ELEMENT_NODE ? node : node.parentElement;\n    if (!element)\n      return null;\n    if (behavior === \"none\")\n      return element;\n    if (!element.matches(\"input, textarea, select\") && !element.isContentEditable) {\n      if (behavior === \"button-link\")\n        element = element.closest(\"button, [role=button], a, [role=link]\") || element;\n      else\n        element = element.closest(\"button, [role=button], [role=checkbox], [role=radio]\") || element;\n    }\n    if (behavior === \"follow-label\") {\n      if (!element.matches(\"a, input, textarea, button, select, [role=link], [role=button], [role=checkbox], [role=radio]\") && !element.isContentEditable) {\n        const enclosingLabel = element.closest(\"label\");\n        if (enclosingLabel && enclosingLabel.control)\n          element = enclosingLabel.control;\n      }\n    }\n    return element;\n  }\n  async checkElementStates(node, states) {\n    if (states.includes(\"stable\")) {\n      const stableResult = await this._checkElementIsStable(node);\n      if (stableResult === false)\n        return { missingState: \"stable\" };\n      if (stableResult === \"error:notconnected\")\n        return \"error:notconnected\";\n    }\n    for (const state of states) {\n      if (state !== \"stable\") {\n        const result = this.elementState(node, state);\n        if (result.received === \"error:notconnected\")\n          return \"error:notconnected\";\n        if (!result.matches)\n          return { missingState: state };\n      }\n    }\n  }\n  async _checkElementIsStable(node) {\n    const continuePolling = Symbol(\"continuePolling\");\n    let lastRect;\n    let stableRafCounter = 0;\n    let lastTime = 0;\n    const check = () => {\n      const element = this.retarget(node, \"no-follow-label\");\n      if (!element)\n        return \"error:notconnected\";\n      const time = performance.now();\n      if (this._stableRafCount > 1 && time - lastTime < 15)\n        return continuePolling;\n      lastTime = time;\n      const clientRect = element.getBoundingClientRect();\n      const rect = { x: clientRect.top, y: clientRect.left, width: clientRect.width, height: clientRect.height };\n      if (lastRect) {\n        const samePosition = rect.x === lastRect.x && rect.y === lastRect.y && rect.width === lastRect.width && rect.height === lastRect.height;\n        if (!samePosition)\n          return false;\n        if (++stableRafCounter >= this._stableRafCount)\n          return true;\n      }\n      lastRect = rect;\n      return continuePolling;\n    };\n    let fulfill;\n    let reject;\n    const result = new Promise((f, r) => {\n      fulfill = f;\n      reject = r;\n    });\n    const raf = () => {\n      try {\n        const success = check();\n        if (success !== continuePolling)\n          fulfill(success);\n        else\n          requestAnimationFrame(raf);\n      } catch (e) {\n        reject(e);\n      }\n    };\n    requestAnimationFrame(raf);\n    return result;\n  }\n  _createAriaIdEngine() {\n    const queryAll = (root, selector) => {\n      var _a, _b, _c, _d;\n      const match = selector.match(/^s(\\d+)e(\\d+)$/);\n      if (!match)\n        throw this.createStacklessError(\"Invalid aria-ref selector, should be of form s<number>e<number>\");\n      const [, generation, elementId] = match;\n      if (((_a = this._lastAriaSnapshot) == null ? void 0 : _a.generation) !== +generation)\n        throw this.createStacklessError(`Stale aria-ref, expected s${(_b = this._lastAriaSnapshot) == null ? void 0 : _b.generation}e{number}, got ${selector}`);\n      const result = (_d = (_c = this._lastAriaSnapshot) == null ? void 0 : _c.elements) == null ? void 0 : _d.get(+elementId);\n      return result && result.isConnected ? [result] : [];\n    };\n    return { queryAll };\n  }\n  elementState(node, state) {\n    const element = this.retarget(node, [\"visible\", \"hidden\"].includes(state) ? \"none\" : \"follow-label\");\n    if (!element || !element.isConnected) {\n      if (state === \"hidden\")\n        return { matches: true, received: \"hidden\" };\n      return { matches: false, received: \"error:notconnected\" };\n    }\n    if (state === \"visible\" || state === \"hidden\") {\n      const visible = isElementVisible(element);\n      return {\n        matches: state === \"visible\" ? visible : !visible,\n        received: visible ? \"visible\" : \"hidden\"\n      };\n    }\n    if (state === \"disabled\" || state === \"enabled\") {\n      const disabled = getAriaDisabled(element);\n      return {\n        matches: state === \"disabled\" ? disabled : !disabled,\n        received: disabled ? \"disabled\" : \"enabled\"\n      };\n    }\n    if (state === \"editable\") {\n      const disabled = getAriaDisabled(element);\n      const readonly = getReadonly(element);\n      if (readonly === \"error\")\n        throw this.createStacklessError(\"Element is not an <input>, <textarea>, <select> or [contenteditable] and does not have a role allowing [aria-readonly]\");\n      return {\n        matches: !disabled && !readonly,\n        received: disabled ? \"disabled\" : readonly ? \"readOnly\" : \"editable\"\n      };\n    }\n    if (state === \"checked\" || state === \"unchecked\") {\n      const need = state === \"checked\";\n      const checked = getCheckedWithoutMixed(element);\n      if (checked === \"error\")\n        throw this.createStacklessError(\"Not a checkbox or radio button\");\n      return {\n        matches: need === checked,\n        received: checked ? \"checked\" : \"unchecked\"\n      };\n    }\n    if (state === \"indeterminate\") {\n      const checked = getCheckedAllowMixed(element);\n      if (checked === \"error\")\n        throw this.createStacklessError(\"Not a checkbox or radio button\");\n      return {\n        matches: checked === \"mixed\",\n        received: checked === true ? \"checked\" : checked === false ? \"unchecked\" : \"mixed\"\n      };\n    }\n    throw this.createStacklessError(`Unexpected element state \"${state}\"`);\n  }\n  selectOptions(node, optionsToSelect) {\n    const element = this.retarget(node, \"follow-label\");\n    if (!element)\n      return \"error:notconnected\";\n    if (element.nodeName.toLowerCase() !== \"select\")\n      throw this.createStacklessError(\"Element is not a <select> element\");\n    const select = element;\n    const options = [...select.options];\n    const selectedOptions = [];\n    let remainingOptionsToSelect = optionsToSelect.slice();\n    for (let index = 0; index < options.length; index++) {\n      const option = options[index];\n      const filter = (optionToSelect) => {\n        if (optionToSelect instanceof Node)\n          return option === optionToSelect;\n        let matches = true;\n        if (optionToSelect.valueOrLabel !== void 0)\n          matches = matches && (optionToSelect.valueOrLabel === option.value || optionToSelect.valueOrLabel === option.label);\n        if (optionToSelect.value !== void 0)\n          matches = matches && optionToSelect.value === option.value;\n        if (optionToSelect.label !== void 0)\n          matches = matches && optionToSelect.label === option.label;\n        if (optionToSelect.index !== void 0)\n          matches = matches && optionToSelect.index === index;\n        return matches;\n      };\n      if (!remainingOptionsToSelect.some(filter))\n        continue;\n      selectedOptions.push(option);\n      if (select.multiple) {\n        remainingOptionsToSelect = remainingOptionsToSelect.filter((o) => !filter(o));\n      } else {\n        remainingOptionsToSelect = [];\n        break;\n      }\n    }\n    if (remainingOptionsToSelect.length)\n      return \"error:optionsnotfound\";\n    select.value = void 0;\n    selectedOptions.forEach((option) => option.selected = true);\n    select.dispatchEvent(new Event(\"input\", { bubbles: true, composed: true }));\n    select.dispatchEvent(new Event(\"change\", { bubbles: true }));\n    return selectedOptions.map((option) => option.value);\n  }\n  fill(node, value) {\n    const element = this.retarget(node, \"follow-label\");\n    if (!element)\n      return \"error:notconnected\";\n    if (element.nodeName.toLowerCase() === \"input\") {\n      const input = element;\n      const type = input.type.toLowerCase();\n      const kInputTypesToSetValue = new Set([\"color\", \"date\", \"time\", \"datetime-local\", \"month\", \"range\", \"week\"]);\n      const kInputTypesToTypeInto = new Set([\"\", \"email\", \"number\", \"password\", \"search\", \"tel\", \"text\", \"url\"]);\n      if (!kInputTypesToTypeInto.has(type) && !kInputTypesToSetValue.has(type))\n        throw this.createStacklessError(`Input of type \"${type}\" cannot be filled`);\n      if (type === \"number\") {\n        value = value.trim();\n        if (isNaN(Number(value)))\n          throw this.createStacklessError(\"Cannot type text into input[type=number]\");\n      }\n      if (kInputTypesToSetValue.has(type)) {\n        value = value.trim();\n        input.focus();\n        input.value = value;\n        if (input.value !== value)\n          throw this.createStacklessError(\"Malformed value\");\n        element.dispatchEvent(new Event(\"input\", { bubbles: true, composed: true }));\n        element.dispatchEvent(new Event(\"change\", { bubbles: true }));\n        return \"done\";\n      }\n    } else if (element.nodeName.toLowerCase() === \"textarea\") {\n    } else if (!element.isContentEditable) {\n      throw this.createStacklessError(\"Element is not an <input>, <textarea> or [contenteditable] element\");\n    }\n    this.selectText(element);\n    return \"needsinput\";\n  }\n  selectText(node) {\n    const element = this.retarget(node, \"follow-label\");\n    if (!element)\n      return \"error:notconnected\";\n    if (element.nodeName.toLowerCase() === \"input\") {\n      const input = element;\n      input.select();\n      input.focus();\n      return \"done\";\n    }\n    if (element.nodeName.toLowerCase() === \"textarea\") {\n      const textarea = element;\n      textarea.selectionStart = 0;\n      textarea.selectionEnd = textarea.value.length;\n      textarea.focus();\n      return \"done\";\n    }\n    const range = element.ownerDocument.createRange();\n    range.selectNodeContents(element);\n    const selection = element.ownerDocument.defaultView.getSelection();\n    if (selection) {\n      selection.removeAllRanges();\n      selection.addRange(range);\n    }\n    element.focus();\n    return \"done\";\n  }\n  _activelyFocused(node) {\n    const activeElement = node.getRootNode().activeElement;\n    const isFocused = activeElement === node && !!node.ownerDocument && node.ownerDocument.hasFocus();\n    return { activeElement, isFocused };\n  }\n  focusNode(node, resetSelectionIfNotFocused) {\n    if (!node.isConnected)\n      return \"error:notconnected\";\n    if (node.nodeType !== Node.ELEMENT_NODE)\n      throw this.createStacklessError(\"Node is not an element\");\n    const { activeElement, isFocused: wasFocused } = this._activelyFocused(node);\n    if (node.isContentEditable && !wasFocused && activeElement && activeElement.blur) {\n      activeElement.blur();\n    }\n    node.focus();\n    node.focus();\n    if (resetSelectionIfNotFocused && !wasFocused && node.nodeName.toLowerCase() === \"input\") {\n      try {\n        const input = node;\n        input.setSelectionRange(0, 0);\n      } catch (e) {\n      }\n    }\n    return \"done\";\n  }\n  blurNode(node) {\n    if (!node.isConnected)\n      return \"error:notconnected\";\n    if (node.nodeType !== Node.ELEMENT_NODE)\n      throw this.createStacklessError(\"Node is not an element\");\n    node.blur();\n    return \"done\";\n  }\n  setInputFiles(node, payloads) {\n    if (node.nodeType !== Node.ELEMENT_NODE)\n      return \"Node is not of type HTMLElement\";\n    const element = node;\n    if (element.nodeName !== \"INPUT\")\n      return \"Not an <input> element\";\n    const input = element;\n    const type = (input.getAttribute(\"type\") || \"\").toLowerCase();\n    if (type !== \"file\")\n      return \"Not an input[type=file] element\";\n    const files = payloads.map((file) => {\n      const bytes = Uint8Array.from(atob(file.buffer), (c) => c.charCodeAt(0));\n      return new File([bytes], file.name, { type: file.mimeType, lastModified: file.lastModifiedMs });\n    });\n    const dt = new DataTransfer();\n    for (const file of files)\n      dt.items.add(file);\n    input.files = dt.files;\n    input.dispatchEvent(new Event(\"input\", { bubbles: true, composed: true }));\n    input.dispatchEvent(new Event(\"change\", { bubbles: true }));\n  }\n  expectHitTarget(hitPoint, targetElement) {\n    const roots = [];\n    let parentElement = targetElement;\n    while (parentElement) {\n      const root = enclosingShadowRootOrDocument(parentElement);\n      if (!root)\n        break;\n      roots.push(root);\n      if (root.nodeType === 9)\n        break;\n      parentElement = root.host;\n    }\n    let hitElement;\n    for (let index = roots.length - 1; index >= 0; index--) {\n      const root = roots[index];\n      const elements = root.elementsFromPoint(hitPoint.x, hitPoint.y);\n      const singleElement = root.elementFromPoint(hitPoint.x, hitPoint.y);\n      if (singleElement && elements[0] && parentElementOrShadowHost(singleElement) === elements[0]) {\n        const style = this.window.getComputedStyle(singleElement);\n        if ((style == null ? void 0 : style.display) === \"contents\") {\n          elements.unshift(singleElement);\n        }\n      }\n      if (elements[0] && elements[0].shadowRoot === root && elements[1] === singleElement) {\n        elements.shift();\n      }\n      const innerElement = elements[0];\n      if (!innerElement)\n        break;\n      hitElement = innerElement;\n      if (index && innerElement !== roots[index - 1].host)\n        break;\n    }\n    const hitParents = [];\n    while (hitElement && hitElement !== targetElement) {\n      hitParents.push(hitElement);\n      hitElement = parentElementOrShadowHost(hitElement);\n    }\n    if (hitElement === targetElement)\n      return \"done\";\n    const hitTargetDescription = this.previewNode(hitParents[0] || this.document.documentElement);\n    let rootHitTargetDescription;\n    let element = targetElement;\n    while (element) {\n      const index = hitParents.indexOf(element);\n      if (index !== -1) {\n        if (index > 1)\n          rootHitTargetDescription = this.previewNode(hitParents[index - 1]);\n        break;\n      }\n      element = parentElementOrShadowHost(element);\n    }\n    if (rootHitTargetDescription)\n      return { hitTargetDescription: `${hitTargetDescription} from ${rootHitTargetDescription} subtree` };\n    return { hitTargetDescription };\n  }\n  // Life of a pointer action, for example click.\n  //\n  // 0. Retry items 1 and 2 while action fails due to navigation or element being detached.\n  //   1. Resolve selector to an element.\n  //   2. Retry the following steps until the element is detached or frame navigates away.\n  //     2a. Wait for the element to be stable (not moving), visible and enabled.\n  //     2b. Scroll element into view. Scrolling alternates between:\n  //         - Built-in protocol scrolling.\n  //         - Anchoring to the top/left, bottom/right and center/center.\n  //         This is to scroll elements from under sticky headers/footers.\n  //     2c. Click point is calculated, either based on explicitly specified position,\n  //         or some visible point of the element based on protocol content quads.\n  //     2d. Click point relative to page viewport is converted relative to the target iframe\n  //         for the next hit-point check.\n  //     2e. (injected) Hit target at the click point must be a descendant of the target element.\n  //         This prevents mis-clicking in edge cases like <iframe> overlaying the target.\n  //     2f. (injected) Events specific for click (or some other action type) are intercepted on\n  //         the Window with capture:true. See 2i for details.\n  //         Note: this step is skipped for drag&drop (see inline comments for the reason).\n  //     2g. Necessary keyboard modifiers are pressed.\n  //     2h. Click event is issued (mousemove + mousedown + mouseup).\n  //     2i. (injected) For each event, we check that hit target at the event point\n  //         is a descendant of the target element.\n  //         This guarantees no race between issuing the event and handling it in the page,\n  //         for example due to layout shift.\n  //         When hit target check fails, we block all future events in the page.\n  //     2j. Keyboard modifiers are restored.\n  //     2k. (injected) Event interceptor is removed.\n  //     2l. All navigations triggered between 2g-2k are awaited to be either committed or canceled.\n  //     2m. If failed, wait for increasing amount of time before the next retry.\n  setupHitTargetInterceptor(node, action, hitPoint, blockAllEvents) {\n    const element = this.retarget(node, \"button-link\");\n    if (!element || !element.isConnected)\n      return \"error:notconnected\";\n    if (hitPoint) {\n      const preliminaryResult = this.expectHitTarget(hitPoint, element);\n      if (preliminaryResult !== \"done\")\n        return preliminaryResult.hitTargetDescription;\n    }\n    if (action === \"drag\")\n      return { stop: () => \"done\" };\n    const events = {\n      \"hover\": this._hoverHitTargetInterceptorEvents,\n      \"tap\": this._tapHitTargetInterceptorEvents,\n      \"mouse\": this._mouseHitTargetInterceptorEvents\n    }[action];\n    let result;\n    const listener = (event) => {\n      if (!events.has(event.type))\n        return;\n      if (!event.isTrusted)\n        return;\n      const point = !!this.window.TouchEvent && event instanceof this.window.TouchEvent ? event.touches[0] : event;\n      if (result === void 0 && point)\n        result = this.expectHitTarget({ x: point.clientX, y: point.clientY }, element);\n      if (blockAllEvents || result !== \"done\" && result !== void 0) {\n        event.preventDefault();\n        event.stopPropagation();\n        event.stopImmediatePropagation();\n      }\n    };\n    const stop = () => {\n      if (this._hitTargetInterceptor === listener)\n        this._hitTargetInterceptor = void 0;\n      return result || \"done\";\n    };\n    this._hitTargetInterceptor = listener;\n    return { stop };\n  }\n  dispatchEvent(node, type, eventInitObj) {\n    var _a, _b, _c, _d, _e;\n    let event;\n    const eventInit = { bubbles: true, cancelable: true, composed: true, ...eventInitObj };\n    switch (this._eventTypes.get(type)) {\n      case \"mouse\":\n        event = new MouseEvent(type, eventInit);\n        break;\n      case \"keyboard\":\n        event = new KeyboardEvent(type, eventInit);\n        break;\n      case \"touch\": {\n        if (this._browserName === \"webkit\") {\n          const createTouch = (t) => {\n            var _a2, _b2, _c2;\n            if (t instanceof Touch)\n              return t;\n            let pageX = t.pageX;\n            if (pageX === void 0 && t.clientX !== void 0)\n              pageX = t.clientX + (((_a2 = this.document.scrollingElement) == null ? void 0 : _a2.scrollLeft) || 0);\n            let pageY = t.pageY;\n            if (pageY === void 0 && t.clientY !== void 0)\n              pageY = t.clientY + (((_b2 = this.document.scrollingElement) == null ? void 0 : _b2.scrollTop) || 0);\n            return this.document.createTouch(this.window, (_c2 = t.target) != null ? _c2 : node, t.identifier, pageX, pageY, t.screenX, t.screenY, t.radiusX, t.radiusY, t.rotationAngle, t.force);\n          };\n          const createTouchList = (touches) => {\n            if (touches instanceof TouchList || !touches)\n              return touches;\n            return this.document.createTouchList(...touches.map(createTouch));\n          };\n          (_a = eventInit.target) != null ? _a : eventInit.target = node;\n          eventInit.touches = createTouchList(eventInit.touches);\n          eventInit.targetTouches = createTouchList(eventInit.targetTouches);\n          eventInit.changedTouches = createTouchList(eventInit.changedTouches);\n          event = new TouchEvent(type, eventInit);\n        } else {\n          (_b = eventInit.target) != null ? _b : eventInit.target = node;\n          eventInit.touches = (_c = eventInit.touches) == null ? void 0 : _c.map((t) => {\n            var _a2;\n            return t instanceof Touch ? t : new Touch({ ...t, target: (_a2 = t.target) != null ? _a2 : node });\n          });\n          eventInit.targetTouches = (_d = eventInit.targetTouches) == null ? void 0 : _d.map((t) => {\n            var _a2;\n            return t instanceof Touch ? t : new Touch({ ...t, target: (_a2 = t.target) != null ? _a2 : node });\n          });\n          eventInit.changedTouches = (_e = eventInit.changedTouches) == null ? void 0 : _e.map((t) => {\n            var _a2;\n            return t instanceof Touch ? t : new Touch({ ...t, target: (_a2 = t.target) != null ? _a2 : node });\n          });\n          event = new TouchEvent(type, eventInit);\n        }\n        break;\n      }\n      case \"pointer\":\n        event = new PointerEvent(type, eventInit);\n        break;\n      case \"focus\":\n        event = new FocusEvent(type, eventInit);\n        break;\n      case \"drag\":\n        event = new DragEvent(type, eventInit);\n        break;\n      case \"wheel\":\n        event = new WheelEvent(type, eventInit);\n        break;\n      case \"deviceorientation\":\n        try {\n          event = new DeviceOrientationEvent(type, eventInit);\n        } catch {\n          const { bubbles, cancelable, alpha, beta, gamma, absolute } = eventInit;\n          event = this.document.createEvent(\"DeviceOrientationEvent\");\n          event.initDeviceOrientationEvent(type, bubbles, cancelable, alpha, beta, gamma, absolute);\n        }\n        break;\n      case \"devicemotion\":\n        try {\n          event = new DeviceMotionEvent(type, eventInit);\n        } catch {\n          const { bubbles, cancelable, acceleration, accelerationIncludingGravity, rotationRate, interval } = eventInit;\n          event = this.document.createEvent(\"DeviceMotionEvent\");\n          event.initDeviceMotionEvent(type, bubbles, cancelable, acceleration, accelerationIncludingGravity, rotationRate, interval);\n        }\n        break;\n      default:\n        event = new Event(type, eventInit);\n        break;\n    }\n    node.dispatchEvent(event);\n  }\n  previewNode(node) {\n    if (node.nodeType === Node.TEXT_NODE)\n      return oneLine(`#text=${node.nodeValue || \"\"}`);\n    if (node.nodeType !== Node.ELEMENT_NODE)\n      return oneLine(`<${node.nodeName.toLowerCase()} />`);\n    const element = node;\n    const attrs = [];\n    for (let i = 0; i < element.attributes.length; i++) {\n      const { name, value } = element.attributes[i];\n      if (name === \"style\")\n        continue;\n      if (!value && this._booleanAttributes.has(name))\n        attrs.push(` ${name}`);\n      else\n        attrs.push(` ${name}=\"${value}\"`);\n    }\n    attrs.sort((a, b) => a.length - b.length);\n    const attrText = trimStringWithEllipsis(attrs.join(\"\"), 500);\n    if (this._autoClosingTags.has(element.nodeName))\n      return oneLine(`<${element.nodeName.toLowerCase()}${attrText}/>`);\n    const children = element.childNodes;\n    let onlyText = false;\n    if (children.length <= 5) {\n      onlyText = true;\n      for (let i = 0; i < children.length; i++)\n        onlyText = onlyText && children[i].nodeType === Node.TEXT_NODE;\n    }\n    const text = onlyText ? element.textContent || \"\" : children.length ? \"\\u2026\" : \"\";\n    return oneLine(`<${element.nodeName.toLowerCase()}${attrText}>${trimStringWithEllipsis(text, 50)}</${element.nodeName.toLowerCase()}>`);\n  }\n  strictModeViolationError(selector, matches) {\n    const infos = matches.slice(0, 10).map((m) => ({\n      preview: this.previewNode(m),\n      selector: this.generateSelectorSimple(m)\n    }));\n    const lines = infos.map((info, i) => `\n    ${i + 1}) ${info.preview} aka ${asLocator(this._sdkLanguage, info.selector)}`);\n    if (infos.length < matches.length)\n      lines.push(\"\\n    ...\");\n    return this.createStacklessError(`strict mode violation: ${asLocator(this._sdkLanguage, stringifySelector(selector))} resolved to ${matches.length} elements:${lines.join(\"\")}\n`);\n  }\n  createStacklessError(message) {\n    if (this._browserName === \"firefox\") {\n      const error2 = new Error(\"Error: \" + message);\n      error2.stack = \"\";\n      return error2;\n    }\n    const error = new Error(message);\n    delete error.stack;\n    return error;\n  }\n  createHighlight() {\n    return new Highlight(this);\n  }\n  maskSelectors(selectors, color) {\n    if (this._highlight)\n      this.hideHighlight();\n    this._highlight = new Highlight(this);\n    this._highlight.install();\n    const elements = [];\n    for (const selector of selectors)\n      elements.push(this.querySelectorAll(selector, this.document.documentElement));\n    this._highlight.maskElements(elements.flat(), color);\n  }\n  highlight(selector) {\n    if (!this._highlight) {\n      this._highlight = new Highlight(this);\n      this._highlight.install();\n    }\n    this._highlight.runHighlightOnRaf(selector);\n  }\n  hideHighlight() {\n    if (this._highlight) {\n      this._highlight.uninstall();\n      delete this._highlight;\n    }\n  }\n  markTargetElements(markedElements, callId) {\n    var _a, _b;\n    if (((_a = this._markedElements) == null ? void 0 : _a.callId) !== callId)\n      this._markedElements = void 0;\n    const previous = ((_b = this._markedElements) == null ? void 0 : _b.elements) || new Set();\n    const unmarkEvent = new CustomEvent(\"__playwright_unmark_target__\", {\n      bubbles: true,\n      cancelable: true,\n      detail: callId,\n      composed: true\n    });\n    for (const element of previous) {\n      if (!markedElements.has(element))\n        element.dispatchEvent(unmarkEvent);\n    }\n    const markEvent = new CustomEvent(\"__playwright_mark_target__\", {\n      bubbles: true,\n      cancelable: true,\n      detail: callId,\n      composed: true\n    });\n    for (const element of markedElements) {\n      if (!previous.has(element))\n        element.dispatchEvent(markEvent);\n    }\n    this._markedElements = { callId, elements: markedElements };\n  }\n  _setupGlobalListenersRemovalDetection() {\n    const customEventName = \"__playwright_global_listeners_check__\";\n    let seenEvent = false;\n    const handleCustomEvent = () => seenEvent = true;\n    this.window.addEventListener(customEventName, handleCustomEvent);\n    new MutationObserver((entries) => {\n      const newDocumentElement = entries.some((entry) => Array.from(entry.addedNodes).includes(this.document.documentElement));\n      if (!newDocumentElement)\n        return;\n      seenEvent = false;\n      this.window.dispatchEvent(new CustomEvent(customEventName));\n      if (seenEvent)\n        return;\n      this.window.addEventListener(customEventName, handleCustomEvent);\n      for (const callback of this.onGlobalListenersRemoved)\n        callback();\n    }).observe(this.document, { childList: true });\n  }\n  _setupHitTargetInterceptors() {\n    const listener = (event) => {\n      var _a;\n      return (_a = this._hitTargetInterceptor) == null ? void 0 : _a.call(this, event);\n    };\n    const addHitTargetInterceptorListeners = () => {\n      for (const event of this._allHitTargetInterceptorEvents)\n        this.window.addEventListener(event, listener, { capture: true, passive: false });\n    };\n    addHitTargetInterceptorListeners();\n    this.onGlobalListenersRemoved.add(addHitTargetInterceptorListeners);\n  }\n  async expect(element, options, elements) {\n    const isArray = options.expression === \"to.have.count\" || options.expression.endsWith(\".array\");\n    if (isArray)\n      return this.expectArray(elements, options);\n    if (!element) {\n      if (!options.isNot && options.expression === \"to.be.hidden\")\n        return { matches: true };\n      if (options.isNot && options.expression === \"to.be.visible\")\n        return { matches: false };\n      if (!options.isNot && options.expression === \"to.be.detached\")\n        return { matches: true };\n      if (options.isNot && options.expression === \"to.be.attached\")\n        return { matches: false };\n      if (options.isNot && options.expression === \"to.be.in.viewport\")\n        return { matches: false };\n      return { matches: options.isNot, missingReceived: true };\n    }\n    return await this.expectSingleElement(element, options);\n  }\n  async expectSingleElement(element, options) {\n    var _a, _b;\n    const expression = options.expression;\n    {\n      let result;\n      if (expression === \"to.have.attribute\") {\n        const hasAttribute = element.hasAttribute(options.expressionArg);\n        result = {\n          matches: hasAttribute,\n          received: hasAttribute ? \"attribute present\" : \"attribute not present\"\n        };\n      } else if (expression === \"to.be.checked\") {\n        const { checked, indeterminate } = options.expectedValue;\n        if (indeterminate) {\n          if (checked !== void 0)\n            throw this.createStacklessError(\"Can't assert indeterminate and checked at the same time\");\n          result = this.elementState(element, \"indeterminate\");\n        } else {\n          result = this.elementState(element, checked === false ? \"unchecked\" : \"checked\");\n        }\n      } else if (expression === \"to.be.disabled\") {\n        result = this.elementState(element, \"disabled\");\n      } else if (expression === \"to.be.editable\") {\n        result = this.elementState(element, \"editable\");\n      } else if (expression === \"to.be.readonly\") {\n        result = this.elementState(element, \"editable\");\n        result.matches = !result.matches;\n      } else if (expression === \"to.be.empty\") {\n        if (element.nodeName === \"INPUT\" || element.nodeName === \"TEXTAREA\") {\n          const value = element.value;\n          result = { matches: !value, received: value ? \"notEmpty\" : \"empty\" };\n        } else {\n          const text = (_a = element.textContent) == null ? void 0 : _a.trim();\n          result = { matches: !text, received: text ? \"notEmpty\" : \"empty\" };\n        }\n      } else if (expression === \"to.be.enabled\") {\n        result = this.elementState(element, \"enabled\");\n      } else if (expression === \"to.be.focused\") {\n        const focused = this._activelyFocused(element).isFocused;\n        result = {\n          matches: focused,\n          received: focused ? \"focused\" : \"inactive\"\n        };\n      } else if (expression === \"to.be.hidden\") {\n        result = this.elementState(element, \"hidden\");\n      } else if (expression === \"to.be.visible\") {\n        result = this.elementState(element, \"visible\");\n      } else if (expression === \"to.be.attached\") {\n        result = {\n          matches: true,\n          received: \"attached\"\n        };\n      } else if (expression === \"to.be.detached\") {\n        result = {\n          matches: false,\n          received: \"attached\"\n        };\n      }\n      if (result) {\n        if (result.received === \"error:notconnected\")\n          throw this.createStacklessError(\"Element is not connected\");\n        return result;\n      }\n    }\n    {\n      if (expression === \"to.have.property\") {\n        let target = element;\n        const properties = options.expressionArg.split(\".\");\n        for (let i = 0; i < properties.length - 1; i++) {\n          if (typeof target !== \"object\" || !(properties[i] in target))\n            return { received: void 0, matches: false };\n          target = target[properties[i]];\n        }\n        const received = target[properties[properties.length - 1]];\n        const matches = deepEquals(received, options.expectedValue);\n        return { received, matches };\n      }\n    }\n    {\n      if (expression === \"to.be.in.viewport\") {\n        const ratio = await this.viewportRatio(element);\n        return { received: `viewport ratio ${ratio}`, matches: ratio > 0 && ratio > ((_b = options.expectedNumber) != null ? _b : 0) - 1e-9 };\n      }\n    }\n    {\n      if (expression === \"to.have.values\") {\n        element = this.retarget(element, \"follow-label\");\n        if (element.nodeName !== \"SELECT\" || !element.multiple)\n          throw this.createStacklessError(\"Not a select element with a multiple attribute\");\n        const received = [...element.selectedOptions].map((o) => o.value);\n        if (received.length !== options.expectedText.length)\n          return { received, matches: false };\n        return { received, matches: received.map((r, i) => new ExpectedTextMatcher(options.expectedText[i]).matches(r)).every(Boolean) };\n      }\n    }\n    {\n      if (expression === \"to.match.aria\") {\n        const result = matchesAriaTree(element, options.expectedValue);\n        return {\n          received: result.received,\n          matches: !!result.matches.length\n        };\n      }\n    }\n    {\n      let received;\n      if (expression === \"to.have.attribute.value\") {\n        const value = element.getAttribute(options.expressionArg);\n        if (value === null)\n          return { received: null, matches: false };\n        received = value;\n      } else if ([\"to.have.class\", \"to.contain.class\"].includes(expression)) {\n        if (!options.expectedText)\n          throw this.createStacklessError(\"Expected text is not provided for \" + expression);\n        return {\n          received: element.classList.toString(),\n          matches: new ExpectedTextMatcher(options.expectedText[0]).matchesClassList(\n            this,\n            element.classList,\n            /* partial */\n            expression === \"to.contain.class\"\n          )\n        };\n      } else if (expression === \"to.have.css\") {\n        received = this.window.getComputedStyle(element).getPropertyValue(options.expressionArg);\n      } else if (expression === \"to.have.id\") {\n        received = element.id;\n      } else if (expression === \"to.have.text\") {\n        received = options.useInnerText ? element.innerText : elementText(new Map(), element).full;\n      } else if (expression === \"to.have.accessible.name\") {\n        received = getElementAccessibleName(\n          element,\n          false\n          /* includeHidden */\n        );\n      } else if (expression === \"to.have.accessible.description\") {\n        received = getElementAccessibleDescription(\n          element,\n          false\n          /* includeHidden */\n        );\n      } else if (expression === \"to.have.accessible.error.message\") {\n        received = getElementAccessibleErrorMessage(element);\n      } else if (expression === \"to.have.role\") {\n        received = getAriaRole(element) || \"\";\n      } else if (expression === \"to.have.title\") {\n        received = this.document.title;\n      } else if (expression === \"to.have.url\") {\n        received = this.document.location.href;\n      } else if (expression === \"to.have.value\") {\n        element = this.retarget(element, \"follow-label\");\n        if (element.nodeName !== \"INPUT\" && element.nodeName !== \"TEXTAREA\" && element.nodeName !== \"SELECT\")\n          throw this.createStacklessError(\"Not an input element\");\n        received = element.value;\n      }\n      if (received !== void 0 && options.expectedText) {\n        const matcher = new ExpectedTextMatcher(options.expectedText[0]);\n        return { received, matches: matcher.matches(received) };\n      }\n    }\n    throw this.createStacklessError(\"Unknown expect matcher: \" + expression);\n  }\n  expectArray(elements, options) {\n    const expression = options.expression;\n    if (expression === \"to.have.count\") {\n      const received2 = elements.length;\n      const matches2 = received2 === options.expectedNumber;\n      return { received: received2, matches: matches2 };\n    }\n    if (!options.expectedText)\n      throw this.createStacklessError(\"Expected text is not provided for \" + expression);\n    if ([\"to.have.class.array\", \"to.contain.class.array\"].includes(expression)) {\n      const receivedClassLists = elements.map((e) => e.classList);\n      const received2 = receivedClassLists.map(String);\n      if (receivedClassLists.length !== options.expectedText.length)\n        return { received: received2, matches: false };\n      const matches2 = this._matchSequentially(\n        options.expectedText,\n        receivedClassLists,\n        (matcher, r) => matcher.matchesClassList(\n          this,\n          r,\n          /* partial */\n          expression === \"to.contain.class.array\"\n        )\n      );\n      return {\n        received: received2,\n        matches: matches2\n      };\n    }\n    if (![\"to.contain.text.array\", \"to.have.text.array\"].includes(expression))\n      throw this.createStacklessError(\"Unknown expect matcher: \" + expression);\n    const received = elements.map((e) => options.useInnerText ? e.innerText : elementText(new Map(), e).full);\n    const lengthShouldMatch = expression !== \"to.contain.text.array\";\n    const matchesLength = received.length === options.expectedText.length || !lengthShouldMatch;\n    if (!matchesLength)\n      return { received, matches: false };\n    const matches = this._matchSequentially(options.expectedText, received, (matcher, r) => matcher.matches(r));\n    return { received, matches };\n  }\n  _matchSequentially(expectedText, received, matchFn) {\n    const matchers = expectedText.map((e) => new ExpectedTextMatcher(e));\n    let mIndex = 0;\n    let rIndex = 0;\n    while (mIndex < matchers.length && rIndex < received.length) {\n      if (matchFn(matchers[mIndex], received[rIndex]))\n        ++mIndex;\n      ++rIndex;\n    }\n    return mIndex === matchers.length;\n  }\n};\nfunction oneLine(s) {\n  return s.replace(/\\n/g, \"\\u21B5\").replace(/\\t/g, \"\\u21C6\");\n}\nfunction cssUnquote(s) {\n  s = s.substring(1, s.length - 1);\n  if (!s.includes(\"\\\\\"))\n    return s;\n  const r = [];\n  let i = 0;\n  while (i < s.length) {\n    if (s[i] === \"\\\\\" && i + 1 < s.length)\n      i++;\n    r.push(s[i++]);\n  }\n  return r.join(\"\");\n}\nfunction createTextMatcher(selector, internal) {\n  if (selector[0] === \"/\" && selector.lastIndexOf(\"/\") > 0) {\n    const lastSlash = selector.lastIndexOf(\"/\");\n    const re = new RegExp(selector.substring(1, lastSlash), selector.substring(lastSlash + 1));\n    return { matcher: (elementText2) => re.test(elementText2.full), kind: \"regex\" };\n  }\n  const unquote = internal ? JSON.parse.bind(JSON) : cssUnquote;\n  let strict = false;\n  if (selector.length > 1 && selector[0] === '\"' && selector[selector.length - 1] === '\"') {\n    selector = unquote(selector);\n    strict = true;\n  } else if (internal && selector.length > 1 && selector[0] === '\"' && selector[selector.length - 2] === '\"' && selector[selector.length - 1] === \"i\") {\n    selector = unquote(selector.substring(0, selector.length - 1));\n    strict = false;\n  } else if (internal && selector.length > 1 && selector[0] === '\"' && selector[selector.length - 2] === '\"' && selector[selector.length - 1] === \"s\") {\n    selector = unquote(selector.substring(0, selector.length - 1));\n    strict = true;\n  } else if (selector.length > 1 && selector[0] === \"'\" && selector[selector.length - 1] === \"'\") {\n    selector = unquote(selector);\n    strict = true;\n  }\n  selector = normalizeWhiteSpace(selector);\n  if (strict) {\n    if (internal)\n      return { kind: \"strict\", matcher: (elementText2) => elementText2.normalized === selector };\n    const strictTextNodeMatcher = (elementText2) => {\n      if (!selector && !elementText2.immediate.length)\n        return true;\n      return elementText2.immediate.some((s) => normalizeWhiteSpace(s) === selector);\n    };\n    return { matcher: strictTextNodeMatcher, kind: \"strict\" };\n  }\n  selector = selector.toLowerCase();\n  return { kind: \"lax\", matcher: (elementText2) => elementText2.normalized.toLowerCase().includes(selector) };\n}\nvar ExpectedTextMatcher = class {\n  constructor(expected) {\n    this._normalizeWhiteSpace = expected.normalizeWhiteSpace;\n    this._ignoreCase = expected.ignoreCase;\n    this._string = expected.matchSubstring ? void 0 : this.normalize(expected.string);\n    this._substring = expected.matchSubstring ? this.normalize(expected.string) : void 0;\n    if (expected.regexSource) {\n      const flags = new Set((expected.regexFlags || \"\").split(\"\"));\n      if (expected.ignoreCase === false)\n        flags.delete(\"i\");\n      if (expected.ignoreCase === true)\n        flags.add(\"i\");\n      this._regex = new RegExp(expected.regexSource, [...flags].join(\"\"));\n    }\n  }\n  matches(text) {\n    if (!this._regex)\n      text = this.normalize(text);\n    if (this._string !== void 0)\n      return text === this._string;\n    if (this._substring !== void 0)\n      return text.includes(this._substring);\n    if (this._regex)\n      return !!this._regex.test(text);\n    return false;\n  }\n  matchesClassList(injectedScript, classList, partial) {\n    if (partial) {\n      if (this._regex)\n        throw injectedScript.createStacklessError(\"Partial matching does not support regular expressions. Please provide a string value.\");\n      return this._string.split(/\\s+/g).filter(Boolean).every((className) => classList.contains(className));\n    }\n    return this.matches(classList.toString());\n  }\n  normalize(s) {\n    if (!s)\n      return s;\n    if (this._normalizeWhiteSpace)\n      s = normalizeWhiteSpace(s);\n    if (this._ignoreCase)\n      s = s.toLocaleLowerCase();\n    return s;\n  }\n};\nfunction deepEquals(a, b) {\n  if (a === b)\n    return true;\n  if (a && b && typeof a === \"object\" && typeof b === \"object\") {\n    if (a.constructor !== b.constructor)\n      return false;\n    if (Array.isArray(a)) {\n      if (a.length !== b.length)\n        return false;\n      for (let i = 0; i < a.length; ++i) {\n        if (!deepEquals(a[i], b[i]))\n          return false;\n      }\n      return true;\n    }\n    if (a instanceof RegExp)\n      return a.source === b.source && a.flags === b.flags;\n    if (a.valueOf !== Object.prototype.valueOf)\n      return a.valueOf() === b.valueOf();\n    if (a.toString !== Object.prototype.toString)\n      return a.toString() === b.toString();\n    const keys = Object.keys(a);\n    if (keys.length !== Object.keys(b).length)\n      return false;\n    for (let i = 0; i < keys.length; ++i) {\n      if (!b.hasOwnProperty(keys[i]))\n        return false;\n    }\n    for (const key of keys) {\n      if (!deepEquals(a[key], b[key]))\n        return false;\n    }\n    return true;\n  }\n  if (typeof a === \"number\" && typeof b === \"number\")\n    return isNaN(a) && isNaN(b);\n  return false;\n}\n\n        return new (module.exports.InjectedScript())(\n          globalThis,\n          false,\n          \"javascript\",\n          \"data-testid\",\n          1,\n          \"chromium\",\n          false,\n          []\n        );\n        })();\n      ",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 271929,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10,
            "endOffset": 271918,
            "count": 1
          }
        ]
      },
      {
        "functionName": "__commonJS",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 71,
            "endOffset": 398,
            "count": 0
          }
        ]
      },
      {
        "functionName": "__export",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 415,
            "endOffset": 481,
            "count": 1
          }
        ]
      },
      {
        "functionName": "__toESM",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 497,
            "endOffset": 532,
            "count": 0
          }
        ]
      },
      {
        "functionName": "__toCommonJS",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 553,
            "endOffset": 590,
            "count": 1
          }
        ]
      },
      {
        "functionName": "InjectedScript",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 723,
            "endOffset": 743,
            "count": 1
          }
        ]
      },
      {
        "functionName": "parseAriaSnapshot",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 869,
            "endOffset": 6047,
            "count": 0
          }
        ]
      },
      {
        "functionName": "normalizeWhitespace",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 6104,
            "endOffset": 6224,
            "count": 0
          }
        ]
      },
      {
        "functionName": "valueOrRegex",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 6225,
            "endOffset": 6395,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parse",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 6440,
            "endOffset": 6945,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_KeyParser",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 6948,
            "endOffset": 7049,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_peek",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 7052,
            "endOffset": 7106,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_next",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 7109,
            "endOffset": 7212,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_eof",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 7215,
            "endOffset": 7265,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_isWhitespace",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 7268,
            "endOffset": 7341,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_skipWhitespace",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 7344,
            "endOffset": 7419,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_readIdentifier",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 7422,
            "endOffset": 7698,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_readString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 7701,
            "endOffset": 8098,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_throwError",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 8101,
            "endOffset": 8196,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_readRegex",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 8199,
            "endOffset": 8852,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_readStringOrRegex",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 8855,
            "endOffset": 9109,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_readAttributes",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 9112,
            "endOffset": 9966,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_parse",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 9969,
            "endOffset": 10332,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_applyAttribute",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10335,
            "endOffset": 11832,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_assert",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11835,
            "endOffset": 11954,
            "count": 0
          }
        ]
      },
      {
        "functionName": "ParserError",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12000,
            "endOffset": 12071,
            "count": 0
          }
        ]
      },
      {
        "functionName": "builtins",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 12137,
            "endOffset": 13442,
            "count": 3
          },
          {
            "startOffset": 12233,
            "endOffset": 12241,
            "count": 1
          },
          {
            "startOffset": 12242,
            "endOffset": 12254,
            "count": 2
          },
          {
            "startOffset": 12298,
            "endOffset": 13396,
            "count": 0
          }
        ]
      },
      {
        "functionName": "between",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14082,
            "endOffset": 14150,
            "count": 0
          }
        ]
      },
      {
        "functionName": "digit",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14152,
            "endOffset": 14208,
            "count": 0
          }
        ]
      },
      {
        "functionName": "hexdigit",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14209,
            "endOffset": 14309,
            "count": 0
          }
        ]
      },
      {
        "functionName": "uppercaseletter",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14310,
            "endOffset": 14376,
            "count": 0
          }
        ]
      },
      {
        "functionName": "lowercaseletter",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14377,
            "endOffset": 14444,
            "count": 0
          }
        ]
      },
      {
        "functionName": "letter",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14445,
            "endOffset": 14527,
            "count": 0
          }
        ]
      },
      {
        "functionName": "nonascii",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14528,
            "endOffset": 14577,
            "count": 0
          }
        ]
      },
      {
        "functionName": "namestartchar",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14578,
            "endOffset": 14666,
            "count": 0
          }
        ]
      },
      {
        "functionName": "namechar",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14667,
            "endOffset": 14754,
            "count": 0
          }
        ]
      },
      {
        "functionName": "nonprintable",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14755,
            "endOffset": 14872,
            "count": 0
          }
        ]
      },
      {
        "functionName": "newline",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14873,
            "endOffset": 14921,
            "count": 0
          }
        ]
      },
      {
        "functionName": "whitespace",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14922,
            "endOffset": 15004,
            "count": 0
          }
        ]
      },
      {
        "functionName": "InvalidCharacterError",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15096,
            "endOffset": 15183,
            "count": 0
          }
        ]
      },
      {
        "functionName": "preprocess",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15187,
            "endOffset": 15800,
            "count": 0
          }
        ]
      },
      {
        "functionName": "stringFromCode",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15801,
            "endOffset": 16092,
            "count": 0
          }
        ]
      },
      {
        "functionName": "tokenize",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 16093,
            "endOffset": 28621,
            "count": 0
          }
        ]
      },
      {
        "functionName": "CSSParserToken",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 28653,
            "endOffset": 28697,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toJSON",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 28700,
            "endOffset": 28752,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 28755,
            "endOffset": 28798,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toSource",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 28801,
            "endOffset": 28839,
            "count": 0
          }
        ]
      },
      {
        "functionName": "BadStringToken",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 28897,
            "endOffset": 28975,
            "count": 0
          }
        ]
      },
      {
        "functionName": "BadURLToken",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 29030,
            "endOffset": 29105,
            "count": 0
          }
        ]
      },
      {
        "functionName": "WhitespaceToken",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 29164,
            "endOffset": 29243,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 29246,
            "endOffset": 29279,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toSource",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 29282,
            "endOffset": 29314,
            "count": 0
          }
        ]
      },
      {
        "functionName": "CDOToken",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 29366,
            "endOffset": 29438,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toSource",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 29441,
            "endOffset": 29476,
            "count": 0
          }
        ]
      },
      {
        "functionName": "CDCToken",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 29528,
            "endOffset": 29600,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toSource",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 29603,
            "endOffset": 29637,
            "count": 0
          }
        ]
      },
      {
        "functionName": "ColonToken",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 29691,
            "endOffset": 29761,
            "count": 0
          }
        ]
      },
      {
        "functionName": "SemicolonToken",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 29819,
            "endOffset": 29889,
            "count": 0
          }
        ]
      },
      {
        "functionName": "CommaToken",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 29943,
            "endOffset": 30013,
            "count": 0
          }
        ]
      },
      {
        "functionName": "GroupingToken",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 30070,
            "endOffset": 30157,
            "count": 0
          }
        ]
      },
      {
        "functionName": "OpenCurlyToken",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 30214,
            "endOffset": 30317,
            "count": 0
          }
        ]
      },
      {
        "functionName": "CloseCurlyToken",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 30375,
            "endOffset": 30478,
            "count": 0
          }
        ]
      },
      {
        "functionName": "OpenSquareToken",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 30536,
            "endOffset": 30639,
            "count": 0
          }
        ]
      },
      {
        "functionName": "CloseSquareToken",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 30698,
            "endOffset": 30801,
            "count": 0
          }
        ]
      },
      {
        "functionName": "OpenParenToken",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 30858,
            "endOffset": 30961,
            "count": 0
          }
        ]
      },
      {
        "functionName": "CloseParenToken",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 31019,
            "endOffset": 31122,
            "count": 0
          }
        ]
      },
      {
        "functionName": "IncludeMatchToken",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 31183,
            "endOffset": 31254,
            "count": 0
          }
        ]
      },
      {
        "functionName": "DashMatchToken",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 31312,
            "endOffset": 31383,
            "count": 0
          }
        ]
      },
      {
        "functionName": "PrefixMatchToken",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 31443,
            "endOffset": 31514,
            "count": 0
          }
        ]
      },
      {
        "functionName": "SuffixMatchToken",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 31574,
            "endOffset": 31645,
            "count": 0
          }
        ]
      },
      {
        "functionName": "SubstringMatchToken",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 31708,
            "endOffset": 31779,
            "count": 0
          }
        ]
      },
      {
        "functionName": "ColumnToken",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 31834,
            "endOffset": 31905,
            "count": 0
          }
        ]
      },
      {
        "functionName": "EOFToken",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 31957,
            "endOffset": 32029,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toSource",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 32032,
            "endOffset": 32063,
            "count": 0
          }
        ]
      },
      {
        "functionName": "DelimToken",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 32117,
            "endOffset": 32243,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 32246,
            "endOffset": 32302,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toJSON",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 32305,
            "endOffset": 32450,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toSource",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 32453,
            "endOffset": 32553,
            "count": 0
          }
        ]
      },
      {
        "functionName": "StringValuedToken",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 32614,
            "endOffset": 32679,
            "count": 0
          }
        ]
      },
      {
        "functionName": "ASCIIMatch",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 32682,
            "endOffset": 32762,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toJSON",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 32765,
            "endOffset": 32910,
            "count": 0
          }
        ]
      },
      {
        "functionName": "IdentToken",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 32967,
            "endOffset": 33054,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 33057,
            "endOffset": 33113,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toSource",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 33116,
            "endOffset": 33168,
            "count": 0
          }
        ]
      },
      {
        "functionName": "FunctionToken",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 33228,
            "endOffset": 33341,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 33344,
            "endOffset": 33403,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toSource",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 33406,
            "endOffset": 33464,
            "count": 0
          }
        ]
      },
      {
        "functionName": "AtKeywordToken",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 33525,
            "endOffset": 33617,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 33620,
            "endOffset": 33673,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toSource",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 33676,
            "endOffset": 33734,
            "count": 0
          }
        ]
      },
      {
        "functionName": "HashToken",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 33790,
            "endOffset": 33908,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 33911,
            "endOffset": 33966,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toJSON",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 33969,
            "endOffset": 34141,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toSource",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 34144,
            "endOffset": 34284,
            "count": 0
          }
        ]
      },
      {
        "functionName": "StringToken",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 34342,
            "endOffset": 34430,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 34433,
            "endOffset": 34498,
            "count": 0
          }
        ]
      },
      {
        "functionName": "URLToken",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 34553,
            "endOffset": 34638,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 34641,
            "endOffset": 34695,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toSource",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 34698,
            "endOffset": 34768,
            "count": 0
          }
        ]
      },
      {
        "functionName": "NumberToken",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 34823,
            "endOffset": 34933,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 34936,
            "endOffset": 35066,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toJSON",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 35069,
            "endOffset": 35216,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toSource",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 35219,
            "endOffset": 35257,
            "count": 0
          }
        ]
      },
      {
        "functionName": "PercentageToken",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 35316,
            "endOffset": 35403,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 35406,
            "endOffset": 35467,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toJSON",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 35470,
            "endOffset": 35642,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toSource",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 35645,
            "endOffset": 35689,
            "count": 0
          }
        ]
      },
      {
        "functionName": "DimensionToken",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 35747,
            "endOffset": 35880,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 35883,
            "endOffset": 35955,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toJSON",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 35958,
            "endOffset": 36184,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toSource",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 36187,
            "endOffset": 36456,
            "count": 0
          }
        ]
      },
      {
        "functionName": "escapeIdent",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 36460,
            "endOffset": 37177,
            "count": 0
          }
        ]
      },
      {
        "functionName": "escapeHash",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 37178,
            "endOffset": 37675,
            "count": 0
          }
        ]
      },
      {
        "functionName": "escapeString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 37676,
            "endOffset": 38169,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parseCSS",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 38285,
            "endOffset": 44848,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parseSelector",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 45387,
            "endOffset": 47551,
            "count": 0
          }
        ]
      },
      {
        "functionName": "selectorPartsEqual",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 47552,
            "endOffset": 47683,
            "count": 0
          }
        ]
      },
      {
        "functionName": "stringifySelector",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 47684,
            "endOffset": 48255,
            "count": 0
          }
        ]
      },
      {
        "functionName": "visitAllSelectorParts",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 48256,
            "endOffset": 48544,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parseSelectorString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 48545,
            "endOffset": 50601,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parseAttributeSelector",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 50602,
            "endOffset": 55795,
            "count": 0
          }
        ]
      },
      {
        "functionName": "escapeWithQuotes",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 55861,
            "endOffset": 56328,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toTitleCase",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 56329,
            "endOffset": 56418,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toSnakeCase",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 56419,
            "endOffset": 56558,
            "count": 0
          }
        ]
      },
      {
        "functionName": "cssEscape",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 56559,
            "endOffset": 56691,
            "count": 0
          }
        ]
      },
      {
        "functionName": "quoteCSSAttributeValue",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 56692,
            "endOffset": 56787,
            "count": 0
          }
        ]
      },
      {
        "functionName": "cssEscapeOne",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 56788,
            "endOffset": 57257,
            "count": 0
          }
        ]
      },
      {
        "functionName": "cacheNormalizedWhitespaces",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 57289,
            "endOffset": 57371,
            "count": 0
          }
        ]
      },
      {
        "functionName": "normalizeWhiteSpace",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 57372,
            "endOffset": 57727,
            "count": 0
          }
        ]
      },
      {
        "functionName": "normalizeEscapedRegexQuotes",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 57728,
            "endOffset": 57841,
            "count": 0
          }
        ]
      },
      {
        "functionName": "escapeRegexForSelector",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 57842,
            "endOffset": 58034,
            "count": 0
          }
        ]
      },
      {
        "functionName": "escapeForTextSelector",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 58035,
            "endOffset": 58211,
            "count": 0
          }
        ]
      },
      {
        "functionName": "escapeForAttributeSelector",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 58212,
            "endOffset": 58429,
            "count": 0
          }
        ]
      },
      {
        "functionName": "trimString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 58430,
            "endOffset": 58668,
            "count": 0
          }
        ]
      },
      {
        "functionName": "trimStringWithEllipsis",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 58669,
            "endOffset": 58759,
            "count": 0
          }
        ]
      },
      {
        "functionName": "escapeRegExp",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 58760,
            "endOffset": 58839,
            "count": 0
          }
        ]
      },
      {
        "functionName": "longestCommonSubstring",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 58840,
            "endOffset": 59357,
            "count": 0
          }
        ]
      },
      {
        "functionName": "asLocator",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 59429,
            "endOffset": 59550,
            "count": 0
          }
        ]
      },
      {
        "functionName": "asLocators",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 59551,
            "endOffset": 59823,
            "count": 0
          }
        ]
      },
      {
        "functionName": "innerAsLocators",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 59824,
            "endOffset": 66509,
            "count": 0
          }
        ]
      },
      {
        "functionName": "combineTokens",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 66510,
            "endOffset": 66991,
            "count": 0
          }
        ]
      },
      {
        "functionName": "detectExact",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 66992,
            "endOffset": 67491,
            "count": 0
          }
        ]
      },
      {
        "functionName": "JavaScriptLocatorFactory",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 67533,
            "endOffset": 67608,
            "count": 0
          }
        ]
      },
      {
        "functionName": "generateLocator",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 67611,
            "endOffset": 70137,
            "count": 0
          }
        ]
      },
      {
        "functionName": "chainLocators",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 70140,
            "endOffset": 70200,
            "count": 0
          }
        ]
      },
      {
        "functionName": "regexToSourceString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 70203,
            "endOffset": 70284,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toCallWithExact",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 70287,
            "endOffset": 70519,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toHasText",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 70522,
            "endOffset": 70641,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toTestIdValue",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 70644,
            "endOffset": 70771,
            "count": 0
          }
        ]
      },
      {
        "functionName": "quote",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 70774,
            "endOffset": 70885,
            "count": 0
          }
        ]
      },
      {
        "functionName": "generateLocator",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 70926,
            "endOffset": 73584,
            "count": 0
          }
        ]
      },
      {
        "functionName": "chainLocators",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 73587,
            "endOffset": 73647,
            "count": 0
          }
        ]
      },
      {
        "functionName": "regexToString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 73650,
            "endOffset": 73869,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toCallWithExact",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 73872,
            "endOffset": 74112,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toHasText",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 74115,
            "endOffset": 74233,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toTestIdValue",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 74236,
            "endOffset": 74357,
            "count": 0
          }
        ]
      },
      {
        "functionName": "quote",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 74360,
            "endOffset": 74417,
            "count": 0
          }
        ]
      },
      {
        "functionName": "generateLocator",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 74456,
            "endOffset": 77525,
            "count": 0
          }
        ]
      },
      {
        "functionName": "chainLocators",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 77528,
            "endOffset": 77588,
            "count": 0
          }
        ]
      },
      {
        "functionName": "regexToString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 77591,
            "endOffset": 77793,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toCallWithExact",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 77796,
            "endOffset": 78092,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toHasText",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 78095,
            "endOffset": 78208,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toTestIdValue",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 78211,
            "endOffset": 78332,
            "count": 0
          }
        ]
      },
      {
        "functionName": "quote",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 78335,
            "endOffset": 78392,
            "count": 0
          }
        ]
      },
      {
        "functionName": "generateLocator",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 78433,
            "endOffset": 80994,
            "count": 0
          }
        ]
      },
      {
        "functionName": "chainLocators",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 80997,
            "endOffset": 81057,
            "count": 0
          }
        ]
      },
      {
        "functionName": "regexToString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 81060,
            "endOffset": 81255,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toCallWithExact",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 81258,
            "endOffset": 81510,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toHasText",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 81513,
            "endOffset": 81661,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toTestIdValue",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 81664,
            "endOffset": 81785,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toHasNotText",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 81788,
            "endOffset": 81945,
            "count": 0
          }
        ]
      },
      {
        "functionName": "quote",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 81948,
            "endOffset": 82005,
            "count": 0
          }
        ]
      },
      {
        "functionName": "generateLocator",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 82045,
            "endOffset": 82172,
            "count": 0
          }
        ]
      },
      {
        "functionName": "chainLocators",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 82175,
            "endOffset": 82388,
            "count": 0
          }
        ]
      },
      {
        "functionName": "isRegExp",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 82575,
            "endOffset": 82633,
            "count": 0
          }
        ]
      },
      {
        "functionName": "setGlobalOptions",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 82696,
            "endOffset": 82761,
            "count": 1
          }
        ]
      },
      {
        "functionName": "getGlobalOptions",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 82762,
            "endOffset": 82817,
            "count": 0
          }
        ]
      },
      {
        "functionName": "isInsideScope",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 82818,
            "endOffset": 82996,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parentElementOrShadowHost",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 82997,
            "endOffset": 83251,
            "count": 0
          }
        ]
      },
      {
        "functionName": "enclosingShadowRootOrDocument",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 83252,
            "endOffset": 83447,
            "count": 0
          }
        ]
      },
      {
        "functionName": "enclosingShadowHost",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 83448,
            "endOffset": 83603,
            "count": 0
          }
        ]
      },
      {
        "functionName": "closestCrossShadow",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 83604,
            "endOffset": 83911,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getElementComputedStyle",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 83912,
            "endOffset": 84113,
            "count": 0
          }
        ]
      },
      {
        "functionName": "isElementStyleVisibilityVisible",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 84114,
            "endOffset": 84744,
            "count": 0
          }
        ]
      },
      {
        "functionName": "isElementVisible",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 84745,
            "endOffset": 85334,
            "count": 0
          }
        ]
      },
      {
        "functionName": "isVisibleTextNode",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 85335,
            "endOffset": 85537,
            "count": 0
          }
        ]
      },
      {
        "functionName": "elementSafeTagName",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 85538,
            "endOffset": 85679,
            "count": 0
          }
        ]
      },
      {
        "functionName": "hasExplicitAccessibleName",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 85719,
            "endOffset": 85836,
            "count": 0
          }
        ]
      },
      {
        "functionName": "hasGlobalAriaAttribute",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 87133,
            "endOffset": 87364,
            "count": 0
          }
        ]
      },
      {
        "functionName": "hasTabIndex",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 87365,
            "endOffset": 87472,
            "count": 0
          }
        ]
      },
      {
        "functionName": "isFocusable",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 87473,
            "endOffset": 87603,
            "count": 0
          }
        ]
      },
      {
        "functionName": "isNativelyFocusable",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 87604,
            "endOffset": 87935,
            "count": 0
          }
        ]
      },
      {
        "functionName": "A",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 87974,
            "endOffset": 88037,
            "count": 0
          }
        ]
      },
      {
        "functionName": "AREA",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 88049,
            "endOffset": 88112,
            "count": 0
          }
        ]
      },
      {
        "functionName": "ARTICLE",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 88127,
            "endOffset": 88142,
            "count": 0
          }
        ]
      },
      {
        "functionName": "ASIDE",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 88155,
            "endOffset": 88176,
            "count": 0
          }
        ]
      },
      {
        "functionName": "BLOCKQUOTE",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 88194,
            "endOffset": 88212,
            "count": 0
          }
        ]
      },
      {
        "functionName": "BUTTON",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 88226,
            "endOffset": 88240,
            "count": 0
          }
        ]
      },
      {
        "functionName": "CAPTION",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 88255,
            "endOffset": 88270,
            "count": 0
          }
        ]
      },
      {
        "functionName": "CODE",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 88282,
            "endOffset": 88294,
            "count": 0
          }
        ]
      },
      {
        "functionName": "DATALIST",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 88310,
            "endOffset": 88325,
            "count": 0
          }
        ]
      },
      {
        "functionName": "DD",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 88335,
            "endOffset": 88353,
            "count": 0
          }
        ]
      },
      {
        "functionName": "DEL",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 88364,
            "endOffset": 88380,
            "count": 0
          }
        ]
      },
      {
        "functionName": "DETAILS",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 88395,
            "endOffset": 88408,
            "count": 0
          }
        ]
      },
      {
        "functionName": "DFN",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 88419,
            "endOffset": 88431,
            "count": 0
          }
        ]
      },
      {
        "functionName": "DIALOG",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 88445,
            "endOffset": 88459,
            "count": 0
          }
        ]
      },
      {
        "functionName": "DT",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 88469,
            "endOffset": 88481,
            "count": 0
          }
        ]
      },
      {
        "functionName": "EM",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 88491,
            "endOffset": 88507,
            "count": 0
          }
        ]
      },
      {
        "functionName": "FIELDSET",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 88523,
            "endOffset": 88536,
            "count": 0
          }
        ]
      },
      {
        "functionName": "FIGURE",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 88550,
            "endOffset": 88564,
            "count": 0
          }
        ]
      },
      {
        "functionName": "FOOTER",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 88578,
            "endOffset": 88658,
            "count": 0
          }
        ]
      },
      {
        "functionName": "FORM",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 88670,
            "endOffset": 88721,
            "count": 0
          }
        ]
      },
      {
        "functionName": "H1",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 88731,
            "endOffset": 88746,
            "count": 0
          }
        ]
      },
      {
        "functionName": "H2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 88756,
            "endOffset": 88771,
            "count": 0
          }
        ]
      },
      {
        "functionName": "H3",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 88781,
            "endOffset": 88796,
            "count": 0
          }
        ]
      },
      {
        "functionName": "H4",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 88806,
            "endOffset": 88821,
            "count": 0
          }
        ]
      },
      {
        "functionName": "H5",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 88831,
            "endOffset": 88846,
            "count": 0
          }
        ]
      },
      {
        "functionName": "H6",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 88856,
            "endOffset": 88871,
            "count": 0
          }
        ]
      },
      {
        "functionName": "HEADER",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 88885,
            "endOffset": 88960,
            "count": 0
          }
        ]
      },
      {
        "functionName": "HR",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 88970,
            "endOffset": 88987,
            "count": 0
          }
        ]
      },
      {
        "functionName": "HTML",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 88999,
            "endOffset": 89015,
            "count": 0
          }
        ]
      },
      {
        "functionName": "IMG",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 89026,
            "endOffset": 89163,
            "count": 0
          }
        ]
      },
      {
        "functionName": "INPUT",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 89176,
            "endOffset": 89718,
            "count": 0
          }
        ]
      },
      {
        "functionName": "INS",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 89729,
            "endOffset": 89746,
            "count": 0
          }
        ]
      },
      {
        "functionName": "LI",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 89756,
            "endOffset": 89772,
            "count": 0
          }
        ]
      },
      {
        "functionName": "MAIN",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 89784,
            "endOffset": 89796,
            "count": 0
          }
        ]
      },
      {
        "functionName": "MARK",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 89808,
            "endOffset": 89820,
            "count": 0
          }
        ]
      },
      {
        "functionName": "MATH",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 89832,
            "endOffset": 89844,
            "count": 0
          }
        ]
      },
      {
        "functionName": "MENU",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 89856,
            "endOffset": 89868,
            "count": 0
          }
        ]
      },
      {
        "functionName": "METER",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 89881,
            "endOffset": 89894,
            "count": 0
          }
        ]
      },
      {
        "functionName": "NAV",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 89905,
            "endOffset": 89923,
            "count": 0
          }
        ]
      },
      {
        "functionName": "OL",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 89933,
            "endOffset": 89945,
            "count": 0
          }
        ]
      },
      {
        "functionName": "OPTGROUP",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 89961,
            "endOffset": 89974,
            "count": 0
          }
        ]
      },
      {
        "functionName": "OPTION",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 89988,
            "endOffset": 90002,
            "count": 0
          }
        ]
      },
      {
        "functionName": "OUTPUT",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 90016,
            "endOffset": 90030,
            "count": 0
          }
        ]
      },
      {
        "functionName": "P",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 90039,
            "endOffset": 90056,
            "count": 0
          }
        ]
      },
      {
        "functionName": "PROGRESS",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 90072,
            "endOffset": 90091,
            "count": 0
          }
        ]
      },
      {
        "functionName": "SECTION",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 90106,
            "endOffset": 90159,
            "count": 0
          }
        ]
      },
      {
        "functionName": "SELECT",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 90173,
            "endOffset": 90245,
            "count": 0
          }
        ]
      },
      {
        "functionName": "STRONG",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 90259,
            "endOffset": 90273,
            "count": 0
          }
        ]
      },
      {
        "functionName": "SUB",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 90284,
            "endOffset": 90301,
            "count": 0
          }
        ]
      },
      {
        "functionName": "SUP",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 90312,
            "endOffset": 90331,
            "count": 0
          }
        ]
      },
      {
        "functionName": "SVG",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 90558,
            "endOffset": 90569,
            "count": 0
          }
        ]
      },
      {
        "functionName": "TABLE",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 90582,
            "endOffset": 90595,
            "count": 0
          }
        ]
      },
      {
        "functionName": "TBODY",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 90608,
            "endOffset": 90624,
            "count": 0
          }
        ]
      },
      {
        "functionName": "TD",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 90634,
            "endOffset": 90827,
            "count": 0
          }
        ]
      },
      {
        "functionName": "TEXTAREA",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 90843,
            "endOffset": 90858,
            "count": 0
          }
        ]
      },
      {
        "functionName": "TFOOT",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 90871,
            "endOffset": 90887,
            "count": 0
          }
        ]
      },
      {
        "functionName": "TH",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 90897,
            "endOffset": 91231,
            "count": 0
          }
        ]
      },
      {
        "functionName": "THEAD",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 91244,
            "endOffset": 91260,
            "count": 0
          }
        ]
      },
      {
        "functionName": "TIME",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 91272,
            "endOffset": 91284,
            "count": 0
          }
        ]
      },
      {
        "functionName": "TR",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 91294,
            "endOffset": 91305,
            "count": 0
          }
        ]
      },
      {
        "functionName": "UL",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 91315,
            "endOffset": 91327,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getImplicitAriaRole",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 91602,
            "endOffset": 92410,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getExplicitAriaRole",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 93518,
            "endOffset": 93717,
            "count": 0
          }
        ]
      },
      {
        "functionName": "hasPresentationConflictResolution",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 93718,
            "endOffset": 93851,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getAriaRole",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 93852,
            "endOffset": 94243,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getAriaBoolean",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 94244,
            "endOffset": 94342,
            "count": 0
          }
        ]
      },
      {
        "functionName": "isElementIgnoredForAria",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 94343,
            "endOffset": 94480,
            "count": 0
          }
        ]
      },
      {
        "functionName": "isElementHiddenForAria",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 94481,
            "endOffset": 95294,
            "count": 0
          }
        ]
      },
      {
        "functionName": "belongsToDisplayNoneOrAriaHiddenOrNonSlotted",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 95295,
            "endOffset": 96056,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getIdRefs",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 96057,
            "endOffset": 96537,
            "count": 0
          }
        ]
      },
      {
        "functionName": "trimFlatString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 96538,
            "endOffset": 96587,
            "count": 0
          }
        ]
      },
      {
        "functionName": "asFlatString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 96588,
            "endOffset": 96761,
            "count": 0
          }
        ]
      },
      {
        "functionName": "queryInAriaOwned",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 96762,
            "endOffset": 97081,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getPseudoContent",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 97082,
            "endOffset": 97525,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getPseudoContentImpl",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 97526,
            "endOffset": 98365,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getAriaLabelledByElements",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 98366,
            "endOffset": 98581,
            "count": 0
          }
        ]
      },
      {
        "functionName": "allowsNameFromContent",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 98582,
            "endOffset": 99309,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getElementAccessibleName",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 99310,
            "endOffset": 100159,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getElementAccessibleDescription",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 100160,
            "endOffset": 101239,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getAriaInvalid",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 101449,
            "endOffset": 101904,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getValidityInvalid",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 101905,
            "endOffset": 102102,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getElementAccessibleErrorMessage",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 102103,
            "endOffset": 103158,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getTextAlternativeInternal",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 103159,
            "endOffset": 113101,
            "count": 0
          }
        ]
      },
      {
        "functionName": "innerAccumulatedElementText",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 113102,
            "endOffset": 114383,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getAriaSelected",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 114488,
            "endOffset": 114756,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getAriaChecked",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 114873,
            "endOffset": 114999,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getCheckedAllowMixed",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 115000,
            "endOffset": 115078,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getCheckedWithoutMixed",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 115079,
            "endOffset": 115185,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getChecked",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 115186,
            "endOffset": 115740,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getReadonly",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 115936,
            "endOffset": 116311,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getAriaPressed",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 116348,
            "endOffset": 116624,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getAriaExpanded",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 116859,
            "endOffset": 117230,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getAriaLevel",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 117297,
            "endOffset": 117727,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getAriaDisabled",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 118166,
            "endOffset": 118277,
            "count": 0
          }
        ]
      },
      {
        "functionName": "isNativelyDisabled",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 118278,
            "endOffset": 118545,
            "count": 0
          }
        ]
      },
      {
        "functionName": "belongsToDisabledFieldSet",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 118546,
            "endOffset": 118862,
            "count": 0
          }
        ]
      },
      {
        "functionName": "hasExplicitAriaDisabled",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 118863,
            "endOffset": 119322,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getAccessibleNameFromAssociatedLabels",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 119323,
            "endOffset": 119770,
            "count": 0
          }
        ]
      },
      {
        "functionName": "beginAriaCaches",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 120031,
            "endOffset": 120887,
            "count": 0
          }
        ]
      },
      {
        "functionName": "endAriaCaches",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 120888,
            "endOffset": 121255,
            "count": 0
          }
        ]
      },
      {
        "functionName": "yamlEscapeKeyIfNeeded",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 121495,
            "endOffset": 121631,
            "count": 0
          }
        ]
      },
      {
        "functionName": "yamlEscapeValueIfNeeded",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 121632,
            "endOffset": 122207,
            "count": 0
          }
        ]
      },
      {
        "functionName": "yamlStringNeedsQuotes",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 122208,
            "endOffset": 122865,
            "count": 0
          }
        ]
      },
      {
        "functionName": "generateAriaTree",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 122908,
            "endOffset": 125929,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toAriaNode",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 125930,
            "endOffset": 127143,
            "count": 0
          }
        ]
      },
      {
        "functionName": "normalizeStringChildren",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 127144,
            "endOffset": 128038,
            "count": 0
          }
        ]
      },
      {
        "functionName": "matchesText",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 128039,
            "endOffset": 128263,
            "count": 0
          }
        ]
      },
      {
        "functionName": "matchesTextNode",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 128264,
            "endOffset": 128351,
            "count": 0
          }
        ]
      },
      {
        "functionName": "matchesName",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 128352,
            "endOffset": 128435,
            "count": 0
          }
        ]
      },
      {
        "functionName": "matchesAriaTree",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 128436,
            "endOffset": 128776,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getAllByAria",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 128777,
            "endOffset": 128983,
            "count": 0
          }
        ]
      },
      {
        "functionName": "matchesNode",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 128984,
            "endOffset": 130473,
            "count": 0
          }
        ]
      },
      {
        "functionName": "listEqual",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 130474,
            "endOffset": 130736,
            "count": 0
          }
        ]
      },
      {
        "functionName": "containsList",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 130737,
            "endOffset": 131097,
            "count": 0
          }
        ]
      },
      {
        "functionName": "matchesNodeDeep",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 131098,
            "endOffset": 131640,
            "count": 0
          }
        ]
      },
      {
        "functionName": "renderAriaTree",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 131641,
            "endOffset": 134395,
            "count": 0
          }
        ]
      },
      {
        "functionName": "convertToBestGuessRegex",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 134396,
            "endOffset": 135740,
            "count": 0
          }
        ]
      },
      {
        "functionName": "textContributesInfo",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 135741,
            "endOffset": 136192,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Highlight",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 140172,
            "endOffset": 142049,
            "count": 0
          }
        ]
      },
      {
        "functionName": "install",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 142052,
            "endOffset": 142294,
            "count": 0
          }
        ]
      },
      {
        "functionName": "setLanguage",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 142297,
            "endOffset": 142355,
            "count": 0
          }
        ]
      },
      {
        "functionName": "runHighlightOnRaf",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 142358,
            "endOffset": 143031,
            "count": 0
          }
        ]
      },
      {
        "functionName": "uninstall",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 143034,
            "endOffset": 143160,
            "count": 0
          }
        ]
      },
      {
        "functionName": "showActionPoint",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 143163,
            "endOffset": 143338,
            "count": 0
          }
        ]
      },
      {
        "functionName": "hideActionPoint",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 143341,
            "endOffset": 143408,
            "count": 0
          }
        ]
      },
      {
        "functionName": "clearHighlight",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 143411,
            "endOffset": 143670,
            "count": 0
          }
        ]
      },
      {
        "functionName": "maskElements",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 143673,
            "endOffset": 143783,
            "count": 0
          }
        ]
      },
      {
        "functionName": "updateHighlight",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 143786,
            "endOffset": 145832,
            "count": 0
          }
        ]
      },
      {
        "functionName": "firstBox",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 145835,
            "endOffset": 145933,
            "count": 0
          }
        ]
      },
      {
        "functionName": "tooltipPosition",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 145936,
            "endOffset": 146640,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_highlightIsUpToDate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 146643,
            "endOffset": 147319,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_createHighlightElement",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 147322,
            "endOffset": 147427,
            "count": 0
          }
        ]
      },
      {
        "functionName": "appendChild",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 147430,
            "endOffset": 147504,
            "count": 0
          }
        ]
      },
      {
        "functionName": "boxRightOf",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 147557,
            "endOffset": 147827,
            "count": 0
          }
        ]
      },
      {
        "functionName": "boxLeftOf",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 147828,
            "endOffset": 148097,
            "count": 0
          }
        ]
      },
      {
        "functionName": "boxAbove",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 148098,
            "endOffset": 148366,
            "count": 0
          }
        ]
      },
      {
        "functionName": "boxBelow",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 148367,
            "endOffset": 148635,
            "count": 0
          }
        ]
      },
      {
        "functionName": "boxNear",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 148636,
            "endOffset": 149096,
            "count": 0
          }
        ]
      },
      {
        "functionName": "layoutSelectorScore",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 149175,
            "endOffset": 149713,
            "count": 0
          }
        ]
      },
      {
        "functionName": "matchesComponentAttribute",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 149757,
            "endOffset": 149955,
            "count": 0
          }
        ]
      },
      {
        "functionName": "matchesAttributePart",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 149956,
            "endOffset": 150919,
            "count": 0
          }
        ]
      },
      {
        "functionName": "shouldSkipForTextMatching",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 150920,
            "endOffset": 151168,
            "count": 0
          }
        ]
      },
      {
        "functionName": "elementText",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 151169,
            "endOffset": 152537,
            "count": 0
          }
        ]
      },
      {
        "functionName": "elementMatchesText",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 152538,
            "endOffset": 153038,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getElementLabels",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 153039,
            "endOffset": 153775,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getFunctionComponentName",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 153825,
            "endOffset": 153938,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getComponentName",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 153939,
            "endOffset": 154649,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getComponentKey",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 154650,
            "endOffset": 154817,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getChildren",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 154818,
            "endOffset": 155600,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getProps",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 155601,
            "endOffset": 155937,
            "count": 0
          }
        ]
      },
      {
        "functionName": "buildComponentsTree",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 155938,
            "endOffset": 156743,
            "count": 0
          }
        ]
      },
      {
        "functionName": "filterComponentsTree",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 156744,
            "endOffset": 156972,
            "count": 0
          }
        ]
      },
      {
        "functionName": "findReactRoots",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 156973,
            "endOffset": 158080,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createReactEngine",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 158105,
            "endOffset": 159138,
            "count": 1
          }
        ]
      },
      {
        "functionName": "queryAll",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 158116,
            "endOffset": 159135,
            "count": 0
          }
        ]
      },
      {
        "functionName": "validateSupportedRole",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 159339,
            "endOffset": 159558,
            "count": 0
          }
        ]
      },
      {
        "functionName": "validateSupportedValues",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 159559,
            "endOffset": 159776,
            "count": 0
          }
        ]
      },
      {
        "functionName": "validateSupportedOp",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 159777,
            "endOffset": 159927,
            "count": 0
          }
        ]
      },
      {
        "functionName": "validateAttributes",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 159928,
            "endOffset": 162718,
            "count": 0
          }
        ]
      },
      {
        "functionName": "queryRole",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 162719,
            "endOffset": 164485,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createRoleEngine",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 164486,
            "endOffset": 164966,
            "count": 2
          }
        ]
      },
      {
        "functionName": "queryAll",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 164549,
            "endOffset": 164959,
            "count": 0
          }
        ]
      },
      {
        "functionName": "SelectorEvaluatorImpl",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 165052,
            "endOffset": 166672,
            "count": 1
          },
          {
            "startOffset": 166540,
            "endOffset": 166668,
            "count": 0
          }
        ]
      },
      {
        "functionName": "begin",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 166675,
            "endOffset": 166720,
            "count": 0
          }
        ]
      },
      {
        "functionName": "end",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 166723,
            "endOffset": 167134,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_cached",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 167137,
            "endOffset": 167479,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_checkSelector",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 167482,
            "endOffset": 167703,
            "count": 0
          }
        ]
      },
      {
        "functionName": "matches",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 167706,
            "endOffset": 168447,
            "count": 0
          }
        ]
      },
      {
        "functionName": "query",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 168450,
            "endOffset": 169729,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_markScore",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 169732,
            "endOffset": 169830,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_hasScopeClause",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 169833,
            "endOffset": 169969,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_expandContextForScopeMatching",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 169972,
            "endOffset": 170264,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_matchesSimple",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 170267,
            "endOffset": 170790,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_querySimple",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 170793,
            "endOffset": 172212,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_matchesParents",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 172215,
            "endOffset": 174693,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_matchesEngine",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 174696,
            "endOffset": 175007,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_queryEngine",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 175010,
            "endOffset": 175342,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_callMatches",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 175345,
            "endOffset": 175606,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_callQuery",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 175609,
            "endOffset": 175837,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_matchesCSS",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 175840,
            "endOffset": 175904,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_queryCSS",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 175907,
            "endOffset": 176497,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_getEngine",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 176500,
            "endOffset": 176662,
            "count": 0
          }
        ]
      },
      {
        "functionName": "matches",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 176685,
            "endOffset": 176913,
            "count": 0
          }
        ]
      },
      {
        "functionName": "query",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 176917,
            "endOffset": 177235,
            "count": 0
          }
        ]
      },
      {
        "functionName": "matches",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 177259,
            "endOffset": 177482,
            "count": 0
          }
        ]
      },
      {
        "functionName": "matches",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 177669,
            "endOffset": 177996,
            "count": 0
          }
        ]
      },
      {
        "functionName": "query",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 178000,
            "endOffset": 178394,
            "count": 0
          }
        ]
      },
      {
        "functionName": "matches",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 178418,
            "endOffset": 178619,
            "count": 0
          }
        ]
      },
      {
        "functionName": "query",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 178645,
            "endOffset": 178753,
            "count": 0
          }
        ]
      },
      {
        "functionName": "matches",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 178757,
            "endOffset": 178887,
            "count": 0
          }
        ]
      },
      {
        "functionName": "matches",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 178915,
            "endOffset": 179086,
            "count": 0
          }
        ]
      },
      {
        "functionName": "matches",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 179111,
            "endOffset": 179516,
            "count": 0
          }
        ]
      },
      {
        "functionName": "matches",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 179543,
            "endOffset": 180046,
            "count": 0
          }
        ]
      },
      {
        "functionName": "matches",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 180078,
            "endOffset": 180573,
            "count": 0
          }
        ]
      },
      {
        "functionName": "matches",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 180601,
            "endOffset": 181056,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createLayoutEngine",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 181060,
            "endOffset": 181790,
            "count": 5
          }
        ]
      },
      {
        "functionName": "matches",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 181111,
            "endOffset": 181783,
            "count": 0
          }
        ]
      },
      {
        "functionName": "query",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 181816,
            "endOffset": 182319,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parentElementOrShadowHostInContext",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 182323,
            "endOffset": 182551,
            "count": 0
          }
        ]
      },
      {
        "functionName": "previousSiblingInContext",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 182552,
            "endOffset": 182703,
            "count": 0
          }
        ]
      },
      {
        "functionName": "sortInDOMOrder",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 182704,
            "endOffset": 184082,
            "count": 0
          }
        ]
      },
      {
        "functionName": "generateSelector",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 185068,
            "endOffset": 187970,
            "count": 0
          }
        ]
      },
      {
        "functionName": "filterRegexTokens",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 187971,
            "endOffset": 188082,
            "count": 0
          }
        ]
      },
      {
        "functionName": "generateSelectorFor",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 188083,
            "endOffset": 190933,
            "count": 0
          }
        ]
      },
      {
        "functionName": "buildNoTextCandidates",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 190934,
            "endOffset": 194911,
            "count": 0
          }
        ]
      },
      {
        "functionName": "buildTextCandidates",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 194912,
            "endOffset": 198444,
            "count": 0
          }
        ]
      },
      {
        "functionName": "makeSelectorForId",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 198445,
            "endOffset": 198566,
            "count": 0
          }
        ]
      },
      {
        "functionName": "hasCSSIdToken",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 198567,
            "endOffset": 198732,
            "count": 0
          }
        ]
      },
      {
        "functionName": "cssFallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 198733,
            "endOffset": 201314,
            "count": 0
          }
        ]
      },
      {
        "functionName": "penalizeScoreForLength",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 201315,
            "endOffset": 201597,
            "count": 0
          }
        ]
      },
      {
        "functionName": "joinTokens",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 201598,
            "endOffset": 202010,
            "count": 0
          }
        ]
      },
      {
        "functionName": "combineScores",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 202011,
            "endOffset": 202172,
            "count": 0
          }
        ]
      },
      {
        "functionName": "chooseFirstSelector",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 202173,
            "endOffset": 202994,
            "count": 0
          }
        ]
      },
      {
        "functionName": "isGuidLike",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 202995,
            "endOffset": 203749,
            "count": 0
          }
        ]
      },
      {
        "functionName": "trimWordBoundary",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 203750,
            "endOffset": 203987,
            "count": 0
          }
        ]
      },
      {
        "functionName": "suitableTextAlternatives",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 203988,
            "endOffset": 205073,
            "count": 0
          }
        ]
      },
      {
        "functionName": "basename",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 205121,
            "endOffset": 205418,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toUpper",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 205419,
            "endOffset": 205480,
            "count": 0
          }
        ]
      },
      {
        "functionName": "classify",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 205533,
            "endOffset": 205595,
            "count": 0
          }
        ]
      },
      {
        "functionName": "buildComponentsTreeVue3",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 205597,
            "endOffset": 208597,
            "count": 0
          }
        ]
      },
      {
        "functionName": "buildComponentsTreeVue2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 208598,
            "endOffset": 209727,
            "count": 0
          }
        ]
      },
      {
        "functionName": "filterComponentsTree2",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 209728,
            "endOffset": 209958,
            "count": 0
          }
        ]
      },
      {
        "functionName": "findVueRoots",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 209959,
            "endOffset": 210676,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createVueEngine",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 210699,
            "endOffset": 211708,
            "count": 1
          }
        ]
      },
      {
        "functionName": "queryAll",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 210710,
            "endOffset": 211705,
            "count": 0
          }
        ]
      },
      {
        "functionName": "queryAll",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 211781,
            "endOffset": 212296,
            "count": 0
          }
        ]
      },
      {
        "functionName": "InjectedScript",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 212427,
            "endOffset": 218564,
            "count": 1
          },
          {
            "startOffset": 218206,
            "endOffset": 218238,
            "count": 0
          },
          {
            "startOffset": 218524,
            "endOffset": 218560,
            "count": 0
          }
        ]
      },
      {
        "functionName": "queryAll",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 217064,
            "endOffset": 217072,
            "count": 0
          }
        ]
      },
      {
        "functionName": "queryAll",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 217397,
            "endOffset": 217405,
            "count": 0
          }
        ]
      },
      {
        "functionName": "queryAll",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 217459,
            "endOffset": 217467,
            "count": 0
          }
        ]
      },
      {
        "functionName": "eval",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 218567,
            "endOffset": 218630,
            "count": 0
          }
        ]
      },
      {
        "functionName": "testIdAttributeNameForStrictErrorAndConsoleCodegen",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 218633,
            "endOffset": 218760,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parseSelector",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 218763,
            "endOffset": 219059,
            "count": 0
          }
        ]
      },
      {
        "functionName": "generateSelector",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 219062,
            "endOffset": 219167,
            "count": 0
          }
        ]
      },
      {
        "functionName": "generateSelectorSimple",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 219170,
            "endOffset": 219376,
            "count": 0
          }
        ]
      },
      {
        "functionName": "querySelector",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 219379,
            "endOffset": 219600,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_queryNth",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 219603,
            "endOffset": 219787,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_queryLayoutSelector",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 219790,
            "endOffset": 220280,
            "count": 0
          }
        ]
      },
      {
        "functionName": "ariaSnapshot",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 220283,
            "endOffset": 220689,
            "count": 0
          }
        ]
      },
      {
        "functionName": "ariaSnapshotElement",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 220692,
            "endOffset": 220791,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getAllByAria",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 220794,
            "endOffset": 220893,
            "count": 0
          }
        ]
      },
      {
        "functionName": "querySelectorAll",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 220896,
            "endOffset": 223027,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_queryEngineAll",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 223030,
            "endOffset": 223346,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_createAttributeEngine",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 223349,
            "endOffset": 223745,
            "count": 8
          }
        ]
      },
      {
        "functionName": "toCSS",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 223411,
            "endOffset": 223580,
            "count": 0
          }
        ]
      },
      {
        "functionName": "queryAll",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 223611,
            "endOffset": 223734,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_createCSSEngine",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 223748,
            "endOffset": 223915,
            "count": 1
          }
        ]
      },
      {
        "functionName": "queryAll",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 223798,
            "endOffset": 223904,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_createTextEngine",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 223918,
            "endOffset": 224891,
            "count": 3
          }
        ]
      },
      {
        "functionName": "queryAll",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 223977,
            "endOffset": 224861,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_createInternalHasTextEngine",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 224894,
            "endOffset": 225261,
            "count": 1
          }
        ]
      },
      {
        "functionName": "queryAll",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 224956,
            "endOffset": 225250,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_createInternalHasNotTextEngine",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 225264,
            "endOffset": 225634,
            "count": 1
          }
        ]
      },
      {
        "functionName": "queryAll",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 225329,
            "endOffset": 225623,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_createInternalLabelEngine",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 225637,
            "endOffset": 226062,
            "count": 1
          }
        ]
      },
      {
        "functionName": "queryAll",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 225697,
            "endOffset": 226051,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_createNamedAttributeEngine",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 226065,
            "endOffset": 226914,
            "count": 2
          }
        ]
      },
      {
        "functionName": "queryAll",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 226118,
            "endOffset": 226884,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_createControlEngine",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 226917,
            "endOffset": 227388,
            "count": 1
          }
        ]
      },
      {
        "functionName": "queryAll",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 226961,
            "endOffset": 227377,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_createHasEngine",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 227391,
            "endOffset": 227634,
            "count": 1
          }
        ]
      },
      {
        "functionName": "queryAll",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 227433,
            "endOffset": 227604,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_createHasNotEngine",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 227637,
            "endOffset": 227883,
            "count": 1
          }
        ]
      },
      {
        "functionName": "queryAll",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 227682,
            "endOffset": 227853,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_createVisibleEngine",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 227886,
            "endOffset": 228137,
            "count": 1
          }
        ]
      },
      {
        "functionName": "queryAll",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 227932,
            "endOffset": 228107,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_createInternalChainEngine",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 228140,
            "endOffset": 228300,
            "count": 1
          }
        ]
      },
      {
        "functionName": "queryAll",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 228192,
            "endOffset": 228270,
            "count": 0
          }
        ]
      },
      {
        "functionName": "extend",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 228303,
            "endOffset": 228527,
            "count": 0
          }
        ]
      },
      {
        "functionName": "viewportRatio",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 228530,
            "endOffset": 228846,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getElementBorderWidth",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 228849,
            "endOffset": 229203,
            "count": 0
          }
        ]
      },
      {
        "functionName": "describeIFrameStyle",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 229206,
            "endOffset": 229856,
            "count": 0
          }
        ]
      },
      {
        "functionName": "retarget",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 229859,
            "endOffset": 230774,
            "count": 0
          }
        ]
      },
      {
        "functionName": "checkElementStates",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 230777,
            "endOffset": 231393,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_checkElementIsStable",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 231396,
            "endOffset": 232810,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_createAriaIdEngine",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 232813,
            "endOffset": 233609,
            "count": 1
          }
        ]
      },
      {
        "functionName": "queryAll",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 232858,
            "endOffset": 233579,
            "count": 0
          }
        ]
      },
      {
        "functionName": "elementState",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 233612,
            "endOffset": 235710,
            "count": 0
          }
        ]
      },
      {
        "functionName": "selectOptions",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 235713,
            "endOffset": 237639,
            "count": 0
          }
        ]
      },
      {
        "functionName": "fill",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 237642,
            "endOffset": 239179,
            "count": 0
          }
        ]
      },
      {
        "functionName": "selectText",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 239182,
            "endOffset": 239996,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_activelyFocused",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 239999,
            "endOffset": 240231,
            "count": 0
          }
        ]
      },
      {
        "functionName": "focusNode",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 240234,
            "endOffset": 240923,
            "count": 0
          }
        ]
      },
      {
        "functionName": "blurNode",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 240926,
            "endOffset": 241154,
            "count": 0
          }
        ]
      },
      {
        "functionName": "setInputFiles",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 241157,
            "endOffset": 242053,
            "count": 0
          }
        ]
      },
      {
        "functionName": "expectHitTarget",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 242056,
            "endOffset": 244144,
            "count": 0
          }
        ]
      },
      {
        "functionName": "setupHitTargetInterceptor",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 246283,
            "endOffset": 247740,
            "count": 0
          }
        ]
      },
      {
        "functionName": "dispatchEvent",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 247743,
            "endOffset": 251770,
            "count": 0
          }
        ]
      },
      {
        "functionName": "previewNode",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 251773,
            "endOffset": 253067,
            "count": 0
          }
        ]
      },
      {
        "functionName": "strictModeViolationError",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 253070,
            "endOffset": 253644,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createStacklessError",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 253647,
            "endOffset": 253910,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createHighlight",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 253913,
            "endOffset": 253968,
            "count": 0
          }
        ]
      },
      {
        "functionName": "maskSelectors",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 253971,
            "endOffset": 254341,
            "count": 0
          }
        ]
      },
      {
        "functionName": "highlight",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 254344,
            "endOffset": 254530,
            "count": 0
          }
        ]
      },
      {
        "functionName": "hideHighlight",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 254533,
            "endOffset": 254652,
            "count": 0
          }
        ]
      },
      {
        "functionName": "markTargetElements",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 254655,
            "endOffset": 255586,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_setupGlobalListenersRemovalDetection",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 255589,
            "endOffset": 256402,
            "count": 1
          }
        ]
      },
      {
        "functionName": "handleCustomEvent",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 255757,
            "endOffset": 255779,
            "count": 0
          }
        ]
      },
      {
        "functionName": "MutationObserver.observe.childList",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 255876,
            "endOffset": 256352,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_setupHitTargetInterceptors",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 256405,
            "endOffset": 256909,
            "count": 1
          }
        ]
      },
      {
        "functionName": "listener",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 256458,
            "endOffset": 256578,
            "count": 0
          }
        ]
      },
      {
        "functionName": "addHitTargetInterceptorListeners",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 256625,
            "endOffset": 256791,
            "count": 1
          },
          {
            "startOffset": 256704,
            "endOffset": 256785,
            "count": 12
          }
        ]
      },
      {
        "functionName": "expect",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 256912,
            "endOffset": 257792,
            "count": 0
          }
        ]
      },
      {
        "functionName": "expectSingleElement",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 257795,
            "endOffset": 264706,
            "count": 0
          }
        ]
      },
      {
        "functionName": "expectArray",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 264709,
            "endOffset": 266460,
            "count": 0
          }
        ]
      },
      {
        "functionName": "_matchSequentially",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 266463,
            "endOffset": 266835,
            "count": 0
          }
        ]
      },
      {
        "functionName": "oneLine",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 266839,
            "endOffset": 266924,
            "count": 0
          }
        ]
      },
      {
        "functionName": "cssUnquote",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 266925,
            "endOffset": 267179,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createTextMatcher",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 267180,
            "endOffset": 269011,
            "count": 0
          }
        ]
      },
      {
        "functionName": "ExpectedTextMatcher",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 269048,
            "endOffset": 269671,
            "count": 0
          }
        ]
      },
      {
        "functionName": "matches",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 269674,
            "endOffset": 269978,
            "count": 0
          }
        ]
      },
      {
        "functionName": "matchesClassList",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 269981,
            "endOffset": 270383,
            "count": 0
          }
        ]
      },
      {
        "functionName": "normalize",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 270386,
            "endOffset": 270574,
            "count": 0
          }
        ]
      },
      {
        "functionName": "deepEquals",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 270578,
            "endOffset": 271689,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "",
    "scriptId": "144",
    "source": "((utilityScript, ...args) => utilityScript.evaluate(...args))",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 61,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1,
            "endOffset": 60,
            "count": 1
          }
        ]
      }
    ]
  },
  {
    "url": "",
    "scriptId": "145",
    "source": "(injected, { expression: expression2, isFunction: isFunction2, polling, arg: arg2 }) => {\n          const predicate = () => {\n            let result2 = globalThis.eval(expression2);\n            if (isFunction2 === true) {\n              result2 = result2(arg2);\n            } else if (isFunction2 === false) {\n              result2 = result2;\n            } else {\n              if (typeof result2 === \"function\")\n                result2 = result2(arg2);\n            }\n            return result2;\n          };\n          let fulfill;\n          let reject;\n          let aborted = false;\n          const result = new Promise((f, r) => {\n            fulfill = f;\n            reject = r;\n          });\n          const next = () => {\n            if (aborted)\n              return;\n            try {\n              const success = predicate();\n              if (success) {\n                fulfill(success);\n                return;\n              }\n              if (typeof polling !== \"number\")\n                injected.utils.builtins.requestAnimationFrame(next);\n              else\n                injected.utils.builtins.setTimeout(next, polling);\n            } catch (e) {\n              reject(e);\n            }\n          };\n          next();\n          return { result, abort: () => aborted = true };\n        }",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 1303,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 1303,
            "count": 1
          }
        ]
      },
      {
        "functionName": "predicate",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 118,
            "endOffset": 506,
            "count": 1
          },
          {
            "startOffset": 274,
            "endOffset": 466,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 621,
            "endOffset": 693,
            "count": 1
          }
        ]
      },
      {
        "functionName": "next",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 719,
            "endOffset": 1216,
            "count": 1
          },
          {
            "startOffset": 766,
            "endOffset": 773,
            "count": 0
          },
          {
            "startOffset": 937,
            "endOffset": 1139,
            "count": 0
          },
          {
            "startOffset": 1154,
            "endOffset": 1204,
            "count": 0
          }
        ]
      },
      {
        "functionName": "abort",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1270,
            "endOffset": 1290,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "",
    "scriptId": "146",
    "source": "() => {\n      const result = (() => {\n      if (!document.body || !document.documentElement)\n        return null;\n      return {\n        width: Math.max(\n          document.body.scrollWidth,\n          document.documentElement.scrollWidth,\n          document.body.offsetWidth,\n          document.documentElement.offsetWidth,\n          document.body.clientWidth,\n          document.documentElement.clientWidth\n        ),\n        height: Math.max(\n          document.body.scrollHeight,\n          document.documentElement.scrollHeight,\n          document.body.offsetHeight,\n          document.documentElement.offsetHeight,\n          document.body.clientHeight,\n          document.documentElement.clientHeight\n        )\n      };\n    })();\n      if (!result)\n        return result;\n      return JSON.stringify(result);\n    }",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 818,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 818,
            "count": 1
          },
          {
            "startOffset": 761,
            "endOffset": 775,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 30,
            "endOffset": 729,
            "count": 1
          },
          {
            "startOffset": 101,
            "endOffset": 113,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "",
    "scriptId": "153",
    "source": "((utilityScript, ...args) => utilityScript.evaluate(...args))",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 61,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1,
            "endOffset": 60,
            "count": 1
          }
        ]
      }
    ]
  },
  {
    "url": "",
    "scriptId": "154",
    "source": "(h) => h.result",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 15,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 15,
            "count": 1
          }
        ]
      }
    ]
  },
  {
    "url": "",
    "scriptId": "160",
    "source": "((utilityScript, ...args) => utilityScript.evaluate(...args))",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 61,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1,
            "endOffset": 60,
            "count": 1
          }
        ]
      }
    ]
  },
  {
    "url": "",
    "scriptId": "161",
    "source": "window.__pwCleanupScreenshot && window.__pwCleanupScreenshot()",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 62,
            "count": 1
          }
        ]
      }
    ]
  },
  {
    "url": "",
    "scriptId": "167",
    "source": "((utilityScript, ...args) => utilityScript.evaluate(...args))",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 61,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1,
            "endOffset": 60,
            "count": 1
          }
        ]
      }
    ]
  },
  {
    "url": "",
    "scriptId": "168",
    "source": "() => {\n      return {\n        url: window.location.href,\n        scrollY: window.scrollY,\n        scrollX: window.scrollX,\n        bodyHeight: document.body.scrollHeight,\n        bodyWidth: document.body.scrollWidth,\n        viewportHeight: window.innerHeight,\n        viewportWidth: window.innerWidth,\n        // Capture motion system state\n        motionState: window.__motionState || null,\n        observerState: window.__observerState || null\n      };\n    }",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 462,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 462,
            "count": 1
          },
          {
            "startOffset": 385,
            "endOffset": 392,
            "count": 0
          },
          {
            "startOffset": 440,
            "endOffset": 447,
            "count": 0
          }
        ]
      }
    ]
  }
]
