/**
 * @fileoverview The definitive, centralized scroll management hook.
 * This hook is the single source of truth for all scroll-related state,
 * animations, and user input. It orchestrates Lenis, GSAP, and Observer
 * to create a stable and predictable scroll experience.
 */

import { useRef, useCallback, useEffect } from 'react';
import gsap from 'gsap';
import { ScrollTrigger } from 'gsap/ScrollTrigger';
import { ScrollToPlugin } from 'gsap/ScrollToPlugin';
import { Observer } from 'gsap/Observer';
import type { 
  ScrollManagerAPI, 
  ScrollManagerConfig, 
  AnimationControllers,
  NavigationOptions,
  ScrollState 
} from '../types/scroll-manager';
import { useScrollContext, useScrollActions } from '../context/ScrollContext';
import { IBrowserService, createBrowserService } from '../services/BrowserService';
import { createAnimationQueue, calculateAnimationDuration, shouldInterruptAnimation } from '../utils/animation-queue';
import { forceSync, emergencyReset, verifyState, checkStuckAnimation, getDiagnosticReport } from '../utils/scroll-sync';
import { TIMING, PHYSICS, EASING_FUNCTIONS, POSITION_TOLERANCE, SCROLLTRIGGER_CONFIG, DEBUG_CONFIG } from '../constants/scroll-physics';

// Register GSAP plugins once at module level
gsap.registerPlugin(ScrollTrigger, ScrollToPlugin, Observer);

// Verify plugins are loaded
console.log('ðŸ”Œ [useScrollManager] GSAP Plugins registered:', {
  ScrollTrigger: !!gsap.plugins.scrollTrigger,
  ScrollToPlugin: !!gsap.plugins.scrollTo,
  Observer: !!gsap.plugins.observer
});

// Dynamic import for Lenis to prevent SSR issues
const initLenis = async () => {
  const Lenis = (await import('lenis')).default;
  return new Lenis({
    lerp: PHYSICS.LENIS_LERP,
    wheelMultiplier: PHYSICS.LENIS_WHEEL_MULTIPLIER,
    smoothWheel: true,
    smoothTouch: false, // Critical: Prevents mobile conflicts
    touchMultiplier: PHYSICS.TOUCH_MULTIPLIER,
    infinite: false,
    orientation: 'vertical',
    gestureOrientation: 'vertical',
    duration: PHYSICS.LENIS_DURATION_MULTIPLIER,
    easing: EASING_FUNCTIONS.DEFAULT,
  });
};

/**
 * The definitive, centralized scroll management hook.
 */
export function useScrollManager(config: ScrollManagerConfig): ScrollManagerAPI {
  const {
    sections,
    duration = PHYSICS.BASE_ANIMATION_DURATION,
    easing = EASING_FUNCTIONS.DEFAULT,
    tolerance = PHYSICS.OBSERVER_TOLERANCE,
    touchMultiplier = PHYSICS.TOUCH_MULTIPLIER,
    preventDefault = true,
    invertDirection = false,
    keyboardNavigation = true,
    onSectionChange,
    browserService: providedBrowserService,
    magneticSnap = false,
    narrativeConfig,
  } = config;

  // Core refs
  const containerRef = useRef<HTMLDivElement>(null);
  const { state: contextState, dispatch } = useScrollContext();
  const actions = useScrollActions();
  
  // Service and state refs
  const browserService = useRef<IBrowserService>(providedBrowserService || createBrowserService());
  const animationQueue = useRef(createAnimationQueue());
  const controllers = useRef<AnimationControllers>({
    lenis: null,
    observer: null,
    scrollTween: null,
    rafId: null,
    verificationIntervalId: null,
    keyboardCleanup: null,
    lenisTickerCallback: undefined,
  });
  
  // Convert context state to our ScrollState format
  const scrollState = useRef<ScrollState>({
    currentSection: contextState.currentIndex || 0,
    targetSection: null,
    isAnimating: contextState.isAnimating || false,
    isScrolling: false,
    canNavigate: !contextState.isAnimating,
    scrollPosition: 0,
    velocity: 0,
    lastNavigationTime: contextState.lastScrollTime || 0,
  });
  
  // Keep state ref updated
  useEffect(() => {
    scrollState.current.currentSection = contextState.currentIndex || 0;
    scrollState.current.isAnimating = contextState.isAnimating || false;
    scrollState.current.canNavigate = !contextState.isAnimating;
    scrollState.current.lastNavigationTime = contextState.lastScrollTime || 0;
  }, [contextState]);
  
  const stateRef = scrollState;

  // Track initialization state
  const isInitialized = useRef(false);
  const initializationError = useRef<Error | null>(null);

  /**
   * The core navigation logic.
   * This function is the single entry point for all scroll animations.
   */
  const gotoSection = useCallback((index: number, options?: NavigationOptions) => {
    console.log(`ðŸŽ¯ [useScrollManager.gotoSection] ENTER:`, {
      requestedIndex: index,
      currentSection: stateRef.current.currentSection,
      isAnimating: stateRef.current.isAnimating,
      options
    });
    
    // Validate bounds
    const newIndex = gsap.utils.clamp(0, sections.length - 1, index);
    
    // Check if already at target
    if (newIndex === stateRef.current.currentSection && !stateRef.current.isAnimating) {
      console.log(`ðŸ“ [useScrollManager.gotoSection] Already at section ${newIndex}, EXIT early`);
      return;
    }

    // Create navigation request
    const request = animationQueue.current.enqueue({
      targetSection: newIndex,
      source: options?.metadata?.storyContext?.trigger === 'story' ? 'narrative' : 'programmatic',
      priority: options?.force ? 'high' : 'normal',
      options,
    });

    if (!request) {
      return; // Request was deduplicated
    }

    // Check if we should interrupt current animation
    if (stateRef.current.isAnimating && controllers.current.scrollTween) {
      const currentRequest = animationQueue.current.peek();
      if (shouldInterruptAnimation(currentRequest, request)) {
        console.log(`âš¡ Interrupting current animation for higher priority request`);
        controllers.current.scrollTween.kill();
      } else {
        console.log(`â¸ï¸ Current animation has higher priority, queueing request`);
        return;
      }
    }

    // Start animation
    console.log(`ðŸš€ [useScrollManager.gotoSection] Starting animation to section ${newIndex}`);
    stateRef.current.isAnimating = true;
    stateRef.current.canNavigate = false;
    stateRef.current.targetSection = newIndex;
    actions.gotoSection(newIndex, Date.now());

    // Get target element
    const targetElement = containerRef.current?.querySelector(`[data-section-idx="${newIndex}"]`) as HTMLElement;
    if (!targetElement) {
      console.error(`âŒ [useScrollManager.gotoSection] Target element for section ${newIndex} not found`);
      animationQueue.current.clear();
      stateRef.current.isAnimating = false;
      stateRef.current.canNavigate = true;
      actions.endAnimation();
      return;
    }

    // Calculate target position using getBoundingClientRect (NOT offsetTop)
    const targetY = targetElement.getBoundingClientRect().top + window.scrollY;
    
    console.log(`ðŸ“¦ [useScrollManager] Target calculation:`, {
      targetElementRect: targetElement.getBoundingClientRect(),
      currentScrollY: window.scrollY,
      calculatedTargetY: targetY,
      windowHeight: window.innerHeight,
      expectedSectionTop: newIndex * window.innerHeight
    });
    
    // Calculate dynamic duration based on distance
    const calculatedDuration = options?.immediate 
      ? 0 
      : options?.duration || calculateAnimationDuration(
          stateRef.current.currentSection,
          newIndex,
          duration
        );

    // Kill any existing tweens
    gsap.killTweensOf(window);

    // Create the animation
    console.log(`ðŸŽ¬ [useScrollManager] Creating GSAP animation:`, {
      from: window.scrollY,
      to: targetY,
      duration: calculatedDuration,
      containerHeight: window.innerHeight,
      targetElement: targetElement,
      gsapRegistered: !!gsap.plugins.scrollTo
    });
    
    controllers.current.scrollTween = gsap.to(window, {
      scrollTo: { 
        y: targetY, 
        autoKill: false // Prevent user scroll from canceling
      },
      duration: calculatedDuration,
      ease: options?.easing || easing,
      onStart: () => {
        console.log(`ðŸš€ [GSAP onStart] Animation started to section ${newIndex}`);
        // Notify Lenis to stop its smooth scroll during animation
        if (controllers.current.lenis) {
          controllers.current.lenis.stop();
        }
      },
      onUpdate: () => {
        console.log(`ðŸ“Š [GSAP onUpdate] Scroll position:`, window.scrollY);
        // Keep Lenis in sync during animation
        if (controllers.current.lenis) {
          controllers.current.lenis.scroll = window.scrollY;
        }
      },
      onComplete: () => {
        console.log(`âœ… [useScrollManager] Animation to section ${newIndex} complete`);
        
        // Update state
        if (stateRef.current.currentSection !== newIndex) {
          actions.setCurrentIndex(newIndex);
          stateRef.current.currentSection = newIndex;
        }
        stateRef.current.isAnimating = false;
        stateRef.current.canNavigate = true;
        actions.endAnimation();
        
        // Clear queue and restart Lenis
        animationQueue.current.clear();
        if (controllers.current.lenis) {
          controllers.current.lenis.start();
        }
        
        // Fire callbacks
        onSectionChange?.(newIndex);
        options?.onComplete?.();
        
        // Verify we landed correctly
        setTimeout(() => {
          console.log(`ðŸ” [useScrollManager] Post-animation verification check`);
          verifyState(stateRef, controllers.current, browserService.current, dispatch);
        }, TIMING.POSITION_CHECK_DELAY);
      },
      onInterrupt: () => {
        console.warn(`âš ï¸ Animation to section ${newIndex} interrupted`);
        
        // Sync to actual position
        const actualY = browserService.current.getScrollY();
        const actualSection = Math.round(actualY / browserService.current.getInnerHeight());
        
        forceSync(actualSection, stateRef, controllers.current, browserService.current, dispatch);
        
        // Clear queue and fire callback
        animationQueue.current.clear();
        options?.onInterrupt?.();
      },
    });
  }, [sections.length, duration, easing, onSectionChange, actions, dispatch]);

  // Navigation helpers
  const nextSection = useCallback(() => {
    gotoSection(stateRef.current.currentSection + 1);
  }, [gotoSection]);

  const prevSection = useCallback(() => {
    gotoSection(stateRef.current.currentSection - 1);
  }, [gotoSection]);

  /**
   * Initialize all scroll systems.
   * This is called on mount and after emergency reset.
   */
  const initialize = useCallback(async () => {
    const bs = browserService.current;
    if (!bs.isClient() || !containerRef.current) return;

    try {
      console.log('ðŸš€ Initializing scroll manager...');

      // 1. Initialize Lenis with GSAP ticker (NOT separate RAF)
      controllers.current.lenis = await initLenis();
      const lenis = controllers.current.lenis;
      
      console.log('ðŸšœ [useScrollManager] Lenis initialized:', {
        lenis: !!lenis,
        lenisScroll: lenis?.scroll,
        documentHeight: document.documentElement.scrollHeight,
        windowHeight: window.innerHeight,
        bodyHeight: document.body.scrollHeight
      });

      // CRITICAL: Use GSAP ticker to drive Lenis
      const tickerCallback = (time: number) => {
        // GSAP provides time in seconds, Lenis needs milliseconds
        lenis?.raf(time * 1000);
      };
      controllers.current.lenisTickerCallback = tickerCallback;
      gsap.ticker.add(tickerCallback);

      // Sync Lenis scroll events with ScrollTrigger
      lenis.on('scroll', () => {
        ScrollTrigger.update();
        // Update our state
        const scrollY = lenis.scroll || 0;
        const section = Math.round(scrollY / bs.getInnerHeight());
        if (section !== stateRef.current.currentSection && !stateRef.current.isAnimating) {
          actions.setCurrentIndex(section);
        }
      });

      // 2. Configure ScrollTrigger after hydration delay
      if (typeof window !== 'undefined') {
        setTimeout(() => {
          ScrollTrigger.config({
            syncInterval: SCROLLTRIGGER_CONFIG.SYNC_INTERVAL,
            autoRefreshEvents: SCROLLTRIGGER_CONFIG.AUTO_REFRESH_EVENTS,
          });

          // Set up ScrollTrigger proxy for Lenis
          ScrollTrigger.scrollerProxy(document.body, {
            scrollTop(value) {
              if (arguments.length) {
                lenis.scrollTo(value, { immediate: true });
              }
              return lenis.scroll || 0;
            },
            getBoundingClientRect() {
              return {
                top: 0,
                left: 0,
                width: window.innerWidth,
                height: window.innerHeight,
              };
            },
          });

          ScrollTrigger.refresh(true);
        }, TIMING.HYDRATION_DELAY);
      }

      // 3. Initialize Observer for input detection
      console.log('ðŸŽ® [useScrollManager] Creating Observer with config:', {
        tolerance,
        preventDefault,
        wheelSpeed: PHYSICS.WHEEL_SPEED * (invertDirection ? -1 : 1)
      });
      
      controllers.current.observer = Observer.create({
        target: window,
        type: 'wheel,touch,pointer',
        tolerance: tolerance,
        preventDefault: preventDefault,
        wheelSpeed: PHYSICS.WHEEL_SPEED * (invertDirection ? -1 : 1),
        onUp: () => {
          console.log('â¬†ï¸ [Observer] onUp triggered, state:', {
            isAnimating: stateRef.current.isAnimating,
            canNavigate: stateRef.current.canNavigate,
            currentSection: stateRef.current.currentSection
          });
          if (!stateRef.current.isAnimating && stateRef.current.canNavigate) {
            nextSection(); // SWAPPED: onUp = scroll down
          }
        },
        onDown: () => {
          console.log('â¬‡ï¸ [Observer] onDown triggered, state:', {
            isAnimating: stateRef.current.isAnimating,
            canNavigate: stateRef.current.canNavigate,
            currentSection: stateRef.current.currentSection
          });
          if (!stateRef.current.isAnimating && stateRef.current.canNavigate) {
            prevSection(); // SWAPPED: onDown = scroll up
          }
        },
        // Firefox Logitech mouse workaround
        onWheel: (self) => {
          const isFirefox = navigator.userAgent.includes('Firefox');
          if (isFirefox && Math.abs(self.deltaY) < 50) {
            self.deltaY *= 2;
          }
        },
      });

      // 4. Set up keyboard navigation
      if (keyboardNavigation) {
        const handleKeyDown = (e: KeyboardEvent) => {
          if (stateRef.current.isAnimating || !stateRef.current.canNavigate) return;

          switch (e.key) {
            case 'ArrowDown':
            case 'PageDown':
              e.preventDefault();
              nextSection();
              break;
            case 'ArrowUp':
            case 'PageUp':
              e.preventDefault();
              prevSection();
              break;
            case 'Home':
              e.preventDefault();
              gotoSection(0);
              break;
            case 'End':
              e.preventDefault();
              gotoSection(sections.length - 1);
              break;
            case ' ': // Spacebar
              e.preventDefault();
              if (e.shiftKey) {
                prevSection();
              } else {
                nextSection();
              }
              break;
          }
        };

        bs.addEventListener('keydown', handleKeyDown);
        controllers.current.keyboardCleanup = () => bs.removeEventListener('keydown', handleKeyDown);
      }

      // 5. Start state verification interval
      controllers.current.verificationIntervalId = setInterval(() => {
        verifyState(stateRef, controllers.current, bs, dispatch);
        checkStuckAnimation(stateRef, controllers.current, bs, dispatch);
      }, TIMING.STATE_VERIFICATION_INTERVAL);

      isInitialized.current = true;
      console.log('âœ… Scroll manager initialized successfully');

    } catch (error) {
      console.error('âŒ Failed to initialize scroll manager:', error);
      initializationError.current = error as Error;
      throw error;
    }
  }, [gotoSection, nextSection, prevSection, keyboardNavigation, sections.length, tolerance, preventDefault, invertDirection, dispatch]);

  /**
   * Complete cleanup of all resources.
   */
  const destroy = useCallback(() => {
    console.log('ðŸ§¹ Destroying scroll manager...');

    // Kill all animations
    if (controllers.current.scrollTween) {
      controllers.current.scrollTween.kill();
    }
    gsap.killTweensOf(window);

    // Remove GSAP ticker callback
    if (controllers.current.lenisTickerCallback) {
      gsap.ticker.remove(controllers.current.lenisTickerCallback);
    }

    // Destroy Observer
    if (controllers.current.observer) {
      controllers.current.observer.kill();
    }

    // Destroy Lenis
    if (controllers.current.lenis) {
      controllers.current.lenis.destroy();
    }

    // Clear intervals
    if (controllers.current.verificationIntervalId) {
      clearInterval(controllers.current.verificationIntervalId);
    }

    // Remove keyboard listeners
    if (controllers.current.keyboardCleanup) {
      controllers.current.keyboardCleanup();
    }

    // Kill all ScrollTriggers
    ScrollTrigger.killAll();

    // Clear queue
    animationQueue.current.clear();

    isInitialized.current = false;
    console.log('âœ… Scroll manager destroyed');
  }, []);

  // Initialize on mount, cleanup on unmount
  useEffect(() => {
    initialize();
    return () => destroy();
  }, [initialize, destroy]);

  // Public API
  return {
    containerRef,
    gotoSection,
    nextSection,
    prevSection,
    forceSync: () => {
      const actualSection = Math.round(
        browserService.current.getScrollY() / browserService.current.getInnerHeight()
      );
      forceSync(actualSection, stateRef, controllers.current, browserService.current, dispatch);
    },
    emergencyReset: () => {
      emergencyReset(controllers.current, initialize, dispatch);
    },
    destroy,
    getState: () => stateRef.current,
    getQueueStatus: () => ({
      pending: animationQueue.current.requests.length,
      processing: animationQueue.current.processing,
    }),
  };
}